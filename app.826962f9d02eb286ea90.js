webpackJsonp([0],[
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	module.exports = __webpack_require__(587);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.store = undefined;
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(38);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _createHashHistory = __webpack_require__(185);
	
	var _createHashHistory2 = _interopRequireDefault(_createHashHistory);
	
	var _reactRouter = __webpack_require__(202);
	
	var _reactRouterRedux = __webpack_require__(248);
	
	var _createStore = __webpack_require__(253);
	
	var _createStore2 = _interopRequireDefault(_createStore);
	
	var _AppContainer = __webpack_require__(383);
	
	var _AppContainer2 = _interopRequireDefault(_AppContainer);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// ========================================================
	// Browser History Setup
	// ========================================================
	var browserHistory = (0, _reactRouter.useRouterHistory)(_createHashHistory2.default)({
	  basename: ("")
	});
	
	// ========================================================
	// Store and History Instantiation
	// ========================================================
	// Create redux store and sync with react-router-redux. We have installed the
	// react-router-redux reducer under the routerKey "router" in src/routes/index.js,
	// so we need to provide a custom `selectLocationState` to inform
	// react-router-redux of its location.
	var initialState = window.___INITIAL_STATE__;
	var store = exports.store = (0, _createStore2.default)(initialState, browserHistory);
	var history = (0, _reactRouterRedux.syncHistoryWithStore)(browserHistory, store, {
	  selectLocationState: function selectLocationState(state) {
	    return state.router;
	  }
	});
	
	// ========================================================
	// Developer Tools Setup
	// ========================================================
	if (true) {
	  if (window.devToolsExtension) {
	    window.devToolsExtension.open();
	  }
	}
	
	// ========================================================
	// Render Setup
	// ========================================================
	var MOUNT_NODE = document.getElementById('root');
	
	var render = function render() {
	  var routes = __webpack_require__(426).default(store);
	
	  _reactDom2.default.render(_react2.default.createElement(_AppContainer2.default, {
	    store: store,
	    history: history,
	    routes: routes
	  }), MOUNT_NODE);
	};
	
	// This code is excluded from production bundle
	if (true) {
	  if (true) {
	    // Development render functions
	    var renderApp = render;
	    var renderError = function renderError(error) {
	      var RedBox = __webpack_require__(581).default;
	
	      _reactDom2.default.render(_react2.default.createElement(RedBox, { error: error }), MOUNT_NODE);
	    };
	
	    // Wrap render in try/catch
	    render = function render() {
	      try {
	        renderApp();
	      } catch (error) {
	        renderError(error);
	      }
	    };
	
	    // Setup hot module replacement
	    module.hot.accept(426, function () {
	      setTimeout(function () {
	        _reactDom2.default.unmountComponentAtNode(MOUNT_NODE);
	        render();
	      });
	    });
	  }
	}
	
	// ========================================================
	// Go!
	// ========================================================
	render();

/***/ }),
/* 2 */,
/* 3 */,
/* 4 */,
/* 5 */,
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */,
/* 37 */,
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(39);


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/
	
	'use strict';
	
	var ReactDOMComponentTree = __webpack_require__(40);
	var ReactDefaultInjection = __webpack_require__(44);
	var ReactMount = __webpack_require__(173);
	var ReactReconciler = __webpack_require__(65);
	var ReactUpdates = __webpack_require__(62);
	var ReactVersion = __webpack_require__(178);
	
	var findDOMNode = __webpack_require__(179);
	var getHostComponentFromComposite = __webpack_require__(180);
	var renderSubtreeIntoContainer = __webpack_require__(181);
	var warning = __webpack_require__(8);
	
	ReactDefaultInjection.inject();
	
	var ReactDOM = {
	  findDOMNode: findDOMNode,
	  render: ReactMount.render,
	  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
	  version: ReactVersion,
	
	  /* eslint-disable camelcase */
	  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
	  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
	  /* eslint-enable camelcase */
	};
	
	// Inject the runtime into a devtools global hook regardless of browser.
	// Allows for debugging when the hook is injected on the page.
	if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
	  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
	    ComponentTree: {
	      getClosestInstanceFromNode: ReactDOMComponentTree.getClosestInstanceFromNode,
	      getNodeFromInstance: function (inst) {
	        // inst is an internal instance (but could be a composite)
	        if (inst._renderedComponent) {
	          inst = getHostComponentFromComposite(inst);
	        }
	        if (inst) {
	          return ReactDOMComponentTree.getNodeFromInstance(inst);
	        } else {
	          return null;
	        }
	      }
	    },
	    Mount: ReactMount,
	    Reconciler: ReactReconciler
	  });
	}
	
	if (true) {
	  var ExecutionEnvironment = __webpack_require__(54);
	  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
	    // First check if devtools is not installed
	    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
	      // If we're in Chrome or Firefox, provide a download link if not installed.
	      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
	        // Firefox does not have the issue with devtools loaded over file://
	        var showFileUrlMessage = window.location.protocol.indexOf('http') === -1 && navigator.userAgent.indexOf('Firefox') === -1;
	        console.debug('Download the React DevTools ' + (showFileUrlMessage ? 'and use an HTTP server (instead of a file: URL) ' : '') + 'for a better development experience: ' + 'https://fb.me/react-devtools');
	      }
	    }
	
	    var testFunc = function testFn() {};
	     true ? warning((testFunc.name || testFunc.toString()).indexOf('testFn') !== -1, "It looks like you're using a minified copy of the development build " + 'of React. When deploying React apps to production, make sure to use ' + 'the production build which skips development warnings and is faster. ' + 'See https://fb.me/react-minification for more details.') : void 0;
	
	    // If we're in IE8, check to see if we are in compatibility mode and provide
	    // information on preventing compatibility mode
	    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;
	
	     true ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : void 0;
	
	    var expectedFeatures = [
	    // shims
	    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.trim];
	
	    for (var i = 0; i < expectedFeatures.length; i++) {
	      if (!expectedFeatures[i]) {
	         true ? warning(false, 'One or more ES5 shims expected by React are not available: ' + 'https://fb.me/react-warning-polyfills') : void 0;
	        break;
	      }
	    }
	  }
	}
	
	if (true) {
	  var ReactInstrumentation = __webpack_require__(68);
	  var ReactDOMUnknownPropertyHook = __webpack_require__(182);
	  var ReactDOMNullInputValuePropHook = __webpack_require__(183);
	  var ReactDOMInvalidARIAHook = __webpack_require__(184);
	
	  ReactInstrumentation.debugTool.addHook(ReactDOMUnknownPropertyHook);
	  ReactInstrumentation.debugTool.addHook(ReactDOMNullInputValuePropHook);
	  ReactInstrumentation.debugTool.addHook(ReactDOMInvalidARIAHook);
	}
	
	module.exports = ReactDOM;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(41);
	
	var DOMProperty = __webpack_require__(42);
	var ReactDOMComponentFlags = __webpack_require__(43);
	
	var invariant = __webpack_require__(12);
	
	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var Flags = ReactDOMComponentFlags;
	
	var internalInstanceKey = '__reactInternalInstance$' + Math.random().toString(36).slice(2);
	
	/**
	 * Check if a given node should be cached.
	 */
	function shouldPrecacheNode(node, nodeID) {
	  return node.nodeType === 1 && node.getAttribute(ATTR_NAME) === String(nodeID) || node.nodeType === 8 && node.nodeValue === ' react-text: ' + nodeID + ' ' || node.nodeType === 8 && node.nodeValue === ' react-empty: ' + nodeID + ' ';
	}
	
	/**
	 * Drill down (through composites and empty components) until we get a host or
	 * host text component.
	 *
	 * This is pretty polymorphic but unavoidable with the current structure we have
	 * for `_renderedChildren`.
	 */
	function getRenderedHostOrTextFromComponent(component) {
	  var rendered;
	  while (rendered = component._renderedComponent) {
	    component = rendered;
	  }
	  return component;
	}
	
	/**
	 * Populate `_hostNode` on the rendered host/text component with the given
	 * DOM node. The passed `inst` can be a composite.
	 */
	function precacheNode(inst, node) {
	  var hostInst = getRenderedHostOrTextFromComponent(inst);
	  hostInst._hostNode = node;
	  node[internalInstanceKey] = hostInst;
	}
	
	function uncacheNode(inst) {
	  var node = inst._hostNode;
	  if (node) {
	    delete node[internalInstanceKey];
	    inst._hostNode = null;
	  }
	}
	
	/**
	 * Populate `_hostNode` on each child of `inst`, assuming that the children
	 * match up with the DOM (element) children of `node`.
	 *
	 * We cache entire levels at once to avoid an n^2 problem where we access the
	 * children of a node sequentially and have to walk from the start to our target
	 * node every time.
	 *
	 * Since we update `_renderedChildren` and the actual DOM at (slightly)
	 * different times, we could race here and see a newer `_renderedChildren` than
	 * the DOM nodes we see. To avoid this, ReactMultiChild calls
	 * `prepareToManageChildren` before we change `_renderedChildren`, at which
	 * time the container's child nodes are always cached (until it unmounts).
	 */
	function precacheChildNodes(inst, node) {
	  if (inst._flags & Flags.hasCachedChildNodes) {
	    return;
	  }
	  var children = inst._renderedChildren;
	  var childNode = node.firstChild;
	  outer: for (var name in children) {
	    if (!children.hasOwnProperty(name)) {
	      continue;
	    }
	    var childInst = children[name];
	    var childID = getRenderedHostOrTextFromComponent(childInst)._domID;
	    if (childID === 0) {
	      // We're currently unmounting this child in ReactMultiChild; skip it.
	      continue;
	    }
	    // We assume the child nodes are in the same order as the child instances.
	    for (; childNode !== null; childNode = childNode.nextSibling) {
	      if (shouldPrecacheNode(childNode, childID)) {
	        precacheNode(childInst, childNode);
	        continue outer;
	      }
	    }
	    // We reached the end of the DOM children without finding an ID match.
	     true ?  true ? invariant(false, 'Unable to find element with ID %s.', childID) : _prodInvariant('32', childID) : void 0;
	  }
	  inst._flags |= Flags.hasCachedChildNodes;
	}
	
	/**
	 * Given a DOM node, return the closest ReactDOMComponent or
	 * ReactDOMTextComponent instance ancestor.
	 */
	function getClosestInstanceFromNode(node) {
	  if (node[internalInstanceKey]) {
	    return node[internalInstanceKey];
	  }
	
	  // Walk up the tree until we find an ancestor whose instance we have cached.
	  var parents = [];
	  while (!node[internalInstanceKey]) {
	    parents.push(node);
	    if (node.parentNode) {
	      node = node.parentNode;
	    } else {
	      // Top of the tree. This node must not be part of a React tree (or is
	      // unmounted, potentially).
	      return null;
	    }
	  }
	
	  var closest;
	  var inst;
	  for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
	    closest = inst;
	    if (parents.length) {
	      precacheChildNodes(inst, node);
	    }
	  }
	
	  return closest;
	}
	
	/**
	 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
	 * instance, or null if the node was not rendered by this React.
	 */
	function getInstanceFromNode(node) {
	  var inst = getClosestInstanceFromNode(node);
	  if (inst != null && inst._hostNode === node) {
	    return inst;
	  } else {
	    return null;
	  }
	}
	
	/**
	 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
	 * DOM node.
	 */
	function getNodeFromInstance(inst) {
	  // Without this first invariant, passing a non-DOM-component triggers the next
	  // invariant for a missing parent, which is super confusing.
	  !(inst._hostNode !== undefined) ?  true ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	
	  if (inst._hostNode) {
	    return inst._hostNode;
	  }
	
	  // Walk up the tree until we find an ancestor whose DOM node we have cached.
	  var parents = [];
	  while (!inst._hostNode) {
	    parents.push(inst);
	    !inst._hostParent ?  true ? invariant(false, 'React DOM tree root should always have a node reference.') : _prodInvariant('34') : void 0;
	    inst = inst._hostParent;
	  }
	
	  // Now parents contains each ancestor that does *not* have a cached native
	  // node, and `inst` is the deepest ancestor that does.
	  for (; parents.length; inst = parents.pop()) {
	    precacheChildNodes(inst, inst._hostNode);
	  }
	
	  return inst._hostNode;
	}
	
	var ReactDOMComponentTree = {
	  getClosestInstanceFromNode: getClosestInstanceFromNode,
	  getInstanceFromNode: getInstanceFromNode,
	  getNodeFromInstance: getNodeFromInstance,
	  precacheChildNodes: precacheChildNodes,
	  precacheNode: precacheNode,
	  uncacheNode: uncacheNode
	};
	
	module.exports = ReactDOMComponentTree;

/***/ }),
/* 41 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	'use strict';
	
	/**
	 * WARNING: DO NOT manually require this module.
	 * This is a replacement for `invariant(...)` used by the error code system
	 * and will _only_ be required by the corresponding babel pass.
	 * It always throws.
	 */
	
	function reactProdInvariant(code) {
	  var argCount = arguments.length - 1;
	
	  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;
	
	  for (var argIdx = 0; argIdx < argCount; argIdx++) {
	    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
	  }
	
	  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';
	
	  var error = new Error(message);
	  error.name = 'Invariant Violation';
	  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame
	
	  throw error;
	}
	
	module.exports = reactProdInvariant;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(41);
	
	var invariant = __webpack_require__(12);
	
	function checkMask(value, bitmask) {
	  return (value & bitmask) === bitmask;
	}
	
	var DOMPropertyInjection = {
	  /**
	   * Mapping from normalized, camelcased property names to a configuration that
	   * specifies how the associated DOM property should be accessed or rendered.
	   */
	  MUST_USE_PROPERTY: 0x1,
	  HAS_BOOLEAN_VALUE: 0x4,
	  HAS_NUMERIC_VALUE: 0x8,
	  HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
	  HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,
	
	  /**
	   * Inject some specialized knowledge about the DOM. This takes a config object
	   * with the following properties:
	   *
	   * isCustomAttribute: function that given an attribute name will return true
	   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
	   * attributes where it's impossible to enumerate all of the possible
	   * attribute names,
	   *
	   * Properties: object mapping DOM property name to one of the
	   * DOMPropertyInjection constants or null. If your attribute isn't in here,
	   * it won't get written to the DOM.
	   *
	   * DOMAttributeNames: object mapping React attribute name to the DOM
	   * attribute name. Attribute names not specified use the **lowercase**
	   * normalized name.
	   *
	   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
	   * attribute namespace URL. (Attribute names not specified use no namespace.)
	   *
	   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
	   * Property names not specified use the normalized name.
	   *
	   * DOMMutationMethods: Properties that require special mutation methods. If
	   * `value` is undefined, the mutation method should unset the property.
	   *
	   * @param {object} domPropertyConfig the config as described above.
	   */
	  injectDOMPropertyConfig: function (domPropertyConfig) {
	    var Injection = DOMPropertyInjection;
	    var Properties = domPropertyConfig.Properties || {};
	    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
	    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
	    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
	    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
	
	    if (domPropertyConfig.isCustomAttribute) {
	      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
	    }
	
	    for (var propName in Properties) {
	      !!DOMProperty.properties.hasOwnProperty(propName) ?  true ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property \'%s\' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.', propName) : _prodInvariant('48', propName) : void 0;
	
	      var lowerCased = propName.toLowerCase();
	      var propConfig = Properties[propName];
	
	      var propertyInfo = {
	        attributeName: lowerCased,
	        attributeNamespace: null,
	        propertyName: propName,
	        mutationMethod: null,
	
	        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
	        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
	        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
	        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
	        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
	      };
	      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ?  true ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s', propName) : _prodInvariant('50', propName) : void 0;
	
	      if (true) {
	        DOMProperty.getPossibleStandardName[lowerCased] = propName;
	      }
	
	      if (DOMAttributeNames.hasOwnProperty(propName)) {
	        var attributeName = DOMAttributeNames[propName];
	        propertyInfo.attributeName = attributeName;
	        if (true) {
	          DOMProperty.getPossibleStandardName[attributeName] = propName;
	        }
	      }
	
	      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
	        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
	      }
	
	      if (DOMPropertyNames.hasOwnProperty(propName)) {
	        propertyInfo.propertyName = DOMPropertyNames[propName];
	      }
	
	      if (DOMMutationMethods.hasOwnProperty(propName)) {
	        propertyInfo.mutationMethod = DOMMutationMethods[propName];
	      }
	
	      DOMProperty.properties[propName] = propertyInfo;
	    }
	  }
	};
	
	/* eslint-disable max-len */
	var ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
	/* eslint-enable max-len */
	
	/**
	 * DOMProperty exports lookup objects that can be used like functions:
	 *
	 *   > DOMProperty.isValid['id']
	 *   true
	 *   > DOMProperty.isValid['foobar']
	 *   undefined
	 *
	 * Although this may be confusing, it performs better in general.
	 *
	 * @see http://jsperf.com/key-exists
	 * @see http://jsperf.com/key-missing
	 */
	var DOMProperty = {
	  ID_ATTRIBUTE_NAME: 'data-reactid',
	  ROOT_ATTRIBUTE_NAME: 'data-reactroot',
	
	  ATTRIBUTE_NAME_START_CHAR: ATTRIBUTE_NAME_START_CHAR,
	  ATTRIBUTE_NAME_CHAR: ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040',
	
	  /**
	   * Map from property "standard name" to an object with info about how to set
	   * the property in the DOM. Each object contains:
	   *
	   * attributeName:
	   *   Used when rendering markup or with `*Attribute()`.
	   * attributeNamespace
	   * propertyName:
	   *   Used on DOM node instances. (This includes properties that mutate due to
	   *   external factors.)
	   * mutationMethod:
	   *   If non-null, used instead of the property or `setAttribute()` after
	   *   initial render.
	   * mustUseProperty:
	   *   Whether the property must be accessed and mutated as an object property.
	   * hasBooleanValue:
	   *   Whether the property should be removed when set to a falsey value.
	   * hasNumericValue:
	   *   Whether the property must be numeric or parse as a numeric and should be
	   *   removed when set to a falsey value.
	   * hasPositiveNumericValue:
	   *   Whether the property must be positive numeric or parse as a positive
	   *   numeric and should be removed when set to a falsey value.
	   * hasOverloadedBooleanValue:
	   *   Whether the property can be used as a flag as well as with a value.
	   *   Removed when strictly equal to false; present without a value when
	   *   strictly equal to true; present with a value otherwise.
	   */
	  properties: {},
	
	  /**
	   * Mapping from lowercase property names to the properly cased version, used
	   * to warn in the case of missing properties. Available only in __DEV__.
	   *
	   * autofocus is predefined, because adding it to the property whitelist
	   * causes unintended side effects.
	   *
	   * @type {Object}
	   */
	  getPossibleStandardName:  true ? { autofocus: 'autoFocus' } : null,
	
	  /**
	   * All of the isCustomAttribute() functions that have been injected.
	   */
	  _isCustomAttributeFunctions: [],
	
	  /**
	   * Checks whether a property name is a custom attribute.
	   * @method
	   */
	  isCustomAttribute: function (attributeName) {
	    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
	      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
	      if (isCustomAttributeFn(attributeName)) {
	        return true;
	      }
	    }
	    return false;
	  },
	
	  injection: DOMPropertyInjection
	};
	
	module.exports = DOMProperty;

/***/ }),
/* 43 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var ReactDOMComponentFlags = {
	  hasCachedChildNodes: 1 << 0
	};
	
	module.exports = ReactDOMComponentFlags;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var ARIADOMPropertyConfig = __webpack_require__(45);
	var BeforeInputEventPlugin = __webpack_require__(46);
	var ChangeEventPlugin = __webpack_require__(61);
	var DefaultEventPluginOrder = __webpack_require__(79);
	var EnterLeaveEventPlugin = __webpack_require__(80);
	var HTMLDOMPropertyConfig = __webpack_require__(85);
	var ReactComponentBrowserEnvironment = __webpack_require__(86);
	var ReactDOMComponent = __webpack_require__(99);
	var ReactDOMComponentTree = __webpack_require__(40);
	var ReactDOMEmptyComponent = __webpack_require__(144);
	var ReactDOMTreeTraversal = __webpack_require__(145);
	var ReactDOMTextComponent = __webpack_require__(146);
	var ReactDefaultBatchingStrategy = __webpack_require__(147);
	var ReactEventListener = __webpack_require__(148);
	var ReactInjection = __webpack_require__(151);
	var ReactReconcileTransaction = __webpack_require__(152);
	var SVGDOMPropertyConfig = __webpack_require__(160);
	var SelectEventPlugin = __webpack_require__(161);
	var SimpleEventPlugin = __webpack_require__(162);
	
	var alreadyInjected = false;
	
	function inject() {
	  if (alreadyInjected) {
	    // TODO: This is currently true because these injections are shared between
	    // the client and the server package. They should be built independently
	    // and not share any injection state. Then this problem will be solved.
	    return;
	  }
	  alreadyInjected = true;
	
	  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);
	
	  /**
	   * Inject modules for resolving DOM hierarchy and plugin ordering.
	   */
	  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
	  ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
	  ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);
	
	  /**
	   * Some important event plugins included by default (without having to require
	   * them).
	   */
	  ReactInjection.EventPluginHub.injectEventPluginsByName({
	    SimpleEventPlugin: SimpleEventPlugin,
	    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
	    ChangeEventPlugin: ChangeEventPlugin,
	    SelectEventPlugin: SelectEventPlugin,
	    BeforeInputEventPlugin: BeforeInputEventPlugin
	  });
	
	  ReactInjection.HostComponent.injectGenericComponentClass(ReactDOMComponent);
	
	  ReactInjection.HostComponent.injectTextComponentClass(ReactDOMTextComponent);
	
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(ARIADOMPropertyConfig);
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);
	
	  ReactInjection.EmptyComponent.injectEmptyComponentFactory(function (instantiate) {
	    return new ReactDOMEmptyComponent(instantiate);
	  });
	
	  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
	  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	
	  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
	}
	
	module.exports = {
	  inject: inject
	};

/***/ }),
/* 45 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var ARIADOMPropertyConfig = {
	  Properties: {
	    // Global States and Properties
	    'aria-current': 0, // state
	    'aria-details': 0,
	    'aria-disabled': 0, // state
	    'aria-hidden': 0, // state
	    'aria-invalid': 0, // state
	    'aria-keyshortcuts': 0,
	    'aria-label': 0,
	    'aria-roledescription': 0,
	    // Widget Attributes
	    'aria-autocomplete': 0,
	    'aria-checked': 0,
	    'aria-expanded': 0,
	    'aria-haspopup': 0,
	    'aria-level': 0,
	    'aria-modal': 0,
	    'aria-multiline': 0,
	    'aria-multiselectable': 0,
	    'aria-orientation': 0,
	    'aria-placeholder': 0,
	    'aria-pressed': 0,
	    'aria-readonly': 0,
	    'aria-required': 0,
	    'aria-selected': 0,
	    'aria-sort': 0,
	    'aria-valuemax': 0,
	    'aria-valuemin': 0,
	    'aria-valuenow': 0,
	    'aria-valuetext': 0,
	    // Live Region Attributes
	    'aria-atomic': 0,
	    'aria-busy': 0,
	    'aria-live': 0,
	    'aria-relevant': 0,
	    // Drag-and-Drop Attributes
	    'aria-dropeffect': 0,
	    'aria-grabbed': 0,
	    // Relationship Attributes
	    'aria-activedescendant': 0,
	    'aria-colcount': 0,
	    'aria-colindex': 0,
	    'aria-colspan': 0,
	    'aria-controls': 0,
	    'aria-describedby': 0,
	    'aria-errormessage': 0,
	    'aria-flowto': 0,
	    'aria-labelledby': 0,
	    'aria-owns': 0,
	    'aria-posinset': 0,
	    'aria-rowcount': 0,
	    'aria-rowindex': 0,
	    'aria-rowspan': 0,
	    'aria-setsize': 0
	  },
	  DOMAttributeNames: {},
	  DOMPropertyNames: {}
	};
	
	module.exports = ARIADOMPropertyConfig;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var EventPropagators = __webpack_require__(47);
	var ExecutionEnvironment = __webpack_require__(54);
	var FallbackCompositionState = __webpack_require__(55);
	var SyntheticCompositionEvent = __webpack_require__(58);
	var SyntheticInputEvent = __webpack_require__(60);
	
	var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
	var START_KEYCODE = 229;
	
	var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;
	
	var documentMode = null;
	if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
	  documentMode = document.documentMode;
	}
	
	// Webkit offers a very useful `textInput` event that can be used to
	// directly represent `beforeInput`. The IE `textinput` event is not as
	// useful, so we don't use it.
	var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();
	
	// In IE9+, we have access to composition events, but the data supplied
	// by the native compositionend event may be incorrect. Japanese ideographic
	// spaces, for instance (\u3000) are not recorded correctly.
	var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
	
	/**
	 * Opera <= 12 includes TextEvent in window, but does not fire
	 * text input events. Rely on keypress instead.
	 */
	function isPresto() {
	  var opera = window.opera;
	  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
	}
	
	var SPACEBAR_CODE = 32;
	var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
	
	// Events and their corresponding property names.
	var eventTypes = {
	  beforeInput: {
	    phasedRegistrationNames: {
	      bubbled: 'onBeforeInput',
	      captured: 'onBeforeInputCapture'
	    },
	    dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']
	  },
	  compositionEnd: {
	    phasedRegistrationNames: {
	      bubbled: 'onCompositionEnd',
	      captured: 'onCompositionEndCapture'
	    },
	    dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
	  },
	  compositionStart: {
	    phasedRegistrationNames: {
	      bubbled: 'onCompositionStart',
	      captured: 'onCompositionStartCapture'
	    },
	    dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
	  },
	  compositionUpdate: {
	    phasedRegistrationNames: {
	      bubbled: 'onCompositionUpdate',
	      captured: 'onCompositionUpdateCapture'
	    },
	    dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
	  }
	};
	
	// Track whether we've ever handled a keypress on the space key.
	var hasSpaceKeypress = false;
	
	/**
	 * Return whether a native keypress event is assumed to be a command.
	 * This is required because Firefox fires `keypress` events for key commands
	 * (cut, copy, select-all, etc.) even though no character is inserted.
	 */
	function isKeypressCommand(nativeEvent) {
	  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
	  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
	  !(nativeEvent.ctrlKey && nativeEvent.altKey);
	}
	
	/**
	 * Translate native top level events into event types.
	 *
	 * @param {string} topLevelType
	 * @return {object}
	 */
	function getCompositionEventType(topLevelType) {
	  switch (topLevelType) {
	    case 'topCompositionStart':
	      return eventTypes.compositionStart;
	    case 'topCompositionEnd':
	      return eventTypes.compositionEnd;
	    case 'topCompositionUpdate':
	      return eventTypes.compositionUpdate;
	  }
	}
	
	/**
	 * Does our fallback best-guess model think this event signifies that
	 * composition has begun?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionStart(topLevelType, nativeEvent) {
	  return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;
	}
	
	/**
	 * Does our fallback mode think that this event is the end of composition?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionEnd(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case 'topKeyUp':
	      // Command keys insert or clear IME input.
	      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
	    case 'topKeyDown':
	      // Expect IME keyCode on each keydown. If we get any other
	      // code we must have exited earlier.
	      return nativeEvent.keyCode !== START_KEYCODE;
	    case 'topKeyPress':
	    case 'topMouseDown':
	    case 'topBlur':
	      // Events are not possible without cancelling IME.
	      return true;
	    default:
	      return false;
	  }
	}
	
	/**
	 * Google Input Tools provides composition data via a CustomEvent,
	 * with the `data` property populated in the `detail` object. If this
	 * is available on the event object, use it. If not, this is a plain
	 * composition event and we have nothing special to extract.
	 *
	 * @param {object} nativeEvent
	 * @return {?string}
	 */
	function getDataFromCustomEvent(nativeEvent) {
	  var detail = nativeEvent.detail;
	  if (typeof detail === 'object' && 'data' in detail) {
	    return detail.data;
	  }
	  return null;
	}
	
	// Track the current IME composition fallback object, if any.
	var currentComposition = null;
	
	/**
	 * @return {?object} A SyntheticCompositionEvent.
	 */
	function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	  var eventType;
	  var fallbackData;
	
	  if (canUseCompositionEvent) {
	    eventType = getCompositionEventType(topLevelType);
	  } else if (!currentComposition) {
	    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
	      eventType = eventTypes.compositionStart;
	    }
	  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	    eventType = eventTypes.compositionEnd;
	  }
	
	  if (!eventType) {
	    return null;
	  }
	
	  if (useFallbackCompositionData) {
	    // The current composition is stored statically and must not be
	    // overwritten while composition continues.
	    if (!currentComposition && eventType === eventTypes.compositionStart) {
	      currentComposition = FallbackCompositionState.getPooled(nativeEventTarget);
	    } else if (eventType === eventTypes.compositionEnd) {
	      if (currentComposition) {
	        fallbackData = currentComposition.getData();
	      }
	    }
	  }
	
	  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);
	
	  if (fallbackData) {
	    // Inject data generated from fallback path into the synthetic event.
	    // This matches the property of native CompositionEventInterface.
	    event.data = fallbackData;
	  } else {
	    var customData = getDataFromCustomEvent(nativeEvent);
	    if (customData !== null) {
	      event.data = customData;
	    }
	  }
	
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The string corresponding to this `beforeInput` event.
	 */
	function getNativeBeforeInputChars(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case 'topCompositionEnd':
	      return getDataFromCustomEvent(nativeEvent);
	    case 'topKeyPress':
	      /**
	       * If native `textInput` events are available, our goal is to make
	       * use of them. However, there is a special case: the spacebar key.
	       * In Webkit, preventing default on a spacebar `textInput` event
	       * cancels character insertion, but it *also* causes the browser
	       * to fall back to its default spacebar behavior of scrolling the
	       * page.
	       *
	       * Tracking at:
	       * https://code.google.com/p/chromium/issues/detail?id=355103
	       *
	       * To avoid this issue, use the keypress event as if no `textInput`
	       * event is available.
	       */
	      var which = nativeEvent.which;
	      if (which !== SPACEBAR_CODE) {
	        return null;
	      }
	
	      hasSpaceKeypress = true;
	      return SPACEBAR_CHAR;
	
	    case 'topTextInput':
	      // Record the characters to be added to the DOM.
	      var chars = nativeEvent.data;
	
	      // If it's a spacebar character, assume that we have already handled
	      // it at the keypress level and bail immediately. Android Chrome
	      // doesn't give us keycodes, so we need to blacklist it.
	      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
	        return null;
	      }
	
	      return chars;
	
	    default:
	      // For other native event types, do nothing.
	      return null;
	  }
	}
	
	/**
	 * For browsers that do not provide the `textInput` event, extract the
	 * appropriate string to use for SyntheticInputEvent.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The fallback string for this `beforeInput` event.
	 */
	function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
	  // If we are currently composing (IME) and using a fallback to do so,
	  // try to extract the composed characters from the fallback object.
	  // If composition event is available, we extract a string only at
	  // compositionevent, otherwise extract it at fallback events.
	  if (currentComposition) {
	    if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	      var chars = currentComposition.getData();
	      FallbackCompositionState.release(currentComposition);
	      currentComposition = null;
	      return chars;
	    }
	    return null;
	  }
	
	  switch (topLevelType) {
	    case 'topPaste':
	      // If a paste event occurs after a keypress, throw out the input
	      // chars. Paste events should not lead to BeforeInput events.
	      return null;
	    case 'topKeyPress':
	      /**
	       * As of v27, Firefox may fire keypress events even when no character
	       * will be inserted. A few possibilities:
	       *
	       * - `which` is `0`. Arrow keys, Esc key, etc.
	       *
	       * - `which` is the pressed key code, but no char is available.
	       *   Ex: 'AltGr + d` in Polish. There is no modified character for
	       *   this key combination and no character is inserted into the
	       *   document, but FF fires the keypress for char code `100` anyway.
	       *   No `input` event will occur.
	       *
	       * - `which` is the pressed key code, but a command combination is
	       *   being used. Ex: `Cmd+C`. No character is inserted, and no
	       *   `input` event will occur.
	       */
	      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
	        return String.fromCharCode(nativeEvent.which);
	      }
	      return null;
	    case 'topCompositionEnd':
	      return useFallbackCompositionData ? null : nativeEvent.data;
	    default:
	      return null;
	  }
	}
	
	/**
	 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
	 * `textInput` or fallback behavior.
	 *
	 * @return {?object} A SyntheticInputEvent.
	 */
	function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	  var chars;
	
	  if (canUseTextInputEvent) {
	    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
	  } else {
	    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
	  }
	
	  // If no characters are being inserted, no BeforeInput event should
	  // be fired.
	  if (!chars) {
	    return null;
	  }
	
	  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);
	
	  event.data = chars;
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * Create an `onBeforeInput` event to match
	 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
	 *
	 * This event plugin is based on the native `textInput` event
	 * available in Chrome, Safari, Opera, and IE. This event fires after
	 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
	 *
	 * `beforeInput` is spec'd but not implemented in any browsers, and
	 * the `input` event does not provide any useful information about what has
	 * actually been added, contrary to the spec. Thus, `textInput` is the best
	 * available event to identify the characters that have actually been inserted
	 * into the target node.
	 *
	 * This plugin is also responsible for emitting `composition` events, thus
	 * allowing us to share composition fallback code for both `beforeInput` and
	 * `composition` event types.
	 */
	var BeforeInputEventPlugin = {
	  eventTypes: eventTypes,
	
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
	  }
	};
	
	module.exports = BeforeInputEventPlugin;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var EventPluginHub = __webpack_require__(48);
	var EventPluginUtils = __webpack_require__(50);
	
	var accumulateInto = __webpack_require__(52);
	var forEachAccumulated = __webpack_require__(53);
	var warning = __webpack_require__(8);
	
	var getListener = EventPluginHub.getListener;
	
	/**
	 * Some event types have a notion of different registration names for different
	 * "phases" of propagation. This finds listeners by a given phase.
	 */
	function listenerAtPhase(inst, event, propagationPhase) {
	  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
	  return getListener(inst, registrationName);
	}
	
	/**
	 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
	 * here, allows us to not have to bind or create functions for each event.
	 * Mutating the event's members allows us to not have to create a wrapping
	 * "dispatch" object that pairs the event with the listener.
	 */
	function accumulateDirectionalDispatches(inst, phase, event) {
	  if (true) {
	     true ? warning(inst, 'Dispatching inst must not be null') : void 0;
	  }
	  var listener = listenerAtPhase(inst, event, phase);
	  if (listener) {
	    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
	  }
	}
	
	/**
	 * Collect dispatches (must be entirely collected before dispatching - see unit
	 * tests). Lazily allocate the array to conserve memory.  We must loop through
	 * each event and perform the traversal for each one. We cannot perform a
	 * single traversal for the entire collection of events because each event may
	 * have a different target.
	 */
	function accumulateTwoPhaseDispatchesSingle(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
	 */
	function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    var targetInst = event._targetInst;
	    var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;
	    EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Accumulates without regard to direction, does not look for phased
	 * registration names. Same as `accumulateDirectDispatchesSingle` but without
	 * requiring that the `dispatchMarker` be the same as the dispatched ID.
	 */
	function accumulateDispatches(inst, ignoredDirection, event) {
	  if (event && event.dispatchConfig.registrationName) {
	    var registrationName = event.dispatchConfig.registrationName;
	    var listener = getListener(inst, registrationName);
	    if (listener) {
	      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
	    }
	  }
	}
	
	/**
	 * Accumulates dispatches on an `SyntheticEvent`, but only for the
	 * `dispatchMarker`.
	 * @param {SyntheticEvent} event
	 */
	function accumulateDirectDispatchesSingle(event) {
	  if (event && event.dispatchConfig.registrationName) {
	    accumulateDispatches(event._targetInst, null, event);
	  }
	}
	
	function accumulateTwoPhaseDispatches(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
	}
	
	function accumulateTwoPhaseDispatchesSkipTarget(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
	}
	
	function accumulateEnterLeaveDispatches(leave, enter, from, to) {
	  EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
	}
	
	function accumulateDirectDispatches(events) {
	  forEachAccumulated(events, accumulateDirectDispatchesSingle);
	}
	
	/**
	 * A small set of propagation patterns, each of which will accept a small amount
	 * of information, and generate a set of "dispatch ready event objects" - which
	 * are sets of events that have already been annotated with a set of dispatched
	 * listener functions/ids. The API is designed this way to discourage these
	 * propagation strategies from actually executing the dispatches, since we
	 * always want to collect the entire set of dispatches before executing event a
	 * single one.
	 *
	 * @constructor EventPropagators
	 */
	var EventPropagators = {
	  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
	  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
	  accumulateDirectDispatches: accumulateDirectDispatches,
	  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
	};
	
	module.exports = EventPropagators;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(41);
	
	var EventPluginRegistry = __webpack_require__(49);
	var EventPluginUtils = __webpack_require__(50);
	var ReactErrorUtils = __webpack_require__(51);
	
	var accumulateInto = __webpack_require__(52);
	var forEachAccumulated = __webpack_require__(53);
	var invariant = __webpack_require__(12);
	
	/**
	 * Internal store for event listeners
	 */
	var listenerBank = {};
	
	/**
	 * Internal queue of events that have accumulated their dispatches and are
	 * waiting to have their dispatches executed.
	 */
	var eventQueue = null;
	
	/**
	 * Dispatches an event and releases it back into the pool, unless persistent.
	 *
	 * @param {?object} event Synthetic event to be dispatched.
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @private
	 */
	var executeDispatchesAndRelease = function (event, simulated) {
	  if (event) {
	    EventPluginUtils.executeDispatchesInOrder(event, simulated);
	
	    if (!event.isPersistent()) {
	      event.constructor.release(event);
	    }
	  }
	};
	var executeDispatchesAndReleaseSimulated = function (e) {
	  return executeDispatchesAndRelease(e, true);
	};
	var executeDispatchesAndReleaseTopLevel = function (e) {
	  return executeDispatchesAndRelease(e, false);
	};
	
	var getDictionaryKey = function (inst) {
	  // Prevents V8 performance issue:
	  // https://github.com/facebook/react/pull/7232
	  return '.' + inst._rootNodeID;
	};
	
	function isInteractive(tag) {
	  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
	}
	
	function shouldPreventMouseEvent(name, type, props) {
	  switch (name) {
	    case 'onClick':
	    case 'onClickCapture':
	    case 'onDoubleClick':
	    case 'onDoubleClickCapture':
	    case 'onMouseDown':
	    case 'onMouseDownCapture':
	    case 'onMouseMove':
	    case 'onMouseMoveCapture':
	    case 'onMouseUp':
	    case 'onMouseUpCapture':
	      return !!(props.disabled && isInteractive(type));
	    default:
	      return false;
	  }
	}
	
	/**
	 * This is a unified interface for event plugins to be installed and configured.
	 *
	 * Event plugins can implement the following properties:
	 *
	 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
	 *     Required. When a top-level event is fired, this method is expected to
	 *     extract synthetic events that will in turn be queued and dispatched.
	 *
	 *   `eventTypes` {object}
	 *     Optional, plugins that fire events must publish a mapping of registration
	 *     names that are used to register listeners. Values of this mapping must
	 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
	 *
	 *   `executeDispatch` {function(object, function, string)}
	 *     Optional, allows plugins to override how an event gets dispatched. By
	 *     default, the listener is simply invoked.
	 *
	 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
	 *
	 * @public
	 */
	var EventPluginHub = {
	  /**
	   * Methods for injecting dependencies.
	   */
	  injection: {
	    /**
	     * @param {array} InjectedEventPluginOrder
	     * @public
	     */
	    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,
	
	    /**
	     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	     */
	    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
	  },
	
	  /**
	   * Stores `listener` at `listenerBank[registrationName][key]`. Is idempotent.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {function} listener The callback to store.
	   */
	  putListener: function (inst, registrationName, listener) {
	    !(typeof listener === 'function') ?  true ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : _prodInvariant('94', registrationName, typeof listener) : void 0;
	
	    var key = getDictionaryKey(inst);
	    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
	    bankForRegistrationName[key] = listener;
	
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.didPutListener) {
	      PluginModule.didPutListener(inst, registrationName, listener);
	    }
	  },
	
	  /**
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @return {?function} The stored callback.
	   */
	  getListener: function (inst, registrationName) {
	    // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
	    // live here; needs to be moved to a better place soon
	    var bankForRegistrationName = listenerBank[registrationName];
	    if (shouldPreventMouseEvent(registrationName, inst._currentElement.type, inst._currentElement.props)) {
	      return null;
	    }
	    var key = getDictionaryKey(inst);
	    return bankForRegistrationName && bankForRegistrationName[key];
	  },
	
	  /**
	   * Deletes a listener from the registration bank.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   */
	  deleteListener: function (inst, registrationName) {
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.willDeleteListener) {
	      PluginModule.willDeleteListener(inst, registrationName);
	    }
	
	    var bankForRegistrationName = listenerBank[registrationName];
	    // TODO: This should never be null -- when is it?
	    if (bankForRegistrationName) {
	      var key = getDictionaryKey(inst);
	      delete bankForRegistrationName[key];
	    }
	  },
	
	  /**
	   * Deletes all listeners for the DOM element with the supplied ID.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   */
	  deleteAllListeners: function (inst) {
	    var key = getDictionaryKey(inst);
	    for (var registrationName in listenerBank) {
	      if (!listenerBank.hasOwnProperty(registrationName)) {
	        continue;
	      }
	
	      if (!listenerBank[registrationName][key]) {
	        continue;
	      }
	
	      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	      if (PluginModule && PluginModule.willDeleteListener) {
	        PluginModule.willDeleteListener(inst, registrationName);
	      }
	
	      delete listenerBank[registrationName][key];
	    }
	  },
	
	  /**
	   * Allows registered plugins an opportunity to extract events from top-level
	   * native browser events.
	   *
	   * @return {*} An accumulation of synthetic events.
	   * @internal
	   */
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var events;
	    var plugins = EventPluginRegistry.plugins;
	    for (var i = 0; i < plugins.length; i++) {
	      // Not every plugin in the ordering may be loaded at runtime.
	      var possiblePlugin = plugins[i];
	      if (possiblePlugin) {
	        var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
	        if (extractedEvents) {
	          events = accumulateInto(events, extractedEvents);
	        }
	      }
	    }
	    return events;
	  },
	
	  /**
	   * Enqueues a synthetic event that should be dispatched when
	   * `processEventQueue` is invoked.
	   *
	   * @param {*} events An accumulation of synthetic events.
	   * @internal
	   */
	  enqueueEvents: function (events) {
	    if (events) {
	      eventQueue = accumulateInto(eventQueue, events);
	    }
	  },
	
	  /**
	   * Dispatches all synthetic events on the event queue.
	   *
	   * @internal
	   */
	  processEventQueue: function (simulated) {
	    // Set `eventQueue` to null before processing it so that we can tell if more
	    // events get enqueued while processing.
	    var processingEventQueue = eventQueue;
	    eventQueue = null;
	    if (simulated) {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
	    } else {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
	    }
	    !!eventQueue ?  true ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : _prodInvariant('95') : void 0;
	    // This would be a good time to rethrow if any of the event handlers threw.
	    ReactErrorUtils.rethrowCaughtError();
	  },
	
	  /**
	   * These are needed for tests only. Do not use!
	   */
	  __purge: function () {
	    listenerBank = {};
	  },
	
	  __getListenerBank: function () {
	    return listenerBank;
	  }
	};
	
	module.exports = EventPluginHub;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(41);
	
	var invariant = __webpack_require__(12);
	
	/**
	 * Injectable ordering of event plugins.
	 */
	var eventPluginOrder = null;
	
	/**
	 * Injectable mapping from names to event plugin modules.
	 */
	var namesToPlugins = {};
	
	/**
	 * Recomputes the plugin list using the injected plugins and plugin ordering.
	 *
	 * @private
	 */
	function recomputePluginOrdering() {
	  if (!eventPluginOrder) {
	    // Wait until an `eventPluginOrder` is injected.
	    return;
	  }
	  for (var pluginName in namesToPlugins) {
	    var pluginModule = namesToPlugins[pluginName];
	    var pluginIndex = eventPluginOrder.indexOf(pluginName);
	    !(pluginIndex > -1) ?  true ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : _prodInvariant('96', pluginName) : void 0;
	    if (EventPluginRegistry.plugins[pluginIndex]) {
	      continue;
	    }
	    !pluginModule.extractEvents ?  true ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : _prodInvariant('97', pluginName) : void 0;
	    EventPluginRegistry.plugins[pluginIndex] = pluginModule;
	    var publishedEvents = pluginModule.eventTypes;
	    for (var eventName in publishedEvents) {
	      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ?  true ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : _prodInvariant('98', eventName, pluginName) : void 0;
	    }
	  }
	}
	
	/**
	 * Publishes an event so that it can be dispatched by the supplied plugin.
	 *
	 * @param {object} dispatchConfig Dispatch configuration for the event.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @return {boolean} True if the event was successfully published.
	 * @private
	 */
	function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
	  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ?  true ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : _prodInvariant('99', eventName) : void 0;
	  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
	
	  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
	  if (phasedRegistrationNames) {
	    for (var phaseName in phasedRegistrationNames) {
	      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
	        var phasedRegistrationName = phasedRegistrationNames[phaseName];
	        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
	      }
	    }
	    return true;
	  } else if (dispatchConfig.registrationName) {
	    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
	    return true;
	  }
	  return false;
	}
	
	/**
	 * Publishes a registration name that is used to identify dispatched events and
	 * can be used with `EventPluginHub.putListener` to register listeners.
	 *
	 * @param {string} registrationName Registration name to add.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @private
	 */
	function publishRegistrationName(registrationName, pluginModule, eventName) {
	  !!EventPluginRegistry.registrationNameModules[registrationName] ?  true ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : _prodInvariant('100', registrationName) : void 0;
	  EventPluginRegistry.registrationNameModules[registrationName] = pluginModule;
	  EventPluginRegistry.registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;
	
	  if (true) {
	    var lowerCasedName = registrationName.toLowerCase();
	    EventPluginRegistry.possibleRegistrationNames[lowerCasedName] = registrationName;
	
	    if (registrationName === 'onDoubleClick') {
	      EventPluginRegistry.possibleRegistrationNames.ondblclick = registrationName;
	    }
	  }
	}
	
	/**
	 * Registers plugins so that they can extract and dispatch events.
	 *
	 * @see {EventPluginHub}
	 */
	var EventPluginRegistry = {
	  /**
	   * Ordered list of injected plugins.
	   */
	  plugins: [],
	
	  /**
	   * Mapping from event name to dispatch config
	   */
	  eventNameDispatchConfigs: {},
	
	  /**
	   * Mapping from registration name to plugin module
	   */
	  registrationNameModules: {},
	
	  /**
	   * Mapping from registration name to event name
	   */
	  registrationNameDependencies: {},
	
	  /**
	   * Mapping from lowercase registration names to the properly cased version,
	   * used to warn in the case of missing event handlers. Available
	   * only in __DEV__.
	   * @type {Object}
	   */
	  possibleRegistrationNames:  true ? {} : null,
	  // Trust the developer to only use possibleRegistrationNames in __DEV__
	
	  /**
	   * Injects an ordering of plugins (by plugin name). This allows the ordering
	   * to be decoupled from injection of the actual plugins so that ordering is
	   * always deterministic regardless of packaging, on-the-fly injection, etc.
	   *
	   * @param {array} InjectedEventPluginOrder
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginOrder}
	   */
	  injectEventPluginOrder: function (injectedEventPluginOrder) {
	    !!eventPluginOrder ?  true ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : _prodInvariant('101') : void 0;
	    // Clone the ordering so it cannot be dynamically mutated.
	    eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
	    recomputePluginOrdering();
	  },
	
	  /**
	   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
	   * in the ordering injected by `injectEventPluginOrder`.
	   *
	   * Plugins can be injected as part of page initialization or on-the-fly.
	   *
	   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginsByName}
	   */
	  injectEventPluginsByName: function (injectedNamesToPlugins) {
	    var isOrderingDirty = false;
	    for (var pluginName in injectedNamesToPlugins) {
	      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
	        continue;
	      }
	      var pluginModule = injectedNamesToPlugins[pluginName];
	      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
	        !!namesToPlugins[pluginName] ?  true ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : _prodInvariant('102', pluginName) : void 0;
	        namesToPlugins[pluginName] = pluginModule;
	        isOrderingDirty = true;
	      }
	    }
	    if (isOrderingDirty) {
	      recomputePluginOrdering();
	    }
	  },
	
	  /**
	   * Looks up the plugin for the supplied event.
	   *
	   * @param {object} event A synthetic event.
	   * @return {?object} The plugin that created the supplied event.
	   * @internal
	   */
	  getPluginModuleForEvent: function (event) {
	    var dispatchConfig = event.dispatchConfig;
	    if (dispatchConfig.registrationName) {
	      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
	    }
	    if (dispatchConfig.phasedRegistrationNames !== undefined) {
	      // pulling phasedRegistrationNames out of dispatchConfig helps Flow see
	      // that it is not undefined.
	      var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
	
	      for (var phase in phasedRegistrationNames) {
	        if (!phasedRegistrationNames.hasOwnProperty(phase)) {
	          continue;
	        }
	        var pluginModule = EventPluginRegistry.registrationNameModules[phasedRegistrationNames[phase]];
	        if (pluginModule) {
	          return pluginModule;
	        }
	      }
	    }
	    return null;
	  },
	
	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _resetEventPlugins: function () {
	    eventPluginOrder = null;
	    for (var pluginName in namesToPlugins) {
	      if (namesToPlugins.hasOwnProperty(pluginName)) {
	        delete namesToPlugins[pluginName];
	      }
	    }
	    EventPluginRegistry.plugins.length = 0;
	
	    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
	    for (var eventName in eventNameDispatchConfigs) {
	      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
	        delete eventNameDispatchConfigs[eventName];
	      }
	    }
	
	    var registrationNameModules = EventPluginRegistry.registrationNameModules;
	    for (var registrationName in registrationNameModules) {
	      if (registrationNameModules.hasOwnProperty(registrationName)) {
	        delete registrationNameModules[registrationName];
	      }
	    }
	
	    if (true) {
	      var possibleRegistrationNames = EventPluginRegistry.possibleRegistrationNames;
	      for (var lowerCasedName in possibleRegistrationNames) {
	        if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {
	          delete possibleRegistrationNames[lowerCasedName];
	        }
	      }
	    }
	  }
	};
	
	module.exports = EventPluginRegistry;

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(41);
	
	var ReactErrorUtils = __webpack_require__(51);
	
	var invariant = __webpack_require__(12);
	var warning = __webpack_require__(8);
	
	/**
	 * Injected dependencies:
	 */
	
	/**
	 * - `ComponentTree`: [required] Module that can convert between React instances
	 *   and actual node references.
	 */
	var ComponentTree;
	var TreeTraversal;
	var injection = {
	  injectComponentTree: function (Injected) {
	    ComponentTree = Injected;
	    if (true) {
	       true ? warning(Injected && Injected.getNodeFromInstance && Injected.getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;
	    }
	  },
	  injectTreeTraversal: function (Injected) {
	    TreeTraversal = Injected;
	    if (true) {
	       true ? warning(Injected && Injected.isAncestor && Injected.getLowestCommonAncestor, 'EventPluginUtils.injection.injectTreeTraversal(...): Injected ' + 'module is missing isAncestor or getLowestCommonAncestor.') : void 0;
	    }
	  }
	};
	
	function isEndish(topLevelType) {
	  return topLevelType === 'topMouseUp' || topLevelType === 'topTouchEnd' || topLevelType === 'topTouchCancel';
	}
	
	function isMoveish(topLevelType) {
	  return topLevelType === 'topMouseMove' || topLevelType === 'topTouchMove';
	}
	function isStartish(topLevelType) {
	  return topLevelType === 'topMouseDown' || topLevelType === 'topTouchStart';
	}
	
	var validateEventDispatches;
	if (true) {
	  validateEventDispatches = function (event) {
	    var dispatchListeners = event._dispatchListeners;
	    var dispatchInstances = event._dispatchInstances;
	
	    var listenersIsArr = Array.isArray(dispatchListeners);
	    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
	
	    var instancesIsArr = Array.isArray(dispatchInstances);
	    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;
	
	     true ? warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : void 0;
	  };
	}
	
	/**
	 * Dispatch the event to the listener.
	 * @param {SyntheticEvent} event SyntheticEvent to handle
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @param {function} listener Application-level callback
	 * @param {*} inst Internal component instance
	 */
	function executeDispatch(event, simulated, listener, inst) {
	  var type = event.type || 'unknown-event';
	  event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
	  if (simulated) {
	    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
	  } else {
	    ReactErrorUtils.invokeGuardedCallback(type, listener, event);
	  }
	  event.currentTarget = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches.
	 */
	function executeDispatchesInOrder(event, simulated) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchInstances = event._dispatchInstances;
	  if (true) {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and Instances are two parallel arrays that are always in sync.
	      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
	    }
	  } else if (dispatchListeners) {
	    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
	  }
	  event._dispatchListeners = null;
	  event._dispatchInstances = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches, but stops
	 * at the first dispatch execution returning true, and returns that id.
	 *
	 * @return {?string} id of the first dispatch execution who's listener returns
	 * true, or null if no listener returned true.
	 */
	function executeDispatchesInOrderStopAtTrueImpl(event) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchInstances = event._dispatchInstances;
	  if (true) {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and Instances are two parallel arrays that are always in sync.
	      if (dispatchListeners[i](event, dispatchInstances[i])) {
	        return dispatchInstances[i];
	      }
	    }
	  } else if (dispatchListeners) {
	    if (dispatchListeners(event, dispatchInstances)) {
	      return dispatchInstances;
	    }
	  }
	  return null;
	}
	
	/**
	 * @see executeDispatchesInOrderStopAtTrueImpl
	 */
	function executeDispatchesInOrderStopAtTrue(event) {
	  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
	  event._dispatchInstances = null;
	  event._dispatchListeners = null;
	  return ret;
	}
	
	/**
	 * Execution of a "direct" dispatch - there must be at most one dispatch
	 * accumulated on the event or it is considered an error. It doesn't really make
	 * sense for an event with multiple dispatches (bubbled) to keep track of the
	 * return values at each dispatch execution, but it does tend to make sense when
	 * dealing with "direct" dispatches.
	 *
	 * @return {*} The return value of executing the single dispatch.
	 */
	function executeDirectDispatch(event) {
	  if (true) {
	    validateEventDispatches(event);
	  }
	  var dispatchListener = event._dispatchListeners;
	  var dispatchInstance = event._dispatchInstances;
	  !!Array.isArray(dispatchListener) ?  true ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : _prodInvariant('103') : void 0;
	  event.currentTarget = dispatchListener ? EventPluginUtils.getNodeFromInstance(dispatchInstance) : null;
	  var res = dispatchListener ? dispatchListener(event) : null;
	  event.currentTarget = null;
	  event._dispatchListeners = null;
	  event._dispatchInstances = null;
	  return res;
	}
	
	/**
	 * @param {SyntheticEvent} event
	 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
	 */
	function hasDispatches(event) {
	  return !!event._dispatchListeners;
	}
	
	/**
	 * General utilities that are useful in creating custom Event Plugins.
	 */
	var EventPluginUtils = {
	  isEndish: isEndish,
	  isMoveish: isMoveish,
	  isStartish: isStartish,
	
	  executeDirectDispatch: executeDirectDispatch,
	  executeDispatchesInOrder: executeDispatchesInOrder,
	  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
	  hasDispatches: hasDispatches,
	
	  getInstanceFromNode: function (node) {
	    return ComponentTree.getInstanceFromNode(node);
	  },
	  getNodeFromInstance: function (node) {
	    return ComponentTree.getNodeFromInstance(node);
	  },
	  isAncestor: function (a, b) {
	    return TreeTraversal.isAncestor(a, b);
	  },
	  getLowestCommonAncestor: function (a, b) {
	    return TreeTraversal.getLowestCommonAncestor(a, b);
	  },
	  getParentInstance: function (inst) {
	    return TreeTraversal.getParentInstance(inst);
	  },
	  traverseTwoPhase: function (target, fn, arg) {
	    return TreeTraversal.traverseTwoPhase(target, fn, arg);
	  },
	  traverseEnterLeave: function (from, to, fn, argFrom, argTo) {
	    return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
	  },
	
	  injection: injection
	};
	
	module.exports = EventPluginUtils;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	'use strict';
	
	var caughtError = null;
	
	/**
	 * Call a function while guarding against errors that happens within it.
	 *
	 * @param {String} name of the guard to use for logging or debugging
	 * @param {Function} func The function to invoke
	 * @param {*} a First argument
	 * @param {*} b Second argument
	 */
	function invokeGuardedCallback(name, func, a) {
	  try {
	    func(a);
	  } catch (x) {
	    if (caughtError === null) {
	      caughtError = x;
	    }
	  }
	}
	
	var ReactErrorUtils = {
	  invokeGuardedCallback: invokeGuardedCallback,
	
	  /**
	   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
	   * handler are sure to be rethrown by rethrowCaughtError.
	   */
	  invokeGuardedCallbackWithCatch: invokeGuardedCallback,
	
	  /**
	   * During execution of guarded functions we will capture the first error which
	   * we will rethrow to be handled by the top level error handler.
	   */
	  rethrowCaughtError: function () {
	    if (caughtError) {
	      var error = caughtError;
	      caughtError = null;
	      throw error;
	    }
	  }
	};
	
	if (true) {
	  /**
	   * To help development we can get better devtools integration by simulating a
	   * real browser event.
	   */
	  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
	    var fakeNode = document.createElement('react');
	    ReactErrorUtils.invokeGuardedCallback = function (name, func, a) {
	      var boundFunc = function () {
	        func(a);
	      };
	      var evtType = 'react-' + name;
	      fakeNode.addEventListener(evtType, boundFunc, false);
	      var evt = document.createEvent('Event');
	      evt.initEvent(evtType, false, false);
	      fakeNode.dispatchEvent(evt);
	      fakeNode.removeEventListener(evtType, boundFunc, false);
	    };
	  }
	}
	
	module.exports = ReactErrorUtils;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(41);
	
	var invariant = __webpack_require__(12);
	
	/**
	 * Accumulates items that must not be null or undefined into the first one. This
	 * is used to conserve memory by avoiding array allocations, and thus sacrifices
	 * API cleanness. Since `current` can be null before being passed in and not
	 * null after this function, make sure to assign it back to `current`:
	 *
	 * `a = accumulateInto(a, b);`
	 *
	 * This API should be sparingly used. Try `accumulate` for something cleaner.
	 *
	 * @return {*|array<*>} An accumulation of items.
	 */
	
	function accumulateInto(current, next) {
	  !(next != null) ?  true ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : _prodInvariant('30') : void 0;
	
	  if (current == null) {
	    return next;
	  }
	
	  // Both are not empty. Warning: Never call x.concat(y) when you are not
	  // certain that x is an Array (x could be a string with concat method).
	  if (Array.isArray(current)) {
	    if (Array.isArray(next)) {
	      current.push.apply(current, next);
	      return current;
	    }
	    current.push(next);
	    return current;
	  }
	
	  if (Array.isArray(next)) {
	    // A bit too dangerous to mutate `next`.
	    return [current].concat(next);
	  }
	
	  return [current, next];
	}
	
	module.exports = accumulateInto;

/***/ }),
/* 53 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	'use strict';
	
	/**
	 * @param {array} arr an "accumulation" of items which is either an Array or
	 * a single item. Useful when paired with the `accumulate` module. This is a
	 * simple utility that allows us to reason about a collection of items, but
	 * handling the case when there is exactly one item (and we do not need to
	 * allocate an array).
	 */
	
	function forEachAccumulated(arr, cb, scope) {
	  if (Array.isArray(arr)) {
	    arr.forEach(cb, scope);
	  } else if (arr) {
	    cb.call(scope, arr);
	  }
	}
	
	module.exports = forEachAccumulated;

/***/ }),
/* 54 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	
	/**
	 * Simple, lightweight module assisting with the detection and context of
	 * Worker. Helps avoid circular dependencies and allows code to reason about
	 * whether or not they are in a Worker, even if they never include the main
	 * `ReactWorker` dependency.
	 */
	var ExecutionEnvironment = {
	
	  canUseDOM: canUseDOM,
	
	  canUseWorkers: typeof Worker !== 'undefined',
	
	  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
	
	  canUseViewport: canUseDOM && !!window.screen,
	
	  isInWorker: !canUseDOM // For now, this is true - might change in the future.
	
	};
	
	module.exports = ExecutionEnvironment;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var PooledClass = __webpack_require__(56);
	
	var getTextContentAccessor = __webpack_require__(57);
	
	/**
	 * This helper class stores information about text content of a target node,
	 * allowing comparison of content before and after a given event.
	 *
	 * Identify the node where selection currently begins, then observe
	 * both its text content and its current position in the DOM. Since the
	 * browser may natively replace the target node during composition, we can
	 * use its position to find its replacement.
	 *
	 * @param {DOMEventTarget} root
	 */
	function FallbackCompositionState(root) {
	  this._root = root;
	  this._startText = this.getText();
	  this._fallbackText = null;
	}
	
	_assign(FallbackCompositionState.prototype, {
	  destructor: function () {
	    this._root = null;
	    this._startText = null;
	    this._fallbackText = null;
	  },
	
	  /**
	   * Get current text of input.
	   *
	   * @return {string}
	   */
	  getText: function () {
	    if ('value' in this._root) {
	      return this._root.value;
	    }
	    return this._root[getTextContentAccessor()];
	  },
	
	  /**
	   * Determine the differing substring between the initially stored
	   * text content and the current content.
	   *
	   * @return {string}
	   */
	  getData: function () {
	    if (this._fallbackText) {
	      return this._fallbackText;
	    }
	
	    var start;
	    var startValue = this._startText;
	    var startLength = startValue.length;
	    var end;
	    var endValue = this.getText();
	    var endLength = endValue.length;
	
	    for (start = 0; start < startLength; start++) {
	      if (startValue[start] !== endValue[start]) {
	        break;
	      }
	    }
	
	    var minEnd = startLength - start;
	    for (end = 1; end <= minEnd; end++) {
	      if (startValue[startLength - end] !== endValue[endLength - end]) {
	        break;
	      }
	    }
	
	    var sliceTail = end > 1 ? 1 - end : undefined;
	    this._fallbackText = endValue.slice(start, sliceTail);
	    return this._fallbackText;
	  }
	});
	
	PooledClass.addPoolingTo(FallbackCompositionState);
	
	module.exports = FallbackCompositionState;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(41);
	
	var invariant = __webpack_require__(12);
	
	/**
	 * Static poolers. Several custom versions for each potential number of
	 * arguments. A completely generic pooler is easy to implement, but would
	 * require accessing the `arguments` object. In each of these, `this` refers to
	 * the Class itself, not an instance. If any others are needed, simply add them
	 * here, or in their own files.
	 */
	var oneArgumentPooler = function (copyFieldsFrom) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, copyFieldsFrom);
	    return instance;
	  } else {
	    return new Klass(copyFieldsFrom);
	  }
	};
	
	var twoArgumentPooler = function (a1, a2) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2);
	    return instance;
	  } else {
	    return new Klass(a1, a2);
	  }
	};
	
	var threeArgumentPooler = function (a1, a2, a3) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3);
	  }
	};
	
	var fourArgumentPooler = function (a1, a2, a3, a4) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4);
	  }
	};
	
	var standardReleaser = function (instance) {
	  var Klass = this;
	  !(instance instanceof Klass) ?  true ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
	  instance.destructor();
	  if (Klass.instancePool.length < Klass.poolSize) {
	    Klass.instancePool.push(instance);
	  }
	};
	
	var DEFAULT_POOL_SIZE = 10;
	var DEFAULT_POOLER = oneArgumentPooler;
	
	/**
	 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
	 * itself (statically) not adding any prototypical fields. Any CopyConstructor
	 * you give this may have a `poolSize` property, and will look for a
	 * prototypical `destructor` on instances.
	 *
	 * @param {Function} CopyConstructor Constructor that can be used to reset.
	 * @param {Function} pooler Customizable pooler.
	 */
	var addPoolingTo = function (CopyConstructor, pooler) {
	  // Casting as any so that flow ignores the actual implementation and trusts
	  // it to match the type we declared
	  var NewKlass = CopyConstructor;
	  NewKlass.instancePool = [];
	  NewKlass.getPooled = pooler || DEFAULT_POOLER;
	  if (!NewKlass.poolSize) {
	    NewKlass.poolSize = DEFAULT_POOL_SIZE;
	  }
	  NewKlass.release = standardReleaser;
	  return NewKlass;
	};
	
	var PooledClass = {
	  addPoolingTo: addPoolingTo,
	  oneArgumentPooler: oneArgumentPooler,
	  twoArgumentPooler: twoArgumentPooler,
	  threeArgumentPooler: threeArgumentPooler,
	  fourArgumentPooler: fourArgumentPooler
	};
	
	module.exports = PooledClass;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(54);
	
	var contentKey = null;
	
	/**
	 * Gets the key used to access text content on a DOM node.
	 *
	 * @return {?string} Key used to access text content.
	 * @internal
	 */
	function getTextContentAccessor() {
	  if (!contentKey && ExecutionEnvironment.canUseDOM) {
	    // Prefer textContent to innerText because many browsers support both but
	    // SVG <text> elements don't support innerText even when <div> does.
	    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
	  }
	  return contentKey;
	}
	
	module.exports = getTextContentAccessor;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(59);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
	 */
	var CompositionEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);
	
	module.exports = SyntheticCompositionEvent;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var PooledClass = __webpack_require__(56);
	
	var emptyFunction = __webpack_require__(9);
	var warning = __webpack_require__(8);
	
	var didWarnForAddedNewProperty = false;
	var isProxySupported = typeof Proxy === 'function';
	
	var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var EventInterface = {
	  type: null,
	  target: null,
	  // currentTarget is set when dispatching; no use in copying it here
	  currentTarget: emptyFunction.thatReturnsNull,
	  eventPhase: null,
	  bubbles: null,
	  cancelable: null,
	  timeStamp: function (event) {
	    return event.timeStamp || Date.now();
	  },
	  defaultPrevented: null,
	  isTrusted: null
	};
	
	/**
	 * Synthetic events are dispatched by event plugins, typically in response to a
	 * top-level event delegation handler.
	 *
	 * These systems should generally use pooling to reduce the frequency of garbage
	 * collection. The system should check `isPersistent` to determine whether the
	 * event should be released into the pool after being dispatched. Users that
	 * need a persisted event should invoke `persist`.
	 *
	 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
	 * normalizing browser quirks. Subclasses do not necessarily have to implement a
	 * DOM interface; custom application-specific events can also subclass this.
	 *
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {*} targetInst Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @param {DOMEventTarget} nativeEventTarget Target node.
	 */
	function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
	  if (true) {
	    // these have a getter/setter for warnings
	    delete this.nativeEvent;
	    delete this.preventDefault;
	    delete this.stopPropagation;
	  }
	
	  this.dispatchConfig = dispatchConfig;
	  this._targetInst = targetInst;
	  this.nativeEvent = nativeEvent;
	
	  var Interface = this.constructor.Interface;
	  for (var propName in Interface) {
	    if (!Interface.hasOwnProperty(propName)) {
	      continue;
	    }
	    if (true) {
	      delete this[propName]; // this has a getter/setter for warnings
	    }
	    var normalize = Interface[propName];
	    if (normalize) {
	      this[propName] = normalize(nativeEvent);
	    } else {
	      if (propName === 'target') {
	        this.target = nativeEventTarget;
	      } else {
	        this[propName] = nativeEvent[propName];
	      }
	    }
	  }
	
	  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
	  if (defaultPrevented) {
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  } else {
	    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
	  }
	  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
	  return this;
	}
	
	_assign(SyntheticEvent.prototype, {
	  preventDefault: function () {
	    this.defaultPrevented = true;
	    var event = this.nativeEvent;
	    if (!event) {
	      return;
	    }
	
	    if (event.preventDefault) {
	      event.preventDefault();
	      // eslint-disable-next-line valid-typeof
	    } else if (typeof event.returnValue !== 'unknown') {
	      event.returnValue = false;
	    }
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  },
	
	  stopPropagation: function () {
	    var event = this.nativeEvent;
	    if (!event) {
	      return;
	    }
	
	    if (event.stopPropagation) {
	      event.stopPropagation();
	      // eslint-disable-next-line valid-typeof
	    } else if (typeof event.cancelBubble !== 'unknown') {
	      // The ChangeEventPlugin registers a "propertychange" event for
	      // IE. This event does not support bubbling or cancelling, and
	      // any references to cancelBubble throw "Member not found".  A
	      // typeof check of "unknown" circumvents this issue (and is also
	      // IE specific).
	      event.cancelBubble = true;
	    }
	
	    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * We release all dispatched `SyntheticEvent`s after each event loop, adding
	   * them back into the pool. This allows a way to hold onto a reference that
	   * won't be added back into the pool.
	   */
	  persist: function () {
	    this.isPersistent = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * Checks if this event should be released back into the pool.
	   *
	   * @return {boolean} True if this should not be released, false otherwise.
	   */
	  isPersistent: emptyFunction.thatReturnsFalse,
	
	  /**
	   * `PooledClass` looks for `destructor` on each instance it releases.
	   */
	  destructor: function () {
	    var Interface = this.constructor.Interface;
	    for (var propName in Interface) {
	      if (true) {
	        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
	      } else {
	        this[propName] = null;
	      }
	    }
	    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
	      this[shouldBeReleasedProperties[i]] = null;
	    }
	    if (true) {
	      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
	      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
	      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
	    }
	  }
	});
	
	SyntheticEvent.Interface = EventInterface;
	
	/**
	 * Helper to reduce boilerplate when creating subclasses.
	 *
	 * @param {function} Class
	 * @param {?object} Interface
	 */
	SyntheticEvent.augmentClass = function (Class, Interface) {
	  var Super = this;
	
	  var E = function () {};
	  E.prototype = Super.prototype;
	  var prototype = new E();
	
	  _assign(prototype, Class.prototype);
	  Class.prototype = prototype;
	  Class.prototype.constructor = Class;
	
	  Class.Interface = _assign({}, Super.Interface, Interface);
	  Class.augmentClass = Super.augmentClass;
	
	  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
	};
	
	/** Proxying after everything set on SyntheticEvent
	  * to resolve Proxy issue on some WebKit browsers
	  * in which some Event properties are set to undefined (GH#10010)
	  */
	if (true) {
	  if (isProxySupported) {
	    /*eslint-disable no-func-assign */
	    SyntheticEvent = new Proxy(SyntheticEvent, {
	      construct: function (target, args) {
	        return this.apply(target, Object.create(target.prototype), args);
	      },
	      apply: function (constructor, that, args) {
	        return new Proxy(constructor.apply(that, args), {
	          set: function (target, prop, value) {
	            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
	               true ? warning(didWarnForAddedNewProperty || target.isPersistent(), "This synthetic event is reused for performance reasons. If you're " + "seeing this, you're adding a new property in the synthetic event object. " + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.') : void 0;
	              didWarnForAddedNewProperty = true;
	            }
	            target[prop] = value;
	            return true;
	          }
	        });
	      }
	    });
	    /*eslint-enable no-func-assign */
	  }
	}
	
	PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);
	
	module.exports = SyntheticEvent;
	
	/**
	  * Helper to nullify syntheticEvent instance properties when destructing
	  *
	  * @param {object} SyntheticEvent
	  * @param {String} propName
	  * @return {object} defineProperty object
	  */
	function getPooledWarningPropertyDefinition(propName, getVal) {
	  var isFunction = typeof getVal === 'function';
	  return {
	    configurable: true,
	    set: set,
	    get: get
	  };
	
	  function set(val) {
	    var action = isFunction ? 'setting the method' : 'setting the property';
	    warn(action, 'This is effectively a no-op');
	    return val;
	  }
	
	  function get() {
	    var action = isFunction ? 'accessing the method' : 'accessing the property';
	    var result = isFunction ? 'This is a no-op function' : 'This is set to null';
	    warn(action, result);
	    return getVal;
	  }
	
	  function warn(action, result) {
	    var warningCondition = false;
	     true ? warning(warningCondition, "This synthetic event is reused for performance reasons. If you're seeing this, " + "you're %s `%s` on a released/nullified synthetic event. %s. " + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;
	  }
	}

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(59);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
	 *      /#events-inputevents
	 */
	var InputEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);
	
	module.exports = SyntheticInputEvent;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var EventPluginHub = __webpack_require__(48);
	var EventPropagators = __webpack_require__(47);
	var ExecutionEnvironment = __webpack_require__(54);
	var ReactDOMComponentTree = __webpack_require__(40);
	var ReactUpdates = __webpack_require__(62);
	var SyntheticEvent = __webpack_require__(59);
	
	var inputValueTracking = __webpack_require__(75);
	var getEventTarget = __webpack_require__(76);
	var isEventSupported = __webpack_require__(77);
	var isTextInputElement = __webpack_require__(78);
	
	var eventTypes = {
	  change: {
	    phasedRegistrationNames: {
	      bubbled: 'onChange',
	      captured: 'onChangeCapture'
	    },
	    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']
	  }
	};
	
	function createAndAccumulateChangeEvent(inst, nativeEvent, target) {
	  var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, target);
	  event.type = 'change';
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	/**
	 * For IE shims
	 */
	var activeElement = null;
	var activeElementInst = null;
	
	/**
	 * SECTION: handle `change` event
	 */
	function shouldUseChangeEvent(elem) {
	  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
	}
	
	var doesChangeEventBubble = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // See `handleChange` comment below
	  doesChangeEventBubble = isEventSupported('change') && (!document.documentMode || document.documentMode > 8);
	}
	
	function manualDispatchChangeEvent(nativeEvent) {
	  var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent));
	
	  // If change and propertychange bubbled, we'd just bind to it like all the
	  // other events and have it go through ReactBrowserEventEmitter. Since it
	  // doesn't, we manually listen for the events and so we have to enqueue and
	  // process the abstract event manually.
	  //
	  // Batching is necessary here in order to ensure that all event handlers run
	  // before the next rerender (including event handlers attached to ancestor
	  // elements instead of directly on the input). Without this, controlled
	  // components don't work properly in conjunction with event bubbling because
	  // the component is rerendered and the value reverted before all the event
	  // handlers can run. See https://github.com/facebook/react/issues/708.
	  ReactUpdates.batchedUpdates(runEventInBatch, event);
	}
	
	function runEventInBatch(event) {
	  EventPluginHub.enqueueEvents(event);
	  EventPluginHub.processEventQueue(false);
	}
	
	function startWatchingForChangeEventIE8(target, targetInst) {
	  activeElement = target;
	  activeElementInst = targetInst;
	  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
	}
	
	function stopWatchingForChangeEventIE8() {
	  if (!activeElement) {
	    return;
	  }
	  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
	  activeElement = null;
	  activeElementInst = null;
	}
	
	function getInstIfValueChanged(targetInst, nativeEvent) {
	  var updated = inputValueTracking.updateValueIfChanged(targetInst);
	  var simulated = nativeEvent.simulated === true && ChangeEventPlugin._allowSimulatedPassThrough;
	
	  if (updated || simulated) {
	    return targetInst;
	  }
	}
	
	function getTargetInstForChangeEvent(topLevelType, targetInst) {
	  if (topLevelType === 'topChange') {
	    return targetInst;
	  }
	}
	
	function handleEventsForChangeEventIE8(topLevelType, target, targetInst) {
	  if (topLevelType === 'topFocus') {
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForChangeEventIE8();
	    startWatchingForChangeEventIE8(target, targetInst);
	  } else if (topLevelType === 'topBlur') {
	    stopWatchingForChangeEventIE8();
	  }
	}
	
	/**
	 * SECTION: handle `input` event
	 */
	var isInputEventSupported = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // IE9 claims to support the input event but fails to trigger it when
	  // deleting text, so we ignore its input events.
	
	  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);
	}
	
	/**
	 * (For IE <=9) Starts tracking propertychange events on the passed-in element
	 * and override the value property so that we can distinguish user events from
	 * value changes in JS.
	 */
	function startWatchingForValueChange(target, targetInst) {
	  activeElement = target;
	  activeElementInst = targetInst;
	  activeElement.attachEvent('onpropertychange', handlePropertyChange);
	}
	
	/**
	 * (For IE <=9) Removes the event listeners from the currently-tracked element,
	 * if any exists.
	 */
	function stopWatchingForValueChange() {
	  if (!activeElement) {
	    return;
	  }
	  activeElement.detachEvent('onpropertychange', handlePropertyChange);
	
	  activeElement = null;
	  activeElementInst = null;
	}
	
	/**
	 * (For IE <=9) Handles a propertychange event, sending a `change` event if
	 * the value of the active element has changed.
	 */
	function handlePropertyChange(nativeEvent) {
	  if (nativeEvent.propertyName !== 'value') {
	    return;
	  }
	  if (getInstIfValueChanged(activeElementInst, nativeEvent)) {
	    manualDispatchChangeEvent(nativeEvent);
	  }
	}
	
	function handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {
	  if (topLevelType === 'topFocus') {
	    // In IE8, we can capture almost all .value changes by adding a
	    // propertychange handler and looking for events with propertyName
	    // equal to 'value'
	    // In IE9, propertychange fires for most input events but is buggy and
	    // doesn't fire when text is deleted, but conveniently, selectionchange
	    // appears to fire in all of the remaining cases so we catch those and
	    // forward the event if the value has changed
	    // In either case, we don't want to call the event handler if the value
	    // is changed from JS so we redefine a setter for `.value` that updates
	    // our activeElementValue variable, allowing us to ignore those changes
	    //
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForValueChange();
	    startWatchingForValueChange(target, targetInst);
	  } else if (topLevelType === 'topBlur') {
	    stopWatchingForValueChange();
	  }
	}
	
	// For IE8 and IE9.
	function getTargetInstForInputEventPolyfill(topLevelType, targetInst, nativeEvent) {
	  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {
	    // On the selectionchange event, the target is just document which isn't
	    // helpful for us so just check activeElement instead.
	    //
	    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
	    // propertychange on the first input event after setting `value` from a
	    // script and fires only keydown, keypress, keyup. Catching keyup usually
	    // gets it and catching keydown lets us fire an event for the first
	    // keystroke if user does a key repeat (it'll be a little delayed: right
	    // before the second keystroke). Other input methods (e.g., paste) seem to
	    // fire selectionchange normally.
	    return getInstIfValueChanged(activeElementInst, nativeEvent);
	  }
	}
	
	/**
	 * SECTION: handle `click` event
	 */
	function shouldUseClickEvent(elem) {
	  // Use the `click` event to detect changes to checkbox and radio inputs.
	  // This approach works across all browsers, whereas `change` does not fire
	  // until `blur` in IE8.
	  var nodeName = elem.nodeName;
	  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
	}
	
	function getTargetInstForClickEvent(topLevelType, targetInst, nativeEvent) {
	  if (topLevelType === 'topClick') {
	    return getInstIfValueChanged(targetInst, nativeEvent);
	  }
	}
	
	function getTargetInstForInputOrChangeEvent(topLevelType, targetInst, nativeEvent) {
	  if (topLevelType === 'topInput' || topLevelType === 'topChange') {
	    return getInstIfValueChanged(targetInst, nativeEvent);
	  }
	}
	
	function handleControlledInputBlur(inst, node) {
	  // TODO: In IE, inst is occasionally null. Why?
	  if (inst == null) {
	    return;
	  }
	
	  // Fiber and ReactDOM keep wrapper state in separate places
	  var state = inst._wrapperState || node._wrapperState;
	
	  if (!state || !state.controlled || node.type !== 'number') {
	    return;
	  }
	
	  // If controlled, assign the value attribute to the current value on blur
	  var value = '' + node.value;
	  if (node.getAttribute('value') !== value) {
	    node.setAttribute('value', value);
	  }
	}
	
	/**
	 * This plugin creates an `onChange` event that normalizes change events
	 * across form elements. This event fires at a time when it's possible to
	 * change the element's value without seeing a flicker.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - select
	 */
	var ChangeEventPlugin = {
	  eventTypes: eventTypes,
	
	  _allowSimulatedPassThrough: true,
	  _isInputEventSupported: isInputEventSupported,
	
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;
	
	    var getTargetInstFunc, handleEventFunc;
	    if (shouldUseChangeEvent(targetNode)) {
	      if (doesChangeEventBubble) {
	        getTargetInstFunc = getTargetInstForChangeEvent;
	      } else {
	        handleEventFunc = handleEventsForChangeEventIE8;
	      }
	    } else if (isTextInputElement(targetNode)) {
	      if (isInputEventSupported) {
	        getTargetInstFunc = getTargetInstForInputOrChangeEvent;
	      } else {
	        getTargetInstFunc = getTargetInstForInputEventPolyfill;
	        handleEventFunc = handleEventsForInputEventPolyfill;
	      }
	    } else if (shouldUseClickEvent(targetNode)) {
	      getTargetInstFunc = getTargetInstForClickEvent;
	    }
	
	    if (getTargetInstFunc) {
	      var inst = getTargetInstFunc(topLevelType, targetInst, nativeEvent);
	      if (inst) {
	        var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);
	        return event;
	      }
	    }
	
	    if (handleEventFunc) {
	      handleEventFunc(topLevelType, targetNode, targetInst);
	    }
	
	    // When blurring, set the value attribute for number inputs
	    if (topLevelType === 'topBlur') {
	      handleControlledInputBlur(targetInst, targetNode);
	    }
	  }
	};
	
	module.exports = ChangeEventPlugin;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(41),
	    _assign = __webpack_require__(4);
	
	var CallbackQueue = __webpack_require__(63);
	var PooledClass = __webpack_require__(56);
	var ReactFeatureFlags = __webpack_require__(64);
	var ReactReconciler = __webpack_require__(65);
	var Transaction = __webpack_require__(74);
	
	var invariant = __webpack_require__(12);
	
	var dirtyComponents = [];
	var updateBatchNumber = 0;
	var asapCallbackQueue = CallbackQueue.getPooled();
	var asapEnqueued = false;
	
	var batchingStrategy = null;
	
	function ensureInjected() {
	  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ?  true ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant('123') : void 0;
	}
	
	var NESTED_UPDATES = {
	  initialize: function () {
	    this.dirtyComponentsLength = dirtyComponents.length;
	  },
	  close: function () {
	    if (this.dirtyComponentsLength !== dirtyComponents.length) {
	      // Additional updates were enqueued by componentDidUpdate handlers or
	      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
	      // these new updates so that if A's componentDidUpdate calls setState on
	      // B, B will update before the callback A's updater provided when calling
	      // setState.
	      dirtyComponents.splice(0, this.dirtyComponentsLength);
	      flushBatchedUpdates();
	    } else {
	      dirtyComponents.length = 0;
	    }
	  }
	};
	
	var UPDATE_QUEUEING = {
	  initialize: function () {
	    this.callbackQueue.reset();
	  },
	  close: function () {
	    this.callbackQueue.notifyAll();
	  }
	};
	
	var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];
	
	function ReactUpdatesFlushTransaction() {
	  this.reinitializeTransaction();
	  this.dirtyComponentsLength = null;
	  this.callbackQueue = CallbackQueue.getPooled();
	  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* useCreateElement */true);
	}
	
	_assign(ReactUpdatesFlushTransaction.prototype, Transaction, {
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  destructor: function () {
	    this.dirtyComponentsLength = null;
	    CallbackQueue.release(this.callbackQueue);
	    this.callbackQueue = null;
	    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
	    this.reconcileTransaction = null;
	  },
	
	  perform: function (method, scope, a) {
	    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
	    // with this transaction's wrappers around it.
	    return Transaction.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
	  }
	});
	
	PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);
	
	function batchedUpdates(callback, a, b, c, d, e) {
	  ensureInjected();
	  return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
	}
	
	/**
	 * Array comparator for ReactComponents by mount ordering.
	 *
	 * @param {ReactComponent} c1 first component you're comparing
	 * @param {ReactComponent} c2 second component you're comparing
	 * @return {number} Return value usable by Array.prototype.sort().
	 */
	function mountOrderComparator(c1, c2) {
	  return c1._mountOrder - c2._mountOrder;
	}
	
	function runBatchedUpdates(transaction) {
	  var len = transaction.dirtyComponentsLength;
	  !(len === dirtyComponents.length) ?  true ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant('124', len, dirtyComponents.length) : void 0;
	
	  // Since reconciling a component higher in the owner hierarchy usually (not
	  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
	  // them before their children by sorting the array.
	  dirtyComponents.sort(mountOrderComparator);
	
	  // Any updates enqueued while reconciling must be performed after this entire
	  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and
	  // C, B could update twice in a single batch if C's render enqueues an update
	  // to B (since B would have already updated, we should skip it, and the only
	  // way we can know to do so is by checking the batch counter).
	  updateBatchNumber++;
	
	  for (var i = 0; i < len; i++) {
	    // If a component is unmounted before pending changes apply, it will still
	    // be here, but we assume that it has cleared its _pendingCallbacks and
	    // that performUpdateIfNecessary is a noop.
	    var component = dirtyComponents[i];
	
	    // If performUpdateIfNecessary happens to enqueue any new updates, we
	    // shouldn't execute the callbacks until the next render happens, so
	    // stash the callbacks first
	    var callbacks = component._pendingCallbacks;
	    component._pendingCallbacks = null;
	
	    var markerName;
	    if (ReactFeatureFlags.logTopLevelRenders) {
	      var namedComponent = component;
	      // Duck type TopLevelWrapper. This is probably always true.
	      if (component._currentElement.type.isReactTopLevelWrapper) {
	        namedComponent = component._renderedComponent;
	      }
	      markerName = 'React update: ' + namedComponent.getName();
	      console.time(markerName);
	    }
	
	    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);
	
	    if (markerName) {
	      console.timeEnd(markerName);
	    }
	
	    if (callbacks) {
	      for (var j = 0; j < callbacks.length; j++) {
	        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
	      }
	    }
	  }
	}
	
	var flushBatchedUpdates = function () {
	  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
	  // array and perform any updates enqueued by mount-ready handlers (i.e.,
	  // componentDidUpdate) but we need to check here too in order to catch
	  // updates enqueued by setState callbacks and asap calls.
	  while (dirtyComponents.length || asapEnqueued) {
	    if (dirtyComponents.length) {
	      var transaction = ReactUpdatesFlushTransaction.getPooled();
	      transaction.perform(runBatchedUpdates, null, transaction);
	      ReactUpdatesFlushTransaction.release(transaction);
	    }
	
	    if (asapEnqueued) {
	      asapEnqueued = false;
	      var queue = asapCallbackQueue;
	      asapCallbackQueue = CallbackQueue.getPooled();
	      queue.notifyAll();
	      CallbackQueue.release(queue);
	    }
	  }
	};
	
	/**
	 * Mark a component as needing a rerender, adding an optional callback to a
	 * list of functions which will be executed once the rerender occurs.
	 */
	function enqueueUpdate(component) {
	  ensureInjected();
	
	  // Various parts of our code (such as ReactCompositeComponent's
	  // _renderValidatedComponent) assume that calls to render aren't nested;
	  // verify that that's the case. (This is called by each top-level update
	  // function, like setState, forceUpdate, etc.; creation and
	  // destruction of top-level components is guarded in ReactMount.)
	
	  if (!batchingStrategy.isBatchingUpdates) {
	    batchingStrategy.batchedUpdates(enqueueUpdate, component);
	    return;
	  }
	
	  dirtyComponents.push(component);
	  if (component._updateBatchNumber == null) {
	    component._updateBatchNumber = updateBatchNumber + 1;
	  }
	}
	
	/**
	 * Enqueue a callback to be run at the end of the current batching cycle. Throws
	 * if no updates are currently being performed.
	 */
	function asap(callback, context) {
	  invariant(batchingStrategy.isBatchingUpdates, "ReactUpdates.asap: Can't enqueue an asap callback in a context where" + 'updates are not being batched.');
	  asapCallbackQueue.enqueue(callback, context);
	  asapEnqueued = true;
	}
	
	var ReactUpdatesInjection = {
	  injectReconcileTransaction: function (ReconcileTransaction) {
	    !ReconcileTransaction ?  true ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant('126') : void 0;
	    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
	  },
	
	  injectBatchingStrategy: function (_batchingStrategy) {
	    !_batchingStrategy ?  true ? invariant(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant('127') : void 0;
	    !(typeof _batchingStrategy.batchedUpdates === 'function') ?  true ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant('128') : void 0;
	    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ?  true ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant('129') : void 0;
	    batchingStrategy = _batchingStrategy;
	  }
	};
	
	var ReactUpdates = {
	  /**
	   * React references `ReactReconcileTransaction` using this property in order
	   * to allow dependency injection.
	   *
	   * @internal
	   */
	  ReactReconcileTransaction: null,
	
	  batchedUpdates: batchedUpdates,
	  enqueueUpdate: enqueueUpdate,
	  flushBatchedUpdates: flushBatchedUpdates,
	  injection: ReactUpdatesInjection,
	  asap: asap
	};
	
	module.exports = ReactUpdates;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(41);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var PooledClass = __webpack_require__(56);
	
	var invariant = __webpack_require__(12);
	
	/**
	 * A specialized pseudo-event module to help keep track of components waiting to
	 * be notified when their DOM representations are available for use.
	 *
	 * This implements `PooledClass`, so you should never need to instantiate this.
	 * Instead, use `CallbackQueue.getPooled()`.
	 *
	 * @class ReactMountReady
	 * @implements PooledClass
	 * @internal
	 */
	
	var CallbackQueue = function () {
	  function CallbackQueue(arg) {
	    _classCallCheck(this, CallbackQueue);
	
	    this._callbacks = null;
	    this._contexts = null;
	    this._arg = arg;
	  }
	
	  /**
	   * Enqueues a callback to be invoked when `notifyAll` is invoked.
	   *
	   * @param {function} callback Invoked when `notifyAll` is invoked.
	   * @param {?object} context Context to call `callback` with.
	   * @internal
	   */
	
	
	  CallbackQueue.prototype.enqueue = function enqueue(callback, context) {
	    this._callbacks = this._callbacks || [];
	    this._callbacks.push(callback);
	    this._contexts = this._contexts || [];
	    this._contexts.push(context);
	  };
	
	  /**
	   * Invokes all enqueued callbacks and clears the queue. This is invoked after
	   * the DOM representation of a component has been created or updated.
	   *
	   * @internal
	   */
	
	
	  CallbackQueue.prototype.notifyAll = function notifyAll() {
	    var callbacks = this._callbacks;
	    var contexts = this._contexts;
	    var arg = this._arg;
	    if (callbacks && contexts) {
	      !(callbacks.length === contexts.length) ?  true ? invariant(false, 'Mismatched list of contexts in callback queue') : _prodInvariant('24') : void 0;
	      this._callbacks = null;
	      this._contexts = null;
	      for (var i = 0; i < callbacks.length; i++) {
	        callbacks[i].call(contexts[i], arg);
	      }
	      callbacks.length = 0;
	      contexts.length = 0;
	    }
	  };
	
	  CallbackQueue.prototype.checkpoint = function checkpoint() {
	    return this._callbacks ? this._callbacks.length : 0;
	  };
	
	  CallbackQueue.prototype.rollback = function rollback(len) {
	    if (this._callbacks && this._contexts) {
	      this._callbacks.length = len;
	      this._contexts.length = len;
	    }
	  };
	
	  /**
	   * Resets the internal queue.
	   *
	   * @internal
	   */
	
	
	  CallbackQueue.prototype.reset = function reset() {
	    this._callbacks = null;
	    this._contexts = null;
	  };
	
	  /**
	   * `PooledClass` looks for this.
	   */
	
	
	  CallbackQueue.prototype.destructor = function destructor() {
	    this.reset();
	  };
	
	  return CallbackQueue;
	}();
	
	module.exports = PooledClass.addPoolingTo(CallbackQueue);

/***/ }),
/* 64 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	'use strict';
	
	var ReactFeatureFlags = {
	  // When true, call console.time() before and .timeEnd() after each top-level
	  // render (both initial renders and updates). Useful when looking at prod-mode
	  // timeline profiles in Chrome, for example.
	  logTopLevelRenders: false
	};
	
	module.exports = ReactFeatureFlags;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var ReactRef = __webpack_require__(66);
	var ReactInstrumentation = __webpack_require__(68);
	
	var warning = __webpack_require__(8);
	
	/**
	 * Helper to call ReactRef.attachRefs with this composite component, split out
	 * to avoid allocations in the transaction mount-ready queue.
	 */
	function attachRefs() {
	  ReactRef.attachRefs(this, this._currentElement);
	}
	
	var ReactReconciler = {
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?object} the containing host component instance
	   * @param {?object} info about the host container
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function (internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID) // 0 in production and for roots
	  {
	    if (true) {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID, internalInstance._currentElement, parentDebugID);
	      }
	    }
	    var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
	    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	    if (true) {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);
	      }
	    }
	    return markup;
	  },
	
	  /**
	   * Returns a value that can be passed to
	   * ReactComponentEnvironment.replaceNodeWithMarkup.
	   */
	  getHostNode: function (internalInstance) {
	    return internalInstance.getHostNode();
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function (internalInstance, safely) {
	    if (true) {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);
	      }
	    }
	    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
	    internalInstance.unmountComponent(safely);
	    if (true) {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);
	      }
	    }
	  },
	
	  /**
	   * Update a component using a new element.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @internal
	   */
	  receiveComponent: function (internalInstance, nextElement, transaction, context) {
	    var prevElement = internalInstance._currentElement;
	
	    if (nextElement === prevElement && context === internalInstance._context) {
	      // Since elements are immutable after the owner is rendered,
	      // we can do a cheap identity compare here to determine if this is a
	      // superfluous reconcile. It's possible for state to be mutable but such
	      // change should trigger an update of the owner which would recreate
	      // the element. We explicitly check for the existence of an owner since
	      // it's possible for an element created outside a composite to be
	      // deeply mutated and reused.
	
	      // TODO: Bailing out early is just a perf optimization right?
	      // TODO: Removing the return statement should affect correctness?
	      return;
	    }
	
	    if (true) {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);
	      }
	    }
	
	    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);
	
	    if (refsChanged) {
	      ReactRef.detachRefs(internalInstance, prevElement);
	    }
	
	    internalInstance.receiveComponent(nextElement, transaction, context);
	
	    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	
	    if (true) {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
	      }
	    }
	  },
	
	  /**
	   * Flush any dirty changes in a component.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function (internalInstance, transaction, updateBatchNumber) {
	    if (internalInstance._updateBatchNumber !== updateBatchNumber) {
	      // The component's enqueued batch number should always be the current
	      // batch or the following one.
	       true ? warning(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber === updateBatchNumber + 1, 'performUpdateIfNecessary: Unexpected batch number (current %s, ' + 'pending %s)', updateBatchNumber, internalInstance._updateBatchNumber) : void 0;
	      return;
	    }
	    if (true) {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);
	      }
	    }
	    internalInstance.performUpdateIfNecessary(transaction);
	    if (true) {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
	      }
	    }
	  }
	};
	
	module.exports = ReactReconciler;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	'use strict';
	
	var ReactOwner = __webpack_require__(67);
	
	var ReactRef = {};
	
	function attachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(component.getPublicInstance());
	  } else {
	    // Legacy ref
	    ReactOwner.addComponentAsRefTo(component, ref, owner);
	  }
	}
	
	function detachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(null);
	  } else {
	    // Legacy ref
	    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
	  }
	}
	
	ReactRef.attachRefs = function (instance, element) {
	  if (element === null || typeof element !== 'object') {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    attachRef(ref, instance, element._owner);
	  }
	};
	
	ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
	  // If either the owner or a `ref` has changed, make sure the newest owner
	  // has stored a reference to `this`, and the previous owner (if different)
	  // has forgotten the reference to `this`. We use the element instead
	  // of the public this.props because the post processing cannot determine
	  // a ref. The ref conceptually lives on the element.
	
	  // TODO: Should this even be possible? The owner cannot change because
	  // it's forbidden by shouldUpdateReactComponent. The ref can change
	  // if you swap the keys of but not the refs. Reconsider where this check
	  // is made. It probably belongs where the key checking and
	  // instantiateReactComponent is done.
	
	  var prevRef = null;
	  var prevOwner = null;
	  if (prevElement !== null && typeof prevElement === 'object') {
	    prevRef = prevElement.ref;
	    prevOwner = prevElement._owner;
	  }
	
	  var nextRef = null;
	  var nextOwner = null;
	  if (nextElement !== null && typeof nextElement === 'object') {
	    nextRef = nextElement.ref;
	    nextOwner = nextElement._owner;
	  }
	
	  return prevRef !== nextRef ||
	  // If owner changes but we have an unchanged function ref, don't update refs
	  typeof nextRef === 'string' && nextOwner !== prevOwner;
	};
	
	ReactRef.detachRefs = function (instance, element) {
	  if (element === null || typeof element !== 'object') {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    detachRef(ref, instance, element._owner);
	  }
	};
	
	module.exports = ReactRef;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(41);
	
	var invariant = __webpack_require__(12);
	
	/**
	 * @param {?object} object
	 * @return {boolean} True if `object` is a valid owner.
	 * @final
	 */
	function isValidOwner(object) {
	  return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
	}
	
	/**
	 * ReactOwners are capable of storing references to owned components.
	 *
	 * All components are capable of //being// referenced by owner components, but
	 * only ReactOwner components are capable of //referencing// owned components.
	 * The named reference is known as a "ref".
	 *
	 * Refs are available when mounted and updated during reconciliation.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return (
	 *         <div onClick={this.handleClick}>
	 *           <CustomComponent ref="custom" />
	 *         </div>
	 *       );
	 *     },
	 *     handleClick: function() {
	 *       this.refs.custom.handleClick();
	 *     },
	 *     componentDidMount: function() {
	 *       this.refs.custom.initialize();
	 *     }
	 *   });
	 *
	 * Refs should rarely be used. When refs are used, they should only be done to
	 * control data that is not handled by React's data flow.
	 *
	 * @class ReactOwner
	 */
	var ReactOwner = {
	  /**
	   * Adds a component by ref to an owner component.
	   *
	   * @param {ReactComponent} component Component to reference.
	   * @param {string} ref Name by which to refer to the component.
	   * @param {ReactOwner} owner Component on which to record the ref.
	   * @final
	   * @internal
	   */
	  addComponentAsRefTo: function (component, ref, owner) {
	    !isValidOwner(owner) ?  true ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('119') : void 0;
	    owner.attachRef(ref, component);
	  },
	
	  /**
	   * Removes a component by ref from an owner component.
	   *
	   * @param {ReactComponent} component Component to dereference.
	   * @param {string} ref Name of the ref to remove.
	   * @param {ReactOwner} owner Component on which the ref is recorded.
	   * @final
	   * @internal
	   */
	  removeComponentAsRefFrom: function (component, ref, owner) {
	    !isValidOwner(owner) ?  true ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might be removing a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('120') : void 0;
	    var ownerPublicInstance = owner.getPublicInstance();
	    // Check that `component`'s owner is still alive and that `component` is still the current ref
	    // because we do not want to detach the ref if another component stole it.
	    if (ownerPublicInstance && ownerPublicInstance.refs[ref] === component.getPublicInstance()) {
	      owner.detachRef(ref);
	    }
	  }
	};
	
	module.exports = ReactOwner;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2016-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	'use strict';
	
	// Trust the developer to only use ReactInstrumentation with a __DEV__ check
	
	var debugTool = null;
	
	if (true) {
	  var ReactDebugTool = __webpack_require__(69);
	  debugTool = ReactDebugTool;
	}
	
	module.exports = { debugTool: debugTool };

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2016-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	'use strict';
	
	var ReactInvalidSetStateWarningHook = __webpack_require__(70);
	var ReactHostOperationHistoryHook = __webpack_require__(71);
	var ReactComponentTreeHook = __webpack_require__(24);
	var ExecutionEnvironment = __webpack_require__(54);
	
	var performanceNow = __webpack_require__(72);
	var warning = __webpack_require__(8);
	
	var hooks = [];
	var didHookThrowForEvent = {};
	
	function callHook(event, fn, context, arg1, arg2, arg3, arg4, arg5) {
	  try {
	    fn.call(context, arg1, arg2, arg3, arg4, arg5);
	  } catch (e) {
	     true ? warning(didHookThrowForEvent[event], 'Exception thrown by hook while handling %s: %s', event, e + '\n' + e.stack) : void 0;
	    didHookThrowForEvent[event] = true;
	  }
	}
	
	function emitEvent(event, arg1, arg2, arg3, arg4, arg5) {
	  for (var i = 0; i < hooks.length; i++) {
	    var hook = hooks[i];
	    var fn = hook[event];
	    if (fn) {
	      callHook(event, fn, hook, arg1, arg2, arg3, arg4, arg5);
	    }
	  }
	}
	
	var isProfiling = false;
	var flushHistory = [];
	var lifeCycleTimerStack = [];
	var currentFlushNesting = 0;
	var currentFlushMeasurements = [];
	var currentFlushStartTime = 0;
	var currentTimerDebugID = null;
	var currentTimerStartTime = 0;
	var currentTimerNestedFlushDuration = 0;
	var currentTimerType = null;
	
	var lifeCycleTimerHasWarned = false;
	
	function clearHistory() {
	  ReactComponentTreeHook.purgeUnmountedComponents();
	  ReactHostOperationHistoryHook.clearHistory();
	}
	
	function getTreeSnapshot(registeredIDs) {
	  return registeredIDs.reduce(function (tree, id) {
	    var ownerID = ReactComponentTreeHook.getOwnerID(id);
	    var parentID = ReactComponentTreeHook.getParentID(id);
	    tree[id] = {
	      displayName: ReactComponentTreeHook.getDisplayName(id),
	      text: ReactComponentTreeHook.getText(id),
	      updateCount: ReactComponentTreeHook.getUpdateCount(id),
	      childIDs: ReactComponentTreeHook.getChildIDs(id),
	      // Text nodes don't have owners but this is close enough.
	      ownerID: ownerID || parentID && ReactComponentTreeHook.getOwnerID(parentID) || 0,
	      parentID: parentID
	    };
	    return tree;
	  }, {});
	}
	
	function resetMeasurements() {
	  var previousStartTime = currentFlushStartTime;
	  var previousMeasurements = currentFlushMeasurements;
	  var previousOperations = ReactHostOperationHistoryHook.getHistory();
	
	  if (currentFlushNesting === 0) {
	    currentFlushStartTime = 0;
	    currentFlushMeasurements = [];
	    clearHistory();
	    return;
	  }
	
	  if (previousMeasurements.length || previousOperations.length) {
	    var registeredIDs = ReactComponentTreeHook.getRegisteredIDs();
	    flushHistory.push({
	      duration: performanceNow() - previousStartTime,
	      measurements: previousMeasurements || [],
	      operations: previousOperations || [],
	      treeSnapshot: getTreeSnapshot(registeredIDs)
	    });
	  }
	
	  clearHistory();
	  currentFlushStartTime = performanceNow();
	  currentFlushMeasurements = [];
	}
	
	function checkDebugID(debugID) {
	  var allowRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	
	  if (allowRoot && debugID === 0) {
	    return;
	  }
	  if (!debugID) {
	     true ? warning(false, 'ReactDebugTool: debugID may not be empty.') : void 0;
	  }
	}
	
	function beginLifeCycleTimer(debugID, timerType) {
	  if (currentFlushNesting === 0) {
	    return;
	  }
	  if (currentTimerType && !lifeCycleTimerHasWarned) {
	     true ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'Did not expect %s timer to start while %s timer is still in ' + 'progress for %s instance.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
	    lifeCycleTimerHasWarned = true;
	  }
	  currentTimerStartTime = performanceNow();
	  currentTimerNestedFlushDuration = 0;
	  currentTimerDebugID = debugID;
	  currentTimerType = timerType;
	}
	
	function endLifeCycleTimer(debugID, timerType) {
	  if (currentFlushNesting === 0) {
	    return;
	  }
	  if (currentTimerType !== timerType && !lifeCycleTimerHasWarned) {
	     true ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'We did not expect %s timer to stop while %s timer is still in ' + 'progress for %s instance. Please report this as a bug in React.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
	    lifeCycleTimerHasWarned = true;
	  }
	  if (isProfiling) {
	    currentFlushMeasurements.push({
	      timerType: timerType,
	      instanceID: debugID,
	      duration: performanceNow() - currentTimerStartTime - currentTimerNestedFlushDuration
	    });
	  }
	  currentTimerStartTime = 0;
	  currentTimerNestedFlushDuration = 0;
	  currentTimerDebugID = null;
	  currentTimerType = null;
	}
	
	function pauseCurrentLifeCycleTimer() {
	  var currentTimer = {
	    startTime: currentTimerStartTime,
	    nestedFlushStartTime: performanceNow(),
	    debugID: currentTimerDebugID,
	    timerType: currentTimerType
	  };
	  lifeCycleTimerStack.push(currentTimer);
	  currentTimerStartTime = 0;
	  currentTimerNestedFlushDuration = 0;
	  currentTimerDebugID = null;
	  currentTimerType = null;
	}
	
	function resumeCurrentLifeCycleTimer() {
	  var _lifeCycleTimerStack$ = lifeCycleTimerStack.pop(),
	      startTime = _lifeCycleTimerStack$.startTime,
	      nestedFlushStartTime = _lifeCycleTimerStack$.nestedFlushStartTime,
	      debugID = _lifeCycleTimerStack$.debugID,
	      timerType = _lifeCycleTimerStack$.timerType;
	
	  var nestedFlushDuration = performanceNow() - nestedFlushStartTime;
	  currentTimerStartTime = startTime;
	  currentTimerNestedFlushDuration += nestedFlushDuration;
	  currentTimerDebugID = debugID;
	  currentTimerType = timerType;
	}
	
	var lastMarkTimeStamp = 0;
	var canUsePerformanceMeasure = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';
	
	function shouldMark(debugID) {
	  if (!isProfiling || !canUsePerformanceMeasure) {
	    return false;
	  }
	  var element = ReactComponentTreeHook.getElement(debugID);
	  if (element == null || typeof element !== 'object') {
	    return false;
	  }
	  var isHostElement = typeof element.type === 'string';
	  if (isHostElement) {
	    return false;
	  }
	  return true;
	}
	
	function markBegin(debugID, markType) {
	  if (!shouldMark(debugID)) {
	    return;
	  }
	
	  var markName = debugID + '::' + markType;
	  lastMarkTimeStamp = performanceNow();
	  performance.mark(markName);
	}
	
	function markEnd(debugID, markType) {
	  if (!shouldMark(debugID)) {
	    return;
	  }
	
	  var markName = debugID + '::' + markType;
	  var displayName = ReactComponentTreeHook.getDisplayName(debugID) || 'Unknown';
	
	  // Chrome has an issue of dropping markers recorded too fast:
	  // https://bugs.chromium.org/p/chromium/issues/detail?id=640652
	  // To work around this, we will not report very small measurements.
	  // I determined the magic number by tweaking it back and forth.
	  // 0.05ms was enough to prevent the issue, but I set it to 0.1ms to be safe.
	  // When the bug is fixed, we can `measure()` unconditionally if we want to.
	  var timeStamp = performanceNow();
	  if (timeStamp - lastMarkTimeStamp > 0.1) {
	    var measurementName = displayName + ' [' + markType + ']';
	    performance.measure(measurementName, markName);
	  }
	
	  performance.clearMarks(markName);
	  if (measurementName) {
	    performance.clearMeasures(measurementName);
	  }
	}
	
	var ReactDebugTool = {
	  addHook: function (hook) {
	    hooks.push(hook);
	  },
	  removeHook: function (hook) {
	    for (var i = 0; i < hooks.length; i++) {
	      if (hooks[i] === hook) {
	        hooks.splice(i, 1);
	        i--;
	      }
	    }
	  },
	  isProfiling: function () {
	    return isProfiling;
	  },
	  beginProfiling: function () {
	    if (isProfiling) {
	      return;
	    }
	
	    isProfiling = true;
	    flushHistory.length = 0;
	    resetMeasurements();
	    ReactDebugTool.addHook(ReactHostOperationHistoryHook);
	  },
	  endProfiling: function () {
	    if (!isProfiling) {
	      return;
	    }
	
	    isProfiling = false;
	    resetMeasurements();
	    ReactDebugTool.removeHook(ReactHostOperationHistoryHook);
	  },
	  getFlushHistory: function () {
	    return flushHistory;
	  },
	  onBeginFlush: function () {
	    currentFlushNesting++;
	    resetMeasurements();
	    pauseCurrentLifeCycleTimer();
	    emitEvent('onBeginFlush');
	  },
	  onEndFlush: function () {
	    resetMeasurements();
	    currentFlushNesting--;
	    resumeCurrentLifeCycleTimer();
	    emitEvent('onEndFlush');
	  },
	  onBeginLifeCycleTimer: function (debugID, timerType) {
	    checkDebugID(debugID);
	    emitEvent('onBeginLifeCycleTimer', debugID, timerType);
	    markBegin(debugID, timerType);
	    beginLifeCycleTimer(debugID, timerType);
	  },
	  onEndLifeCycleTimer: function (debugID, timerType) {
	    checkDebugID(debugID);
	    endLifeCycleTimer(debugID, timerType);
	    markEnd(debugID, timerType);
	    emitEvent('onEndLifeCycleTimer', debugID, timerType);
	  },
	  onBeginProcessingChildContext: function () {
	    emitEvent('onBeginProcessingChildContext');
	  },
	  onEndProcessingChildContext: function () {
	    emitEvent('onEndProcessingChildContext');
	  },
	  onHostOperation: function (operation) {
	    checkDebugID(operation.instanceID);
	    emitEvent('onHostOperation', operation);
	  },
	  onSetState: function () {
	    emitEvent('onSetState');
	  },
	  onSetChildren: function (debugID, childDebugIDs) {
	    checkDebugID(debugID);
	    childDebugIDs.forEach(checkDebugID);
	    emitEvent('onSetChildren', debugID, childDebugIDs);
	  },
	  onBeforeMountComponent: function (debugID, element, parentDebugID) {
	    checkDebugID(debugID);
	    checkDebugID(parentDebugID, true);
	    emitEvent('onBeforeMountComponent', debugID, element, parentDebugID);
	    markBegin(debugID, 'mount');
	  },
	  onMountComponent: function (debugID) {
	    checkDebugID(debugID);
	    markEnd(debugID, 'mount');
	    emitEvent('onMountComponent', debugID);
	  },
	  onBeforeUpdateComponent: function (debugID, element) {
	    checkDebugID(debugID);
	    emitEvent('onBeforeUpdateComponent', debugID, element);
	    markBegin(debugID, 'update');
	  },
	  onUpdateComponent: function (debugID) {
	    checkDebugID(debugID);
	    markEnd(debugID, 'update');
	    emitEvent('onUpdateComponent', debugID);
	  },
	  onBeforeUnmountComponent: function (debugID) {
	    checkDebugID(debugID);
	    emitEvent('onBeforeUnmountComponent', debugID);
	    markBegin(debugID, 'unmount');
	  },
	  onUnmountComponent: function (debugID) {
	    checkDebugID(debugID);
	    markEnd(debugID, 'unmount');
	    emitEvent('onUnmountComponent', debugID);
	  },
	  onTestEvent: function () {
	    emitEvent('onTestEvent');
	  }
	};
	
	// TODO remove these when RN/www gets updated
	ReactDebugTool.addDevtool = ReactDebugTool.addHook;
	ReactDebugTool.removeDevtool = ReactDebugTool.removeHook;
	
	ReactDebugTool.addHook(ReactInvalidSetStateWarningHook);
	ReactDebugTool.addHook(ReactComponentTreeHook);
	var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
	if (/[?&]react_perf\b/.test(url)) {
	  ReactDebugTool.beginProfiling();
	}
	
	module.exports = ReactDebugTool;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2016-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	'use strict';
	
	var warning = __webpack_require__(8);
	
	if (true) {
	  var processingChildContext = false;
	
	  var warnInvalidSetState = function () {
	     true ? warning(!processingChildContext, 'setState(...): Cannot call setState() inside getChildContext()') : void 0;
	  };
	}
	
	var ReactInvalidSetStateWarningHook = {
	  onBeginProcessingChildContext: function () {
	    processingChildContext = true;
	  },
	  onEndProcessingChildContext: function () {
	    processingChildContext = false;
	  },
	  onSetState: function () {
	    warnInvalidSetState();
	  }
	};
	
	module.exports = ReactInvalidSetStateWarningHook;

/***/ }),
/* 71 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2016-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	'use strict';
	
	var history = [];
	
	var ReactHostOperationHistoryHook = {
	  onHostOperation: function (operation) {
	    history.push(operation);
	  },
	  clearHistory: function () {
	    if (ReactHostOperationHistoryHook._preventClearing) {
	      // Should only be used for tests.
	      return;
	    }
	
	    history = [];
	  },
	  getHistory: function () {
	    return history;
	  }
	};
	
	module.exports = ReactHostOperationHistoryHook;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 */
	
	var performance = __webpack_require__(73);
	
	var performanceNow;
	
	/**
	 * Detect if we can use `window.performance.now()` and gracefully fallback to
	 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
	 * because of Facebook's testing infrastructure.
	 */
	if (performance.now) {
	  performanceNow = function performanceNow() {
	    return performance.now();
	  };
	} else {
	  performanceNow = function performanceNow() {
	    return Date.now();
	  };
	}
	
	module.exports = performanceNow;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(54);
	
	var performance;
	
	if (ExecutionEnvironment.canUseDOM) {
	  performance = window.performance || window.msPerformance || window.webkitPerformance;
	}
	
	module.exports = performance || {};

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(41);
	
	var invariant = __webpack_require__(12);
	
	var OBSERVED_ERROR = {};
	
	/**
	 * `Transaction` creates a black box that is able to wrap any method such that
	 * certain invariants are maintained before and after the method is invoked
	 * (Even if an exception is thrown while invoking the wrapped method). Whoever
	 * instantiates a transaction can provide enforcers of the invariants at
	 * creation time. The `Transaction` class itself will supply one additional
	 * automatic invariant for you - the invariant that any transaction instance
	 * should not be run while it is already being run. You would typically create a
	 * single instance of a `Transaction` for reuse multiple times, that potentially
	 * is used to wrap several different methods. Wrappers are extremely simple -
	 * they only require implementing two methods.
	 *
	 * <pre>
	 *                       wrappers (injected at creation time)
	 *                                      +        +
	 *                                      |        |
	 *                    +-----------------|--------|--------------+
	 *                    |                 v        |              |
	 *                    |      +---------------+   |              |
	 *                    |   +--|    wrapper1   |---|----+         |
	 *                    |   |  +---------------+   v    |         |
	 *                    |   |          +-------------+  |         |
	 *                    |   |     +----|   wrapper2  |--------+   |
	 *                    |   |     |    +-------------+  |     |   |
	 *                    |   |     |                     |     |   |
	 *                    |   v     v                     v     v   | wrapper
	 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
	 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
	 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | +---+ +---+   +---------+   +---+ +---+ |
	 *                    |  initialize                    close    |
	 *                    +-----------------------------------------+
	 * </pre>
	 *
	 * Use cases:
	 * - Preserving the input selection ranges before/after reconciliation.
	 *   Restoring selection even in the event of an unexpected error.
	 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
	 *   while guaranteeing that afterwards, the event system is reactivated.
	 * - Flushing a queue of collected DOM mutations to the main UI thread after a
	 *   reconciliation takes place in a worker thread.
	 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
	 *   content.
	 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
	 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
	 * - (Future use case): Layout calculations before and after DOM updates.
	 *
	 * Transactional plugin API:
	 * - A module that has an `initialize` method that returns any precomputation.
	 * - and a `close` method that accepts the precomputation. `close` is invoked
	 *   when the wrapped process is completed, or has failed.
	 *
	 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
	 * that implement `initialize` and `close`.
	 * @return {Transaction} Single transaction for reuse in thread.
	 *
	 * @class Transaction
	 */
	var TransactionImpl = {
	  /**
	   * Sets up this instance so that it is prepared for collecting metrics. Does
	   * so such that this setup method may be used on an instance that is already
	   * initialized, in a way that does not consume additional memory upon reuse.
	   * That can be useful if you decide to make your subclass of this mixin a
	   * "PooledClass".
	   */
	  reinitializeTransaction: function () {
	    this.transactionWrappers = this.getTransactionWrappers();
	    if (this.wrapperInitData) {
	      this.wrapperInitData.length = 0;
	    } else {
	      this.wrapperInitData = [];
	    }
	    this._isInTransaction = false;
	  },
	
	  _isInTransaction: false,
	
	  /**
	   * @abstract
	   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
	   */
	  getTransactionWrappers: null,
	
	  isInTransaction: function () {
	    return !!this._isInTransaction;
	  },
	
	  /* eslint-disable space-before-function-paren */
	
	  /**
	   * Executes the function within a safety window. Use this for the top level
	   * methods that result in large amounts of computation/mutations that would
	   * need to be safety checked. The optional arguments helps prevent the need
	   * to bind in many cases.
	   *
	   * @param {function} method Member of scope to call.
	   * @param {Object} scope Scope to invoke from.
	   * @param {Object?=} a Argument to pass to the method.
	   * @param {Object?=} b Argument to pass to the method.
	   * @param {Object?=} c Argument to pass to the method.
	   * @param {Object?=} d Argument to pass to the method.
	   * @param {Object?=} e Argument to pass to the method.
	   * @param {Object?=} f Argument to pass to the method.
	   *
	   * @return {*} Return value from `method`.
	   */
	  perform: function (method, scope, a, b, c, d, e, f) {
	    /* eslint-enable space-before-function-paren */
	    !!this.isInTransaction() ?  true ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.') : _prodInvariant('27') : void 0;
	    var errorThrown;
	    var ret;
	    try {
	      this._isInTransaction = true;
	      // Catching errors makes debugging more difficult, so we start with
	      // errorThrown set to true before setting it to false after calling
	      // close -- if it's still set to true in the finally block, it means
	      // one of these calls threw.
	      errorThrown = true;
	      this.initializeAll(0);
	      ret = method.call(scope, a, b, c, d, e, f);
	      errorThrown = false;
	    } finally {
	      try {
	        if (errorThrown) {
	          // If `method` throws, prefer to show that stack trace over any thrown
	          // by invoking `closeAll`.
	          try {
	            this.closeAll(0);
	          } catch (err) {}
	        } else {
	          // Since `method` didn't throw, we don't want to silence the exception
	          // here.
	          this.closeAll(0);
	        }
	      } finally {
	        this._isInTransaction = false;
	      }
	    }
	    return ret;
	  },
	
	  initializeAll: function (startIndex) {
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      try {
	        // Catching errors makes debugging more difficult, so we start with the
	        // OBSERVED_ERROR state before overwriting it with the real return value
	        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
	        // block, it means wrapper.initialize threw.
	        this.wrapperInitData[i] = OBSERVED_ERROR;
	        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
	      } finally {
	        if (this.wrapperInitData[i] === OBSERVED_ERROR) {
	          // The initializer for wrapper i threw an error; initialize the
	          // remaining wrappers but silence any exceptions from them to ensure
	          // that the first error is the one to bubble up.
	          try {
	            this.initializeAll(i + 1);
	          } catch (err) {}
	        }
	      }
	    }
	  },
	
	  /**
	   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
	   * them the respective return values of `this.transactionWrappers.init[i]`
	   * (`close`rs that correspond to initializers that failed will not be
	   * invoked).
	   */
	  closeAll: function (startIndex) {
	    !this.isInTransaction() ?  true ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : _prodInvariant('28') : void 0;
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      var initData = this.wrapperInitData[i];
	      var errorThrown;
	      try {
	        // Catching errors makes debugging more difficult, so we start with
	        // errorThrown set to true before setting it to false after calling
	        // close -- if it's still set to true in the finally block, it means
	        // wrapper.close threw.
	        errorThrown = true;
	        if (initData !== OBSERVED_ERROR && wrapper.close) {
	          wrapper.close.call(this, initData);
	        }
	        errorThrown = false;
	      } finally {
	        if (errorThrown) {
	          // The closer for wrapper i threw an error; close the remaining
	          // wrappers but silence any exceptions from them to ensure that the
	          // first error is the one to bubble up.
	          try {
	            this.closeAll(i + 1);
	          } catch (e) {}
	        }
	      }
	    }
	    this.wrapperInitData.length = 0;
	  }
	};
	
	module.exports = TransactionImpl;

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var ReactDOMComponentTree = __webpack_require__(40);
	
	function isCheckable(elem) {
	  var type = elem.type;
	  var nodeName = elem.nodeName;
	  return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');
	}
	
	function getTracker(inst) {
	  return inst._wrapperState.valueTracker;
	}
	
	function attachTracker(inst, tracker) {
	  inst._wrapperState.valueTracker = tracker;
	}
	
	function detachTracker(inst) {
	  inst._wrapperState.valueTracker = null;
	}
	
	function getValueFromNode(node) {
	  var value;
	  if (node) {
	    value = isCheckable(node) ? '' + node.checked : node.value;
	  }
	  return value;
	}
	
	var inputValueTracking = {
	  // exposed for testing
	  _getTrackerFromNode: function (node) {
	    return getTracker(ReactDOMComponentTree.getInstanceFromNode(node));
	  },
	
	
	  track: function (inst) {
	    if (getTracker(inst)) {
	      return;
	    }
	
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var valueField = isCheckable(node) ? 'checked' : 'value';
	    var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
	
	    var currentValue = '' + node[valueField];
	
	    // if someone has already defined a value or Safari, then bail
	    // and don't track value will cause over reporting of changes,
	    // but it's better then a hard failure
	    // (needed for certain tests that spyOn input values and Safari)
	    if (node.hasOwnProperty(valueField) || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {
	      return;
	    }
	
	    Object.defineProperty(node, valueField, {
	      enumerable: descriptor.enumerable,
	      configurable: true,
	      get: function () {
	        return descriptor.get.call(this);
	      },
	      set: function (value) {
	        currentValue = '' + value;
	        descriptor.set.call(this, value);
	      }
	    });
	
	    attachTracker(inst, {
	      getValue: function () {
	        return currentValue;
	      },
	      setValue: function (value) {
	        currentValue = '' + value;
	      },
	      stopTracking: function () {
	        detachTracker(inst);
	        delete node[valueField];
	      }
	    });
	  },
	
	  updateValueIfChanged: function (inst) {
	    if (!inst) {
	      return false;
	    }
	    var tracker = getTracker(inst);
	
	    if (!tracker) {
	      inputValueTracking.track(inst);
	      return true;
	    }
	
	    var lastValue = tracker.getValue();
	    var nextValue = getValueFromNode(ReactDOMComponentTree.getNodeFromInstance(inst));
	
	    if (nextValue !== lastValue) {
	      tracker.setValue(nextValue);
	      return true;
	    }
	
	    return false;
	  },
	  stopTracking: function (inst) {
	    var tracker = getTracker(inst);
	    if (tracker) {
	      tracker.stopTracking();
	    }
	  }
	};
	
	module.exports = inputValueTracking;

/***/ }),
/* 76 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	/**
	 * Gets the target node from a native browser event by accounting for
	 * inconsistencies in browser DOM APIs.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {DOMEventTarget} Target node.
	 */
	
	function getEventTarget(nativeEvent) {
	  var target = nativeEvent.target || nativeEvent.srcElement || window;
	
	  // Normalize SVG <use> element events #4963
	  if (target.correspondingUseElement) {
	    target = target.correspondingUseElement;
	  }
	
	  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
	  // @see http://www.quirksmode.org/js/events_properties.html
	  return target.nodeType === 3 ? target.parentNode : target;
	}
	
	module.exports = getEventTarget;

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(54);
	
	var useHasFeature;
	if (ExecutionEnvironment.canUseDOM) {
	  useHasFeature = document.implementation && document.implementation.hasFeature &&
	  // always returns true in newer browsers as per the standard.
	  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
	  document.implementation.hasFeature('', '') !== true;
	}
	
	/**
	 * Checks if an event is supported in the current execution environment.
	 *
	 * NOTE: This will not work correctly for non-generic events such as `change`,
	 * `reset`, `load`, `error`, and `select`.
	 *
	 * Borrows from Modernizr.
	 *
	 * @param {string} eventNameSuffix Event name, e.g. "click".
	 * @param {?boolean} capture Check if the capture phase is supported.
	 * @return {boolean} True if the event is supported.
	 * @internal
	 * @license Modernizr 3.0.0pre (Custom Build) | MIT
	 */
	function isEventSupported(eventNameSuffix, capture) {
	  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
	    return false;
	  }
	
	  var eventName = 'on' + eventNameSuffix;
	  var isSupported = eventName in document;
	
	  if (!isSupported) {
	    var element = document.createElement('div');
	    element.setAttribute(eventName, 'return;');
	    isSupported = typeof element[eventName] === 'function';
	  }
	
	  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
	    // This is the only way to test support for the `wheel` event in IE9+.
	    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
	  }
	
	  return isSupported;
	}
	
	module.exports = isEventSupported;

/***/ }),
/* 78 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	'use strict';
	
	/**
	 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
	 */
	
	var supportedInputTypes = {
	  color: true,
	  date: true,
	  datetime: true,
	  'datetime-local': true,
	  email: true,
	  month: true,
	  number: true,
	  password: true,
	  range: true,
	  search: true,
	  tel: true,
	  text: true,
	  time: true,
	  url: true,
	  week: true
	};
	
	function isTextInputElement(elem) {
	  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	
	  if (nodeName === 'input') {
	    return !!supportedInputTypes[elem.type];
	  }
	
	  if (nodeName === 'textarea') {
	    return true;
	  }
	
	  return false;
	}
	
	module.exports = isTextInputElement;

/***/ }),
/* 79 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	/**
	 * Module that is injectable into `EventPluginHub`, that specifies a
	 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
	 * plugins, without having to package every one of them. This is better than
	 * having plugins be ordered in the same order that they are injected because
	 * that ordering would be influenced by the packaging order.
	 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
	 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
	 */
	
	var DefaultEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];
	
	module.exports = DefaultEventPluginOrder;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var EventPropagators = __webpack_require__(47);
	var ReactDOMComponentTree = __webpack_require__(40);
	var SyntheticMouseEvent = __webpack_require__(81);
	
	var eventTypes = {
	  mouseEnter: {
	    registrationName: 'onMouseEnter',
	    dependencies: ['topMouseOut', 'topMouseOver']
	  },
	  mouseLeave: {
	    registrationName: 'onMouseLeave',
	    dependencies: ['topMouseOut', 'topMouseOver']
	  }
	};
	
	var EnterLeaveEventPlugin = {
	  eventTypes: eventTypes,
	
	  /**
	   * For almost every interaction we care about, there will be both a top-level
	   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
	   * we do not extract duplicate events. However, moving the mouse into the
	   * browser from outside will not fire a `mouseout` event. In this case, we use
	   * the `mouseover` top-level event.
	   */
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
	      return null;
	    }
	    if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {
	      // Must not be a mouse in or mouse out - ignoring.
	      return null;
	    }
	
	    var win;
	    if (nativeEventTarget.window === nativeEventTarget) {
	      // `nativeEventTarget` is probably a window object.
	      win = nativeEventTarget;
	    } else {
	      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	      var doc = nativeEventTarget.ownerDocument;
	      if (doc) {
	        win = doc.defaultView || doc.parentWindow;
	      } else {
	        win = window;
	      }
	    }
	
	    var from;
	    var to;
	    if (topLevelType === 'topMouseOut') {
	      from = targetInst;
	      var related = nativeEvent.relatedTarget || nativeEvent.toElement;
	      to = related ? ReactDOMComponentTree.getClosestInstanceFromNode(related) : null;
	    } else {
	      // Moving to a node from outside the window.
	      from = null;
	      to = targetInst;
	    }
	
	    if (from === to) {
	      // Nothing pertains to our managed components.
	      return null;
	    }
	
	    var fromNode = from == null ? win : ReactDOMComponentTree.getNodeFromInstance(from);
	    var toNode = to == null ? win : ReactDOMComponentTree.getNodeFromInstance(to);
	
	    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, from, nativeEvent, nativeEventTarget);
	    leave.type = 'mouseleave';
	    leave.target = fromNode;
	    leave.relatedTarget = toNode;
	
	    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, to, nativeEvent, nativeEventTarget);
	    enter.type = 'mouseenter';
	    enter.target = toNode;
	    enter.relatedTarget = fromNode;
	
	    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, from, to);
	
	    return [leave, enter];
	  }
	};
	
	module.exports = EnterLeaveEventPlugin;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(82);
	var ViewportMetrics = __webpack_require__(83);
	
	var getEventModifierState = __webpack_require__(84);
	
	/**
	 * @interface MouseEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var MouseEventInterface = {
	  screenX: null,
	  screenY: null,
	  clientX: null,
	  clientY: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  getModifierState: getEventModifierState,
	  button: function (event) {
	    // Webkit, Firefox, IE9+
	    // which:  1 2 3
	    // button: 0 1 2 (standard)
	    var button = event.button;
	    if ('which' in event) {
	      return button;
	    }
	    // IE<9
	    // which:  undefined
	    // button: 0 0 0
	    // button: 1 4 2 (onmouseup)
	    return button === 2 ? 2 : button === 4 ? 1 : 0;
	  },
	  buttons: null,
	  relatedTarget: function (event) {
	    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
	  },
	  // "Proprietary" Interface.
	  pageX: function (event) {
	    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
	  },
	  pageY: function (event) {
	    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
	
	module.exports = SyntheticMouseEvent;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(59);
	
	var getEventTarget = __webpack_require__(76);
	
	/**
	 * @interface UIEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var UIEventInterface = {
	  view: function (event) {
	    if (event.view) {
	      return event.view;
	    }
	
	    var target = getEventTarget(event);
	    if (target.window === target) {
	      // target is a window object
	      return target;
	    }
	
	    var doc = target.ownerDocument;
	    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	    if (doc) {
	      return doc.defaultView || doc.parentWindow;
	    } else {
	      return window;
	    }
	  },
	  detail: function (event) {
	    return event.detail || 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);
	
	module.exports = SyntheticUIEvent;

/***/ }),
/* 83 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var ViewportMetrics = {
	  currentScrollLeft: 0,
	
	  currentScrollTop: 0,
	
	  refreshScrollValues: function (scrollPosition) {
	    ViewportMetrics.currentScrollLeft = scrollPosition.x;
	    ViewportMetrics.currentScrollTop = scrollPosition.y;
	  }
	};
	
	module.exports = ViewportMetrics;

/***/ }),
/* 84 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	/**
	 * Translation from modifier key to the associated property in the event.
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
	 */
	
	var modifierKeyToProp = {
	  Alt: 'altKey',
	  Control: 'ctrlKey',
	  Meta: 'metaKey',
	  Shift: 'shiftKey'
	};
	
	// IE8 does not implement getModifierState so we simply map it to the only
	// modifier keys exposed by the event itself, does not support Lock-keys.
	// Currently, all major browsers except Chrome seems to support Lock-keys.
	function modifierStateGetter(keyArg) {
	  var syntheticEvent = this;
	  var nativeEvent = syntheticEvent.nativeEvent;
	  if (nativeEvent.getModifierState) {
	    return nativeEvent.getModifierState(keyArg);
	  }
	  var keyProp = modifierKeyToProp[keyArg];
	  return keyProp ? !!nativeEvent[keyProp] : false;
	}
	
	function getEventModifierState(nativeEvent) {
	  return modifierStateGetter;
	}
	
	module.exports = getEventModifierState;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(42);
	
	var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
	var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
	var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
	var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
	var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
	
	var HTMLDOMPropertyConfig = {
	  isCustomAttribute: RegExp.prototype.test.bind(new RegExp('^(data|aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$')),
	  Properties: {
	    /**
	     * Standard Properties
	     */
	    accept: 0,
	    acceptCharset: 0,
	    accessKey: 0,
	    action: 0,
	    allowFullScreen: HAS_BOOLEAN_VALUE,
	    allowTransparency: 0,
	    alt: 0,
	    // specifies target context for links with `preload` type
	    as: 0,
	    async: HAS_BOOLEAN_VALUE,
	    autoComplete: 0,
	    // autoFocus is polyfilled/normalized by AutoFocusUtils
	    // autoFocus: HAS_BOOLEAN_VALUE,
	    autoPlay: HAS_BOOLEAN_VALUE,
	    capture: HAS_BOOLEAN_VALUE,
	    cellPadding: 0,
	    cellSpacing: 0,
	    charSet: 0,
	    challenge: 0,
	    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    cite: 0,
	    classID: 0,
	    className: 0,
	    cols: HAS_POSITIVE_NUMERIC_VALUE,
	    colSpan: 0,
	    content: 0,
	    contentEditable: 0,
	    contextMenu: 0,
	    controls: HAS_BOOLEAN_VALUE,
	    controlsList: 0,
	    coords: 0,
	    crossOrigin: 0,
	    data: 0, // For `<object />` acts as `src`.
	    dateTime: 0,
	    'default': HAS_BOOLEAN_VALUE,
	    defer: HAS_BOOLEAN_VALUE,
	    dir: 0,
	    disabled: HAS_BOOLEAN_VALUE,
	    download: HAS_OVERLOADED_BOOLEAN_VALUE,
	    draggable: 0,
	    encType: 0,
	    form: 0,
	    formAction: 0,
	    formEncType: 0,
	    formMethod: 0,
	    formNoValidate: HAS_BOOLEAN_VALUE,
	    formTarget: 0,
	    frameBorder: 0,
	    headers: 0,
	    height: 0,
	    hidden: HAS_BOOLEAN_VALUE,
	    high: 0,
	    href: 0,
	    hrefLang: 0,
	    htmlFor: 0,
	    httpEquiv: 0,
	    icon: 0,
	    id: 0,
	    inputMode: 0,
	    integrity: 0,
	    is: 0,
	    keyParams: 0,
	    keyType: 0,
	    kind: 0,
	    label: 0,
	    lang: 0,
	    list: 0,
	    loop: HAS_BOOLEAN_VALUE,
	    low: 0,
	    manifest: 0,
	    marginHeight: 0,
	    marginWidth: 0,
	    max: 0,
	    maxLength: 0,
	    media: 0,
	    mediaGroup: 0,
	    method: 0,
	    min: 0,
	    minLength: 0,
	    // Caution; `option.selected` is not updated if `select.multiple` is
	    // disabled with `removeAttribute`.
	    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    name: 0,
	    nonce: 0,
	    noValidate: HAS_BOOLEAN_VALUE,
	    open: HAS_BOOLEAN_VALUE,
	    optimum: 0,
	    pattern: 0,
	    placeholder: 0,
	    playsInline: HAS_BOOLEAN_VALUE,
	    poster: 0,
	    preload: 0,
	    profile: 0,
	    radioGroup: 0,
	    readOnly: HAS_BOOLEAN_VALUE,
	    referrerPolicy: 0,
	    rel: 0,
	    required: HAS_BOOLEAN_VALUE,
	    reversed: HAS_BOOLEAN_VALUE,
	    role: 0,
	    rows: HAS_POSITIVE_NUMERIC_VALUE,
	    rowSpan: HAS_NUMERIC_VALUE,
	    sandbox: 0,
	    scope: 0,
	    scoped: HAS_BOOLEAN_VALUE,
	    scrolling: 0,
	    seamless: HAS_BOOLEAN_VALUE,
	    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    shape: 0,
	    size: HAS_POSITIVE_NUMERIC_VALUE,
	    sizes: 0,
	    span: HAS_POSITIVE_NUMERIC_VALUE,
	    spellCheck: 0,
	    src: 0,
	    srcDoc: 0,
	    srcLang: 0,
	    srcSet: 0,
	    start: HAS_NUMERIC_VALUE,
	    step: 0,
	    style: 0,
	    summary: 0,
	    tabIndex: 0,
	    target: 0,
	    title: 0,
	    // Setting .type throws on non-<input> tags
	    type: 0,
	    useMap: 0,
	    value: 0,
	    width: 0,
	    wmode: 0,
	    wrap: 0,
	
	    /**
	     * RDFa Properties
	     */
	    about: 0,
	    datatype: 0,
	    inlist: 0,
	    prefix: 0,
	    // property is also supported for OpenGraph in meta tags.
	    property: 0,
	    resource: 0,
	    'typeof': 0,
	    vocab: 0,
	
	    /**
	     * Non-standard Properties
	     */
	    // autoCapitalize and autoCorrect are supported in Mobile Safari for
	    // keyboard hints.
	    autoCapitalize: 0,
	    autoCorrect: 0,
	    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
	    autoSave: 0,
	    // color is for Safari mask-icon link
	    color: 0,
	    // itemProp, itemScope, itemType are for
	    // Microdata support. See http://schema.org/docs/gs.html
	    itemProp: 0,
	    itemScope: HAS_BOOLEAN_VALUE,
	    itemType: 0,
	    // itemID and itemRef are for Microdata support as well but
	    // only specified in the WHATWG spec document. See
	    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
	    itemID: 0,
	    itemRef: 0,
	    // results show looking glass icon and recent searches on input
	    // search fields in WebKit/Blink
	    results: 0,
	    // IE-only attribute that specifies security restrictions on an iframe
	    // as an alternative to the sandbox attribute on IE<10
	    security: 0,
	    // IE-only attribute that controls focus behavior
	    unselectable: 0
	  },
	  DOMAttributeNames: {
	    acceptCharset: 'accept-charset',
	    className: 'class',
	    htmlFor: 'for',
	    httpEquiv: 'http-equiv'
	  },
	  DOMPropertyNames: {},
	  DOMMutationMethods: {
	    value: function (node, value) {
	      if (value == null) {
	        return node.removeAttribute('value');
	      }
	
	      // Number inputs get special treatment due to some edge cases in
	      // Chrome. Let everything else assign the value attribute as normal.
	      // https://github.com/facebook/react/issues/7253#issuecomment-236074326
	      if (node.type !== 'number' || node.hasAttribute('value') === false) {
	        node.setAttribute('value', '' + value);
	      } else if (node.validity && !node.validity.badInput && node.ownerDocument.activeElement !== node) {
	        // Don't assign an attribute if validation reports bad
	        // input. Chrome will clear the value. Additionally, don't
	        // operate on inputs that have focus, otherwise Chrome might
	        // strip off trailing decimal places and cause the user's
	        // cursor position to jump to the beginning of the input.
	        //
	        // In ReactDOMInput, we have an onBlur event that will trigger
	        // this function again when focus is lost.
	        node.setAttribute('value', '' + value);
	      }
	    }
	  }
	};
	
	module.exports = HTMLDOMPropertyConfig;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(87);
	var ReactDOMIDOperations = __webpack_require__(98);
	
	/**
	 * Abstracts away all functionality of the reconciler that requires knowledge of
	 * the browser context. TODO: These callers should be refactored to avoid the
	 * need for this injection.
	 */
	var ReactComponentBrowserEnvironment = {
	  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,
	
	  replaceNodeWithMarkup: DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup
	};
	
	module.exports = ReactComponentBrowserEnvironment;

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var DOMLazyTree = __webpack_require__(88);
	var Danger = __webpack_require__(94);
	var ReactDOMComponentTree = __webpack_require__(40);
	var ReactInstrumentation = __webpack_require__(68);
	
	var createMicrosoftUnsafeLocalFunction = __webpack_require__(91);
	var setInnerHTML = __webpack_require__(90);
	var setTextContent = __webpack_require__(92);
	
	function getNodeAfter(parentNode, node) {
	  // Special case for text components, which return [open, close] comments
	  // from getHostNode.
	  if (Array.isArray(node)) {
	    node = node[1];
	  }
	  return node ? node.nextSibling : parentNode.firstChild;
	}
	
	/**
	 * Inserts `childNode` as a child of `parentNode` at the `index`.
	 *
	 * @param {DOMElement} parentNode Parent node in which to insert.
	 * @param {DOMElement} childNode Child node to insert.
	 * @param {number} index Index at which to insert the child.
	 * @internal
	 */
	var insertChildAt = createMicrosoftUnsafeLocalFunction(function (parentNode, childNode, referenceNode) {
	  // We rely exclusively on `insertBefore(node, null)` instead of also using
	  // `appendChild(node)`. (Using `undefined` is not allowed by all browsers so
	  // we are careful to use `null`.)
	  parentNode.insertBefore(childNode, referenceNode);
	});
	
	function insertLazyTreeChildAt(parentNode, childTree, referenceNode) {
	  DOMLazyTree.insertTreeBefore(parentNode, childTree, referenceNode);
	}
	
	function moveChild(parentNode, childNode, referenceNode) {
	  if (Array.isArray(childNode)) {
	    moveDelimitedText(parentNode, childNode[0], childNode[1], referenceNode);
	  } else {
	    insertChildAt(parentNode, childNode, referenceNode);
	  }
	}
	
	function removeChild(parentNode, childNode) {
	  if (Array.isArray(childNode)) {
	    var closingComment = childNode[1];
	    childNode = childNode[0];
	    removeDelimitedText(parentNode, childNode, closingComment);
	    parentNode.removeChild(closingComment);
	  }
	  parentNode.removeChild(childNode);
	}
	
	function moveDelimitedText(parentNode, openingComment, closingComment, referenceNode) {
	  var node = openingComment;
	  while (true) {
	    var nextNode = node.nextSibling;
	    insertChildAt(parentNode, node, referenceNode);
	    if (node === closingComment) {
	      break;
	    }
	    node = nextNode;
	  }
	}
	
	function removeDelimitedText(parentNode, startNode, closingComment) {
	  while (true) {
	    var node = startNode.nextSibling;
	    if (node === closingComment) {
	      // The closing comment is removed by ReactMultiChild.
	      break;
	    } else {
	      parentNode.removeChild(node);
	    }
	  }
	}
	
	function replaceDelimitedText(openingComment, closingComment, stringText) {
	  var parentNode = openingComment.parentNode;
	  var nodeAfterComment = openingComment.nextSibling;
	  if (nodeAfterComment === closingComment) {
	    // There are no text nodes between the opening and closing comments; insert
	    // a new one if stringText isn't empty.
	    if (stringText) {
	      insertChildAt(parentNode, document.createTextNode(stringText), nodeAfterComment);
	    }
	  } else {
	    if (stringText) {
	      // Set the text content of the first node after the opening comment, and
	      // remove all following nodes up until the closing comment.
	      setTextContent(nodeAfterComment, stringText);
	      removeDelimitedText(parentNode, nodeAfterComment, closingComment);
	    } else {
	      removeDelimitedText(parentNode, openingComment, closingComment);
	    }
	  }
	
	  if (true) {
	    ReactInstrumentation.debugTool.onHostOperation({
	      instanceID: ReactDOMComponentTree.getInstanceFromNode(openingComment)._debugID,
	      type: 'replace text',
	      payload: stringText
	    });
	  }
	}
	
	var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
	if (true) {
	  dangerouslyReplaceNodeWithMarkup = function (oldChild, markup, prevInstance) {
	    Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
	    if (prevInstance._debugID !== 0) {
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: prevInstance._debugID,
	        type: 'replace with',
	        payload: markup.toString()
	      });
	    } else {
	      var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);
	      if (nextInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onHostOperation({
	          instanceID: nextInstance._debugID,
	          type: 'mount',
	          payload: markup.toString()
	        });
	      }
	    }
	  };
	}
	
	/**
	 * Operations for updating with DOM children.
	 */
	var DOMChildrenOperations = {
	  dangerouslyReplaceNodeWithMarkup: dangerouslyReplaceNodeWithMarkup,
	
	  replaceDelimitedText: replaceDelimitedText,
	
	  /**
	   * Updates a component's children by processing a series of updates. The
	   * update configurations are each expected to have a `parentNode` property.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @internal
	   */
	  processUpdates: function (parentNode, updates) {
	    if (true) {
	      var parentNodeDebugID = ReactDOMComponentTree.getInstanceFromNode(parentNode)._debugID;
	    }
	
	    for (var k = 0; k < updates.length; k++) {
	      var update = updates[k];
	      switch (update.type) {
	        case 'INSERT_MARKUP':
	          insertLazyTreeChildAt(parentNode, update.content, getNodeAfter(parentNode, update.afterNode));
	          if (true) {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'insert child',
	              payload: {
	                toIndex: update.toIndex,
	                content: update.content.toString()
	              }
	            });
	          }
	          break;
	        case 'MOVE_EXISTING':
	          moveChild(parentNode, update.fromNode, getNodeAfter(parentNode, update.afterNode));
	          if (true) {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'move child',
	              payload: { fromIndex: update.fromIndex, toIndex: update.toIndex }
	            });
	          }
	          break;
	        case 'SET_MARKUP':
	          setInnerHTML(parentNode, update.content);
	          if (true) {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'replace children',
	              payload: update.content.toString()
	            });
	          }
	          break;
	        case 'TEXT_CONTENT':
	          setTextContent(parentNode, update.content);
	          if (true) {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'replace text',
	              payload: update.content.toString()
	            });
	          }
	          break;
	        case 'REMOVE_NODE':
	          removeChild(parentNode, update.fromNode);
	          if (true) {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'remove child',
	              payload: { fromIndex: update.fromIndex }
	            });
	          }
	          break;
	      }
	    }
	  }
	};
	
	module.exports = DOMChildrenOperations;

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var DOMNamespaces = __webpack_require__(89);
	var setInnerHTML = __webpack_require__(90);
	
	var createMicrosoftUnsafeLocalFunction = __webpack_require__(91);
	var setTextContent = __webpack_require__(92);
	
	var ELEMENT_NODE_TYPE = 1;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	/**
	 * In IE (8-11) and Edge, appending nodes with no children is dramatically
	 * faster than appending a full subtree, so we essentially queue up the
	 * .appendChild calls here and apply them so each node is added to its parent
	 * before any children are added.
	 *
	 * In other browsers, doing so is slower or neutral compared to the other order
	 * (in Firefox, twice as slow) so we only do this inversion in IE.
	 *
	 * See https://github.com/spicyj/innerhtml-vs-createelement-vs-clonenode.
	 */
	var enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\bEdge\/\d/.test(navigator.userAgent);
	
	function insertTreeChildren(tree) {
	  if (!enableLazy) {
	    return;
	  }
	  var node = tree.node;
	  var children = tree.children;
	  if (children.length) {
	    for (var i = 0; i < children.length; i++) {
	      insertTreeBefore(node, children[i], null);
	    }
	  } else if (tree.html != null) {
	    setInnerHTML(node, tree.html);
	  } else if (tree.text != null) {
	    setTextContent(node, tree.text);
	  }
	}
	
	var insertTreeBefore = createMicrosoftUnsafeLocalFunction(function (parentNode, tree, referenceNode) {
	  // DocumentFragments aren't actually part of the DOM after insertion so
	  // appending children won't update the DOM. We need to ensure the fragment
	  // is properly populated first, breaking out of our lazy approach for just
	  // this level. Also, some <object> plugins (like Flash Player) will read
	  // <param> nodes immediately upon insertion into the DOM, so <object>
	  // must also be populated prior to insertion into the DOM.
	  if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {
	    insertTreeChildren(tree);
	    parentNode.insertBefore(tree.node, referenceNode);
	  } else {
	    parentNode.insertBefore(tree.node, referenceNode);
	    insertTreeChildren(tree);
	  }
	});
	
	function replaceChildWithTree(oldNode, newTree) {
	  oldNode.parentNode.replaceChild(newTree.node, oldNode);
	  insertTreeChildren(newTree);
	}
	
	function queueChild(parentTree, childTree) {
	  if (enableLazy) {
	    parentTree.children.push(childTree);
	  } else {
	    parentTree.node.appendChild(childTree.node);
	  }
	}
	
	function queueHTML(tree, html) {
	  if (enableLazy) {
	    tree.html = html;
	  } else {
	    setInnerHTML(tree.node, html);
	  }
	}
	
	function queueText(tree, text) {
	  if (enableLazy) {
	    tree.text = text;
	  } else {
	    setTextContent(tree.node, text);
	  }
	}
	
	function toString() {
	  return this.node.nodeName;
	}
	
	function DOMLazyTree(node) {
	  return {
	    node: node,
	    children: [],
	    html: null,
	    text: null,
	    toString: toString
	  };
	}
	
	DOMLazyTree.insertTreeBefore = insertTreeBefore;
	DOMLazyTree.replaceChildWithTree = replaceChildWithTree;
	DOMLazyTree.queueChild = queueChild;
	DOMLazyTree.queueHTML = queueHTML;
	DOMLazyTree.queueText = queueText;
	
	module.exports = DOMLazyTree;

/***/ }),
/* 89 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var DOMNamespaces = {
	  html: 'http://www.w3.org/1999/xhtml',
	  mathml: 'http://www.w3.org/1998/Math/MathML',
	  svg: 'http://www.w3.org/2000/svg'
	};
	
	module.exports = DOMNamespaces;

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(54);
	var DOMNamespaces = __webpack_require__(89);
	
	var WHITESPACE_TEST = /^[ \r\n\t\f]/;
	var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;
	
	var createMicrosoftUnsafeLocalFunction = __webpack_require__(91);
	
	// SVG temp container for IE lacking innerHTML
	var reusableSVGContainer;
	
	/**
	 * Set the innerHTML property of a node, ensuring that whitespace is preserved
	 * even in IE8.
	 *
	 * @param {DOMElement} node
	 * @param {string} html
	 * @internal
	 */
	var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
	  // IE does not have innerHTML for SVG nodes, so instead we inject the
	  // new markup in a temp node and then move the child nodes across into
	  // the target node
	  if (node.namespaceURI === DOMNamespaces.svg && !('innerHTML' in node)) {
	    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
	    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
	    var svgNode = reusableSVGContainer.firstChild;
	    while (svgNode.firstChild) {
	      node.appendChild(svgNode.firstChild);
	    }
	  } else {
	    node.innerHTML = html;
	  }
	});
	
	if (ExecutionEnvironment.canUseDOM) {
	  // IE8: When updating a just created node with innerHTML only leading
	  // whitespace is removed. When updating an existing node with innerHTML
	  // whitespace in root TextNodes is also collapsed.
	  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html
	
	  // Feature detection; only IE8 is known to behave improperly like this.
	  var testElement = document.createElement('div');
	  testElement.innerHTML = ' ';
	  if (testElement.innerHTML === '') {
	    setInnerHTML = function (node, html) {
	      // Magic theory: IE8 supposedly differentiates between added and updated
	      // nodes when processing innerHTML, innerHTML on updated nodes suffers
	      // from worse whitespace behavior. Re-adding a node like this triggers
	      // the initial and more favorable whitespace behavior.
	      // TODO: What to do on a detached node?
	      if (node.parentNode) {
	        node.parentNode.replaceChild(node, node);
	      }
	
	      // We also implement a workaround for non-visible tags disappearing into
	      // thin air on IE8, this only happens if there is no visible text
	      // in-front of the non-visible tags. Piggyback on the whitespace fix
	      // and simply check if any non-visible tags appear in the source.
	      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
	        // Recover leading whitespace by temporarily prepending any character.
	        // \uFEFF has the potential advantage of being zero-width/invisible.
	        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
	        // in hopes that this is preserved even if "\uFEFF" is transformed to
	        // the actual Unicode character (by Babel, for example).
	        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
	        node.innerHTML = String.fromCharCode(0xfeff) + html;
	
	        // deleteData leaves an empty `TextNode` which offsets the index of all
	        // children. Definitely want to avoid this.
	        var textNode = node.firstChild;
	        if (textNode.data.length === 1) {
	          node.removeChild(textNode);
	        } else {
	          textNode.deleteData(0, 1);
	        }
	      } else {
	        node.innerHTML = html;
	      }
	    };
	  }
	  testElement = null;
	}
	
	module.exports = setInnerHTML;

/***/ }),
/* 91 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	/* globals MSApp */
	
	'use strict';
	
	/**
	 * Create a function which has 'unsafe' privileges (required by windows8 apps)
	 */
	
	var createMicrosoftUnsafeLocalFunction = function (func) {
	  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
	    return function (arg0, arg1, arg2, arg3) {
	      MSApp.execUnsafeLocalFunction(function () {
	        return func(arg0, arg1, arg2, arg3);
	      });
	    };
	  } else {
	    return func;
	  }
	};
	
	module.exports = createMicrosoftUnsafeLocalFunction;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(54);
	var escapeTextContentForBrowser = __webpack_require__(93);
	var setInnerHTML = __webpack_require__(90);
	
	/**
	 * Set the textContent property of a node, ensuring that whitespace is preserved
	 * even in IE8. innerText is a poor substitute for textContent and, among many
	 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
	 * as it should.
	 *
	 * @param {DOMElement} node
	 * @param {string} text
	 * @internal
	 */
	var setTextContent = function (node, text) {
	  if (text) {
	    var firstChild = node.firstChild;
	
	    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === 3) {
	      firstChild.nodeValue = text;
	      return;
	    }
	  }
	  node.textContent = text;
	};
	
	if (ExecutionEnvironment.canUseDOM) {
	  if (!('textContent' in document.documentElement)) {
	    setTextContent = function (node, text) {
	      if (node.nodeType === 3) {
	        node.nodeValue = text;
	        return;
	      }
	      setInnerHTML(node, escapeTextContentForBrowser(text));
	    };
	  }
	}
	
	module.exports = setTextContent;

/***/ }),
/* 93 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2016-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * Based on the escape-html library, which is used under the MIT License below:
	 *
	 * Copyright (c) 2012-2013 TJ Holowaychuk
	 * Copyright (c) 2015 Andreas Lubbe
	 * Copyright (c) 2015 Tiancheng "Timothy" Gu
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining
	 * a copy of this software and associated documentation files (the
	 * 'Software'), to deal in the Software without restriction, including
	 * without limitation the rights to use, copy, modify, merge, publish,
	 * distribute, sublicense, and/or sell copies of the Software, and to
	 * permit persons to whom the Software is furnished to do so, subject to
	 * the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be
	 * included in all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
	 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
	 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
	 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
	 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 *
	 */
	
	'use strict';
	
	// code copied and modified from escape-html
	/**
	 * Module variables.
	 * @private
	 */
	
	var matchHtmlRegExp = /["'&<>]/;
	
	/**
	 * Escape special characters in the given string of html.
	 *
	 * @param  {string} string The string to escape for inserting into HTML
	 * @return {string}
	 * @public
	 */
	
	function escapeHtml(string) {
	  var str = '' + string;
	  var match = matchHtmlRegExp.exec(str);
	
	  if (!match) {
	    return str;
	  }
	
	  var escape;
	  var html = '';
	  var index = 0;
	  var lastIndex = 0;
	
	  for (index = match.index; index < str.length; index++) {
	    switch (str.charCodeAt(index)) {
	      case 34:
	        // "
	        escape = '&quot;';
	        break;
	      case 38:
	        // &
	        escape = '&amp;';
	        break;
	      case 39:
	        // '
	        escape = '&#x27;'; // modified from escape-html; used to be '&#39'
	        break;
	      case 60:
	        // <
	        escape = '&lt;';
	        break;
	      case 62:
	        // >
	        escape = '&gt;';
	        break;
	      default:
	        continue;
	    }
	
	    if (lastIndex !== index) {
	      html += str.substring(lastIndex, index);
	    }
	
	    lastIndex = index + 1;
	    html += escape;
	  }
	
	  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
	}
	// end code copied and modified from escape-html
	
	/**
	 * Escapes text to prevent scripting attacks.
	 *
	 * @param {*} text Text value to escape.
	 * @return {string} An escaped string.
	 */
	function escapeTextContentForBrowser(text) {
	  if (typeof text === 'boolean' || typeof text === 'number') {
	    // this shortcircuit helps perf for types that we know will never have
	    // special characters, especially given that this function is used often
	    // for numeric dom ids.
	    return '' + text;
	  }
	  return escapeHtml(text);
	}
	
	module.exports = escapeTextContentForBrowser;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(41);
	
	var DOMLazyTree = __webpack_require__(88);
	var ExecutionEnvironment = __webpack_require__(54);
	
	var createNodesFromMarkup = __webpack_require__(95);
	var emptyFunction = __webpack_require__(9);
	var invariant = __webpack_require__(12);
	
	var Danger = {
	  /**
	   * Replaces a node with a string of markup at its current position within its
	   * parent. The markup must render into a single root node.
	   *
	   * @param {DOMElement} oldChild Child node to replace.
	   * @param {string} markup Markup to render in place of the child node.
	   * @internal
	   */
	  dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
	    !ExecutionEnvironment.canUseDOM ?  true ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React when unit testing or use ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('56') : void 0;
	    !markup ?  true ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : _prodInvariant('57') : void 0;
	    !(oldChild.nodeName !== 'HTML') ?  true ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the <html> node. This is because browser quirks make this unreliable and/or slow. If you want to render to the root you must use server rendering. See ReactDOMServer.renderToString().') : _prodInvariant('58') : void 0;
	
	    if (typeof markup === 'string') {
	      var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
	      oldChild.parentNode.replaceChild(newChild, oldChild);
	    } else {
	      DOMLazyTree.replaceChildWithTree(oldChild, markup);
	    }
	  }
	};
	
	module.exports = Danger;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 */
	
	/*eslint-disable fb-www/unsafe-html*/
	
	var ExecutionEnvironment = __webpack_require__(54);
	
	var createArrayFromMixed = __webpack_require__(96);
	var getMarkupWrap = __webpack_require__(97);
	var invariant = __webpack_require__(12);
	
	/**
	 * Dummy container used to render all markup.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Pattern used by `getNodeName`.
	 */
	var nodeNamePattern = /^\s*<(\w+)/;
	
	/**
	 * Extracts the `nodeName` of the first element in a string of markup.
	 *
	 * @param {string} markup String of markup.
	 * @return {?string} Node name of the supplied markup.
	 */
	function getNodeName(markup) {
	  var nodeNameMatch = markup.match(nodeNamePattern);
	  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
	}
	
	/**
	 * Creates an array containing the nodes rendered from the supplied markup. The
	 * optionally supplied `handleScript` function will be invoked once for each
	 * <script> element that is rendered. If no `handleScript` function is supplied,
	 * an exception is thrown if any <script> elements are rendered.
	 *
	 * @param {string} markup A string of valid HTML markup.
	 * @param {?function} handleScript Invoked once for each rendered <script>.
	 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
	 */
	function createNodesFromMarkup(markup, handleScript) {
	  var node = dummyNode;
	  !!!dummyNode ?  true ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : void 0;
	  var nodeName = getNodeName(markup);
	
	  var wrap = nodeName && getMarkupWrap(nodeName);
	  if (wrap) {
	    node.innerHTML = wrap[1] + markup + wrap[2];
	
	    var wrapDepth = wrap[0];
	    while (wrapDepth--) {
	      node = node.lastChild;
	    }
	  } else {
	    node.innerHTML = markup;
	  }
	
	  var scripts = node.getElementsByTagName('script');
	  if (scripts.length) {
	    !handleScript ?  true ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : void 0;
	    createArrayFromMixed(scripts).forEach(handleScript);
	  }
	
	  var nodes = Array.from(node.childNodes);
	  while (node.lastChild) {
	    node.removeChild(node.lastChild);
	  }
	  return nodes;
	}
	
	module.exports = createNodesFromMarkup;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 */
	
	var invariant = __webpack_require__(12);
	
	/**
	 * Convert array-like objects to arrays.
	 *
	 * This API assumes the caller knows the contents of the data type. For less
	 * well defined inputs use createArrayFromMixed.
	 *
	 * @param {object|function|filelist} obj
	 * @return {array}
	 */
	function toArray(obj) {
	  var length = obj.length;
	
	  // Some browsers builtin objects can report typeof 'function' (e.g. NodeList
	  // in old versions of Safari).
	  !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ?  true ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : void 0;
	
	  !(typeof length === 'number') ?  true ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : void 0;
	
	  !(length === 0 || length - 1 in obj) ?  true ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : void 0;
	
	  !(typeof obj.callee !== 'function') ?  true ? invariant(false, 'toArray: Object can\'t be `arguments`. Use rest params ' + '(function(...args) {}) or Array.from() instead.') : invariant(false) : void 0;
	
	  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
	  // without method will throw during the slice call and skip straight to the
	  // fallback.
	  if (obj.hasOwnProperty) {
	    try {
	      return Array.prototype.slice.call(obj);
	    } catch (e) {
	      // IE < 9 does not support Array#slice on collections objects
	    }
	  }
	
	  // Fall back to copying key by key. This assumes all keys have a value,
	  // so will not preserve sparsely populated inputs.
	  var ret = Array(length);
	  for (var ii = 0; ii < length; ii++) {
	    ret[ii] = obj[ii];
	  }
	  return ret;
	}
	
	/**
	 * Perform a heuristic test to determine if an object is "array-like".
	 *
	 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
	 *   Joshu replied: "Mu."
	 *
	 * This function determines if its argument has "array nature": it returns
	 * true if the argument is an actual array, an `arguments' object, or an
	 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
	 *
	 * It will return false for other array-like objects like Filelist.
	 *
	 * @param {*} obj
	 * @return {boolean}
	 */
	function hasArrayNature(obj) {
	  return (
	    // not null/false
	    !!obj && (
	    // arrays are objects, NodeLists are functions in Safari
	    typeof obj == 'object' || typeof obj == 'function') &&
	    // quacks like an array
	    'length' in obj &&
	    // not window
	    !('setInterval' in obj) &&
	    // no DOM node should be considered an array-like
	    // a 'select' element has 'length' and 'item' properties on IE8
	    typeof obj.nodeType != 'number' && (
	    // a real array
	    Array.isArray(obj) ||
	    // arguments
	    'callee' in obj ||
	    // HTMLCollection/NodeList
	    'item' in obj)
	  );
	}
	
	/**
	 * Ensure that the argument is an array by wrapping it in an array if it is not.
	 * Creates a copy of the argument if it is already an array.
	 *
	 * This is mostly useful idiomatically:
	 *
	 *   var createArrayFromMixed = require('createArrayFromMixed');
	 *
	 *   function takesOneOrMoreThings(things) {
	 *     things = createArrayFromMixed(things);
	 *     ...
	 *   }
	 *
	 * This allows you to treat `things' as an array, but accept scalars in the API.
	 *
	 * If you need to convert an array-like object, like `arguments`, into an array
	 * use toArray instead.
	 *
	 * @param {*} obj
	 * @return {array}
	 */
	function createArrayFromMixed(obj) {
	  if (!hasArrayNature(obj)) {
	    return [obj];
	  } else if (Array.isArray(obj)) {
	    return obj.slice();
	  } else {
	    return toArray(obj);
	  }
	}
	
	module.exports = createArrayFromMixed;

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	/*eslint-disable fb-www/unsafe-html */
	
	var ExecutionEnvironment = __webpack_require__(54);
	
	var invariant = __webpack_require__(12);
	
	/**
	 * Dummy container used to detect which wraps are necessary.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Some browsers cannot use `innerHTML` to render certain elements standalone,
	 * so we wrap them, render the wrapped nodes, then extract the desired node.
	 *
	 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
	 */
	
	var shouldWrap = {};
	
	var selectWrap = [1, '<select multiple="true">', '</select>'];
	var tableWrap = [1, '<table>', '</table>'];
	var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
	
	var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];
	
	var markupWrap = {
	  '*': [1, '?<div>', '</div>'],
	
	  'area': [1, '<map>', '</map>'],
	  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
	  'legend': [1, '<fieldset>', '</fieldset>'],
	  'param': [1, '<object>', '</object>'],
	  'tr': [2, '<table><tbody>', '</tbody></table>'],
	
	  'optgroup': selectWrap,
	  'option': selectWrap,
	
	  'caption': tableWrap,
	  'colgroup': tableWrap,
	  'tbody': tableWrap,
	  'tfoot': tableWrap,
	  'thead': tableWrap,
	
	  'td': trWrap,
	  'th': trWrap
	};
	
	// Initialize the SVG elements since we know they'll always need to be wrapped
	// consistently. If they are created inside a <div> they will be initialized in
	// the wrong namespace (and will not display).
	var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
	svgElements.forEach(function (nodeName) {
	  markupWrap[nodeName] = svgWrap;
	  shouldWrap[nodeName] = true;
	});
	
	/**
	 * Gets the markup wrap configuration for the supplied `nodeName`.
	 *
	 * NOTE: This lazily detects which wraps are necessary for the current browser.
	 *
	 * @param {string} nodeName Lowercase `nodeName`.
	 * @return {?array} Markup wrap configuration, if applicable.
	 */
	function getMarkupWrap(nodeName) {
	  !!!dummyNode ?  true ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : void 0;
	  if (!markupWrap.hasOwnProperty(nodeName)) {
	    nodeName = '*';
	  }
	  if (!shouldWrap.hasOwnProperty(nodeName)) {
	    if (nodeName === '*') {
	      dummyNode.innerHTML = '<link />';
	    } else {
	      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
	    }
	    shouldWrap[nodeName] = !dummyNode.firstChild;
	  }
	  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
	}
	
	module.exports = getMarkupWrap;

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(87);
	var ReactDOMComponentTree = __webpack_require__(40);
	
	/**
	 * Operations used to process updates to DOM nodes.
	 */
	var ReactDOMIDOperations = {
	  /**
	   * Updates a component's children by processing a series of updates.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @internal
	   */
	  dangerouslyProcessChildrenUpdates: function (parentInst, updates) {
	    var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
	    DOMChildrenOperations.processUpdates(node, updates);
	  }
	};
	
	module.exports = ReactDOMIDOperations;

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	/* global hasOwnProperty:true */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(41),
	    _assign = __webpack_require__(4);
	
	var AutoFocusUtils = __webpack_require__(100);
	var CSSPropertyOperations = __webpack_require__(102);
	var DOMLazyTree = __webpack_require__(88);
	var DOMNamespaces = __webpack_require__(89);
	var DOMProperty = __webpack_require__(42);
	var DOMPropertyOperations = __webpack_require__(110);
	var EventPluginHub = __webpack_require__(48);
	var EventPluginRegistry = __webpack_require__(49);
	var ReactBrowserEventEmitter = __webpack_require__(112);
	var ReactDOMComponentFlags = __webpack_require__(43);
	var ReactDOMComponentTree = __webpack_require__(40);
	var ReactDOMInput = __webpack_require__(115);
	var ReactDOMOption = __webpack_require__(118);
	var ReactDOMSelect = __webpack_require__(119);
	var ReactDOMTextarea = __webpack_require__(120);
	var ReactInstrumentation = __webpack_require__(68);
	var ReactMultiChild = __webpack_require__(121);
	var ReactServerRenderingTransaction = __webpack_require__(140);
	
	var emptyFunction = __webpack_require__(9);
	var escapeTextContentForBrowser = __webpack_require__(93);
	var invariant = __webpack_require__(12);
	var isEventSupported = __webpack_require__(77);
	var shallowEqual = __webpack_require__(130);
	var inputValueTracking = __webpack_require__(75);
	var validateDOMNesting = __webpack_require__(143);
	var warning = __webpack_require__(8);
	
	var Flags = ReactDOMComponentFlags;
	var deleteListener = EventPluginHub.deleteListener;
	var getNode = ReactDOMComponentTree.getNodeFromInstance;
	var listenTo = ReactBrowserEventEmitter.listenTo;
	var registrationNameModules = EventPluginRegistry.registrationNameModules;
	
	// For quickly matching children type, to test if can be treated as content.
	var CONTENT_TYPES = { string: true, number: true };
	
	var STYLE = 'style';
	var HTML = '__html';
	var RESERVED_PROPS = {
	  children: null,
	  dangerouslySetInnerHTML: null,
	  suppressContentEditableWarning: null
	};
	
	// Node type for document fragments (Node.DOCUMENT_FRAGMENT_NODE).
	var DOC_FRAGMENT_TYPE = 11;
	
	function getDeclarationErrorAddendum(internalInstance) {
	  if (internalInstance) {
	    var owner = internalInstance._currentElement._owner || null;
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' This DOM node was rendered by `' + name + '`.';
	      }
	    }
	  }
	  return '';
	}
	
	function friendlyStringify(obj) {
	  if (typeof obj === 'object') {
	    if (Array.isArray(obj)) {
	      return '[' + obj.map(friendlyStringify).join(', ') + ']';
	    } else {
	      var pairs = [];
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) {
	          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
	          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
	        }
	      }
	      return '{' + pairs.join(', ') + '}';
	    }
	  } else if (typeof obj === 'string') {
	    return JSON.stringify(obj);
	  } else if (typeof obj === 'function') {
	    return '[function object]';
	  }
	  // Differs from JSON.stringify in that undefined because undefined and that
	  // inf and nan don't become null
	  return String(obj);
	}
	
	var styleMutationWarning = {};
	
	function checkAndWarnForMutatedStyle(style1, style2, component) {
	  if (style1 == null || style2 == null) {
	    return;
	  }
	  if (shallowEqual(style1, style2)) {
	    return;
	  }
	
	  var componentName = component._tag;
	  var owner = component._currentElement._owner;
	  var ownerName;
	  if (owner) {
	    ownerName = owner.getName();
	  }
	
	  var hash = ownerName + '|' + componentName;
	
	  if (styleMutationWarning.hasOwnProperty(hash)) {
	    return;
	  }
	
	  styleMutationWarning[hash] = true;
	
	   true ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : void 0;
	}
	
	/**
	 * @param {object} component
	 * @param {?object} props
	 */
	function assertValidProps(component, props) {
	  if (!props) {
	    return;
	  }
	  // Note the use of `==` which checks for null or undefined.
	  if (voidElementTags[component._tag]) {
	    !(props.children == null && props.dangerouslySetInnerHTML == null) ?  true ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : _prodInvariant('137', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : void 0;
	  }
	  if (props.dangerouslySetInnerHTML != null) {
	    !(props.children == null) ?  true ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : _prodInvariant('60') : void 0;
	    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ?  true ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : _prodInvariant('61') : void 0;
	  }
	  if (true) {
	     true ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : void 0;
	     true ? warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : void 0;
	     true ? warning(props.onFocusIn == null && props.onFocusOut == null, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.') : void 0;
	  }
	  !(props.style == null || typeof props.style === 'object') ?  true ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getDeclarationErrorAddendum(component)) : _prodInvariant('62', getDeclarationErrorAddendum(component)) : void 0;
	}
	
	function enqueuePutListener(inst, registrationName, listener, transaction) {
	  if (transaction instanceof ReactServerRenderingTransaction) {
	    return;
	  }
	  if (true) {
	    // IE8 has no API for event capturing and the `onScroll` event doesn't
	    // bubble.
	     true ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), "This browser doesn't support the `onScroll` event") : void 0;
	  }
	  var containerInfo = inst._hostContainerInfo;
	  var isDocumentFragment = containerInfo._node && containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
	  var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;
	  listenTo(registrationName, doc);
	  transaction.getReactMountReady().enqueue(putListener, {
	    inst: inst,
	    registrationName: registrationName,
	    listener: listener
	  });
	}
	
	function putListener() {
	  var listenerToPut = this;
	  EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
	}
	
	function inputPostMount() {
	  var inst = this;
	  ReactDOMInput.postMountWrapper(inst);
	}
	
	function textareaPostMount() {
	  var inst = this;
	  ReactDOMTextarea.postMountWrapper(inst);
	}
	
	function optionPostMount() {
	  var inst = this;
	  ReactDOMOption.postMountWrapper(inst);
	}
	
	var setAndValidateContentChildDev = emptyFunction;
	if (true) {
	  setAndValidateContentChildDev = function (content) {
	    var hasExistingContent = this._contentDebugID != null;
	    var debugID = this._debugID;
	    // This ID represents the inlined child that has no backing instance:
	    var contentDebugID = -debugID;
	
	    if (content == null) {
	      if (hasExistingContent) {
	        ReactInstrumentation.debugTool.onUnmountComponent(this._contentDebugID);
	      }
	      this._contentDebugID = null;
	      return;
	    }
	
	    validateDOMNesting(null, String(content), this, this._ancestorInfo);
	    this._contentDebugID = contentDebugID;
	    if (hasExistingContent) {
	      ReactInstrumentation.debugTool.onBeforeUpdateComponent(contentDebugID, content);
	      ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
	    } else {
	      ReactInstrumentation.debugTool.onBeforeMountComponent(contentDebugID, content, debugID);
	      ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
	      ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
	    }
	  };
	}
	
	// There are so many media events, it makes sense to just
	// maintain a list rather than create a `trapBubbledEvent` for each
	var mediaEvents = {
	  topAbort: 'abort',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTimeUpdate: 'timeupdate',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting'
	};
	
	function trackInputValue() {
	  inputValueTracking.track(this);
	}
	
	function trapBubbledEventsLocal() {
	  var inst = this;
	  // If a component renders to null or if another component fatals and causes
	  // the state of the tree to be corrupted, `node` here can be null.
	  !inst._rootNodeID ?  true ? invariant(false, 'Must be mounted to trap events') : _prodInvariant('63') : void 0;
	  var node = getNode(inst);
	  !node ?  true ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : _prodInvariant('64') : void 0;
	
	  switch (inst._tag) {
	    case 'iframe':
	    case 'object':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
	      break;
	    case 'video':
	    case 'audio':
	      inst._wrapperState.listeners = [];
	      // Create listener for each media event
	      for (var event in mediaEvents) {
	        if (mediaEvents.hasOwnProperty(event)) {
	          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(event, mediaEvents[event], node));
	        }
	      }
	      break;
	    case 'source':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node)];
	      break;
	    case 'img':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node), ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
	      break;
	    case 'form':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topReset', 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent('topSubmit', 'submit', node)];
	      break;
	    case 'input':
	    case 'select':
	    case 'textarea':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topInvalid', 'invalid', node)];
	      break;
	  }
	}
	
	function postUpdateSelectWrapper() {
	  ReactDOMSelect.postUpdateWrapper(this);
	}
	
	// For HTML, certain tags should omit their close tag. We keep a whitelist for
	// those special-case tags.
	
	var omittedCloseTags = {
	  area: true,
	  base: true,
	  br: true,
	  col: true,
	  embed: true,
	  hr: true,
	  img: true,
	  input: true,
	  keygen: true,
	  link: true,
	  meta: true,
	  param: true,
	  source: true,
	  track: true,
	  wbr: true
	  // NOTE: menuitem's close tag should be omitted, but that causes problems.
	};
	
	var newlineEatingTags = {
	  listing: true,
	  pre: true,
	  textarea: true
	};
	
	// For HTML, certain tags cannot have children. This has the same purpose as
	// `omittedCloseTags` except that `menuitem` should still have its closing tag.
	
	var voidElementTags = _assign({
	  menuitem: true
	}, omittedCloseTags);
	
	// We accept any tag to be rendered but since this gets injected into arbitrary
	// HTML, we want to make sure that it's a safe tag.
	// http://www.w3.org/TR/REC-xml/#NT-Name
	
	var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
	var validatedTagCache = {};
	var hasOwnProperty = {}.hasOwnProperty;
	
	function validateDangerousTag(tag) {
	  if (!hasOwnProperty.call(validatedTagCache, tag)) {
	    !VALID_TAG_REGEX.test(tag) ?  true ? invariant(false, 'Invalid tag: %s', tag) : _prodInvariant('65', tag) : void 0;
	    validatedTagCache[tag] = true;
	  }
	}
	
	function isCustomComponent(tagName, props) {
	  return tagName.indexOf('-') >= 0 || props.is != null;
	}
	
	var globalIdCounter = 1;
	
	/**
	 * Creates a new React class that is idempotent and capable of containing other
	 * React components. It accepts event listeners and DOM properties that are
	 * valid according to `DOMProperty`.
	 *
	 *  - Event listeners: `onClick`, `onMouseDown`, etc.
	 *  - DOM properties: `className`, `name`, `title`, etc.
	 *
	 * The `style` property functions differently from the DOM API. It accepts an
	 * object mapping of style properties to values.
	 *
	 * @constructor ReactDOMComponent
	 * @extends ReactMultiChild
	 */
	function ReactDOMComponent(element) {
	  var tag = element.type;
	  validateDangerousTag(tag);
	  this._currentElement = element;
	  this._tag = tag.toLowerCase();
	  this._namespaceURI = null;
	  this._renderedChildren = null;
	  this._previousStyle = null;
	  this._previousStyleCopy = null;
	  this._hostNode = null;
	  this._hostParent = null;
	  this._rootNodeID = 0;
	  this._domID = 0;
	  this._hostContainerInfo = null;
	  this._wrapperState = null;
	  this._topLevelWrapper = null;
	  this._flags = 0;
	  if (true) {
	    this._ancestorInfo = null;
	    setAndValidateContentChildDev.call(this, null);
	  }
	}
	
	ReactDOMComponent.displayName = 'ReactDOMComponent';
	
	ReactDOMComponent.Mixin = {
	  /**
	   * Generates root tag markup then recurses. This method has side effects and
	   * is not idempotent.
	   *
	   * @internal
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?ReactDOMComponent} the parent component instance
	   * @param {?object} info about the host container
	   * @param {object} context
	   * @return {string} The computed markup.
	   */
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    this._rootNodeID = globalIdCounter++;
	    this._domID = hostContainerInfo._idCounter++;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;
	
	    var props = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'audio':
	      case 'form':
	      case 'iframe':
	      case 'img':
	      case 'link':
	      case 'object':
	      case 'source':
	      case 'video':
	        this._wrapperState = {
	          listeners: null
	        };
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'input':
	        ReactDOMInput.mountWrapper(this, props, hostParent);
	        props = ReactDOMInput.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trackInputValue, this);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'option':
	        ReactDOMOption.mountWrapper(this, props, hostParent);
	        props = ReactDOMOption.getHostProps(this, props);
	        break;
	      case 'select':
	        ReactDOMSelect.mountWrapper(this, props, hostParent);
	        props = ReactDOMSelect.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.mountWrapper(this, props, hostParent);
	        props = ReactDOMTextarea.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trackInputValue, this);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	    }
	
	    assertValidProps(this, props);
	
	    // We create tags in the namespace of their parent container, except HTML
	    // tags get no namespace.
	    var namespaceURI;
	    var parentTag;
	    if (hostParent != null) {
	      namespaceURI = hostParent._namespaceURI;
	      parentTag = hostParent._tag;
	    } else if (hostContainerInfo._tag) {
	      namespaceURI = hostContainerInfo._namespaceURI;
	      parentTag = hostContainerInfo._tag;
	    }
	    if (namespaceURI == null || namespaceURI === DOMNamespaces.svg && parentTag === 'foreignobject') {
	      namespaceURI = DOMNamespaces.html;
	    }
	    if (namespaceURI === DOMNamespaces.html) {
	      if (this._tag === 'svg') {
	        namespaceURI = DOMNamespaces.svg;
	      } else if (this._tag === 'math') {
	        namespaceURI = DOMNamespaces.mathml;
	      }
	    }
	    this._namespaceURI = namespaceURI;
	
	    if (true) {
	      var parentInfo;
	      if (hostParent != null) {
	        parentInfo = hostParent._ancestorInfo;
	      } else if (hostContainerInfo._tag) {
	        parentInfo = hostContainerInfo._ancestorInfo;
	      }
	      if (parentInfo) {
	        // parentInfo should always be present except for the top-level
	        // component when server rendering
	        validateDOMNesting(this._tag, null, this, parentInfo);
	      }
	      this._ancestorInfo = validateDOMNesting.updatedAncestorInfo(parentInfo, this._tag, this);
	    }
	
	    var mountImage;
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var el;
	      if (namespaceURI === DOMNamespaces.html) {
	        if (this._tag === 'script') {
	          // Create the script via .innerHTML so its "parser-inserted" flag is
	          // set to true and it does not execute
	          var div = ownerDocument.createElement('div');
	          var type = this._currentElement.type;
	          div.innerHTML = '<' + type + '></' + type + '>';
	          el = div.removeChild(div.firstChild);
	        } else if (props.is) {
	          el = ownerDocument.createElement(this._currentElement.type, props.is);
	        } else {
	          // Separate else branch instead of using `props.is || undefined` above becuase of a Firefox bug.
	          // See discussion in https://github.com/facebook/react/pull/6896
	          // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
	          el = ownerDocument.createElement(this._currentElement.type);
	        }
	      } else {
	        el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
	      }
	      ReactDOMComponentTree.precacheNode(this, el);
	      this._flags |= Flags.hasCachedChildNodes;
	      if (!this._hostParent) {
	        DOMPropertyOperations.setAttributeForRoot(el);
	      }
	      this._updateDOMProperties(null, props, transaction);
	      var lazyTree = DOMLazyTree(el);
	      this._createInitialChildren(transaction, props, context, lazyTree);
	      mountImage = lazyTree;
	    } else {
	      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
	      var tagContent = this._createContentMarkup(transaction, props, context);
	      if (!tagContent && omittedCloseTags[this._tag]) {
	        mountImage = tagOpen + '/>';
	      } else {
	        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
	      }
	    }
	
	    switch (this._tag) {
	      case 'input':
	        transaction.getReactMountReady().enqueue(inputPostMount, this);
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'textarea':
	        transaction.getReactMountReady().enqueue(textareaPostMount, this);
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'select':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'button':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'option':
	        transaction.getReactMountReady().enqueue(optionPostMount, this);
	        break;
	    }
	
	    return mountImage;
	  },
	
	  /**
	   * Creates markup for the open tag and all attributes.
	   *
	   * This method has side effects because events get registered.
	   *
	   * Iterating over object properties is faster than iterating over arrays.
	   * @see http://jsperf.com/obj-vs-arr-iteration
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @return {string} Markup of opening tag.
	   */
	  _createOpenTagMarkupAndPutListeners: function (transaction, props) {
	    var ret = '<' + this._currentElement.type;
	
	    for (var propKey in props) {
	      if (!props.hasOwnProperty(propKey)) {
	        continue;
	      }
	      var propValue = props[propKey];
	      if (propValue == null) {
	        continue;
	      }
	      if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (propValue) {
	          enqueuePutListener(this, propKey, propValue, transaction);
	        }
	      } else {
	        if (propKey === STYLE) {
	          if (propValue) {
	            if (true) {
	              // See `_updateDOMProperties`. style block
	              this._previousStyle = propValue;
	            }
	            propValue = this._previousStyleCopy = _assign({}, props.style);
	          }
	          propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
	        }
	        var markup = null;
	        if (this._tag != null && isCustomComponent(this._tag, props)) {
	          if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
	          }
	        } else {
	          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
	        }
	        if (markup) {
	          ret += ' ' + markup;
	        }
	      }
	    }
	
	    // For static pages, no need to put React ID and checksum. Saves lots of
	    // bytes.
	    if (transaction.renderToStaticMarkup) {
	      return ret;
	    }
	
	    if (!this._hostParent) {
	      ret += ' ' + DOMPropertyOperations.createMarkupForRoot();
	    }
	    ret += ' ' + DOMPropertyOperations.createMarkupForID(this._domID);
	    return ret;
	  },
	
	  /**
	   * Creates markup for the content between the tags.
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @param {object} context
	   * @return {string} Content markup.
	   */
	  _createContentMarkup: function (transaction, props, context) {
	    var ret = '';
	
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        ret = innerHTML.__html;
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        ret = escapeTextContentForBrowser(contentToUse);
	        if (true) {
	          setAndValidateContentChildDev.call(this, contentToUse);
	        }
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        ret = mountImages.join('');
	      }
	    }
	    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
	      // text/html ignores the first character in these tags if it's a newline
	      // Prefer to break application/xml over text/html (for now) by adding
	      // a newline specifically to get eaten by the parser. (Alternately for
	      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
	      // \r is normalized out by HTMLTextAreaElement#value.)
	      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
	      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
	      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
	      // See: Parsing of "textarea" "listing" and "pre" elements
	      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
	      return '\n' + ret;
	    } else {
	      return ret;
	    }
	  },
	
	  _createInitialChildren: function (transaction, props, context, lazyTree) {
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        DOMLazyTree.queueHTML(lazyTree, innerHTML.__html);
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      // TODO: Validate that text is allowed as a child of this node
	      if (contentToUse != null) {
	        // Avoid setting textContent when the text is empty. In IE11 setting
	        // textContent on a text area will cause the placeholder to not
	        // show within the textarea until it has been focused and blurred again.
	        // https://github.com/facebook/react/issues/6731#issuecomment-254874553
	        if (contentToUse !== '') {
	          if (true) {
	            setAndValidateContentChildDev.call(this, contentToUse);
	          }
	          DOMLazyTree.queueText(lazyTree, contentToUse);
	        }
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        for (var i = 0; i < mountImages.length; i++) {
	          DOMLazyTree.queueChild(lazyTree, mountImages[i]);
	        }
	      }
	    }
	  },
	
	  /**
	   * Receives a next element and updates the component.
	   *
	   * @internal
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} context
	   */
	  receiveComponent: function (nextElement, transaction, context) {
	    var prevElement = this._currentElement;
	    this._currentElement = nextElement;
	    this.updateComponent(transaction, prevElement, nextElement, context);
	  },
	
	  /**
	   * Updates a DOM component after it has already been allocated and
	   * attached to the DOM. Reconciles the root DOM node, then recurses.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevElement
	   * @param {ReactElement} nextElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function (transaction, prevElement, nextElement, context) {
	    var lastProps = prevElement.props;
	    var nextProps = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'input':
	        lastProps = ReactDOMInput.getHostProps(this, lastProps);
	        nextProps = ReactDOMInput.getHostProps(this, nextProps);
	        break;
	      case 'option':
	        lastProps = ReactDOMOption.getHostProps(this, lastProps);
	        nextProps = ReactDOMOption.getHostProps(this, nextProps);
	        break;
	      case 'select':
	        lastProps = ReactDOMSelect.getHostProps(this, lastProps);
	        nextProps = ReactDOMSelect.getHostProps(this, nextProps);
	        break;
	      case 'textarea':
	        lastProps = ReactDOMTextarea.getHostProps(this, lastProps);
	        nextProps = ReactDOMTextarea.getHostProps(this, nextProps);
	        break;
	    }
	
	    assertValidProps(this, nextProps);
	    this._updateDOMProperties(lastProps, nextProps, transaction);
	    this._updateDOMChildren(lastProps, nextProps, transaction, context);
	
	    switch (this._tag) {
	      case 'input':
	        // Update the wrapper around inputs *after* updating props. This has to
	        // happen after `_updateDOMProperties`. Otherwise HTML5 input validations
	        // raise warnings and prevent the new value from being assigned.
	        ReactDOMInput.updateWrapper(this);
	
	        // We also check that we haven't missed a value update, such as a
	        // Radio group shifting the checked value to another named radio input.
	        inputValueTracking.updateValueIfChanged(this);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.updateWrapper(this);
	        break;
	      case 'select':
	        // <select> value update needs to occur after <option> children
	        // reconciliation
	        transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
	        break;
	    }
	  },
	
	  /**
	   * Reconciles the properties by detecting differences in property values and
	   * updating the DOM as necessary. This function is probably the single most
	   * critical path for performance optimization.
	   *
	   * TODO: Benchmark whether checking for changed values in memory actually
	   *       improves performance (especially statically positioned elements).
	   * TODO: Benchmark the effects of putting this at the top since 99% of props
	   *       do not change for a given reconciliation.
	   * TODO: Benchmark areas that can be improved with caching.
	   *
	   * @private
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {?DOMElement} node
	   */
	  _updateDOMProperties: function (lastProps, nextProps, transaction) {
	    var propKey;
	    var styleName;
	    var styleUpdates;
	    for (propKey in lastProps) {
	      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        var lastStyle = this._previousStyleCopy;
	        for (styleName in lastStyle) {
	          if (lastStyle.hasOwnProperty(styleName)) {
	            styleUpdates = styleUpdates || {};
	            styleUpdates[styleName] = '';
	          }
	        }
	        this._previousStyleCopy = null;
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (lastProps[propKey]) {
	          // Only call deleteListener if there was a listener previously or
	          // else willDeleteListener gets called when there wasn't actually a
	          // listener (e.g., onClick={null})
	          deleteListener(this, propKey);
	        }
	      } else if (isCustomComponent(this._tag, lastProps)) {
	        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	          DOMPropertyOperations.deleteValueForAttribute(getNode(this), propKey);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
	      }
	    }
	    for (propKey in nextProps) {
	      var nextProp = nextProps[propKey];
	      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps != null ? lastProps[propKey] : undefined;
	      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        if (nextProp) {
	          if (true) {
	            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
	            this._previousStyle = nextProp;
	          }
	          nextProp = this._previousStyleCopy = _assign({}, nextProp);
	        } else {
	          this._previousStyleCopy = null;
	        }
	        if (lastProp) {
	          // Unset styles on `lastProp` but not on `nextProp`.
	          for (styleName in lastProp) {
	            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = '';
	            }
	          }
	          // Update styles that changed since `lastProp`.
	          for (styleName in nextProp) {
	            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = nextProp[styleName];
	            }
	          }
	        } else {
	          // Relies on `updateStylesByID` not mutating `styleUpdates`.
	          styleUpdates = nextProp;
	        }
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (nextProp) {
	          enqueuePutListener(this, propKey, nextProp, transaction);
	        } else if (lastProp) {
	          deleteListener(this, propKey);
	        }
	      } else if (isCustomComponent(this._tag, nextProps)) {
	        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	          DOMPropertyOperations.setValueForAttribute(getNode(this), propKey, nextProp);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        var node = getNode(this);
	        // If we're updating to null or undefined, we should remove the property
	        // from the DOM node instead of inadvertently setting to a string. This
	        // brings us in line with the same behavior we have on initial render.
	        if (nextProp != null) {
	          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
	        } else {
	          DOMPropertyOperations.deleteValueForProperty(node, propKey);
	        }
	      }
	    }
	    if (styleUpdates) {
	      CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
	    }
	  },
	
	  /**
	   * Reconciles the children with the various properties that affect the
	   * children content.
	   *
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   */
	  _updateDOMChildren: function (lastProps, nextProps, transaction, context) {
	    var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
	    var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;
	
	    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
	    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;
	
	    // Note the use of `!=` which checks for null or undefined.
	    var lastChildren = lastContent != null ? null : lastProps.children;
	    var nextChildren = nextContent != null ? null : nextProps.children;
	
	    // If we're switching from children to content/html or vice versa, remove
	    // the old content
	    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
	    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
	    if (lastChildren != null && nextChildren == null) {
	      this.updateChildren(null, transaction, context);
	    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
	      this.updateTextContent('');
	      if (true) {
	        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
	      }
	    }
	
	    if (nextContent != null) {
	      if (lastContent !== nextContent) {
	        this.updateTextContent('' + nextContent);
	        if (true) {
	          setAndValidateContentChildDev.call(this, nextContent);
	        }
	      }
	    } else if (nextHtml != null) {
	      if (lastHtml !== nextHtml) {
	        this.updateMarkup('' + nextHtml);
	      }
	      if (true) {
	        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
	      }
	    } else if (nextChildren != null) {
	      if (true) {
	        setAndValidateContentChildDev.call(this, null);
	      }
	
	      this.updateChildren(nextChildren, transaction, context);
	    }
	  },
	
	  getHostNode: function () {
	    return getNode(this);
	  },
	
	  /**
	   * Destroys all event registrations for this instance. Does not remove from
	   * the DOM. That must be done by the parent.
	   *
	   * @internal
	   */
	  unmountComponent: function (safely) {
	    switch (this._tag) {
	      case 'audio':
	      case 'form':
	      case 'iframe':
	      case 'img':
	      case 'link':
	      case 'object':
	      case 'source':
	      case 'video':
	        var listeners = this._wrapperState.listeners;
	        if (listeners) {
	          for (var i = 0; i < listeners.length; i++) {
	            listeners[i].remove();
	          }
	        }
	        break;
	      case 'input':
	      case 'textarea':
	        inputValueTracking.stopTracking(this);
	        break;
	      case 'html':
	      case 'head':
	      case 'body':
	        /**
	         * Components like <html> <head> and <body> can't be removed or added
	         * easily in a cross-browser way, however it's valuable to be able to
	         * take advantage of React's reconciliation for styling and <title>
	         * management. So we just document it and throw in dangerous cases.
	         */
	         true ?  true ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is impossible to unmount some top-level components (eg <html>, <head>, and <body>) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.', this._tag) : _prodInvariant('66', this._tag) : void 0;
	        break;
	    }
	
	    this.unmountChildren(safely);
	    ReactDOMComponentTree.uncacheNode(this);
	    EventPluginHub.deleteAllListeners(this);
	    this._rootNodeID = 0;
	    this._domID = 0;
	    this._wrapperState = null;
	
	    if (true) {
	      setAndValidateContentChildDev.call(this, null);
	    }
	  },
	
	  getPublicInstance: function () {
	    return getNode(this);
	  }
	};
	
	_assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);
	
	module.exports = ReactDOMComponent;

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var ReactDOMComponentTree = __webpack_require__(40);
	
	var focusNode = __webpack_require__(101);
	
	var AutoFocusUtils = {
	  focusDOMComponent: function () {
	    focusNode(ReactDOMComponentTree.getNodeFromInstance(this));
	  }
	};
	
	module.exports = AutoFocusUtils;

/***/ }),
/* 101 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	/**
	 * @param {DOMElement} node input/textarea to focus
	 */
	
	function focusNode(node) {
	  // IE8 can throw "Can't move focus to the control because it is invisible,
	  // not enabled, or of a type that does not accept the focus." for all kinds of
	  // reasons that are too expensive and fragile to test.
	  try {
	    node.focus();
	  } catch (e) {}
	}
	
	module.exports = focusNode;

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(103);
	var ExecutionEnvironment = __webpack_require__(54);
	var ReactInstrumentation = __webpack_require__(68);
	
	var camelizeStyleName = __webpack_require__(104);
	var dangerousStyleValue = __webpack_require__(106);
	var hyphenateStyleName = __webpack_require__(107);
	var memoizeStringOnly = __webpack_require__(109);
	var warning = __webpack_require__(8);
	
	var processStyleName = memoizeStringOnly(function (styleName) {
	  return hyphenateStyleName(styleName);
	});
	
	var hasShorthandPropertyBug = false;
	var styleFloatAccessor = 'cssFloat';
	if (ExecutionEnvironment.canUseDOM) {
	  var tempStyle = document.createElement('div').style;
	  try {
	    // IE8 throws "Invalid argument." if resetting shorthand style properties.
	    tempStyle.font = '';
	  } catch (e) {
	    hasShorthandPropertyBug = true;
	  }
	  // IE8 only supports accessing cssFloat (standard) as styleFloat
	  if (document.documentElement.style.cssFloat === undefined) {
	    styleFloatAccessor = 'styleFloat';
	  }
	}
	
	if (true) {
	  // 'msTransform' is correct, but the other prefixes should be capitalized
	  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
	
	  // style values shouldn't contain a semicolon
	  var badStyleValueWithSemicolonPattern = /;\s*$/;
	
	  var warnedStyleNames = {};
	  var warnedStyleValues = {};
	  var warnedForNaNValue = false;
	
	  var warnHyphenatedStyleName = function (name, owner) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	     true ? warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), checkRenderMessage(owner)) : void 0;
	  };
	
	  var warnBadVendoredStyleName = function (name, owner) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	     true ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), checkRenderMessage(owner)) : void 0;
	  };
	
	  var warnStyleValueWithSemicolon = function (name, value, owner) {
	    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
	      return;
	    }
	
	    warnedStyleValues[value] = true;
	     true ? warning(false, "Style property values shouldn't contain a semicolon.%s " + 'Try "%s: %s" instead.', checkRenderMessage(owner), name, value.replace(badStyleValueWithSemicolonPattern, '')) : void 0;
	  };
	
	  var warnStyleValueIsNaN = function (name, value, owner) {
	    if (warnedForNaNValue) {
	      return;
	    }
	
	    warnedForNaNValue = true;
	     true ? warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, checkRenderMessage(owner)) : void 0;
	  };
	
	  var checkRenderMessage = function (owner) {
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' Check the render method of `' + name + '`.';
	      }
	    }
	    return '';
	  };
	
	  /**
	   * @param {string} name
	   * @param {*} value
	   * @param {ReactDOMComponent} component
	   */
	  var warnValidStyle = function (name, value, component) {
	    var owner;
	    if (component) {
	      owner = component._currentElement._owner;
	    }
	    if (name.indexOf('-') > -1) {
	      warnHyphenatedStyleName(name, owner);
	    } else if (badVendoredStyleNamePattern.test(name)) {
	      warnBadVendoredStyleName(name, owner);
	    } else if (badStyleValueWithSemicolonPattern.test(value)) {
	      warnStyleValueWithSemicolon(name, value, owner);
	    }
	
	    if (typeof value === 'number' && isNaN(value)) {
	      warnStyleValueIsNaN(name, value, owner);
	    }
	  };
	}
	
	/**
	 * Operations for dealing with CSS properties.
	 */
	var CSSPropertyOperations = {
	  /**
	   * Serializes a mapping of style properties for use as inline styles:
	   *
	   *   > createMarkupForStyles({width: '200px', height: 0})
	   *   "width:200px;height:0;"
	   *
	   * Undefined values are ignored so that declarative programming is easier.
	   * The result should be HTML-escaped before insertion into the DOM.
	   *
	   * @param {object} styles
	   * @param {ReactDOMComponent} component
	   * @return {?string}
	   */
	  createMarkupForStyles: function (styles, component) {
	    var serialized = '';
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      var isCustomProperty = styleName.indexOf('--') === 0;
	      var styleValue = styles[styleName];
	      if (true) {
	        if (!isCustomProperty) {
	          warnValidStyle(styleName, styleValue, component);
	        }
	      }
	      if (styleValue != null) {
	        serialized += processStyleName(styleName) + ':';
	        serialized += dangerousStyleValue(styleName, styleValue, component, isCustomProperty) + ';';
	      }
	    }
	    return serialized || null;
	  },
	
	  /**
	   * Sets the value for multiple styles on a node.  If a value is specified as
	   * '' (empty string), the corresponding style property will be unset.
	   *
	   * @param {DOMElement} node
	   * @param {object} styles
	   * @param {ReactDOMComponent} component
	   */
	  setValueForStyles: function (node, styles, component) {
	    if (true) {
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: component._debugID,
	        type: 'update styles',
	        payload: styles
	      });
	    }
	
	    var style = node.style;
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      var isCustomProperty = styleName.indexOf('--') === 0;
	      if (true) {
	        if (!isCustomProperty) {
	          warnValidStyle(styleName, styles[styleName], component);
	        }
	      }
	      var styleValue = dangerousStyleValue(styleName, styles[styleName], component, isCustomProperty);
	      if (styleName === 'float' || styleName === 'cssFloat') {
	        styleName = styleFloatAccessor;
	      }
	      if (isCustomProperty) {
	        style.setProperty(styleName, styleValue);
	      } else if (styleValue) {
	        style[styleName] = styleValue;
	      } else {
	        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
	        if (expansion) {
	          // Shorthand property that IE8 won't like unsetting, so unset each
	          // component to placate it
	          for (var individualStyleName in expansion) {
	            style[individualStyleName] = '';
	          }
	        } else {
	          style[styleName] = '';
	        }
	      }
	    }
	  }
	};
	
	module.exports = CSSPropertyOperations;

/***/ }),
/* 103 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	/**
	 * CSS properties which accept numbers but are not in units of "px".
	 */
	
	var isUnitlessNumber = {
	  animationIterationCount: true,
	  borderImageOutset: true,
	  borderImageSlice: true,
	  borderImageWidth: true,
	  boxFlex: true,
	  boxFlexGroup: true,
	  boxOrdinalGroup: true,
	  columnCount: true,
	  columns: true,
	  flex: true,
	  flexGrow: true,
	  flexPositive: true,
	  flexShrink: true,
	  flexNegative: true,
	  flexOrder: true,
	  gridRow: true,
	  gridRowEnd: true,
	  gridRowSpan: true,
	  gridRowStart: true,
	  gridColumn: true,
	  gridColumnEnd: true,
	  gridColumnSpan: true,
	  gridColumnStart: true,
	  fontWeight: true,
	  lineClamp: true,
	  lineHeight: true,
	  opacity: true,
	  order: true,
	  orphans: true,
	  tabSize: true,
	  widows: true,
	  zIndex: true,
	  zoom: true,
	
	  // SVG-related properties
	  fillOpacity: true,
	  floodOpacity: true,
	  stopOpacity: true,
	  strokeDasharray: true,
	  strokeDashoffset: true,
	  strokeMiterlimit: true,
	  strokeOpacity: true,
	  strokeWidth: true
	};
	
	/**
	 * @param {string} prefix vendor-specific prefix, eg: Webkit
	 * @param {string} key style name, eg: transitionDuration
	 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
	 * WebkitTransitionDuration
	 */
	function prefixKey(prefix, key) {
	  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
	}
	
	/**
	 * Support style names that may come passed in prefixed by adding permutations
	 * of vendor prefixes.
	 */
	var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
	
	// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
	// infinite loop, because it iterates over the newly added props too.
	Object.keys(isUnitlessNumber).forEach(function (prop) {
	  prefixes.forEach(function (prefix) {
	    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
	  });
	});
	
	/**
	 * Most style properties can be unset by doing .style[prop] = '' but IE8
	 * doesn't like doing that with shorthand properties so for the properties that
	 * IE8 breaks on, which are listed here, we instead unset each of the
	 * individual properties. See http://bugs.jquery.com/ticket/12385.
	 * The 4-value 'clock' properties like margin, padding, border-width seem to
	 * behave without any problems. Curiously, list-style works too without any
	 * special prodding.
	 */
	var shorthandPropertyExpansions = {
	  background: {
	    backgroundAttachment: true,
	    backgroundColor: true,
	    backgroundImage: true,
	    backgroundPositionX: true,
	    backgroundPositionY: true,
	    backgroundRepeat: true
	  },
	  backgroundPosition: {
	    backgroundPositionX: true,
	    backgroundPositionY: true
	  },
	  border: {
	    borderWidth: true,
	    borderStyle: true,
	    borderColor: true
	  },
	  borderBottom: {
	    borderBottomWidth: true,
	    borderBottomStyle: true,
	    borderBottomColor: true
	  },
	  borderLeft: {
	    borderLeftWidth: true,
	    borderLeftStyle: true,
	    borderLeftColor: true
	  },
	  borderRight: {
	    borderRightWidth: true,
	    borderRightStyle: true,
	    borderRightColor: true
	  },
	  borderTop: {
	    borderTopWidth: true,
	    borderTopStyle: true,
	    borderTopColor: true
	  },
	  font: {
	    fontStyle: true,
	    fontVariant: true,
	    fontWeight: true,
	    fontSize: true,
	    lineHeight: true,
	    fontFamily: true
	  },
	  outline: {
	    outlineWidth: true,
	    outlineStyle: true,
	    outlineColor: true
	  }
	};
	
	var CSSProperty = {
	  isUnitlessNumber: isUnitlessNumber,
	  shorthandPropertyExpansions: shorthandPropertyExpansions
	};
	
	module.exports = CSSProperty;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	var camelize = __webpack_require__(105);
	
	var msPattern = /^-ms-/;
	
	/**
	 * Camelcases a hyphenated CSS property name, for example:
	 *
	 *   > camelizeStyleName('background-color')
	 *   < "backgroundColor"
	 *   > camelizeStyleName('-moz-transition')
	 *   < "MozTransition"
	 *   > camelizeStyleName('-ms-transition')
	 *   < "msTransition"
	 *
	 * As Andi Smith suggests
	 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
	 * is converted to lowercase `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelizeStyleName(string) {
	  return camelize(string.replace(msPattern, 'ms-'));
	}
	
	module.exports = camelizeStyleName;

/***/ }),
/* 105 */
/***/ (function(module, exports) {

	"use strict";
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 */
	
	var _hyphenPattern = /-(.)/g;
	
	/**
	 * Camelcases a hyphenated string, for example:
	 *
	 *   > camelize('background-color')
	 *   < "backgroundColor"
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelize(string) {
	  return string.replace(_hyphenPattern, function (_, character) {
	    return character.toUpperCase();
	  });
	}
	
	module.exports = camelize;

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(103);
	var warning = __webpack_require__(8);
	
	var isUnitlessNumber = CSSProperty.isUnitlessNumber;
	var styleWarnings = {};
	
	/**
	 * Convert a value into the proper css writable value. The style name `name`
	 * should be logical (no hyphens), as specified
	 * in `CSSProperty.isUnitlessNumber`.
	 *
	 * @param {string} name CSS property name such as `topMargin`.
	 * @param {*} value CSS property value such as `10px`.
	 * @param {ReactDOMComponent} component
	 * @return {string} Normalized style value with dimensions applied.
	 */
	function dangerousStyleValue(name, value, component, isCustomProperty) {
	  // Note that we've removed escapeTextForBrowser() calls here since the
	  // whole string will be escaped when the attribute is injected into
	  // the markup. If you provide unsafe user data here they can inject
	  // arbitrary CSS which may be problematic (I couldn't repro this):
	  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
	  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
	  // This is not an XSS hole but instead a potential CSS injection issue
	  // which has lead to a greater discussion about how we're going to
	  // trust URLs moving forward. See #2115901
	
	  var isEmpty = value == null || typeof value === 'boolean' || value === '';
	  if (isEmpty) {
	    return '';
	  }
	
	  var isNonNumeric = isNaN(value);
	  if (isCustomProperty || isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
	    return '' + value; // cast to string
	  }
	
	  if (typeof value === 'string') {
	    if (true) {
	      // Allow '0' to pass through without warning. 0 is already special and
	      // doesn't require units, so we don't need to warn about it.
	      if (component && value !== '0') {
	        var owner = component._currentElement._owner;
	        var ownerName = owner ? owner.getName() : null;
	        if (ownerName && !styleWarnings[ownerName]) {
	          styleWarnings[ownerName] = {};
	        }
	        var warned = false;
	        if (ownerName) {
	          var warnings = styleWarnings[ownerName];
	          warned = warnings[name];
	          if (!warned) {
	            warnings[name] = true;
	          }
	        }
	        if (!warned) {
	           true ? warning(false, 'a `%s` tag (owner: `%s`) was passed a numeric string value ' + 'for CSS property `%s` (value: `%s`) which will be treated ' + 'as a unitless number in a future version of React.', component._currentElement.type, ownerName || 'unknown', name, value) : void 0;
	        }
	      }
	    }
	    value = value.trim();
	  }
	  return value + 'px';
	}
	
	module.exports = dangerousStyleValue;

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	var hyphenate = __webpack_require__(108);
	
	var msPattern = /^ms-/;
	
	/**
	 * Hyphenates a camelcased CSS property name, for example:
	 *
	 *   > hyphenateStyleName('backgroundColor')
	 *   < "background-color"
	 *   > hyphenateStyleName('MozTransition')
	 *   < "-moz-transition"
	 *   > hyphenateStyleName('msTransition')
	 *   < "-ms-transition"
	 *
	 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
	 * is converted to `-ms-`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenateStyleName(string) {
	  return hyphenate(string).replace(msPattern, '-ms-');
	}
	
	module.exports = hyphenateStyleName;

/***/ }),
/* 108 */
/***/ (function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 */
	
	var _uppercasePattern = /([A-Z])/g;
	
	/**
	 * Hyphenates a camelcased string, for example:
	 *
	 *   > hyphenate('backgroundColor')
	 *   < "background-color"
	 *
	 * For CSS style names, use `hyphenateStyleName` instead which works properly
	 * with all vendor prefixes, including `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenate(string) {
	  return string.replace(_uppercasePattern, '-$1').toLowerCase();
	}
	
	module.exports = hyphenate;

/***/ }),
/* 109 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Memoizes the return value of a function that accepts one string argument.
	 */
	
	function memoizeStringOnly(callback) {
	  var cache = {};
	  return function (string) {
	    if (!cache.hasOwnProperty(string)) {
	      cache[string] = callback.call(this, string);
	    }
	    return cache[string];
	  };
	}
	
	module.exports = memoizeStringOnly;

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(42);
	var ReactDOMComponentTree = __webpack_require__(40);
	var ReactInstrumentation = __webpack_require__(68);
	
	var quoteAttributeValueForBrowser = __webpack_require__(111);
	var warning = __webpack_require__(8);
	
	var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + DOMProperty.ATTRIBUTE_NAME_START_CHAR + '][' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
	var illegalAttributeNameCache = {};
	var validatedAttributeNameCache = {};
	
	function isAttributeNameSafe(attributeName) {
	  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
	    return true;
	  }
	  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
	    return false;
	  }
	  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
	    validatedAttributeNameCache[attributeName] = true;
	    return true;
	  }
	  illegalAttributeNameCache[attributeName] = true;
	   true ? warning(false, 'Invalid attribute name: `%s`', attributeName) : void 0;
	  return false;
	}
	
	function shouldIgnoreValue(propertyInfo, value) {
	  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
	}
	
	/**
	 * Operations for dealing with DOM properties.
	 */
	var DOMPropertyOperations = {
	  /**
	   * Creates markup for the ID property.
	   *
	   * @param {string} id Unescaped ID.
	   * @return {string} Markup string.
	   */
	  createMarkupForID: function (id) {
	    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
	  },
	
	  setAttributeForID: function (node, id) {
	    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
	  },
	
	  createMarkupForRoot: function () {
	    return DOMProperty.ROOT_ATTRIBUTE_NAME + '=""';
	  },
	
	  setAttributeForRoot: function (node) {
	    node.setAttribute(DOMProperty.ROOT_ATTRIBUTE_NAME, '');
	  },
	
	  /**
	   * Creates markup for a property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {?string} Markup string, or null if the property was invalid.
	   */
	  createMarkupForProperty: function (name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      if (shouldIgnoreValue(propertyInfo, value)) {
	        return '';
	      }
	      var attributeName = propertyInfo.attributeName;
	      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	        return attributeName + '=""';
	      }
	      return attributeName + '=' + quoteAttributeValueForBrowser(value);
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      if (value == null) {
	        return '';
	      }
	      return name + '=' + quoteAttributeValueForBrowser(value);
	    }
	    return null;
	  },
	
	  /**
	   * Creates markup for a custom property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {string} Markup string, or empty string if the property was invalid.
	   */
	  createMarkupForCustomAttribute: function (name, value) {
	    if (!isAttributeNameSafe(name) || value == null) {
	      return '';
	    }
	    return name + '=' + quoteAttributeValueForBrowser(value);
	  },
	
	  /**
	   * Sets the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   * @param {*} value
	   */
	  setValueForProperty: function (node, name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, value);
	      } else if (shouldIgnoreValue(propertyInfo, value)) {
	        this.deleteValueForProperty(node, name);
	        return;
	      } else if (propertyInfo.mustUseProperty) {
	        // Contrary to `setAttribute`, object properties are properly
	        // `toString`ed by IE8/9.
	        node[propertyInfo.propertyName] = value;
	      } else {
	        var attributeName = propertyInfo.attributeName;
	        var namespace = propertyInfo.attributeNamespace;
	        // `setAttribute` with objects becomes only `[object]` in IE8/9,
	        // ('' + value) makes it output the correct toString()-value.
	        if (namespace) {
	          node.setAttributeNS(namespace, attributeName, '' + value);
	        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	          node.setAttribute(attributeName, '');
	        } else {
	          node.setAttribute(attributeName, '' + value);
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      DOMPropertyOperations.setValueForAttribute(node, name, value);
	      return;
	    }
	
	    if (true) {
	      var payload = {};
	      payload[name] = value;
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
	        type: 'update attribute',
	        payload: payload
	      });
	    }
	  },
	
	  setValueForAttribute: function (node, name, value) {
	    if (!isAttributeNameSafe(name)) {
	      return;
	    }
	    if (value == null) {
	      node.removeAttribute(name);
	    } else {
	      node.setAttribute(name, '' + value);
	    }
	
	    if (true) {
	      var payload = {};
	      payload[name] = value;
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
	        type: 'update attribute',
	        payload: payload
	      });
	    }
	  },
	
	  /**
	   * Deletes an attributes from a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForAttribute: function (node, name) {
	    node.removeAttribute(name);
	    if (true) {
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
	        type: 'remove attribute',
	        payload: name
	      });
	    }
	  },
	
	  /**
	   * Deletes the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForProperty: function (node, name) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, undefined);
	      } else if (propertyInfo.mustUseProperty) {
	        var propName = propertyInfo.propertyName;
	        if (propertyInfo.hasBooleanValue) {
	          node[propName] = false;
	        } else {
	          node[propName] = '';
	        }
	      } else {
	        node.removeAttribute(propertyInfo.attributeName);
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      node.removeAttribute(name);
	    }
	
	    if (true) {
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
	        type: 'remove attribute',
	        payload: name
	      });
	    }
	  }
	};
	
	module.exports = DOMPropertyOperations;

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var escapeTextContentForBrowser = __webpack_require__(93);
	
	/**
	 * Escapes attribute value to prevent scripting attacks.
	 *
	 * @param {*} value Value to escape.
	 * @return {string} An escaped string.
	 */
	function quoteAttributeValueForBrowser(value) {
	  return '"' + escapeTextContentForBrowser(value) + '"';
	}
	
	module.exports = quoteAttributeValueForBrowser;

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var EventPluginRegistry = __webpack_require__(49);
	var ReactEventEmitterMixin = __webpack_require__(113);
	var ViewportMetrics = __webpack_require__(83);
	
	var getVendorPrefixedEventName = __webpack_require__(114);
	var isEventSupported = __webpack_require__(77);
	
	/**
	 * Summary of `ReactBrowserEventEmitter` event handling:
	 *
	 *  - Top-level delegation is used to trap most native browser events. This
	 *    may only occur in the main thread and is the responsibility of
	 *    ReactEventListener, which is injected and can therefore support pluggable
	 *    event sources. This is the only work that occurs in the main thread.
	 *
	 *  - We normalize and de-duplicate events to account for browser quirks. This
	 *    may be done in the worker thread.
	 *
	 *  - Forward these native events (with the associated top-level type used to
	 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
	 *    to extract any synthetic events.
	 *
	 *  - The `EventPluginHub` will then process each event by annotating them with
	 *    "dispatches", a sequence of listeners and IDs that care about that event.
	 *
	 *  - The `EventPluginHub` then dispatches the events.
	 *
	 * Overview of React and the event system:
	 *
	 * +------------+    .
	 * |    DOM     |    .
	 * +------------+    .
	 *       |           .
	 *       v           .
	 * +------------+    .
	 * | ReactEvent |    .
	 * |  Listener  |    .
	 * +------------+    .                         +-----------+
	 *       |           .               +--------+|SimpleEvent|
	 *       |           .               |         |Plugin     |
	 * +-----|------+    .               v         +-----------+
	 * |     |      |    .    +--------------+                    +------------+
	 * |     +-----------.--->|EventPluginHub|                    |    Event   |
	 * |            |    .    |              |     +-----------+  | Propagators|
	 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
	 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
	 * |            |    .    |              |     +-----------+  |  utilities |
	 * |     +-----------.--->|              |                    +------------+
	 * |     |      |    .    +--------------+
	 * +-----|------+    .                ^        +-----------+
	 *       |           .                |        |Enter/Leave|
	 *       +           .                +-------+|Plugin     |
	 * +-------------+   .                         +-----------+
	 * | application |   .
	 * |-------------|   .
	 * |             |   .
	 * |             |   .
	 * +-------------+   .
	 *                   .
	 *    React Core     .  General Purpose Event Plugin System
	 */
	
	var hasEventPageXY;
	var alreadyListeningTo = {};
	var isMonitoringScrollValue = false;
	var reactTopListenersCounter = 0;
	
	// For events like 'submit' which don't consistently bubble (which we trap at a
	// lower node than `document`), binding at `document` would cause duplicate
	// events so we don't include them here
	var topEventMapping = {
	  topAbort: 'abort',
	  topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
	  topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
	  topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
	  topBlur: 'blur',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topChange: 'change',
	  topClick: 'click',
	  topCompositionEnd: 'compositionend',
	  topCompositionStart: 'compositionstart',
	  topCompositionUpdate: 'compositionupdate',
	  topContextMenu: 'contextmenu',
	  topCopy: 'copy',
	  topCut: 'cut',
	  topDoubleClick: 'dblclick',
	  topDrag: 'drag',
	  topDragEnd: 'dragend',
	  topDragEnter: 'dragenter',
	  topDragExit: 'dragexit',
	  topDragLeave: 'dragleave',
	  topDragOver: 'dragover',
	  topDragStart: 'dragstart',
	  topDrop: 'drop',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topFocus: 'focus',
	  topInput: 'input',
	  topKeyDown: 'keydown',
	  topKeyPress: 'keypress',
	  topKeyUp: 'keyup',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topMouseDown: 'mousedown',
	  topMouseMove: 'mousemove',
	  topMouseOut: 'mouseout',
	  topMouseOver: 'mouseover',
	  topMouseUp: 'mouseup',
	  topPaste: 'paste',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topScroll: 'scroll',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topSelectionChange: 'selectionchange',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTextInput: 'textInput',
	  topTimeUpdate: 'timeupdate',
	  topTouchCancel: 'touchcancel',
	  topTouchEnd: 'touchend',
	  topTouchMove: 'touchmove',
	  topTouchStart: 'touchstart',
	  topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting',
	  topWheel: 'wheel'
	};
	
	/**
	 * To ensure no conflicts with other potential React instances on the page
	 */
	var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);
	
	function getListeningForDocument(mountAt) {
	  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
	  // directly.
	  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
	    mountAt[topListenersIDKey] = reactTopListenersCounter++;
	    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
	  }
	  return alreadyListeningTo[mountAt[topListenersIDKey]];
	}
	
	/**
	 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
	 * example:
	 *
	 *   EventPluginHub.putListener('myID', 'onClick', myFunction);
	 *
	 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
	 *
	 * @internal
	 */
	var ReactBrowserEventEmitter = _assign({}, ReactEventEmitterMixin, {
	  /**
	   * Injectable event backend
	   */
	  ReactEventListener: null,
	
	  injection: {
	    /**
	     * @param {object} ReactEventListener
	     */
	    injectReactEventListener: function (ReactEventListener) {
	      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
	      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
	    }
	  },
	
	  /**
	   * Sets whether or not any created callbacks should be enabled.
	   *
	   * @param {boolean} enabled True if callbacks should be enabled.
	   */
	  setEnabled: function (enabled) {
	    if (ReactBrowserEventEmitter.ReactEventListener) {
	      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
	    }
	  },
	
	  /**
	   * @return {boolean} True if callbacks are enabled.
	   */
	  isEnabled: function () {
	    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
	  },
	
	  /**
	   * We listen for bubbled touch events on the document object.
	   *
	   * Firefox v8.01 (and possibly others) exhibited strange behavior when
	   * mounting `onmousemove` events at some node that was not the document
	   * element. The symptoms were that if your mouse is not moving over something
	   * contained within that mount point (for example on the background) the
	   * top-level listeners for `onmousemove` won't be called. However, if you
	   * register the `mousemove` on the document object, then it will of course
	   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
	   * top-level listeners to the document object only, at least for these
	   * movement types of events and possibly all events.
	   *
	   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	   *
	   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
	   * they bubble to document.
	   *
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {object} contentDocumentHandle Document which owns the container
	   */
	  listenTo: function (registrationName, contentDocumentHandle) {
	    var mountAt = contentDocumentHandle;
	    var isListening = getListeningForDocument(mountAt);
	    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];
	
	    for (var i = 0; i < dependencies.length; i++) {
	      var dependency = dependencies[i];
	      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
	        if (dependency === 'topWheel') {
	          if (isEventSupported('wheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'wheel', mountAt);
	          } else if (isEventSupported('mousewheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'mousewheel', mountAt);
	          } else {
	            // Firefox needs to capture a different mouse scroll event.
	            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'DOMMouseScroll', mountAt);
	          }
	        } else if (dependency === 'topScroll') {
	          if (isEventSupported('scroll', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topScroll', 'scroll', mountAt);
	          } else {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topScroll', 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
	          }
	        } else if (dependency === 'topFocus' || dependency === 'topBlur') {
	          if (isEventSupported('focus', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topFocus', 'focus', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topBlur', 'blur', mountAt);
	          } else if (isEventSupported('focusin')) {
	            // IE has `focusin` and `focusout` events which bubble.
	            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topFocus', 'focusin', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topBlur', 'focusout', mountAt);
	          }
	
	          // to make sure blur and focus event listeners are only attached once
	          isListening.topBlur = true;
	          isListening.topFocus = true;
	        } else if (topEventMapping.hasOwnProperty(dependency)) {
	          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
	        }
	
	        isListening[dependency] = true;
	      }
	    }
	  },
	
	  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  /**
	   * Protect against document.createEvent() returning null
	   * Some popup blocker extensions appear to do this:
	   * https://github.com/facebook/react/issues/6887
	   */
	  supportsEventPageXY: function () {
	    if (!document.createEvent) {
	      return false;
	    }
	    var ev = document.createEvent('MouseEvent');
	    return ev != null && 'pageX' in ev;
	  },
	
	  /**
	   * Listens to window scroll and resize events. We cache scroll values so that
	   * application code can access them without triggering reflows.
	   *
	   * ViewportMetrics is only used by SyntheticMouse/TouchEvent and only when
	   * pageX/pageY isn't supported (legacy browsers).
	   *
	   * NOTE: Scroll events do not bubble.
	   *
	   * @see http://www.quirksmode.org/dom/events/scroll.html
	   */
	  ensureScrollValueMonitoring: function () {
	    if (hasEventPageXY === undefined) {
	      hasEventPageXY = ReactBrowserEventEmitter.supportsEventPageXY();
	    }
	    if (!hasEventPageXY && !isMonitoringScrollValue) {
	      var refresh = ViewportMetrics.refreshScrollValues;
	      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
	      isMonitoringScrollValue = true;
	    }
	  }
	});
	
	module.exports = ReactBrowserEventEmitter;

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var EventPluginHub = __webpack_require__(48);
	
	function runEventQueueInBatch(events) {
	  EventPluginHub.enqueueEvents(events);
	  EventPluginHub.processEventQueue(false);
	}
	
	var ReactEventEmitterMixin = {
	  /**
	   * Streams a fired top-level event to `EventPluginHub` where plugins have the
	   * opportunity to create `ReactEvent`s to be dispatched.
	   */
	  handleTopLevel: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
	    runEventQueueInBatch(events);
	  }
	};
	
	module.exports = ReactEventEmitterMixin;

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(54);
	
	/**
	 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
	 *
	 * @param {string} styleProp
	 * @param {string} eventName
	 * @returns {object}
	 */
	function makePrefixMap(styleProp, eventName) {
	  var prefixes = {};
	
	  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
	  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
	  prefixes['Moz' + styleProp] = 'moz' + eventName;
	  prefixes['ms' + styleProp] = 'MS' + eventName;
	  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();
	
	  return prefixes;
	}
	
	/**
	 * A list of event names to a configurable list of vendor prefixes.
	 */
	var vendorPrefixes = {
	  animationend: makePrefixMap('Animation', 'AnimationEnd'),
	  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
	  animationstart: makePrefixMap('Animation', 'AnimationStart'),
	  transitionend: makePrefixMap('Transition', 'TransitionEnd')
	};
	
	/**
	 * Event names that have already been detected and prefixed (if applicable).
	 */
	var prefixedEventNames = {};
	
	/**
	 * Element to check for prefixes on.
	 */
	var style = {};
	
	/**
	 * Bootstrap if a DOM exists.
	 */
	if (ExecutionEnvironment.canUseDOM) {
	  style = document.createElement('div').style;
	
	  // On some platforms, in particular some releases of Android 4.x,
	  // the un-prefixed "animation" and "transition" properties are defined on the
	  // style object but the events that fire will still be prefixed, so we need
	  // to check if the un-prefixed events are usable, and if not remove them from the map.
	  if (!('AnimationEvent' in window)) {
	    delete vendorPrefixes.animationend.animation;
	    delete vendorPrefixes.animationiteration.animation;
	    delete vendorPrefixes.animationstart.animation;
	  }
	
	  // Same as above
	  if (!('TransitionEvent' in window)) {
	    delete vendorPrefixes.transitionend.transition;
	  }
	}
	
	/**
	 * Attempts to determine the correct vendor prefixed event name.
	 *
	 * @param {string} eventName
	 * @returns {string}
	 */
	function getVendorPrefixedEventName(eventName) {
	  if (prefixedEventNames[eventName]) {
	    return prefixedEventNames[eventName];
	  } else if (!vendorPrefixes[eventName]) {
	    return eventName;
	  }
	
	  var prefixMap = vendorPrefixes[eventName];
	
	  for (var styleProp in prefixMap) {
	    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
	      return prefixedEventNames[eventName] = prefixMap[styleProp];
	    }
	  }
	
	  return '';
	}
	
	module.exports = getVendorPrefixedEventName;

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(41),
	    _assign = __webpack_require__(4);
	
	var DOMPropertyOperations = __webpack_require__(110);
	var LinkedValueUtils = __webpack_require__(116);
	var ReactDOMComponentTree = __webpack_require__(40);
	var ReactUpdates = __webpack_require__(62);
	
	var invariant = __webpack_require__(12);
	var warning = __webpack_require__(8);
	
	var didWarnValueLink = false;
	var didWarnCheckedLink = false;
	var didWarnValueDefaultValue = false;
	var didWarnCheckedDefaultChecked = false;
	var didWarnControlledToUncontrolled = false;
	var didWarnUncontrolledToControlled = false;
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMInput.updateWrapper(this);
	  }
	}
	
	function isControlled(props) {
	  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
	  return usesChecked ? props.checked != null : props.value != null;
	}
	
	/**
	 * Implements an <input> host component that allows setting these optional
	 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
	 *
	 * If `checked` or `value` are not supplied (or null/undefined), user actions
	 * that affect the checked state or value will trigger updates to the element.
	 *
	 * If they are supplied (and not null/undefined), the rendered element will not
	 * trigger updates to the element. Instead, the props must change in order for
	 * the rendered element to be updated.
	 *
	 * The rendered element will be initialized as unchecked (or `defaultChecked`)
	 * with an empty value (or `defaultValue`).
	 *
	 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
	 */
	var ReactDOMInput = {
	  getHostProps: function (inst, props) {
	    var value = LinkedValueUtils.getValue(props);
	    var checked = LinkedValueUtils.getChecked(props);
	
	    var hostProps = _assign({
	      // Make sure we set .type before any other properties (setting .value
	      // before .type means .value is lost in IE11 and below)
	      type: undefined,
	      // Make sure we set .step before .value (setting .value before .step
	      // means .value is rounded on mount, based upon step precision)
	      step: undefined,
	      // Make sure we set .min & .max before .value (to ensure proper order
	      // in corner cases such as min or max deriving from value, e.g. Issue #7170)
	      min: undefined,
	      max: undefined
	    }, props, {
	      defaultChecked: undefined,
	      defaultValue: undefined,
	      value: value != null ? value : inst._wrapperState.initialValue,
	      checked: checked != null ? checked : inst._wrapperState.initialChecked,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return hostProps;
	  },
	
	  mountWrapper: function (inst, props) {
	    if (true) {
	      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);
	
	      var owner = inst._currentElement._owner;
	
	      if (props.valueLink !== undefined && !didWarnValueLink) {
	         true ? warning(false, '`valueLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnValueLink = true;
	      }
	      if (props.checkedLink !== undefined && !didWarnCheckedLink) {
	         true ? warning(false, '`checkedLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnCheckedLink = true;
	      }
	      if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
	         true ? warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnCheckedDefaultChecked = true;
	      }
	      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
	         true ? warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnValueDefaultValue = true;
	      }
	    }
	
	    var defaultValue = props.defaultValue;
	    inst._wrapperState = {
	      initialChecked: props.checked != null ? props.checked : props.defaultChecked,
	      initialValue: props.value != null ? props.value : defaultValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst),
	      controlled: isControlled(props)
	    };
	  },
	
	  updateWrapper: function (inst) {
	    var props = inst._currentElement.props;
	
	    if (true) {
	      var controlled = isControlled(props);
	      var owner = inst._currentElement._owner;
	
	      if (!inst._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
	         true ? warning(false, '%s is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnUncontrolledToControlled = true;
	      }
	      if (inst._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
	         true ? warning(false, '%s is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnControlledToUncontrolled = true;
	      }
	    }
	
	    // TODO: Shouldn't this be getChecked(props)?
	    var checked = props.checked;
	    if (checked != null) {
	      DOMPropertyOperations.setValueForProperty(ReactDOMComponentTree.getNodeFromInstance(inst), 'checked', checked || false);
	    }
	
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      if (value === 0 && node.value === '') {
	        node.value = '0';
	        // Note: IE9 reports a number inputs as 'text', so check props instead.
	      } else if (props.type === 'number') {
	        // Simulate `input.valueAsNumber`. IE9 does not support it
	        var valueAsNumber = parseFloat(node.value, 10) || 0;
	
	        if (
	        // eslint-disable-next-line
	        value != valueAsNumber ||
	        // eslint-disable-next-line
	        value == valueAsNumber && node.value != value) {
	          // Cast `value` to a string to ensure the value is set correctly. While
	          // browsers typically do this as necessary, jsdom doesn't.
	          node.value = '' + value;
	        }
	      } else if (node.value !== '' + value) {
	        // Cast `value` to a string to ensure the value is set correctly. While
	        // browsers typically do this as necessary, jsdom doesn't.
	        node.value = '' + value;
	      }
	    } else {
	      if (props.value == null && props.defaultValue != null) {
	        // In Chrome, assigning defaultValue to certain input types triggers input validation.
	        // For number inputs, the display value loses trailing decimal points. For email inputs,
	        // Chrome raises "The specified value <x> is not a valid email address".
	        //
	        // Here we check to see if the defaultValue has actually changed, avoiding these problems
	        // when the user is inputting text
	        //
	        // https://github.com/facebook/react/issues/7253
	        if (node.defaultValue !== '' + props.defaultValue) {
	          node.defaultValue = '' + props.defaultValue;
	        }
	      }
	      if (props.checked == null && props.defaultChecked != null) {
	        node.defaultChecked = !!props.defaultChecked;
	      }
	    }
	  },
	
	  postMountWrapper: function (inst) {
	    var props = inst._currentElement.props;
	
	    // This is in postMount because we need access to the DOM node, which is not
	    // available until after the component has mounted.
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	
	    // Detach value from defaultValue. We won't do anything if we're working on
	    // submit or reset inputs as those values & defaultValues are linked. They
	    // are not resetable nodes so this operation doesn't matter and actually
	    // removes browser-default values (eg "Submit Query") when no value is
	    // provided.
	
	    switch (props.type) {
	      case 'submit':
	      case 'reset':
	        break;
	      case 'color':
	      case 'date':
	      case 'datetime':
	      case 'datetime-local':
	      case 'month':
	      case 'time':
	      case 'week':
	        // This fixes the no-show issue on iOS Safari and Android Chrome:
	        // https://github.com/facebook/react/issues/7233
	        node.value = '';
	        node.value = node.defaultValue;
	        break;
	      default:
	        node.value = node.value;
	        break;
	    }
	
	    // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
	    // this is needed to work around a chrome bug where setting defaultChecked
	    // will sometimes influence the value of checked (even after detachment).
	    // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
	    // We need to temporarily unset name to avoid disrupting radio button groups.
	    var name = node.name;
	    if (name !== '') {
	      node.name = '';
	    }
	    node.defaultChecked = !node.defaultChecked;
	    node.defaultChecked = !node.defaultChecked;
	    if (name !== '') {
	      node.name = name;
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  // Here we use asap to wait until all updates have propagated, which
	  // is important when using controlled components within layers:
	  // https://github.com/facebook/react/issues/1698
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	
	  var name = props.name;
	  if (props.type === 'radio' && name != null) {
	    var rootNode = ReactDOMComponentTree.getNodeFromInstance(this);
	    var queryRoot = rootNode;
	
	    while (queryRoot.parentNode) {
	      queryRoot = queryRoot.parentNode;
	    }
	
	    // If `rootNode.form` was non-null, then we could try `form.elements`,
	    // but that sometimes behaves strangely in IE8. We could also try using
	    // `form.getElementsByName`, but that will only return direct children
	    // and won't include inputs that use the HTML5 `form=` attribute. Since
	    // the input might not even be in a form, let's just use the global
	    // `querySelectorAll` to ensure we don't miss anything.
	    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');
	
	    for (var i = 0; i < group.length; i++) {
	      var otherNode = group[i];
	      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
	        continue;
	      }
	      // This will throw if radio buttons rendered by different copies of React
	      // and the same name are rendered into the same form (same as #1939).
	      // That's probably okay; we don't support it just as we don't support
	      // mixing React radio buttons with non-React ones.
	      var otherInstance = ReactDOMComponentTree.getInstanceFromNode(otherNode);
	      !otherInstance ?  true ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : _prodInvariant('90') : void 0;
	      // If this is a controlled radio button group, forcing the input that
	      // was previously checked to update will cause it to be come re-checked
	      // as appropriate.
	      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
	    }
	  }
	
	  return returnValue;
	}
	
	module.exports = ReactDOMInput;

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(41);
	
	var ReactPropTypesSecret = __webpack_require__(117);
	var propTypesFactory = __webpack_require__(30);
	
	var React = __webpack_require__(3);
	var PropTypes = propTypesFactory(React.isValidElement);
	
	var invariant = __webpack_require__(12);
	var warning = __webpack_require__(8);
	
	var hasReadOnlyValue = {
	  button: true,
	  checkbox: true,
	  image: true,
	  hidden: true,
	  radio: true,
	  reset: true,
	  submit: true
	};
	
	function _assertSingleLink(inputProps) {
	  !(inputProps.checkedLink == null || inputProps.valueLink == null) ?  true ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use checkedLink, you probably don\'t want to use valueLink and vice versa.') : _prodInvariant('87') : void 0;
	}
	function _assertValueLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.value == null && inputProps.onChange == null) ?  true ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want to use value or onChange, you probably don\'t want to use valueLink.') : _prodInvariant('88') : void 0;
	}
	
	function _assertCheckedLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.checked == null && inputProps.onChange == null) ?  true ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. If you want to use checked or onChange, you probably don\'t want to use checkedLink') : _prodInvariant('89') : void 0;
	}
	
	var propTypes = {
	  value: function (props, propName, componentName) {
	    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  checked: function (props, propName, componentName) {
	    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  onChange: PropTypes.func
	};
	
	var loggedTypeFailures = {};
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Provide a linked `value` attribute for controlled forms. You should not use
	 * this outside of the ReactDOM controlled form components.
	 */
	var LinkedValueUtils = {
	  checkPropTypes: function (tagName, props, owner) {
	    for (var propName in propTypes) {
	      if (propTypes.hasOwnProperty(propName)) {
	        var error = propTypes[propName](props, propName, tagName, 'prop', null, ReactPropTypesSecret);
	      }
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var addendum = getDeclarationErrorAddendum(owner);
	         true ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : void 0;
	      }
	    }
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current value of the input either from value prop or link.
	   */
	  getValue: function (inputProps) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.value;
	    }
	    return inputProps.value;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current checked status of the input either from checked prop
	   *             or link.
	   */
	  getChecked: function (inputProps) {
	    if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.value;
	    }
	    return inputProps.checked;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @param {SyntheticEvent} event change event to handle
	   */
	  executeOnChange: function (inputProps, event) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.requestChange(event.target.value);
	    } else if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.requestChange(event.target.checked);
	    } else if (inputProps.onChange) {
	      return inputProps.onChange.call(undefined, event);
	    }
	  }
	};
	
	module.exports = LinkedValueUtils;

/***/ }),
/* 117 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	'use strict';
	
	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
	
	module.exports = ReactPropTypesSecret;

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var React = __webpack_require__(3);
	var ReactDOMComponentTree = __webpack_require__(40);
	var ReactDOMSelect = __webpack_require__(119);
	
	var warning = __webpack_require__(8);
	var didWarnInvalidOptionChildren = false;
	
	function flattenChildren(children) {
	  var content = '';
	
	  // Flatten children and warn if they aren't strings or numbers;
	  // invalid types are ignored.
	  React.Children.forEach(children, function (child) {
	    if (child == null) {
	      return;
	    }
	    if (typeof child === 'string' || typeof child === 'number') {
	      content += child;
	    } else if (!didWarnInvalidOptionChildren) {
	      didWarnInvalidOptionChildren = true;
	       true ? warning(false, 'Only strings and numbers are supported as <option> children.') : void 0;
	    }
	  });
	
	  return content;
	}
	
	/**
	 * Implements an <option> host component that warns when `selected` is set.
	 */
	var ReactDOMOption = {
	  mountWrapper: function (inst, props, hostParent) {
	    // TODO (yungsters): Remove support for `selected` in <option>.
	    if (true) {
	       true ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : void 0;
	    }
	
	    // Look up whether this option is 'selected'
	    var selectValue = null;
	    if (hostParent != null) {
	      var selectParent = hostParent;
	
	      if (selectParent._tag === 'optgroup') {
	        selectParent = selectParent._hostParent;
	      }
	
	      if (selectParent != null && selectParent._tag === 'select') {
	        selectValue = ReactDOMSelect.getSelectValueContext(selectParent);
	      }
	    }
	
	    // If the value is null (e.g., no specified value or after initial mount)
	    // or missing (e.g., for <datalist>), we don't change props.selected
	    var selected = null;
	    if (selectValue != null) {
	      var value;
	      if (props.value != null) {
	        value = props.value + '';
	      } else {
	        value = flattenChildren(props.children);
	      }
	      selected = false;
	      if (Array.isArray(selectValue)) {
	        // multiple
	        for (var i = 0; i < selectValue.length; i++) {
	          if ('' + selectValue[i] === value) {
	            selected = true;
	            break;
	          }
	        }
	      } else {
	        selected = '' + selectValue === value;
	      }
	    }
	
	    inst._wrapperState = { selected: selected };
	  },
	
	  postMountWrapper: function (inst) {
	    // value="" should make a value attribute (#6219)
	    var props = inst._currentElement.props;
	    if (props.value != null) {
	      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	      node.setAttribute('value', props.value);
	    }
	  },
	
	  getHostProps: function (inst, props) {
	    var hostProps = _assign({ selected: undefined, children: undefined }, props);
	
	    // Read state only from initial mount because <select> updates value
	    // manually; we need the initial state only for server rendering
	    if (inst._wrapperState.selected != null) {
	      hostProps.selected = inst._wrapperState.selected;
	    }
	
	    var content = flattenChildren(props.children);
	
	    if (content) {
	      hostProps.children = content;
	    }
	
	    return hostProps;
	  }
	};
	
	module.exports = ReactDOMOption;

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var LinkedValueUtils = __webpack_require__(116);
	var ReactDOMComponentTree = __webpack_require__(40);
	var ReactUpdates = __webpack_require__(62);
	
	var warning = __webpack_require__(8);
	
	var didWarnValueLink = false;
	var didWarnValueDefaultValue = false;
	
	function updateOptionsIfPendingUpdateAndMounted() {
	  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
	    this._wrapperState.pendingUpdate = false;
	
	    var props = this._currentElement.props;
	    var value = LinkedValueUtils.getValue(props);
	
	    if (value != null) {
	      updateOptions(this, Boolean(props.multiple), value);
	    }
	  }
	}
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	var valuePropNames = ['value', 'defaultValue'];
	
	/**
	 * Validation function for `value` and `defaultValue`.
	 * @private
	 */
	function checkSelectPropTypes(inst, props) {
	  var owner = inst._currentElement._owner;
	  LinkedValueUtils.checkPropTypes('select', props, owner);
	
	  if (props.valueLink !== undefined && !didWarnValueLink) {
	     true ? warning(false, '`valueLink` prop on `select` is deprecated; set `value` and `onChange` instead.') : void 0;
	    didWarnValueLink = true;
	  }
	
	  for (var i = 0; i < valuePropNames.length; i++) {
	    var propName = valuePropNames[i];
	    if (props[propName] == null) {
	      continue;
	    }
	    var isArray = Array.isArray(props[propName]);
	    if (props.multiple && !isArray) {
	       true ? warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
	    } else if (!props.multiple && isArray) {
	       true ? warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
	    }
	  }
	}
	
	/**
	 * @param {ReactDOMComponent} inst
	 * @param {boolean} multiple
	 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
	 * @private
	 */
	function updateOptions(inst, multiple, propValue) {
	  var selectedValue, i;
	  var options = ReactDOMComponentTree.getNodeFromInstance(inst).options;
	
	  if (multiple) {
	    selectedValue = {};
	    for (i = 0; i < propValue.length; i++) {
	      selectedValue['' + propValue[i]] = true;
	    }
	    for (i = 0; i < options.length; i++) {
	      var selected = selectedValue.hasOwnProperty(options[i].value);
	      if (options[i].selected !== selected) {
	        options[i].selected = selected;
	      }
	    }
	  } else {
	    // Do not set `select.value` as exact behavior isn't consistent across all
	    // browsers for all cases.
	    selectedValue = '' + propValue;
	    for (i = 0; i < options.length; i++) {
	      if (options[i].value === selectedValue) {
	        options[i].selected = true;
	        return;
	      }
	    }
	    if (options.length) {
	      options[0].selected = true;
	    }
	  }
	}
	
	/**
	 * Implements a <select> host component that allows optionally setting the
	 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
	 * stringable. If `multiple` is true, the prop must be an array of stringables.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that change the
	 * selected option will trigger updates to the rendered options.
	 *
	 * If it is supplied (and not null/undefined), the rendered options will not
	 * update in response to user actions. Instead, the `value` prop must change in
	 * order for the rendered options to update.
	 *
	 * If `defaultValue` is provided, any options with the supplied values will be
	 * selected.
	 */
	var ReactDOMSelect = {
	  getHostProps: function (inst, props) {
	    return _assign({}, props, {
	      onChange: inst._wrapperState.onChange,
	      value: undefined
	    });
	  },
	
	  mountWrapper: function (inst, props) {
	    if (true) {
	      checkSelectPropTypes(inst, props);
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    inst._wrapperState = {
	      pendingUpdate: false,
	      initialValue: value != null ? value : props.defaultValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst),
	      wasMultiple: Boolean(props.multiple)
	    };
	
	    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
	       true ? warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
	      didWarnValueDefaultValue = true;
	    }
	  },
	
	  getSelectValueContext: function (inst) {
	    // ReactDOMOption looks at this initial value so the initial generated
	    // markup has correct `selected` attributes
	    return inst._wrapperState.initialValue;
	  },
	
	  postUpdateWrapper: function (inst) {
	    var props = inst._currentElement.props;
	
	    // After the initial mount, we control selected-ness manually so don't pass
	    // this value down
	    inst._wrapperState.initialValue = undefined;
	
	    var wasMultiple = inst._wrapperState.wasMultiple;
	    inst._wrapperState.wasMultiple = Boolean(props.multiple);
	
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      inst._wrapperState.pendingUpdate = false;
	      updateOptions(inst, Boolean(props.multiple), value);
	    } else if (wasMultiple !== Boolean(props.multiple)) {
	      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
	      if (props.defaultValue != null) {
	        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
	      } else {
	        // Revert the select back to its default unselected state.
	        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
	      }
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  if (this._rootNodeID) {
	    this._wrapperState.pendingUpdate = true;
	  }
	  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMSelect;

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(41),
	    _assign = __webpack_require__(4);
	
	var LinkedValueUtils = __webpack_require__(116);
	var ReactDOMComponentTree = __webpack_require__(40);
	var ReactUpdates = __webpack_require__(62);
	
	var invariant = __webpack_require__(12);
	var warning = __webpack_require__(8);
	
	var didWarnValueLink = false;
	var didWarnValDefaultVal = false;
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMTextarea.updateWrapper(this);
	  }
	}
	
	/**
	 * Implements a <textarea> host component that allows setting `value`, and
	 * `defaultValue`. This differs from the traditional DOM API because value is
	 * usually set as PCDATA children.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that affect the
	 * value will trigger updates to the element.
	 *
	 * If `value` is supplied (and not null/undefined), the rendered element will
	 * not trigger updates to the element. Instead, the `value` prop must change in
	 * order for the rendered element to be updated.
	 *
	 * The rendered element will be initialized with an empty value, the prop
	 * `defaultValue` if specified, or the children content (deprecated).
	 */
	var ReactDOMTextarea = {
	  getHostProps: function (inst, props) {
	    !(props.dangerouslySetInnerHTML == null) ?  true ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : _prodInvariant('91') : void 0;
	
	    // Always set children to the same thing. In IE9, the selection range will
	    // get reset if `textContent` is mutated.  We could add a check in setTextContent
	    // to only set the value if/when the value differs from the node value (which would
	    // completely solve this IE9 bug), but Sebastian+Ben seemed to like this solution.
	    // The value can be a boolean or object so that's why it's forced to be a string.
	    var hostProps = _assign({}, props, {
	      value: undefined,
	      defaultValue: undefined,
	      children: '' + inst._wrapperState.initialValue,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return hostProps;
	  },
	
	  mountWrapper: function (inst, props) {
	    if (true) {
	      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
	      if (props.valueLink !== undefined && !didWarnValueLink) {
	         true ? warning(false, '`valueLink` prop on `textarea` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnValueLink = true;
	      }
	      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
	         true ? warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
	        didWarnValDefaultVal = true;
	      }
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    var initialValue = value;
	
	    // Only bother fetching default value if we're going to use it
	    if (value == null) {
	      var defaultValue = props.defaultValue;
	      // TODO (yungsters): Remove support for children content in <textarea>.
	      var children = props.children;
	      if (children != null) {
	        if (true) {
	           true ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : void 0;
	        }
	        !(defaultValue == null) ?  true ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : _prodInvariant('92') : void 0;
	        if (Array.isArray(children)) {
	          !(children.length <= 1) ?  true ? invariant(false, '<textarea> can only have at most one child.') : _prodInvariant('93') : void 0;
	          children = children[0];
	        }
	
	        defaultValue = '' + children;
	      }
	      if (defaultValue == null) {
	        defaultValue = '';
	      }
	      initialValue = defaultValue;
	    }
	
	    inst._wrapperState = {
	      initialValue: '' + initialValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst)
	    };
	  },
	
	  updateWrapper: function (inst) {
	    var props = inst._currentElement.props;
	
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      var newValue = '' + value;
	
	      // To avoid side effects (such as losing text selection), only set value if changed
	      if (newValue !== node.value) {
	        node.value = newValue;
	      }
	      if (props.defaultValue == null) {
	        node.defaultValue = newValue;
	      }
	    }
	    if (props.defaultValue != null) {
	      node.defaultValue = props.defaultValue;
	    }
	  },
	
	  postMountWrapper: function (inst) {
	    // This is in postMount because we need access to the DOM node, which is not
	    // available until after the component has mounted.
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var textContent = node.textContent;
	
	    // Only set node.value if textContent is equal to the expected
	    // initial value. In IE10/IE11 there is a bug where the placeholder attribute
	    // will populate textContent as well.
	    // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
	    if (textContent === inst._wrapperState.initialValue) {
	      node.value = textContent;
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMTextarea;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(41);
	
	var ReactComponentEnvironment = __webpack_require__(122);
	var ReactInstanceMap = __webpack_require__(123);
	var ReactInstrumentation = __webpack_require__(68);
	
	var ReactCurrentOwner = __webpack_require__(17);
	var ReactReconciler = __webpack_require__(65);
	var ReactChildReconciler = __webpack_require__(124);
	
	var emptyFunction = __webpack_require__(9);
	var flattenChildren = __webpack_require__(139);
	var invariant = __webpack_require__(12);
	
	/**
	 * Make an update for markup to be rendered and inserted at a supplied index.
	 *
	 * @param {string} markup Markup that renders into an element.
	 * @param {number} toIndex Destination index.
	 * @private
	 */
	function makeInsertMarkup(markup, afterNode, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'INSERT_MARKUP',
	    content: markup,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: toIndex,
	    afterNode: afterNode
	  };
	}
	
	/**
	 * Make an update for moving an existing element to another index.
	 *
	 * @param {number} fromIndex Source index of the existing element.
	 * @param {number} toIndex Destination index of the element.
	 * @private
	 */
	function makeMove(child, afterNode, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'MOVE_EXISTING',
	    content: null,
	    fromIndex: child._mountIndex,
	    fromNode: ReactReconciler.getHostNode(child),
	    toIndex: toIndex,
	    afterNode: afterNode
	  };
	}
	
	/**
	 * Make an update for removing an element at an index.
	 *
	 * @param {number} fromIndex Index of the element to remove.
	 * @private
	 */
	function makeRemove(child, node) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'REMOVE_NODE',
	    content: null,
	    fromIndex: child._mountIndex,
	    fromNode: node,
	    toIndex: null,
	    afterNode: null
	  };
	}
	
	/**
	 * Make an update for setting the markup of a node.
	 *
	 * @param {string} markup Markup that renders into an element.
	 * @private
	 */
	function makeSetMarkup(markup) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'SET_MARKUP',
	    content: markup,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: null,
	    afterNode: null
	  };
	}
	
	/**
	 * Make an update for setting the text content.
	 *
	 * @param {string} textContent Text content to set.
	 * @private
	 */
	function makeTextContent(textContent) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'TEXT_CONTENT',
	    content: textContent,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: null,
	    afterNode: null
	  };
	}
	
	/**
	 * Push an update, if any, onto the queue. Creates a new queue if none is
	 * passed and always returns the queue. Mutative.
	 */
	function enqueue(queue, update) {
	  if (update) {
	    queue = queue || [];
	    queue.push(update);
	  }
	  return queue;
	}
	
	/**
	 * Processes any enqueued updates.
	 *
	 * @private
	 */
	function processQueue(inst, updateQueue) {
	  ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);
	}
	
	var setChildrenForInstrumentation = emptyFunction;
	if (true) {
	  var getDebugID = function (inst) {
	    if (!inst._debugID) {
	      // Check for ART-like instances. TODO: This is silly/gross.
	      var internal;
	      if (internal = ReactInstanceMap.get(inst)) {
	        inst = internal;
	      }
	    }
	    return inst._debugID;
	  };
	  setChildrenForInstrumentation = function (children) {
	    var debugID = getDebugID(this);
	    // TODO: React Native empty components are also multichild.
	    // This means they still get into this method but don't have _debugID.
	    if (debugID !== 0) {
	      ReactInstrumentation.debugTool.onSetChildren(debugID, children ? Object.keys(children).map(function (key) {
	        return children[key]._debugID;
	      }) : []);
	    }
	  };
	}
	
	/**
	 * ReactMultiChild are capable of reconciling multiple children.
	 *
	 * @class ReactMultiChild
	 * @internal
	 */
	var ReactMultiChild = {
	  /**
	   * Provides common functionality for components that must reconcile multiple
	   * children. This is used by `ReactDOMComponent` to mount, update, and
	   * unmount child components.
	   *
	   * @lends {ReactMultiChild.prototype}
	   */
	  Mixin: {
	    _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {
	      if (true) {
	        var selfDebugID = getDebugID(this);
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, selfDebugID);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	        }
	      }
	      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
	    },
	
	    _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {
	      var nextChildren;
	      var selfDebugID = 0;
	      if (true) {
	        selfDebugID = getDebugID(this);
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	          ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
	          return nextChildren;
	        }
	      }
	      nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
	      ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
	      return nextChildren;
	    },
	
	    /**
	     * Generates a "mount image" for each of the supplied children. In the case
	     * of `ReactDOMComponent`, a mount image is a string of markup.
	     *
	     * @param {?object} nestedChildren Nested child maps.
	     * @return {array} An array of mounted representations.
	     * @internal
	     */
	    mountChildren: function (nestedChildren, transaction, context) {
	      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
	      this._renderedChildren = children;
	
	      var mountImages = [];
	      var index = 0;
	      for (var name in children) {
	        if (children.hasOwnProperty(name)) {
	          var child = children[name];
	          var selfDebugID = 0;
	          if (true) {
	            selfDebugID = getDebugID(this);
	          }
	          var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);
	          child._mountIndex = index++;
	          mountImages.push(mountImage);
	        }
	      }
	
	      if (true) {
	        setChildrenForInstrumentation.call(this, children);
	      }
	
	      return mountImages;
	    },
	
	    /**
	     * Replaces any rendered children with a text content string.
	     *
	     * @param {string} nextContent String of content.
	     * @internal
	     */
	    updateTextContent: function (nextContent) {
	      var prevChildren = this._renderedChildren;
	      // Remove any rendered children.
	      ReactChildReconciler.unmountChildren(prevChildren, false);
	      for (var name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name)) {
	           true ?  true ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
	        }
	      }
	      // Set new text content.
	      var updates = [makeTextContent(nextContent)];
	      processQueue(this, updates);
	    },
	
	    /**
	     * Replaces any rendered children with a markup string.
	     *
	     * @param {string} nextMarkup String of markup.
	     * @internal
	     */
	    updateMarkup: function (nextMarkup) {
	      var prevChildren = this._renderedChildren;
	      // Remove any rendered children.
	      ReactChildReconciler.unmountChildren(prevChildren, false);
	      for (var name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name)) {
	           true ?  true ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
	        }
	      }
	      var updates = [makeSetMarkup(nextMarkup)];
	      processQueue(this, updates);
	    },
	
	    /**
	     * Updates the rendered children with new children.
	     *
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @internal
	     */
	    updateChildren: function (nextNestedChildrenElements, transaction, context) {
	      // Hook used by React ART
	      this._updateChildren(nextNestedChildrenElements, transaction, context);
	    },
	
	    /**
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @final
	     * @protected
	     */
	    _updateChildren: function (nextNestedChildrenElements, transaction, context) {
	      var prevChildren = this._renderedChildren;
	      var removedNodes = {};
	      var mountImages = [];
	      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context);
	      if (!nextChildren && !prevChildren) {
	        return;
	      }
	      var updates = null;
	      var name;
	      // `nextIndex` will increment for each child in `nextChildren`, but
	      // `lastIndex` will be the last index visited in `prevChildren`.
	      var nextIndex = 0;
	      var lastIndex = 0;
	      // `nextMountIndex` will increment for each newly mounted child.
	      var nextMountIndex = 0;
	      var lastPlacedNode = null;
	      for (name in nextChildren) {
	        if (!nextChildren.hasOwnProperty(name)) {
	          continue;
	        }
	        var prevChild = prevChildren && prevChildren[name];
	        var nextChild = nextChildren[name];
	        if (prevChild === nextChild) {
	          updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));
	          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	          prevChild._mountIndex = nextIndex;
	        } else {
	          if (prevChild) {
	            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
	            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	            // The `removedNodes` loop below will actually remove the child.
	          }
	          // The child must be instantiated before it's mounted.
	          updates = enqueue(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context));
	          nextMountIndex++;
	        }
	        nextIndex++;
	        lastPlacedNode = ReactReconciler.getHostNode(nextChild);
	      }
	      // Remove children that are no longer present.
	      for (name in removedNodes) {
	        if (removedNodes.hasOwnProperty(name)) {
	          updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));
	        }
	      }
	      if (updates) {
	        processQueue(this, updates);
	      }
	      this._renderedChildren = nextChildren;
	
	      if (true) {
	        setChildrenForInstrumentation.call(this, nextChildren);
	      }
	    },
	
	    /**
	     * Unmounts all rendered children. This should be used to clean up children
	     * when this component is unmounted. It does not actually perform any
	     * backend operations.
	     *
	     * @internal
	     */
	    unmountChildren: function (safely) {
	      var renderedChildren = this._renderedChildren;
	      ReactChildReconciler.unmountChildren(renderedChildren, safely);
	      this._renderedChildren = null;
	    },
	
	    /**
	     * Moves a child component to the supplied index.
	     *
	     * @param {ReactComponent} child Component to move.
	     * @param {number} toIndex Destination index of the element.
	     * @param {number} lastIndex Last index visited of the siblings of `child`.
	     * @protected
	     */
	    moveChild: function (child, afterNode, toIndex, lastIndex) {
	      // If the index of `child` is less than `lastIndex`, then it needs to
	      // be moved. Otherwise, we do not need to move it because a child will be
	      // inserted or moved before `child`.
	      if (child._mountIndex < lastIndex) {
	        return makeMove(child, afterNode, toIndex);
	      }
	    },
	
	    /**
	     * Creates a child component.
	     *
	     * @param {ReactComponent} child Component to create.
	     * @param {string} mountImage Markup to insert.
	     * @protected
	     */
	    createChild: function (child, afterNode, mountImage) {
	      return makeInsertMarkup(mountImage, afterNode, child._mountIndex);
	    },
	
	    /**
	     * Removes a child component.
	     *
	     * @param {ReactComponent} child Child to remove.
	     * @protected
	     */
	    removeChild: function (child, node) {
	      return makeRemove(child, node);
	    },
	
	    /**
	     * Mounts a child with the supplied name.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to mount.
	     * @param {string} name Name of the child.
	     * @param {number} index Index at which to insert the child.
	     * @param {ReactReconcileTransaction} transaction
	     * @private
	     */
	    _mountChildAtIndex: function (child, mountImage, afterNode, index, transaction, context) {
	      child._mountIndex = index;
	      return this.createChild(child, afterNode, mountImage);
	    },
	
	    /**
	     * Unmounts a rendered child.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to unmount.
	     * @private
	     */
	    _unmountChild: function (child, node) {
	      var update = this.removeChild(child, node);
	      child._mountIndex = null;
	      return update;
	    }
	  }
	};
	
	module.exports = ReactMultiChild;

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(41);
	
	var invariant = __webpack_require__(12);
	
	var injected = false;
	
	var ReactComponentEnvironment = {
	  /**
	   * Optionally injectable hook for swapping out mount images in the middle of
	   * the tree.
	   */
	  replaceNodeWithMarkup: null,
	
	  /**
	   * Optionally injectable hook for processing a queue of child updates. Will
	   * later move into MultiChildComponents.
	   */
	  processChildrenUpdates: null,
	
	  injection: {
	    injectEnvironment: function (environment) {
	      !!injected ?  true ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : _prodInvariant('104') : void 0;
	      ReactComponentEnvironment.replaceNodeWithMarkup = environment.replaceNodeWithMarkup;
	      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
	      injected = true;
	    }
	  }
	};
	
	module.exports = ReactComponentEnvironment;

/***/ }),
/* 123 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	/**
	 * `ReactInstanceMap` maintains a mapping from a public facing stateful
	 * instance (key) and the internal representation (value). This allows public
	 * methods to accept the user facing instance as an argument and map them back
	 * to internal methods.
	 */
	
	// TODO: Replace this with ES6: var ReactInstanceMap = new Map();
	
	var ReactInstanceMap = {
	  /**
	   * This API should be called `delete` but we'd have to make sure to always
	   * transform these to strings for IE support. When this transform is fully
	   * supported we can rename it.
	   */
	  remove: function (key) {
	    key._reactInternalInstance = undefined;
	  },
	
	  get: function (key) {
	    return key._reactInternalInstance;
	  },
	
	  has: function (key) {
	    return key._reactInternalInstance !== undefined;
	  },
	
	  set: function (key, value) {
	    key._reactInternalInstance = value;
	  }
	};
	
	module.exports = ReactInstanceMap;

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var ReactReconciler = __webpack_require__(65);
	
	var instantiateReactComponent = __webpack_require__(125);
	var KeyEscapeUtils = __webpack_require__(135);
	var shouldUpdateReactComponent = __webpack_require__(131);
	var traverseAllChildren = __webpack_require__(136);
	var warning = __webpack_require__(8);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && ({"NODE_ENV":"development"}) && ("development") === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(24);
	}
	
	function instantiateChild(childInstances, child, name, selfDebugID) {
	  // We found a component instance.
	  var keyUnique = childInstances[name] === undefined;
	  if (true) {
	    if (!ReactComponentTreeHook) {
	      ReactComponentTreeHook = __webpack_require__(24);
	    }
	    if (!keyUnique) {
	       true ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
	    }
	  }
	  if (child != null && keyUnique) {
	    childInstances[name] = instantiateReactComponent(child, true);
	  }
	}
	
	/**
	 * ReactChildReconciler provides helpers for initializing or updating a set of
	 * children. Its output is suitable for passing it onto ReactMultiChild which
	 * does diffed reordering and insertion.
	 */
	var ReactChildReconciler = {
	  /**
	   * Generates a "mount image" for each of the supplied children. In the case
	   * of `ReactDOMComponent`, a mount image is a string of markup.
	   *
	   * @param {?object} nestedChildNodes Nested child maps.
	   * @return {?object} A set of child instances.
	   * @internal
	   */
	  instantiateChildren: function (nestedChildNodes, transaction, context, selfDebugID) // 0 in production and for roots
	  {
	    if (nestedChildNodes == null) {
	      return null;
	    }
	    var childInstances = {};
	
	    if (true) {
	      traverseAllChildren(nestedChildNodes, function (childInsts, child, name) {
	        return instantiateChild(childInsts, child, name, selfDebugID);
	      }, childInstances);
	    } else {
	      traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
	    }
	    return childInstances;
	  },
	
	  /**
	   * Updates the rendered children and returns a new set of children.
	   *
	   * @param {?object} prevChildren Previously initialized set of children.
	   * @param {?object} nextChildren Flat child element maps.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @return {?object} A new set of child instances.
	   * @internal
	   */
	  updateChildren: function (prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID) // 0 in production and for roots
	  {
	    // We currently don't have a way to track moves here but if we use iterators
	    // instead of for..in we can zip the iterators and check if an item has
	    // moved.
	    // TODO: If nothing has changed, return the prevChildren object so that we
	    // can quickly bailout if nothing has changed.
	    if (!nextChildren && !prevChildren) {
	      return;
	    }
	    var name;
	    var prevChild;
	    for (name in nextChildren) {
	      if (!nextChildren.hasOwnProperty(name)) {
	        continue;
	      }
	      prevChild = prevChildren && prevChildren[name];
	      var prevElement = prevChild && prevChild._currentElement;
	      var nextElement = nextChildren[name];
	      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
	        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
	        nextChildren[name] = prevChild;
	      } else {
	        if (prevChild) {
	          removedNodes[name] = ReactReconciler.getHostNode(prevChild);
	          ReactReconciler.unmountComponent(prevChild, false);
	        }
	        // The child must be instantiated before it's mounted.
	        var nextChildInstance = instantiateReactComponent(nextElement, true);
	        nextChildren[name] = nextChildInstance;
	        // Creating mount image now ensures refs are resolved in right order
	        // (see https://github.com/facebook/react/pull/7101 for explanation).
	        var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID);
	        mountImages.push(nextChildMountImage);
	      }
	    }
	    // Unmount children that are no longer present.
	    for (name in prevChildren) {
	      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
	        prevChild = prevChildren[name];
	        removedNodes[name] = ReactReconciler.getHostNode(prevChild);
	        ReactReconciler.unmountComponent(prevChild, false);
	      }
	    }
	  },
	
	  /**
	   * Unmounts all rendered children. This should be used to clean up children
	   * when this component is unmounted.
	   *
	   * @param {?object} renderedChildren Previously initialized set of children.
	   * @internal
	   */
	  unmountChildren: function (renderedChildren, safely) {
	    for (var name in renderedChildren) {
	      if (renderedChildren.hasOwnProperty(name)) {
	        var renderedChild = renderedChildren[name];
	        ReactReconciler.unmountComponent(renderedChild, safely);
	      }
	    }
	  }
	};
	
	module.exports = ReactChildReconciler;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(41),
	    _assign = __webpack_require__(4);
	
	var ReactCompositeComponent = __webpack_require__(126);
	var ReactEmptyComponent = __webpack_require__(132);
	var ReactHostComponent = __webpack_require__(133);
	
	var getNextDebugID = __webpack_require__(134);
	var invariant = __webpack_require__(12);
	var warning = __webpack_require__(8);
	
	// To avoid a cyclic dependency, we create the final class in this module
	var ReactCompositeComponentWrapper = function (element) {
	  this.construct(element);
	};
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Check if the type reference is a known internal type. I.e. not a user
	 * provided composite type.
	 *
	 * @param {function} type
	 * @return {boolean} Returns true if this is a valid internal type.
	 */
	function isInternalComponentType(type) {
	  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
	}
	
	/**
	 * Given a ReactNode, create an instance that will actually be mounted.
	 *
	 * @param {ReactNode} node
	 * @param {boolean} shouldHaveDebugID
	 * @return {object} A new instance of the element's constructor.
	 * @protected
	 */
	function instantiateReactComponent(node, shouldHaveDebugID) {
	  var instance;
	
	  if (node === null || node === false) {
	    instance = ReactEmptyComponent.create(instantiateReactComponent);
	  } else if (typeof node === 'object') {
	    var element = node;
	    var type = element.type;
	    if (typeof type !== 'function' && typeof type !== 'string') {
	      var info = '';
	      if (true) {
	        if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
	          info += ' You likely forgot to export your component from the file ' + "it's defined in.";
	        }
	      }
	      info += getDeclarationErrorAddendum(element._owner);
	       true ?  true ? invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info) : _prodInvariant('130', type == null ? type : typeof type, info) : void 0;
	    }
	
	    // Special case string values
	    if (typeof element.type === 'string') {
	      instance = ReactHostComponent.createInternalComponent(element);
	    } else if (isInternalComponentType(element.type)) {
	      // This is temporarily available for custom components that are not string
	      // representations. I.e. ART. Once those are updated to use the string
	      // representation, we can drop this code path.
	      instance = new element.type(element);
	
	      // We renamed this. Allow the old name for compat. :(
	      if (!instance.getHostNode) {
	        instance.getHostNode = instance.getNativeNode;
	      }
	    } else {
	      instance = new ReactCompositeComponentWrapper(element);
	    }
	  } else if (typeof node === 'string' || typeof node === 'number') {
	    instance = ReactHostComponent.createInstanceForText(node);
	  } else {
	     true ?  true ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : _prodInvariant('131', typeof node) : void 0;
	  }
	
	  if (true) {
	     true ? warning(typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.getHostNode === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : void 0;
	  }
	
	  // These two fields are used by the DOM and ART diffing algorithms
	  // respectively. Instead of using expandos on components, we should be
	  // storing the state needed by the diffing algorithms elsewhere.
	  instance._mountIndex = 0;
	  instance._mountImage = null;
	
	  if (true) {
	    instance._debugID = shouldHaveDebugID ? getNextDebugID() : 0;
	  }
	
	  // Internal instances should fully constructed at this point, so they should
	  // not get any new fields added to them at this point.
	  if (true) {
	    if (Object.preventExtensions) {
	      Object.preventExtensions(instance);
	    }
	  }
	
	  return instance;
	}
	
	_assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent, {
	  _instantiateReactComponent: instantiateReactComponent
	});
	
	module.exports = instantiateReactComponent;

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(41),
	    _assign = __webpack_require__(4);
	
	var React = __webpack_require__(3);
	var ReactComponentEnvironment = __webpack_require__(122);
	var ReactCurrentOwner = __webpack_require__(17);
	var ReactErrorUtils = __webpack_require__(51);
	var ReactInstanceMap = __webpack_require__(123);
	var ReactInstrumentation = __webpack_require__(68);
	var ReactNodeTypes = __webpack_require__(127);
	var ReactReconciler = __webpack_require__(65);
	
	if (true) {
	  var checkReactTypeSpec = __webpack_require__(128);
	}
	
	var emptyObject = __webpack_require__(11);
	var invariant = __webpack_require__(12);
	var shallowEqual = __webpack_require__(130);
	var shouldUpdateReactComponent = __webpack_require__(131);
	var warning = __webpack_require__(8);
	
	var CompositeTypes = {
	  ImpureClass: 0,
	  PureClass: 1,
	  StatelessFunctional: 2
	};
	
	function StatelessComponent(Component) {}
	StatelessComponent.prototype.render = function () {
	  var Component = ReactInstanceMap.get(this)._currentElement.type;
	  var element = Component(this.props, this.context, this.updater);
	  warnIfInvalidElement(Component, element);
	  return element;
	};
	
	function warnIfInvalidElement(Component, element) {
	  if (true) {
	     true ? warning(element === null || element === false || React.isValidElement(element), '%s(...): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : void 0;
	     true ? warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component') : void 0;
	  }
	}
	
	function shouldConstruct(Component) {
	  return !!(Component.prototype && Component.prototype.isReactComponent);
	}
	
	function isPureComponent(Component) {
	  return !!(Component.prototype && Component.prototype.isPureReactComponent);
	}
	
	// Separated into a function to contain deoptimizations caused by try/finally.
	function measureLifeCyclePerf(fn, debugID, timerType) {
	  if (debugID === 0) {
	    // Top-level wrappers (see ReactMount) and empty components (see
	    // ReactDOMEmptyComponent) are invisible to hooks and devtools.
	    // Both are implementation details that should go away in the future.
	    return fn();
	  }
	
	  ReactInstrumentation.debugTool.onBeginLifeCycleTimer(debugID, timerType);
	  try {
	    return fn();
	  } finally {
	    ReactInstrumentation.debugTool.onEndLifeCycleTimer(debugID, timerType);
	  }
	}
	
	/**
	 * ------------------ The Life-Cycle of a Composite Component ------------------
	 *
	 * - constructor: Initialization of state. The instance is now retained.
	 *   - componentWillMount
	 *   - render
	 *   - [children's constructors]
	 *     - [children's componentWillMount and render]
	 *     - [children's componentDidMount]
	 *     - componentDidMount
	 *
	 *       Update Phases:
	 *       - componentWillReceiveProps (only called if parent updated)
	 *       - shouldComponentUpdate
	 *         - componentWillUpdate
	 *           - render
	 *           - [children's constructors or receive props phases]
	 *         - componentDidUpdate
	 *
	 *     - componentWillUnmount
	 *     - [children's componentWillUnmount]
	 *   - [children destroyed]
	 * - (destroyed): The instance is now blank, released by React and ready for GC.
	 *
	 * -----------------------------------------------------------------------------
	 */
	
	/**
	 * An incrementing ID assigned to each component when it is mounted. This is
	 * used to enforce the order in which `ReactUpdates` updates dirty components.
	 *
	 * @private
	 */
	var nextMountID = 1;
	
	/**
	 * @lends {ReactCompositeComponent.prototype}
	 */
	var ReactCompositeComponent = {
	  /**
	   * Base constructor for all composite component.
	   *
	   * @param {ReactElement} element
	   * @final
	   * @internal
	   */
	  construct: function (element) {
	    this._currentElement = element;
	    this._rootNodeID = 0;
	    this._compositeType = null;
	    this._instance = null;
	    this._hostParent = null;
	    this._hostContainerInfo = null;
	
	    // See ReactUpdateQueue
	    this._updateBatchNumber = null;
	    this._pendingElement = null;
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    this._renderedNodeType = null;
	    this._renderedComponent = null;
	    this._context = null;
	    this._mountOrder = 0;
	    this._topLevelWrapper = null;
	
	    // See ReactUpdates and ReactUpdateQueue.
	    this._pendingCallbacks = null;
	
	    // ComponentWillUnmount shall only be called once
	    this._calledComponentWillUnmount = false;
	
	    if (true) {
	      this._warnedAboutRefsInRender = false;
	    }
	  },
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?object} hostParent
	   * @param {?object} hostContainerInfo
	   * @param {?object} context
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    var _this = this;
	
	    this._context = context;
	    this._mountOrder = nextMountID++;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;
	
	    var publicProps = this._currentElement.props;
	    var publicContext = this._processContext(context);
	
	    var Component = this._currentElement.type;
	
	    var updateQueue = transaction.getUpdateQueue();
	
	    // Initialize the public class
	    var doConstruct = shouldConstruct(Component);
	    var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
	    var renderedElement;
	
	    // Support functional components
	    if (!doConstruct && (inst == null || inst.render == null)) {
	      renderedElement = inst;
	      warnIfInvalidElement(Component, renderedElement);
	      !(inst === null || inst === false || React.isValidElement(inst)) ?  true ? invariant(false, '%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : _prodInvariant('105', Component.displayName || Component.name || 'Component') : void 0;
	      inst = new StatelessComponent(Component);
	      this._compositeType = CompositeTypes.StatelessFunctional;
	    } else {
	      if (isPureComponent(Component)) {
	        this._compositeType = CompositeTypes.PureClass;
	      } else {
	        this._compositeType = CompositeTypes.ImpureClass;
	      }
	    }
	
	    if (true) {
	      // This will throw later in _renderValidatedComponent, but add an early
	      // warning now to help debugging
	      if (inst.render == null) {
	         true ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', Component.displayName || Component.name || 'Component') : void 0;
	      }
	
	      var propsMutated = inst.props !== publicProps;
	      var componentName = Component.displayName || Component.name || 'Component';
	
	       true ? warning(inst.props === undefined || !propsMutated, '%s(...): When calling super() in `%s`, make sure to pass ' + "up the same props that your component's constructor was passed.", componentName, componentName) : void 0;
	    }
	
	    // These should be set up in the constructor, but as a convenience for
	    // simpler class abstractions, we set them up after the fact.
	    inst.props = publicProps;
	    inst.context = publicContext;
	    inst.refs = emptyObject;
	    inst.updater = updateQueue;
	
	    this._instance = inst;
	
	    // Store a reference from the instance back to the internal representation
	    ReactInstanceMap.set(inst, this);
	
	    if (true) {
	      // Since plain JS classes are defined without any special initialization
	      // logic, we can not catch common errors early. Therefore, we have to
	      // catch them here, at initialization time, instead.
	       true ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved || inst.state, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : void 0;
	       true ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : void 0;
	       true ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : void 0;
	       true ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : void 0;
	       true ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : void 0;
	       true ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : void 0;
	       true ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : void 0;
	    }
	
	    var initialState = inst.state;
	    if (initialState === undefined) {
	      inst.state = initialState = null;
	    }
	    !(typeof initialState === 'object' && !Array.isArray(initialState)) ?  true ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : _prodInvariant('106', this.getName() || 'ReactCompositeComponent') : void 0;
	
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    var markup;
	    if (inst.unstable_handleError) {
	      markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    } else {
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    }
	
	    if (inst.componentDidMount) {
	      if (true) {
	        transaction.getReactMountReady().enqueue(function () {
	          measureLifeCyclePerf(function () {
	            return inst.componentDidMount();
	          }, _this._debugID, 'componentDidMount');
	        });
	      } else {
	        transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
	      }
	    }
	
	    return markup;
	  },
	
	  _constructComponent: function (doConstruct, publicProps, publicContext, updateQueue) {
	    if (("development") !== 'production' && !doConstruct) {
	      ReactCurrentOwner.current = this;
	      try {
	        return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
	      } finally {
	        ReactCurrentOwner.current = null;
	      }
	    } else {
	      return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
	    }
	  },
	
	  _constructComponentWithoutOwner: function (doConstruct, publicProps, publicContext, updateQueue) {
	    var Component = this._currentElement.type;
	
	    if (doConstruct) {
	      if (true) {
	        return measureLifeCyclePerf(function () {
	          return new Component(publicProps, publicContext, updateQueue);
	        }, this._debugID, 'ctor');
	      } else {
	        return new Component(publicProps, publicContext, updateQueue);
	      }
	    }
	
	    // This can still be an instance in case of factory components
	    // but we'll count this as time spent rendering as the more common case.
	    if (true) {
	      return measureLifeCyclePerf(function () {
	        return Component(publicProps, publicContext, updateQueue);
	      }, this._debugID, 'render');
	    } else {
	      return Component(publicProps, publicContext, updateQueue);
	    }
	  },
	
	  performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
	    var markup;
	    var checkpoint = transaction.checkpoint();
	    try {
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    } catch (e) {
	      // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
	      transaction.rollback(checkpoint);
	      this._instance.unstable_handleError(e);
	      if (this._pendingStateQueue) {
	        this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
	      }
	      checkpoint = transaction.checkpoint();
	
	      this._renderedComponent.unmountComponent(true);
	      transaction.rollback(checkpoint);
	
	      // Try again - we've informed the component about the error, so they can render an error message this time.
	      // If this throws again, the error will bubble up (and can be caught by a higher error boundary).
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    }
	    return markup;
	  },
	
	  performInitialMount: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
	    var inst = this._instance;
	
	    var debugID = 0;
	    if (true) {
	      debugID = this._debugID;
	    }
	
	    if (inst.componentWillMount) {
	      if (true) {
	        measureLifeCyclePerf(function () {
	          return inst.componentWillMount();
	        }, debugID, 'componentWillMount');
	      } else {
	        inst.componentWillMount();
	      }
	      // When mounting, calls to `setState` by `componentWillMount` will set
	      // `this._pendingStateQueue` without triggering a re-render.
	      if (this._pendingStateQueue) {
	        inst.state = this._processPendingState(inst.props, inst.context);
	      }
	    }
	
	    // If not a stateless component, we now render
	    if (renderedElement === undefined) {
	      renderedElement = this._renderValidatedComponent();
	    }
	
	    var nodeType = ReactNodeTypes.getType(renderedElement);
	    this._renderedNodeType = nodeType;
	    var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
	    );
	    this._renderedComponent = child;
	
	    var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context), debugID);
	
	    if (true) {
	      if (debugID !== 0) {
	        var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
	        ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
	      }
	    }
	
	    return markup;
	  },
	
	  getHostNode: function () {
	    return ReactReconciler.getHostNode(this._renderedComponent);
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function (safely) {
	    if (!this._renderedComponent) {
	      return;
	    }
	
	    var inst = this._instance;
	
	    if (inst.componentWillUnmount && !inst._calledComponentWillUnmount) {
	      inst._calledComponentWillUnmount = true;
	
	      if (safely) {
	        var name = this.getName() + '.componentWillUnmount()';
	        ReactErrorUtils.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst));
	      } else {
	        if (true) {
	          measureLifeCyclePerf(function () {
	            return inst.componentWillUnmount();
	          }, this._debugID, 'componentWillUnmount');
	        } else {
	          inst.componentWillUnmount();
	        }
	      }
	    }
	
	    if (this._renderedComponent) {
	      ReactReconciler.unmountComponent(this._renderedComponent, safely);
	      this._renderedNodeType = null;
	      this._renderedComponent = null;
	      this._instance = null;
	    }
	
	    // Reset pending fields
	    // Even if this component is scheduled for another update in ReactUpdates,
	    // it would still be ignored because these fields are reset.
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	    this._pendingCallbacks = null;
	    this._pendingElement = null;
	
	    // These fields do not really need to be reset since this object is no
	    // longer accessible.
	    this._context = null;
	    this._rootNodeID = 0;
	    this._topLevelWrapper = null;
	
	    // Delete the reference from the instance to this internal representation
	    // which allow the internals to be properly cleaned up even if the user
	    // leaks a reference to the public instance.
	    ReactInstanceMap.remove(inst);
	
	    // Some existing components rely on inst.props even after they've been
	    // destroyed (in event handlers).
	    // TODO: inst.props = null;
	    // TODO: inst.state = null;
	    // TODO: inst.context = null;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _maskContext: function (context) {
	    var Component = this._currentElement.type;
	    var contextTypes = Component.contextTypes;
	    if (!contextTypes) {
	      return emptyObject;
	    }
	    var maskedContext = {};
	    for (var contextName in contextTypes) {
	      maskedContext[contextName] = context[contextName];
	    }
	    return maskedContext;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`, and asserts that they are valid.
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _processContext: function (context) {
	    var maskedContext = this._maskContext(context);
	    if (true) {
	      var Component = this._currentElement.type;
	      if (Component.contextTypes) {
	        this._checkContextTypes(Component.contextTypes, maskedContext, 'context');
	      }
	    }
	    return maskedContext;
	  },
	
	  /**
	   * @param {object} currentContext
	   * @return {object}
	   * @private
	   */
	  _processChildContext: function (currentContext) {
	    var Component = this._currentElement.type;
	    var inst = this._instance;
	    var childContext;
	
	    if (inst.getChildContext) {
	      if (true) {
	        ReactInstrumentation.debugTool.onBeginProcessingChildContext();
	        try {
	          childContext = inst.getChildContext();
	        } finally {
	          ReactInstrumentation.debugTool.onEndProcessingChildContext();
	        }
	      } else {
	        childContext = inst.getChildContext();
	      }
	    }
	
	    if (childContext) {
	      !(typeof Component.childContextTypes === 'object') ?  true ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', this.getName() || 'ReactCompositeComponent') : _prodInvariant('107', this.getName() || 'ReactCompositeComponent') : void 0;
	      if (true) {
	        this._checkContextTypes(Component.childContextTypes, childContext, 'child context');
	      }
	      for (var name in childContext) {
	        !(name in Component.childContextTypes) ?  true ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : _prodInvariant('108', this.getName() || 'ReactCompositeComponent', name) : void 0;
	      }
	      return _assign({}, currentContext, childContext);
	    }
	    return currentContext;
	  },
	
	  /**
	   * Assert that the context types are valid
	   *
	   * @param {object} typeSpecs Map of context field to a ReactPropType
	   * @param {object} values Runtime values that need to be type-checked
	   * @param {string} location e.g. "prop", "context", "child context"
	   * @private
	   */
	  _checkContextTypes: function (typeSpecs, values, location) {
	    if (true) {
	      checkReactTypeSpec(typeSpecs, values, location, this.getName(), null, this._debugID);
	    }
	  },
	
	  receiveComponent: function (nextElement, transaction, nextContext) {
	    var prevElement = this._currentElement;
	    var prevContext = this._context;
	
	    this._pendingElement = null;
	
	    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
	  },
	
	  /**
	   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
	   * is set, update the component.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function (transaction) {
	    if (this._pendingElement != null) {
	      ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);
	    } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
	      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
	    } else {
	      this._updateBatchNumber = null;
	    }
	  },
	
	  /**
	   * Perform an update to a mounted component. The componentWillReceiveProps and
	   * shouldComponentUpdate methods are called, then (assuming the update isn't
	   * skipped) the remaining update lifecycle methods are called and the DOM
	   * representation is updated.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevParentElement
	   * @param {ReactElement} nextParentElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
	    var inst = this._instance;
	    !(inst != null) ?  true ? invariant(false, 'Attempted to update component `%s` that has already been unmounted (or failed to mount).', this.getName() || 'ReactCompositeComponent') : _prodInvariant('136', this.getName() || 'ReactCompositeComponent') : void 0;
	
	    var willReceive = false;
	    var nextContext;
	
	    // Determine if the context has changed or not
	    if (this._context === nextUnmaskedContext) {
	      nextContext = inst.context;
	    } else {
	      nextContext = this._processContext(nextUnmaskedContext);
	      willReceive = true;
	    }
	
	    var prevProps = prevParentElement.props;
	    var nextProps = nextParentElement.props;
	
	    // Not a simple state update but a props update
	    if (prevParentElement !== nextParentElement) {
	      willReceive = true;
	    }
	
	    // An update here will schedule an update but immediately set
	    // _pendingStateQueue which will ensure that any state updates gets
	    // immediately reconciled instead of waiting for the next batch.
	    if (willReceive && inst.componentWillReceiveProps) {
	      if (true) {
	        measureLifeCyclePerf(function () {
	          return inst.componentWillReceiveProps(nextProps, nextContext);
	        }, this._debugID, 'componentWillReceiveProps');
	      } else {
	        inst.componentWillReceiveProps(nextProps, nextContext);
	      }
	    }
	
	    var nextState = this._processPendingState(nextProps, nextContext);
	    var shouldUpdate = true;
	
	    if (!this._pendingForceUpdate) {
	      if (inst.shouldComponentUpdate) {
	        if (true) {
	          shouldUpdate = measureLifeCyclePerf(function () {
	            return inst.shouldComponentUpdate(nextProps, nextState, nextContext);
	          }, this._debugID, 'shouldComponentUpdate');
	        } else {
	          shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);
	        }
	      } else {
	        if (this._compositeType === CompositeTypes.PureClass) {
	          shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);
	        }
	      }
	    }
	
	    if (true) {
	       true ? warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : void 0;
	    }
	
	    this._updateBatchNumber = null;
	    if (shouldUpdate) {
	      this._pendingForceUpdate = false;
	      // Will set `this.props`, `this.state` and `this.context`.
	      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
	    } else {
	      // If it's determined that a component should not update, we still want
	      // to set props and state but we shortcut the rest of the update.
	      this._currentElement = nextParentElement;
	      this._context = nextUnmaskedContext;
	      inst.props = nextProps;
	      inst.state = nextState;
	      inst.context = nextContext;
	    }
	  },
	
	  _processPendingState: function (props, context) {
	    var inst = this._instance;
	    var queue = this._pendingStateQueue;
	    var replace = this._pendingReplaceState;
	    this._pendingReplaceState = false;
	    this._pendingStateQueue = null;
	
	    if (!queue) {
	      return inst.state;
	    }
	
	    if (replace && queue.length === 1) {
	      return queue[0];
	    }
	
	    var nextState = _assign({}, replace ? queue[0] : inst.state);
	    for (var i = replace ? 1 : 0; i < queue.length; i++) {
	      var partial = queue[i];
	      _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
	    }
	
	    return nextState;
	  },
	
	  /**
	   * Merges new props and state, notifies delegate methods of update and
	   * performs update.
	   *
	   * @param {ReactElement} nextElement Next element
	   * @param {object} nextProps Next public object to set as properties.
	   * @param {?object} nextState Next object to set as state.
	   * @param {?object} nextContext Next public object to set as context.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {?object} unmaskedContext
	   * @private
	   */
	  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
	    var _this2 = this;
	
	    var inst = this._instance;
	
	    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
	    var prevProps;
	    var prevState;
	    var prevContext;
	    if (hasComponentDidUpdate) {
	      prevProps = inst.props;
	      prevState = inst.state;
	      prevContext = inst.context;
	    }
	
	    if (inst.componentWillUpdate) {
	      if (true) {
	        measureLifeCyclePerf(function () {
	          return inst.componentWillUpdate(nextProps, nextState, nextContext);
	        }, this._debugID, 'componentWillUpdate');
	      } else {
	        inst.componentWillUpdate(nextProps, nextState, nextContext);
	      }
	    }
	
	    this._currentElement = nextElement;
	    this._context = unmaskedContext;
	    inst.props = nextProps;
	    inst.state = nextState;
	    inst.context = nextContext;
	
	    this._updateRenderedComponent(transaction, unmaskedContext);
	
	    if (hasComponentDidUpdate) {
	      if (true) {
	        transaction.getReactMountReady().enqueue(function () {
	          measureLifeCyclePerf(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), _this2._debugID, 'componentDidUpdate');
	        });
	      } else {
	        transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
	      }
	    }
	  },
	
	  /**
	   * Call the component's `render` method and update the DOM accordingly.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  _updateRenderedComponent: function (transaction, context) {
	    var prevComponentInstance = this._renderedComponent;
	    var prevRenderedElement = prevComponentInstance._currentElement;
	    var nextRenderedElement = this._renderValidatedComponent();
	
	    var debugID = 0;
	    if (true) {
	      debugID = this._debugID;
	    }
	
	    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
	      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
	    } else {
	      var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);
	      ReactReconciler.unmountComponent(prevComponentInstance, false);
	
	      var nodeType = ReactNodeTypes.getType(nextRenderedElement);
	      this._renderedNodeType = nodeType;
	      var child = this._instantiateReactComponent(nextRenderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
	      );
	      this._renderedComponent = child;
	
	      var nextMarkup = ReactReconciler.mountComponent(child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext(context), debugID);
	
	      if (true) {
	        if (debugID !== 0) {
	          var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
	          ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
	        }
	      }
	
	      this._replaceNodeWithMarkup(oldHostNode, nextMarkup, prevComponentInstance);
	    }
	  },
	
	  /**
	   * Overridden in shallow rendering.
	   *
	   * @protected
	   */
	  _replaceNodeWithMarkup: function (oldHostNode, nextMarkup, prevInstance) {
	    ReactComponentEnvironment.replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance);
	  },
	
	  /**
	   * @protected
	   */
	  _renderValidatedComponentWithoutOwnerOrContext: function () {
	    var inst = this._instance;
	    var renderedElement;
	
	    if (true) {
	      renderedElement = measureLifeCyclePerf(function () {
	        return inst.render();
	      }, this._debugID, 'render');
	    } else {
	      renderedElement = inst.render();
	    }
	
	    if (true) {
	      // We allow auto-mocks to proceed as if they're returning null.
	      if (renderedElement === undefined && inst.render._isMockFunction) {
	        // This is probably bad practice. Consider warning here and
	        // deprecating this convenience.
	        renderedElement = null;
	      }
	    }
	
	    return renderedElement;
	  },
	
	  /**
	   * @private
	   */
	  _renderValidatedComponent: function () {
	    var renderedElement;
	    if (true) {
	      ReactCurrentOwner.current = this;
	      try {
	        renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
	      } finally {
	        ReactCurrentOwner.current = null;
	      }
	    } else {
	      renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
	    }
	    !(
	    // TODO: An `isValidNode` function would probably be more appropriate
	    renderedElement === null || renderedElement === false || React.isValidElement(renderedElement)) ?  true ? invariant(false, '%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : _prodInvariant('109', this.getName() || 'ReactCompositeComponent') : void 0;
	
	    return renderedElement;
	  },
	
	  /**
	   * Lazily allocates the refs object and stores `component` as `ref`.
	   *
	   * @param {string} ref Reference name.
	   * @param {component} component Component to store as `ref`.
	   * @final
	   * @private
	   */
	  attachRef: function (ref, component) {
	    var inst = this.getPublicInstance();
	    !(inst != null) ?  true ? invariant(false, 'Stateless function components cannot have refs.') : _prodInvariant('110') : void 0;
	    var publicComponentInstance = component.getPublicInstance();
	    if (true) {
	      var componentName = component && component.getName ? component.getName() : 'a component';
	       true ? warning(publicComponentInstance != null || component._compositeType !== CompositeTypes.StatelessFunctional, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : void 0;
	    }
	    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
	    refs[ref] = publicComponentInstance;
	  },
	
	  /**
	   * Detaches a reference name.
	   *
	   * @param {string} ref Name to dereference.
	   * @final
	   * @private
	   */
	  detachRef: function (ref) {
	    var refs = this.getPublicInstance().refs;
	    delete refs[ref];
	  },
	
	  /**
	   * Get a text description of the component that can be used to identify it
	   * in error messages.
	   * @return {string} The name or null.
	   * @internal
	   */
	  getName: function () {
	    var type = this._currentElement.type;
	    var constructor = this._instance && this._instance.constructor;
	    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
	  },
	
	  /**
	   * Get the publicly accessible representation of this component - i.e. what
	   * is exposed by refs and returned by render. Can be null for stateless
	   * components.
	   *
	   * @return {ReactComponent} the public component instance.
	   * @internal
	   */
	  getPublicInstance: function () {
	    var inst = this._instance;
	    if (this._compositeType === CompositeTypes.StatelessFunctional) {
	      return null;
	    }
	    return inst;
	  },
	
	  // Stub
	  _instantiateReactComponent: null
	};
	
	module.exports = ReactCompositeComponent;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(41);
	
	var React = __webpack_require__(3);
	
	var invariant = __webpack_require__(12);
	
	var ReactNodeTypes = {
	  HOST: 0,
	  COMPOSITE: 1,
	  EMPTY: 2,
	
	  getType: function (node) {
	    if (node === null || node === false) {
	      return ReactNodeTypes.EMPTY;
	    } else if (React.isValidElement(node)) {
	      if (typeof node.type === 'function') {
	        return ReactNodeTypes.COMPOSITE;
	      } else {
	        return ReactNodeTypes.HOST;
	      }
	    }
	     true ?  true ? invariant(false, 'Unexpected node: %s', node) : _prodInvariant('26', node) : void 0;
	  }
	};
	
	module.exports = ReactNodeTypes;

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(41);
	
	var ReactPropTypeLocationNames = __webpack_require__(129);
	var ReactPropTypesSecret = __webpack_require__(117);
	
	var invariant = __webpack_require__(12);
	var warning = __webpack_require__(8);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && ({"NODE_ENV":"development"}) && ("development") === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(24);
	}
	
	var loggedTypeFailures = {};
	
	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?object} element The React element that is being type-checked
	 * @param {?number} debugID The React component instance that is being type-checked
	 * @private
	 */
	function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
	  for (var typeSpecName in typeSpecs) {
	    if (typeSpecs.hasOwnProperty(typeSpecName)) {
	      var error;
	      // Prop type validation may throw. In case they do, we don't want to
	      // fail the render phase where it didn't fail before. So we log it.
	      // After these have been cleaned up, we'll let them throw.
	      try {
	        // This is intentionally an invariant that gets caught. It's the same
	        // behavior as without this statement except with a better message.
	        !(typeof typeSpecs[typeSpecName] === 'function') ?  true ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
	        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	      } catch (ex) {
	        error = ex;
	      }
	       true ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var componentStackInfo = '';
	
	        if (true) {
	          if (!ReactComponentTreeHook) {
	            ReactComponentTreeHook = __webpack_require__(24);
	          }
	          if (debugID !== null) {
	            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
	          } else if (element !== null) {
	            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
	          }
	        }
	
	         true ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
	      }
	    }
	  }
	}
	
	module.exports = checkReactTypeSpec;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	'use strict';
	
	var ReactPropTypeLocationNames = {};
	
	if (true) {
	  ReactPropTypeLocationNames = {
	    prop: 'prop',
	    context: 'context',
	    childContext: 'child context'
	  };
	}
	
	module.exports = ReactPropTypeLocationNames;

/***/ }),
/* 130 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 * 
	 */
	
	/*eslint-disable no-self-compare */
	
	'use strict';
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	/**
	 * inlined Object.is polyfill to avoid requiring consumers ship their own
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	 */
	function is(x, y) {
	  // SameValue algorithm
	  if (x === y) {
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    // Added the nonzero y check to make Flow happy, but it is redundant
	    return x !== 0 || y !== 0 || 1 / x === 1 / y;
	  } else {
	    // Step 6.a: NaN == NaN
	    return x !== x && y !== y;
	  }
	}
	
	/**
	 * Performs equality by iterating through keys on an object and returning false
	 * when any key has values which are not strictly equal between the arguments.
	 * Returns true when the values of all keys are strictly equal.
	 */
	function shallowEqual(objA, objB) {
	  if (is(objA, objB)) {
	    return true;
	  }
	
	  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
	    return false;
	  }
	
	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);
	
	  if (keysA.length !== keysB.length) {
	    return false;
	  }
	
	  // Test for A's keys different from B.
	  for (var i = 0; i < keysA.length; i++) {
	    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
	      return false;
	    }
	  }
	
	  return true;
	}
	
	module.exports = shallowEqual;

/***/ }),
/* 131 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	/**
	 * Given a `prevElement` and `nextElement`, determines if the existing
	 * instance should be updated as opposed to being destroyed or replaced by a new
	 * instance. Both arguments are elements. This ensures that this logic can
	 * operate on stateless trees without any backing instance.
	 *
	 * @param {?object} prevElement
	 * @param {?object} nextElement
	 * @return {boolean} True if the existing instance should be updated.
	 * @protected
	 */
	
	function shouldUpdateReactComponent(prevElement, nextElement) {
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	  if (prevEmpty || nextEmpty) {
	    return prevEmpty === nextEmpty;
	  }
	
	  var prevType = typeof prevElement;
	  var nextType = typeof nextElement;
	  if (prevType === 'string' || prevType === 'number') {
	    return nextType === 'string' || nextType === 'number';
	  } else {
	    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
	  }
	}
	
	module.exports = shouldUpdateReactComponent;

/***/ }),
/* 132 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var emptyComponentFactory;
	
	var ReactEmptyComponentInjection = {
	  injectEmptyComponentFactory: function (factory) {
	    emptyComponentFactory = factory;
	  }
	};
	
	var ReactEmptyComponent = {
	  create: function (instantiate) {
	    return emptyComponentFactory(instantiate);
	  }
	};
	
	ReactEmptyComponent.injection = ReactEmptyComponentInjection;
	
	module.exports = ReactEmptyComponent;

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(41);
	
	var invariant = __webpack_require__(12);
	
	var genericComponentClass = null;
	var textComponentClass = null;
	
	var ReactHostComponentInjection = {
	  // This accepts a class that receives the tag string. This is a catch all
	  // that can render any kind of tag.
	  injectGenericComponentClass: function (componentClass) {
	    genericComponentClass = componentClass;
	  },
	  // This accepts a text component class that takes the text string to be
	  // rendered as props.
	  injectTextComponentClass: function (componentClass) {
	    textComponentClass = componentClass;
	  }
	};
	
	/**
	 * Get a host internal component class for a specific tag.
	 *
	 * @param {ReactElement} element The element to create.
	 * @return {function} The internal class constructor function.
	 */
	function createInternalComponent(element) {
	  !genericComponentClass ?  true ? invariant(false, 'There is no registered component for the tag %s', element.type) : _prodInvariant('111', element.type) : void 0;
	  return new genericComponentClass(element);
	}
	
	/**
	 * @param {ReactText} text
	 * @return {ReactComponent}
	 */
	function createInstanceForText(text) {
	  return new textComponentClass(text);
	}
	
	/**
	 * @param {ReactComponent} component
	 * @return {boolean}
	 */
	function isTextComponent(component) {
	  return component instanceof textComponentClass;
	}
	
	var ReactHostComponent = {
	  createInternalComponent: createInternalComponent,
	  createInstanceForText: createInstanceForText,
	  isTextComponent: isTextComponent,
	  injection: ReactHostComponentInjection
	};
	
	module.exports = ReactHostComponent;

/***/ }),
/* 134 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	'use strict';
	
	var nextDebugID = 1;
	
	function getNextDebugID() {
	  return nextDebugID++;
	}
	
	module.exports = getNextDebugID;

/***/ }),
/* 135 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	'use strict';
	
	/**
	 * Escape and wrap key so it is safe to use as a reactid
	 *
	 * @param {string} key to be escaped.
	 * @return {string} the escaped key.
	 */
	
	function escape(key) {
	  var escapeRegex = /[=:]/g;
	  var escaperLookup = {
	    '=': '=0',
	    ':': '=2'
	  };
	  var escapedString = ('' + key).replace(escapeRegex, function (match) {
	    return escaperLookup[match];
	  });
	
	  return '$' + escapedString;
	}
	
	/**
	 * Unescape and unwrap key for human-readable display
	 *
	 * @param {string} key to unescape.
	 * @return {string} the unescaped key.
	 */
	function unescape(key) {
	  var unescapeRegex = /(=0|=2)/g;
	  var unescaperLookup = {
	    '=0': '=',
	    '=2': ':'
	  };
	  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);
	
	  return ('' + keySubstring).replace(unescapeRegex, function (match) {
	    return unescaperLookup[match];
	  });
	}
	
	var KeyEscapeUtils = {
	  escape: escape,
	  unescape: unescape
	};
	
	module.exports = KeyEscapeUtils;

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(41);
	
	var ReactCurrentOwner = __webpack_require__(17);
	var REACT_ELEMENT_TYPE = __webpack_require__(137);
	
	var getIteratorFn = __webpack_require__(138);
	var invariant = __webpack_require__(12);
	var KeyEscapeUtils = __webpack_require__(135);
	var warning = __webpack_require__(8);
	
	var SEPARATOR = '.';
	var SUBSEPARATOR = ':';
	
	/**
	 * This is inlined from ReactElement since this file is shared between
	 * isomorphic and renderers. We could extract this to a
	 *
	 */
	
	/**
	 * TODO: Test that a single child and an array with one item have the same key
	 * pattern.
	 */
	
	var didWarnAboutMaps = false;
	
	/**
	 * Generate a key string that identifies a component within a set.
	 *
	 * @param {*} component A component that could contain a manual key.
	 * @param {number} index Index that is used if a manual key is not provided.
	 * @return {string}
	 */
	function getComponentKey(component, index) {
	  // Do some typechecking here since we call this blindly. We want to ensure
	  // that we don't block potential future ES APIs.
	  if (component && typeof component === 'object' && component.key != null) {
	    // Explicit key
	    return KeyEscapeUtils.escape(component.key);
	  }
	  // Implicit key determined by the index in the set
	  return index.toString(36);
	}
	
	/**
	 * @param {?*} children Children tree container.
	 * @param {!string} nameSoFar Name of the key path so far.
	 * @param {!function} callback Callback to invoke with each child found.
	 * @param {?*} traverseContext Used to pass information throughout the traversal
	 * process.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
	  var type = typeof children;
	
	  if (type === 'undefined' || type === 'boolean') {
	    // All of the above are perceived as null.
	    children = null;
	  }
	
	  if (children === null || type === 'string' || type === 'number' ||
	  // The following is inlined from ReactElement. This means we can optimize
	  // some checks. React Fiber also inlines this logic for similar purposes.
	  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
	    callback(traverseContext, children,
	    // If it's the only child, treat the name as if it was wrapped in an array
	    // so that it's consistent if the number of children grows.
	    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
	    return 1;
	  }
	
	  var child;
	  var nextName;
	  var subtreeCount = 0; // Count of children found in the current subtree.
	  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
	
	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      nextName = nextNamePrefix + getComponentKey(child, i);
	      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	    }
	  } else {
	    var iteratorFn = getIteratorFn(children);
	    if (iteratorFn) {
	      var iterator = iteratorFn.call(children);
	      var step;
	      if (iteratorFn !== children.entries) {
	        var ii = 0;
	        while (!(step = iterator.next()).done) {
	          child = step.value;
	          nextName = nextNamePrefix + getComponentKey(child, ii++);
	          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	        }
	      } else {
	        if (true) {
	          var mapsAsChildrenAddendum = '';
	          if (ReactCurrentOwner.current) {
	            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
	            if (mapsAsChildrenOwnerName) {
	              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
	            }
	          }
	           true ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
	          didWarnAboutMaps = true;
	        }
	        // Iterator will provide entry [k,v] tuples rather than values.
	        while (!(step = iterator.next()).done) {
	          var entry = step.value;
	          if (entry) {
	            child = entry[1];
	            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
	            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	          }
	        }
	      }
	    } else if (type === 'object') {
	      var addendum = '';
	      if (true) {
	        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
	        if (children._isReactElement) {
	          addendum = " It looks like you're using an element created by a different " + 'version of React. Make sure to use only one copy of React.';
	        }
	        if (ReactCurrentOwner.current) {
	          var name = ReactCurrentOwner.current.getName();
	          if (name) {
	            addendum += ' Check the render method of `' + name + '`.';
	          }
	        }
	      }
	      var childrenString = String(children);
	       true ?  true ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
	    }
	  }
	
	  return subtreeCount;
	}
	
	/**
	 * Traverses children that are typically specified as `props.children`, but
	 * might also be specified through attributes:
	 *
	 * - `traverseAllChildren(this.props.children, ...)`
	 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
	 *
	 * The `traverseContext` is an optional argument that is passed through the
	 * entire traversal. It can be used to store accumulations or anything else that
	 * the callback might find relevant.
	 *
	 * @param {?*} children Children tree object.
	 * @param {!function} callback To invoke upon traversing each child.
	 * @param {?*} traverseContext Context for traversal.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildren(children, callback, traverseContext) {
	  if (children == null) {
	    return 0;
	  }
	
	  return traverseAllChildrenImpl(children, '', callback, traverseContext);
	}
	
	module.exports = traverseAllChildren;

/***/ }),
/* 137 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	'use strict';
	
	// The Symbol used to tag the ReactElement type. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	
	var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;
	
	module.exports = REACT_ELEMENT_TYPE;

/***/ }),
/* 138 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	'use strict';
	
	/* global Symbol */
	
	var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
	
	/**
	 * Returns the iterator method function contained on the iterable object.
	 *
	 * Be sure to invoke the function with the iterable as context:
	 *
	 *     var iteratorFn = getIteratorFn(myIterable);
	 *     if (iteratorFn) {
	 *       var iterator = iteratorFn.call(myIterable);
	 *       ...
	 *     }
	 *
	 * @param {?object} maybeIterable
	 * @return {?function}
	 */
	function getIteratorFn(maybeIterable) {
	  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	  if (typeof iteratorFn === 'function') {
	    return iteratorFn;
	  }
	}
	
	module.exports = getIteratorFn;

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	'use strict';
	
	var KeyEscapeUtils = __webpack_require__(135);
	var traverseAllChildren = __webpack_require__(136);
	var warning = __webpack_require__(8);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && ({"NODE_ENV":"development"}) && ("development") === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(24);
	}
	
	/**
	 * @param {function} traverseContext Context passed through traversal.
	 * @param {?ReactComponent} child React child component.
	 * @param {!string} name String name of key path to child.
	 * @param {number=} selfDebugID Optional debugID of the current internal instance.
	 */
	function flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID) {
	  // We found a component instance.
	  if (traverseContext && typeof traverseContext === 'object') {
	    var result = traverseContext;
	    var keyUnique = result[name] === undefined;
	    if (true) {
	      if (!ReactComponentTreeHook) {
	        ReactComponentTreeHook = __webpack_require__(24);
	      }
	      if (!keyUnique) {
	         true ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
	      }
	    }
	    if (keyUnique && child != null) {
	      result[name] = child;
	    }
	  }
	}
	
	/**
	 * Flattens children that are typically specified as `props.children`. Any null
	 * children will not be included in the resulting object.
	 * @return {!object} flattened children keyed by name.
	 */
	function flattenChildren(children, selfDebugID) {
	  if (children == null) {
	    return children;
	  }
	  var result = {};
	
	  if (true) {
	    traverseAllChildren(children, function (traverseContext, child, name) {
	      return flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID);
	    }, result);
	  } else {
	    traverseAllChildren(children, flattenSingleChildIntoContext, result);
	  }
	  return result;
	}
	
	module.exports = flattenChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var PooledClass = __webpack_require__(56);
	var Transaction = __webpack_require__(74);
	var ReactInstrumentation = __webpack_require__(68);
	var ReactServerUpdateQueue = __webpack_require__(141);
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [];
	
	if (true) {
	  TRANSACTION_WRAPPERS.push({
	    initialize: ReactInstrumentation.debugTool.onBeginFlush,
	    close: ReactInstrumentation.debugTool.onEndFlush
	  });
	}
	
	var noopCallbackQueue = {
	  enqueue: function () {}
	};
	
	/**
	 * @class ReactServerRenderingTransaction
	 * @param {boolean} renderToStaticMarkup
	 */
	function ReactServerRenderingTransaction(renderToStaticMarkup) {
	  this.reinitializeTransaction();
	  this.renderToStaticMarkup = renderToStaticMarkup;
	  this.useCreateElement = false;
	  this.updateQueue = new ReactServerUpdateQueue(this);
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array} Empty list of operation wrap procedures.
	   */
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function () {
	    return noopCallbackQueue;
	  },
	
	  /**
	   * @return {object} The queue to collect React async events.
	   */
	  getUpdateQueue: function () {
	    return this.updateQueue;
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function () {},
	
	  checkpoint: function () {},
	
	  rollback: function () {}
	};
	
	_assign(ReactServerRenderingTransaction.prototype, Transaction, Mixin);
	
	PooledClass.addPoolingTo(ReactServerRenderingTransaction);
	
	module.exports = ReactServerRenderingTransaction;

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	'use strict';
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var ReactUpdateQueue = __webpack_require__(142);
	
	var warning = __webpack_require__(8);
	
	function warnNoop(publicInstance, callerName) {
	  if (true) {
	    var constructor = publicInstance.constructor;
	     true ? warning(false, '%s(...): Can only update a mounting component. ' + 'This usually means you called %s() outside componentWillMount() on the server. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
	  }
	}
	
	/**
	 * This is the update queue used for server rendering.
	 * It delegates to ReactUpdateQueue while server rendering is in progress and
	 * switches to ReactNoopUpdateQueue after the transaction has completed.
	 * @class ReactServerUpdateQueue
	 * @param {Transaction} transaction
	 */
	
	var ReactServerUpdateQueue = function () {
	  function ReactServerUpdateQueue(transaction) {
	    _classCallCheck(this, ReactServerUpdateQueue);
	
	    this.transaction = transaction;
	  }
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	
	
	  ReactServerUpdateQueue.prototype.isMounted = function isMounted(publicInstance) {
	    return false;
	  };
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	
	
	  ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
	    }
	  };
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	
	
	  ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueForceUpdate(publicInstance);
	    } else {
	      warnNoop(publicInstance, 'forceUpdate');
	    }
	  };
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object|function} completeState Next state.
	   * @internal
	   */
	
	
	  ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueReplaceState(publicInstance, completeState);
	    } else {
	      warnNoop(publicInstance, 'replaceState');
	    }
	  };
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object|function} partialState Next partial state to be merged with state.
	   * @internal
	   */
	
	
	  ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueSetState(publicInstance, partialState);
	    } else {
	      warnNoop(publicInstance, 'setState');
	    }
	  };
	
	  return ReactServerUpdateQueue;
	}();
	
	module.exports = ReactServerUpdateQueue;

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(41);
	
	var ReactCurrentOwner = __webpack_require__(17);
	var ReactInstanceMap = __webpack_require__(123);
	var ReactInstrumentation = __webpack_require__(68);
	var ReactUpdates = __webpack_require__(62);
	
	var invariant = __webpack_require__(12);
	var warning = __webpack_require__(8);
	
	function enqueueUpdate(internalInstance) {
	  ReactUpdates.enqueueUpdate(internalInstance);
	}
	
	function formatUnexpectedArgument(arg) {
	  var type = typeof arg;
	  if (type !== 'object') {
	    return type;
	  }
	  var displayName = arg.constructor && arg.constructor.name || type;
	  var keys = Object.keys(arg);
	  if (keys.length > 0 && keys.length < 20) {
	    return displayName + ' (keys: ' + keys.join(', ') + ')';
	  }
	  return displayName;
	}
	
	function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
	  var internalInstance = ReactInstanceMap.get(publicInstance);
	  if (!internalInstance) {
	    if (true) {
	      var ctor = publicInstance.constructor;
	      // Only warn when we have a callerName. Otherwise we should be silent.
	      // We're probably calling from enqueueCallback. We don't want to warn
	      // there because we already warned for the corresponding lifecycle method.
	       true ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, ctor && (ctor.displayName || ctor.name) || 'ReactClass') : void 0;
	    }
	    return null;
	  }
	
	  if (true) {
	     true ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition (such as ' + "within `render` or another component's constructor). Render methods " + 'should be a pure function of props and state; constructor ' + 'side-effects are an anti-pattern, but can be moved to ' + '`componentWillMount`.', callerName) : void 0;
	  }
	
	  return internalInstance;
	}
	
	/**
	 * ReactUpdateQueue allows for state updates to be scheduled into a later
	 * reconciliation step.
	 */
	var ReactUpdateQueue = {
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function (publicInstance) {
	    if (true) {
	      var owner = ReactCurrentOwner.current;
	      if (owner !== null) {
	         true ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
	        owner._warnedAboutRefsInRender = true;
	      }
	    }
	    var internalInstance = ReactInstanceMap.get(publicInstance);
	    if (internalInstance) {
	      // During componentWillMount and render this will still be null but after
	      // that will always render to something. At least for now. So we can use
	      // this hack.
	      return !!internalInstance._renderedComponent;
	    } else {
	      return false;
	    }
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @param {string} callerName Name of the calling function in the public API.
	   * @internal
	   */
	  enqueueCallback: function (publicInstance, callback, callerName) {
	    ReactUpdateQueue.validateCallback(callback, callerName);
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);
	
	    // Previously we would throw an error if we didn't have an internal
	    // instance. Since we want to make it a no-op instead, we mirror the same
	    // behavior we have in other enqueue* methods.
	    // We also need to ignore callbacks in componentWillMount. See
	    // enqueueUpdates.
	    if (!internalInstance) {
	      return null;
	    }
	
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    // TODO: The callback here is ignored when setState is called from
	    // componentWillMount. Either fix it or disallow doing so completely in
	    // favor of getInitialState. Alternatively, we can disallow
	    // componentWillMount during server-side rendering.
	    enqueueUpdate(internalInstance);
	  },
	
	  enqueueCallbackInternal: function (internalInstance, callback) {
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function (publicInstance) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingForceUpdate = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function (publicInstance, completeState, callback) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingStateQueue = [completeState];
	    internalInstance._pendingReplaceState = true;
	
	    // Future-proof 15.5
	    if (callback !== undefined && callback !== null) {
	      ReactUpdateQueue.validateCallback(callback, 'replaceState');
	      if (internalInstance._pendingCallbacks) {
	        internalInstance._pendingCallbacks.push(callback);
	      } else {
	        internalInstance._pendingCallbacks = [callback];
	      }
	    }
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function (publicInstance, partialState) {
	    if (true) {
	      ReactInstrumentation.debugTool.onSetState();
	       true ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : void 0;
	    }
	
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
	    queue.push(partialState);
	
	    enqueueUpdate(internalInstance);
	  },
	
	  enqueueElementInternal: function (internalInstance, nextElement, nextContext) {
	    internalInstance._pendingElement = nextElement;
	    // TODO: introduce _pendingContext instead of setting it directly.
	    internalInstance._context = nextContext;
	    enqueueUpdate(internalInstance);
	  },
	
	  validateCallback: function (callback, callerName) {
	    !(!callback || typeof callback === 'function') ?  true ? invariant(false, '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.', callerName, formatUnexpectedArgument(callback)) : _prodInvariant('122', callerName, formatUnexpectedArgument(callback)) : void 0;
	  }
	};
	
	module.exports = ReactUpdateQueue;

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var emptyFunction = __webpack_require__(9);
	var warning = __webpack_require__(8);
	
	var validateDOMNesting = emptyFunction;
	
	if (true) {
	  // This validation code was written based on the HTML5 parsing spec:
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  //
	  // Note: this does not catch all invalid nesting, nor does it try to (as it's
	  // not clear what practical benefit doing so provides); instead, we warn only
	  // for cases where the parser will give a parse tree differing from what React
	  // intended. For example, <b><div></div></b> is invalid but we don't warn
	  // because it still parses correctly; we do warn for other cases like nested
	  // <p> tags where the beginning of the second element implicitly closes the
	  // first, causing a confusing mess.
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#special
	  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
	  // TODO: Distinguish by namespace here -- for <title>, including it here
	  // errs on the side of fewer warnings
	  'foreignObject', 'desc', 'title'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
	  var buttonScopeTags = inScopeTags.concat(['button']);
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
	  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];
	
	  var emptyAncestorInfo = {
	    current: null,
	
	    formTag: null,
	    aTagInScope: null,
	    buttonTagInScope: null,
	    nobrTagInScope: null,
	    pTagInButtonScope: null,
	
	    listItemTagAutoclosing: null,
	    dlItemTagAutoclosing: null
	  };
	
	  var updatedAncestorInfo = function (oldInfo, tag, instance) {
	    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
	    var info = { tag: tag, instance: instance };
	
	    if (inScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.aTagInScope = null;
	      ancestorInfo.buttonTagInScope = null;
	      ancestorInfo.nobrTagInScope = null;
	    }
	    if (buttonScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.pTagInButtonScope = null;
	    }
	
	    // See rules for 'li', 'dd', 'dt' start tags in
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
	      ancestorInfo.listItemTagAutoclosing = null;
	      ancestorInfo.dlItemTagAutoclosing = null;
	    }
	
	    ancestorInfo.current = info;
	
	    if (tag === 'form') {
	      ancestorInfo.formTag = info;
	    }
	    if (tag === 'a') {
	      ancestorInfo.aTagInScope = info;
	    }
	    if (tag === 'button') {
	      ancestorInfo.buttonTagInScope = info;
	    }
	    if (tag === 'nobr') {
	      ancestorInfo.nobrTagInScope = info;
	    }
	    if (tag === 'p') {
	      ancestorInfo.pTagInButtonScope = info;
	    }
	    if (tag === 'li') {
	      ancestorInfo.listItemTagAutoclosing = info;
	    }
	    if (tag === 'dd' || tag === 'dt') {
	      ancestorInfo.dlItemTagAutoclosing = info;
	    }
	
	    return ancestorInfo;
	  };
	
	  /**
	   * Returns whether
	   */
	  var isTagValidWithParent = function (tag, parentTag) {
	    // First, let's check if we're in an unusual parsing mode...
	    switch (parentTag) {
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
	      case 'select':
	        return tag === 'option' || tag === 'optgroup' || tag === '#text';
	      case 'optgroup':
	        return tag === 'option' || tag === '#text';
	      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
	      // but
	      case 'option':
	        return tag === '#text';
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
	      // No special behavior since these rules fall back to "in body" mode for
	      // all except special table nodes which cause bad parsing behavior anyway.
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
	      case 'tr':
	        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
	      case 'tbody':
	      case 'thead':
	      case 'tfoot':
	        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
	      case 'colgroup':
	        return tag === 'col' || tag === 'template';
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
	      case 'table':
	        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
	      case 'head':
	        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
	      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
	      case 'html':
	        return tag === 'head' || tag === 'body';
	      case '#document':
	        return tag === 'html';
	    }
	
	    // Probably in the "in body" parsing mode, so we outlaw only tag combos
	    // where the parsing rules cause implicit opens or closes to be added.
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    switch (tag) {
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';
	
	      case 'rp':
	      case 'rt':
	        return impliedEndTags.indexOf(parentTag) === -1;
	
	      case 'body':
	      case 'caption':
	      case 'col':
	      case 'colgroup':
	      case 'frame':
	      case 'head':
	      case 'html':
	      case 'tbody':
	      case 'td':
	      case 'tfoot':
	      case 'th':
	      case 'thead':
	      case 'tr':
	        // These tags are only valid with a few parents that have special child
	        // parsing rules -- if we're down here, then none of those matched and
	        // so we allow it only if we don't know what the parent is, as all other
	        // cases are invalid.
	        return parentTag == null;
	    }
	
	    return true;
	  };
	
	  /**
	   * Returns whether
	   */
	  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
	    switch (tag) {
	      case 'address':
	      case 'article':
	      case 'aside':
	      case 'blockquote':
	      case 'center':
	      case 'details':
	      case 'dialog':
	      case 'dir':
	      case 'div':
	      case 'dl':
	      case 'fieldset':
	      case 'figcaption':
	      case 'figure':
	      case 'footer':
	      case 'header':
	      case 'hgroup':
	      case 'main':
	      case 'menu':
	      case 'nav':
	      case 'ol':
	      case 'p':
	      case 'section':
	      case 'summary':
	      case 'ul':
	      case 'pre':
	      case 'listing':
	      case 'table':
	      case 'hr':
	      case 'xmp':
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return ancestorInfo.pTagInButtonScope;
	
	      case 'form':
	        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
	
	      case 'li':
	        return ancestorInfo.listItemTagAutoclosing;
	
	      case 'dd':
	      case 'dt':
	        return ancestorInfo.dlItemTagAutoclosing;
	
	      case 'button':
	        return ancestorInfo.buttonTagInScope;
	
	      case 'a':
	        // Spec says something about storing a list of markers, but it sounds
	        // equivalent to this check.
	        return ancestorInfo.aTagInScope;
	
	      case 'nobr':
	        return ancestorInfo.nobrTagInScope;
	    }
	
	    return null;
	  };
	
	  /**
	   * Given a ReactCompositeComponent instance, return a list of its recursive
	   * owners, starting at the root and ending with the instance itself.
	   */
	  var findOwnerStack = function (instance) {
	    if (!instance) {
	      return [];
	    }
	
	    var stack = [];
	    do {
	      stack.push(instance);
	    } while (instance = instance._currentElement._owner);
	    stack.reverse();
	    return stack;
	  };
	
	  var didWarn = {};
	
	  validateDOMNesting = function (childTag, childText, childInstance, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.current;
	    var parentTag = parentInfo && parentInfo.tag;
	
	    if (childText != null) {
	       true ? warning(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null') : void 0;
	      childTag = '#text';
	    }
	
	    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
	    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
	    var problematic = invalidParent || invalidAncestor;
	
	    if (problematic) {
	      var ancestorTag = problematic.tag;
	      var ancestorInstance = problematic.instance;
	
	      var childOwner = childInstance && childInstance._currentElement._owner;
	      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;
	
	      var childOwners = findOwnerStack(childOwner);
	      var ancestorOwners = findOwnerStack(ancestorOwner);
	
	      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
	      var i;
	
	      var deepestCommon = -1;
	      for (i = 0; i < minStackLen; i++) {
	        if (childOwners[i] === ancestorOwners[i]) {
	          deepestCommon = i;
	        } else {
	          break;
	        }
	      }
	
	      var UNKNOWN = '(unknown)';
	      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ownerInfo = [].concat(
	      // If the parent and child instances have a common owner ancestor, start
	      // with that -- otherwise we just start with the parent's owners.
	      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
	      // If we're warning about an invalid (non-parent) ancestry, add '...'
	      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');
	
	      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
	      if (didWarn[warnKey]) {
	        return;
	      }
	      didWarn[warnKey] = true;
	
	      var tagDisplayName = childTag;
	      var whitespaceInfo = '';
	      if (childTag === '#text') {
	        if (/\S/.test(childText)) {
	          tagDisplayName = 'Text nodes';
	        } else {
	          tagDisplayName = 'Whitespace text nodes';
	          whitespaceInfo = " Make sure you don't have any extra whitespace between tags on " + 'each line of your source code.';
	        }
	      } else {
	        tagDisplayName = '<' + childTag + '>';
	      }
	
	      if (invalidParent) {
	        var info = '';
	        if (ancestorTag === 'table' && childTag === 'tr') {
	          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
	        }
	         true ? warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s ' + 'See %s.%s', tagDisplayName, ancestorTag, whitespaceInfo, ownerInfo, info) : void 0;
	      } else {
	         true ? warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>. See %s.', tagDisplayName, ancestorTag, ownerInfo) : void 0;
	      }
	    }
	  };
	
	  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;
	
	  // For testing
	  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.current;
	    var parentTag = parentInfo && parentInfo.tag;
	    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
	  };
	}
	
	module.exports = validateDOMNesting;

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var DOMLazyTree = __webpack_require__(88);
	var ReactDOMComponentTree = __webpack_require__(40);
	
	var ReactDOMEmptyComponent = function (instantiate) {
	  // ReactCompositeComponent uses this:
	  this._currentElement = null;
	  // ReactDOMComponentTree uses these:
	  this._hostNode = null;
	  this._hostParent = null;
	  this._hostContainerInfo = null;
	  this._domID = 0;
	};
	_assign(ReactDOMEmptyComponent.prototype, {
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    var domID = hostContainerInfo._idCounter++;
	    this._domID = domID;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;
	
	    var nodeValue = ' react-empty: ' + this._domID + ' ';
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var node = ownerDocument.createComment(nodeValue);
	      ReactDOMComponentTree.precacheNode(this, node);
	      return DOMLazyTree(node);
	    } else {
	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd insert a comment node, but since this is a situation
	        // where React won't take over (static pages), we can simply return
	        // nothing.
	        return '';
	      }
	      return '<!--' + nodeValue + '-->';
	    }
	  },
	  receiveComponent: function () {},
	  getHostNode: function () {
	    return ReactDOMComponentTree.getNodeFromInstance(this);
	  },
	  unmountComponent: function () {
	    ReactDOMComponentTree.uncacheNode(this);
	  }
	});
	
	module.exports = ReactDOMEmptyComponent;

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(41);
	
	var invariant = __webpack_require__(12);
	
	/**
	 * Return the lowest common ancestor of A and B, or null if they are in
	 * different trees.
	 */
	function getLowestCommonAncestor(instA, instB) {
	  !('_hostNode' in instA) ?  true ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	  !('_hostNode' in instB) ?  true ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	
	  var depthA = 0;
	  for (var tempA = instA; tempA; tempA = tempA._hostParent) {
	    depthA++;
	  }
	  var depthB = 0;
	  for (var tempB = instB; tempB; tempB = tempB._hostParent) {
	    depthB++;
	  }
	
	  // If A is deeper, crawl up.
	  while (depthA - depthB > 0) {
	    instA = instA._hostParent;
	    depthA--;
	  }
	
	  // If B is deeper, crawl up.
	  while (depthB - depthA > 0) {
	    instB = instB._hostParent;
	    depthB--;
	  }
	
	  // Walk in lockstep until we find a match.
	  var depth = depthA;
	  while (depth--) {
	    if (instA === instB) {
	      return instA;
	    }
	    instA = instA._hostParent;
	    instB = instB._hostParent;
	  }
	  return null;
	}
	
	/**
	 * Return if A is an ancestor of B.
	 */
	function isAncestor(instA, instB) {
	  !('_hostNode' in instA) ?  true ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
	  !('_hostNode' in instB) ?  true ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
	
	  while (instB) {
	    if (instB === instA) {
	      return true;
	    }
	    instB = instB._hostParent;
	  }
	  return false;
	}
	
	/**
	 * Return the parent instance of the passed-in instance.
	 */
	function getParentInstance(inst) {
	  !('_hostNode' in inst) ?  true ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant('36') : void 0;
	
	  return inst._hostParent;
	}
	
	/**
	 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
	 */
	function traverseTwoPhase(inst, fn, arg) {
	  var path = [];
	  while (inst) {
	    path.push(inst);
	    inst = inst._hostParent;
	  }
	  var i;
	  for (i = path.length; i-- > 0;) {
	    fn(path[i], 'captured', arg);
	  }
	  for (i = 0; i < path.length; i++) {
	    fn(path[i], 'bubbled', arg);
	  }
	}
	
	/**
	 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
	 * should would receive a `mouseEnter` or `mouseLeave` event.
	 *
	 * Does not invoke the callback on the nearest common ancestor because nothing
	 * "entered" or "left" that element.
	 */
	function traverseEnterLeave(from, to, fn, argFrom, argTo) {
	  var common = from && to ? getLowestCommonAncestor(from, to) : null;
	  var pathFrom = [];
	  while (from && from !== common) {
	    pathFrom.push(from);
	    from = from._hostParent;
	  }
	  var pathTo = [];
	  while (to && to !== common) {
	    pathTo.push(to);
	    to = to._hostParent;
	  }
	  var i;
	  for (i = 0; i < pathFrom.length; i++) {
	    fn(pathFrom[i], 'bubbled', argFrom);
	  }
	  for (i = pathTo.length; i-- > 0;) {
	    fn(pathTo[i], 'captured', argTo);
	  }
	}
	
	module.exports = {
	  isAncestor: isAncestor,
	  getLowestCommonAncestor: getLowestCommonAncestor,
	  getParentInstance: getParentInstance,
	  traverseTwoPhase: traverseTwoPhase,
	  traverseEnterLeave: traverseEnterLeave
	};

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(41),
	    _assign = __webpack_require__(4);
	
	var DOMChildrenOperations = __webpack_require__(87);
	var DOMLazyTree = __webpack_require__(88);
	var ReactDOMComponentTree = __webpack_require__(40);
	
	var escapeTextContentForBrowser = __webpack_require__(93);
	var invariant = __webpack_require__(12);
	var validateDOMNesting = __webpack_require__(143);
	
	/**
	 * Text nodes violate a couple assumptions that React makes about components:
	 *
	 *  - When mounting text into the DOM, adjacent text nodes are merged.
	 *  - Text nodes cannot be assigned a React root ID.
	 *
	 * This component is used to wrap strings between comment nodes so that they
	 * can undergo the same reconciliation that is applied to elements.
	 *
	 * TODO: Investigate representing React components in the DOM with text nodes.
	 *
	 * @class ReactDOMTextComponent
	 * @extends ReactComponent
	 * @internal
	 */
	var ReactDOMTextComponent = function (text) {
	  // TODO: This is really a ReactText (ReactNode), not a ReactElement
	  this._currentElement = text;
	  this._stringText = '' + text;
	  // ReactDOMComponentTree uses these:
	  this._hostNode = null;
	  this._hostParent = null;
	
	  // Properties
	  this._domID = 0;
	  this._mountIndex = 0;
	  this._closingComment = null;
	  this._commentNodes = null;
	};
	
	_assign(ReactDOMTextComponent.prototype, {
	  /**
	   * Creates the markup for this text node. This node is not intended to have
	   * any features besides containing text content.
	   *
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {string} Markup for this text node.
	   * @internal
	   */
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    if (true) {
	      var parentInfo;
	      if (hostParent != null) {
	        parentInfo = hostParent._ancestorInfo;
	      } else if (hostContainerInfo != null) {
	        parentInfo = hostContainerInfo._ancestorInfo;
	      }
	      if (parentInfo) {
	        // parentInfo should always be present except for the top-level
	        // component when server rendering
	        validateDOMNesting(null, this._stringText, this, parentInfo);
	      }
	    }
	
	    var domID = hostContainerInfo._idCounter++;
	    var openingValue = ' react-text: ' + domID + ' ';
	    var closingValue = ' /react-text ';
	    this._domID = domID;
	    this._hostParent = hostParent;
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var openingComment = ownerDocument.createComment(openingValue);
	      var closingComment = ownerDocument.createComment(closingValue);
	      var lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());
	      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));
	      if (this._stringText) {
	        DOMLazyTree.queueChild(lazyTree, DOMLazyTree(ownerDocument.createTextNode(this._stringText)));
	      }
	      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));
	      ReactDOMComponentTree.precacheNode(this, openingComment);
	      this._closingComment = closingComment;
	      return lazyTree;
	    } else {
	      var escapedText = escapeTextContentForBrowser(this._stringText);
	
	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd wrap this between comment nodes for the reasons stated
	        // above, but since this is a situation where React won't take over
	        // (static pages), we can simply return the text as it is.
	        return escapedText;
	      }
	
	      return '<!--' + openingValue + '-->' + escapedText + '<!--' + closingValue + '-->';
	    }
	  },
	
	  /**
	   * Updates this component by updating the text content.
	   *
	   * @param {ReactText} nextText The next text content
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  receiveComponent: function (nextText, transaction) {
	    if (nextText !== this._currentElement) {
	      this._currentElement = nextText;
	      var nextStringText = '' + nextText;
	      if (nextStringText !== this._stringText) {
	        // TODO: Save this as pending props and use performUpdateIfNecessary
	        // and/or updateComponent to do the actual update for consistency with
	        // other component types?
	        this._stringText = nextStringText;
	        var commentNodes = this.getHostNode();
	        DOMChildrenOperations.replaceDelimitedText(commentNodes[0], commentNodes[1], nextStringText);
	      }
	    }
	  },
	
	  getHostNode: function () {
	    var hostNode = this._commentNodes;
	    if (hostNode) {
	      return hostNode;
	    }
	    if (!this._closingComment) {
	      var openingComment = ReactDOMComponentTree.getNodeFromInstance(this);
	      var node = openingComment.nextSibling;
	      while (true) {
	        !(node != null) ?  true ? invariant(false, 'Missing closing comment for text component %s', this._domID) : _prodInvariant('67', this._domID) : void 0;
	        if (node.nodeType === 8 && node.nodeValue === ' /react-text ') {
	          this._closingComment = node;
	          break;
	        }
	        node = node.nextSibling;
	      }
	    }
	    hostNode = [this._hostNode, this._closingComment];
	    this._commentNodes = hostNode;
	    return hostNode;
	  },
	
	  unmountComponent: function () {
	    this._closingComment = null;
	    this._commentNodes = null;
	    ReactDOMComponentTree.uncacheNode(this);
	  }
	});
	
	module.exports = ReactDOMTextComponent;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var ReactUpdates = __webpack_require__(62);
	var Transaction = __webpack_require__(74);
	
	var emptyFunction = __webpack_require__(9);
	
	var RESET_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: function () {
	    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
	  }
	};
	
	var FLUSH_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
	};
	
	var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];
	
	function ReactDefaultBatchingStrategyTransaction() {
	  this.reinitializeTransaction();
	}
	
	_assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, {
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  }
	});
	
	var transaction = new ReactDefaultBatchingStrategyTransaction();
	
	var ReactDefaultBatchingStrategy = {
	  isBatchingUpdates: false,
	
	  /**
	   * Call the provided function in a context within which calls to `setState`
	   * and friends are batched such that components aren't updated unnecessarily.
	   */
	  batchedUpdates: function (callback, a, b, c, d, e) {
	    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
	
	    ReactDefaultBatchingStrategy.isBatchingUpdates = true;
	
	    // The code is written this way to avoid extra allocations
	    if (alreadyBatchingUpdates) {
	      return callback(a, b, c, d, e);
	    } else {
	      return transaction.perform(callback, null, a, b, c, d, e);
	    }
	  }
	};
	
	module.exports = ReactDefaultBatchingStrategy;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var EventListener = __webpack_require__(149);
	var ExecutionEnvironment = __webpack_require__(54);
	var PooledClass = __webpack_require__(56);
	var ReactDOMComponentTree = __webpack_require__(40);
	var ReactUpdates = __webpack_require__(62);
	
	var getEventTarget = __webpack_require__(76);
	var getUnboundedScrollPosition = __webpack_require__(150);
	
	/**
	 * Find the deepest React component completely containing the root of the
	 * passed-in instance (for use when entire React trees are nested within each
	 * other). If React trees are not nested, returns null.
	 */
	function findParent(inst) {
	  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
	  // traversal, but caching is difficult to do correctly without using a
	  // mutation observer to listen for all DOM changes.
	  while (inst._hostParent) {
	    inst = inst._hostParent;
	  }
	  var rootNode = ReactDOMComponentTree.getNodeFromInstance(inst);
	  var container = rootNode.parentNode;
	  return ReactDOMComponentTree.getClosestInstanceFromNode(container);
	}
	
	// Used to store ancestor hierarchy in top level callback
	function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
	  this.topLevelType = topLevelType;
	  this.nativeEvent = nativeEvent;
	  this.ancestors = [];
	}
	_assign(TopLevelCallbackBookKeeping.prototype, {
	  destructor: function () {
	    this.topLevelType = null;
	    this.nativeEvent = null;
	    this.ancestors.length = 0;
	  }
	});
	PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);
	
	function handleTopLevelImpl(bookKeeping) {
	  var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
	  var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);
	
	  // Loop through the hierarchy, in case there's any nested components.
	  // It's important that we build the array of ancestors before calling any
	  // event handlers, because event handlers can modify the DOM, leading to
	  // inconsistencies with ReactMount's node cache. See #1105.
	  var ancestor = targetInst;
	  do {
	    bookKeeping.ancestors.push(ancestor);
	    ancestor = ancestor && findParent(ancestor);
	  } while (ancestor);
	
	  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
	    targetInst = bookKeeping.ancestors[i];
	    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
	  }
	}
	
	function scrollValueMonitor(cb) {
	  var scrollPosition = getUnboundedScrollPosition(window);
	  cb(scrollPosition);
	}
	
	var ReactEventListener = {
	  _enabled: true,
	  _handleTopLevel: null,
	
	  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,
	
	  setHandleTopLevel: function (handleTopLevel) {
	    ReactEventListener._handleTopLevel = handleTopLevel;
	  },
	
	  setEnabled: function (enabled) {
	    ReactEventListener._enabled = !!enabled;
	  },
	
	  isEnabled: function () {
	    return ReactEventListener._enabled;
	  },
	
	  /**
	   * Traps top-level events by using event bubbling.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} element Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapBubbledEvent: function (topLevelType, handlerBaseName, element) {
	    if (!element) {
	      return null;
	    }
	    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  /**
	   * Traps a top-level event by using event capturing.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} element Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapCapturedEvent: function (topLevelType, handlerBaseName, element) {
	    if (!element) {
	      return null;
	    }
	    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  monitorScrollValue: function (refresh) {
	    var callback = scrollValueMonitor.bind(null, refresh);
	    EventListener.listen(window, 'scroll', callback);
	  },
	
	  dispatchEvent: function (topLevelType, nativeEvent) {
	    if (!ReactEventListener._enabled) {
	      return;
	    }
	
	    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
	    try {
	      // Event queue being processed in the same cycle allows
	      // `preventDefault`.
	      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
	    } finally {
	      TopLevelCallbackBookKeeping.release(bookKeeping);
	    }
	  }
	};
	
	module.exports = ReactEventListener;

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 */
	
	var emptyFunction = __webpack_require__(9);
	
	/**
	 * Upstream version of event listener. Does not take into account specific
	 * nature of platform.
	 */
	var EventListener = {
	  /**
	   * Listen to DOM events during the bubble phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  listen: function listen(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, false);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, false);
	        }
	      };
	    } else if (target.attachEvent) {
	      target.attachEvent('on' + eventType, callback);
	      return {
	        remove: function remove() {
	          target.detachEvent('on' + eventType, callback);
	        }
	      };
	    }
	  },
	
	  /**
	   * Listen to DOM events during the capture phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  capture: function capture(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, true);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, true);
	        }
	      };
	    } else {
	      if (true) {
	        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
	      }
	      return {
	        remove: emptyFunction
	      };
	    }
	  },
	
	  registerDefault: function registerDefault() {}
	};
	
	module.exports = EventListener;

/***/ }),
/* 150 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	/**
	 * Gets the scroll position of the supplied element or window.
	 *
	 * The return values are unbounded, unlike `getScrollPosition`. This means they
	 * may be negative or exceed the element boundaries (which is possible using
	 * inertial scrolling).
	 *
	 * @param {DOMWindow|DOMElement} scrollable
	 * @return {object} Map with `x` and `y` keys.
	 */
	
	function getUnboundedScrollPosition(scrollable) {
	  if (scrollable.Window && scrollable instanceof scrollable.Window) {
	    return {
	      x: scrollable.pageXOffset || scrollable.document.documentElement.scrollLeft,
	      y: scrollable.pageYOffset || scrollable.document.documentElement.scrollTop
	    };
	  }
	  return {
	    x: scrollable.scrollLeft,
	    y: scrollable.scrollTop
	  };
	}
	
	module.exports = getUnboundedScrollPosition;

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(42);
	var EventPluginHub = __webpack_require__(48);
	var EventPluginUtils = __webpack_require__(50);
	var ReactComponentEnvironment = __webpack_require__(122);
	var ReactEmptyComponent = __webpack_require__(132);
	var ReactBrowserEventEmitter = __webpack_require__(112);
	var ReactHostComponent = __webpack_require__(133);
	var ReactUpdates = __webpack_require__(62);
	
	var ReactInjection = {
	  Component: ReactComponentEnvironment.injection,
	  DOMProperty: DOMProperty.injection,
	  EmptyComponent: ReactEmptyComponent.injection,
	  EventPluginHub: EventPluginHub.injection,
	  EventPluginUtils: EventPluginUtils.injection,
	  EventEmitter: ReactBrowserEventEmitter.injection,
	  HostComponent: ReactHostComponent.injection,
	  Updates: ReactUpdates.injection
	};
	
	module.exports = ReactInjection;

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(4);
	
	var CallbackQueue = __webpack_require__(63);
	var PooledClass = __webpack_require__(56);
	var ReactBrowserEventEmitter = __webpack_require__(112);
	var ReactInputSelection = __webpack_require__(153);
	var ReactInstrumentation = __webpack_require__(68);
	var Transaction = __webpack_require__(74);
	var ReactUpdateQueue = __webpack_require__(142);
	
	/**
	 * Ensures that, when possible, the selection range (currently selected text
	 * input) is not disturbed by performing the transaction.
	 */
	var SELECTION_RESTORATION = {
	  /**
	   * @return {Selection} Selection information.
	   */
	  initialize: ReactInputSelection.getSelectionInformation,
	  /**
	   * @param {Selection} sel Selection information returned from `initialize`.
	   */
	  close: ReactInputSelection.restoreSelection
	};
	
	/**
	 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
	 * high level DOM manipulations (like temporarily removing a text input from the
	 * DOM).
	 */
	var EVENT_SUPPRESSION = {
	  /**
	   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
	   * the reconciliation.
	   */
	  initialize: function () {
	    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
	    ReactBrowserEventEmitter.setEnabled(false);
	    return currentlyEnabled;
	  },
	
	  /**
	   * @param {boolean} previouslyEnabled Enabled status of
	   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
	   *   restores the previous value.
	   */
	  close: function (previouslyEnabled) {
	    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
	  }
	};
	
	/**
	 * Provides a queue for collecting `componentDidMount` and
	 * `componentDidUpdate` callbacks during the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function () {
	    this.reactMountReady.reset();
	  },
	
	  /**
	   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
	   */
	  close: function () {
	    this.reactMountReady.notifyAll();
	  }
	};
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];
	
	if (true) {
	  TRANSACTION_WRAPPERS.push({
	    initialize: ReactInstrumentation.debugTool.onBeginFlush,
	    close: ReactInstrumentation.debugTool.onEndFlush
	  });
	}
	
	/**
	 * Currently:
	 * - The order that these are listed in the transaction is critical:
	 * - Suppresses events.
	 * - Restores selection range.
	 *
	 * Future:
	 * - Restore document/overflow scroll positions that were unintentionally
	 *   modified via DOM insertions above the top viewport boundary.
	 * - Implement/integrate with customized constraint based layout system and keep
	 *   track of which dimensions must be remeasured.
	 *
	 * @class ReactReconcileTransaction
	 */
	function ReactReconcileTransaction(useCreateElement) {
	  this.reinitializeTransaction();
	  // Only server-side rendering really needs this option (see
	  // `ReactServerRendering`), but server-side uses
	  // `ReactServerRenderingTransaction` instead. This option is here so that it's
	  // accessible and defaults to false when `ReactDOMComponent` and
	  // `ReactDOMTextComponent` checks it in `mountComponent`.`
	  this.renderToStaticMarkup = false;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.useCreateElement = useCreateElement;
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array<object>} List of operation wrap procedures.
	   *   TODO: convert to array<TransactionWrapper>
	   */
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function () {
	    return this.reactMountReady;
	  },
	
	  /**
	   * @return {object} The queue to collect React async events.
	   */
	  getUpdateQueue: function () {
	    return ReactUpdateQueue;
	  },
	
	  /**
	   * Save current transaction state -- if the return value from this method is
	   * passed to `rollback`, the transaction will be reset to that state.
	   */
	  checkpoint: function () {
	    // reactMountReady is the our only stateful wrapper
	    return this.reactMountReady.checkpoint();
	  },
	
	  rollback: function (checkpoint) {
	    this.reactMountReady.rollback(checkpoint);
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function () {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	  }
	};
	
	_assign(ReactReconcileTransaction.prototype, Transaction, Mixin);
	
	PooledClass.addPoolingTo(ReactReconcileTransaction);
	
	module.exports = ReactReconcileTransaction;

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var ReactDOMSelection = __webpack_require__(154);
	
	var containsNode = __webpack_require__(156);
	var focusNode = __webpack_require__(101);
	var getActiveElement = __webpack_require__(159);
	
	function isInDocument(node) {
	  return containsNode(document.documentElement, node);
	}
	
	/**
	 * @ReactInputSelection: React input selection module. Based on Selection.js,
	 * but modified to be suitable for react and has a couple of bug fixes (doesn't
	 * assume buttons have range selections allowed).
	 * Input selection module for React.
	 */
	var ReactInputSelection = {
	  hasSelectionCapabilities: function (elem) {
	    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
	  },
	
	  getSelectionInformation: function () {
	    var focusedElem = getActiveElement();
	    return {
	      focusedElem: focusedElem,
	      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
	    };
	  },
	
	  /**
	   * @restoreSelection: If any selection information was potentially lost,
	   * restore it. This is useful when performing operations that could remove dom
	   * nodes and place them back in, resulting in focus being lost.
	   */
	  restoreSelection: function (priorSelectionInformation) {
	    var curFocusedElem = getActiveElement();
	    var priorFocusedElem = priorSelectionInformation.focusedElem;
	    var priorSelectionRange = priorSelectionInformation.selectionRange;
	    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
	      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
	        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
	      }
	      focusNode(priorFocusedElem);
	    }
	  },
	
	  /**
	   * @getSelection: Gets the selection bounds of a focused textarea, input or
	   * contentEditable node.
	   * -@input: Look up selection bounds of this input
	   * -@return {start: selectionStart, end: selectionEnd}
	   */
	  getSelection: function (input) {
	    var selection;
	
	    if ('selectionStart' in input) {
	      // Modern browser with input or textarea.
	      selection = {
	        start: input.selectionStart,
	        end: input.selectionEnd
	      };
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      // IE8 input.
	      var range = document.selection.createRange();
	      // There can only be one selection per document in IE, so it must
	      // be in our element.
	      if (range.parentElement() === input) {
	        selection = {
	          start: -range.moveStart('character', -input.value.length),
	          end: -range.moveEnd('character', -input.value.length)
	        };
	      }
	    } else {
	      // Content editable or old IE textarea.
	      selection = ReactDOMSelection.getOffsets(input);
	    }
	
	    return selection || { start: 0, end: 0 };
	  },
	
	  /**
	   * @setSelection: Sets the selection bounds of a textarea or input and focuses
	   * the input.
	   * -@input     Set selection bounds of this input or textarea
	   * -@offsets   Object of same form that is returned from get*
	   */
	  setSelection: function (input, offsets) {
	    var start = offsets.start;
	    var end = offsets.end;
	    if (end === undefined) {
	      end = start;
	    }
	
	    if ('selectionStart' in input) {
	      input.selectionStart = start;
	      input.selectionEnd = Math.min(end, input.value.length);
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      var range = input.createTextRange();
	      range.collapse(true);
	      range.moveStart('character', start);
	      range.moveEnd('character', end - start);
	      range.select();
	    } else {
	      ReactDOMSelection.setOffsets(input, offsets);
	    }
	  }
	};
	
	module.exports = ReactInputSelection;

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(54);
	
	var getNodeForCharacterOffset = __webpack_require__(155);
	var getTextContentAccessor = __webpack_require__(57);
	
	/**
	 * While `isCollapsed` is available on the Selection object and `collapsed`
	 * is available on the Range object, IE11 sometimes gets them wrong.
	 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
	 */
	function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
	  return anchorNode === focusNode && anchorOffset === focusOffset;
	}
	
	/**
	 * Get the appropriate anchor and focus node/offset pairs for IE.
	 *
	 * The catch here is that IE's selection API doesn't provide information
	 * about whether the selection is forward or backward, so we have to
	 * behave as though it's always forward.
	 *
	 * IE text differs from modern selection in that it behaves as though
	 * block elements end with a new line. This means character offsets will
	 * differ between the two APIs.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getIEOffsets(node) {
	  var selection = document.selection;
	  var selectedRange = selection.createRange();
	  var selectedLength = selectedRange.text.length;
	
	  // Duplicate selection so we can move range without breaking user selection.
	  var fromStart = selectedRange.duplicate();
	  fromStart.moveToElementText(node);
	  fromStart.setEndPoint('EndToStart', selectedRange);
	
	  var startOffset = fromStart.text.length;
	  var endOffset = startOffset + selectedLength;
	
	  return {
	    start: startOffset,
	    end: endOffset
	  };
	}
	
	/**
	 * @param {DOMElement} node
	 * @return {?object}
	 */
	function getModernOffsets(node) {
	  var selection = window.getSelection && window.getSelection();
	
	  if (!selection || selection.rangeCount === 0) {
	    return null;
	  }
	
	  var anchorNode = selection.anchorNode;
	  var anchorOffset = selection.anchorOffset;
	  var focusNode = selection.focusNode;
	  var focusOffset = selection.focusOffset;
	
	  var currentRange = selection.getRangeAt(0);
	
	  // In Firefox, range.startContainer and range.endContainer can be "anonymous
	  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
	  // divs do not seem to expose properties, triggering a "Permission denied
	  // error" if any of its properties are accessed. The only seemingly possible
	  // way to avoid erroring is to access a property that typically works for
	  // non-anonymous divs and catch any error that may otherwise arise. See
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
	  try {
	    /* eslint-disable no-unused-expressions */
	    currentRange.startContainer.nodeType;
	    currentRange.endContainer.nodeType;
	    /* eslint-enable no-unused-expressions */
	  } catch (e) {
	    return null;
	  }
	
	  // If the node and offset values are the same, the selection is collapsed.
	  // `Selection.isCollapsed` is available natively, but IE sometimes gets
	  // this value wrong.
	  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
	
	  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;
	
	  var tempRange = currentRange.cloneRange();
	  tempRange.selectNodeContents(node);
	  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
	
	  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);
	
	  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
	  var end = start + rangeLength;
	
	  // Detect whether the selection is backward.
	  var detectionRange = document.createRange();
	  detectionRange.setStart(anchorNode, anchorOffset);
	  detectionRange.setEnd(focusNode, focusOffset);
	  var isBackward = detectionRange.collapsed;
	
	  return {
	    start: isBackward ? end : start,
	    end: isBackward ? start : end
	  };
	}
	
	/**
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setIEOffsets(node, offsets) {
	  var range = document.selection.createRange().duplicate();
	  var start, end;
	
	  if (offsets.end === undefined) {
	    start = offsets.start;
	    end = start;
	  } else if (offsets.start > offsets.end) {
	    start = offsets.end;
	    end = offsets.start;
	  } else {
	    start = offsets.start;
	    end = offsets.end;
	  }
	
	  range.moveToElementText(node);
	  range.moveStart('character', start);
	  range.setEndPoint('EndToStart', range);
	  range.moveEnd('character', end - start);
	  range.select();
	}
	
	/**
	 * In modern non-IE browsers, we can support both forward and backward
	 * selections.
	 *
	 * Note: IE10+ supports the Selection object, but it does not support
	 * the `extend` method, which means that even in modern IE, it's not possible
	 * to programmatically create a backward selection. Thus, for all IE
	 * versions, we use the old IE API to create our selections.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setModernOffsets(node, offsets) {
	  if (!window.getSelection) {
	    return;
	  }
	
	  var selection = window.getSelection();
	  var length = node[getTextContentAccessor()].length;
	  var start = Math.min(offsets.start, length);
	  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);
	
	  // IE 11 uses modern selection, but doesn't support the extend method.
	  // Flip backward selections, so we can set with a single range.
	  if (!selection.extend && start > end) {
	    var temp = end;
	    end = start;
	    start = temp;
	  }
	
	  var startMarker = getNodeForCharacterOffset(node, start);
	  var endMarker = getNodeForCharacterOffset(node, end);
	
	  if (startMarker && endMarker) {
	    var range = document.createRange();
	    range.setStart(startMarker.node, startMarker.offset);
	    selection.removeAllRanges();
	
	    if (start > end) {
	      selection.addRange(range);
	      selection.extend(endMarker.node, endMarker.offset);
	    } else {
	      range.setEnd(endMarker.node, endMarker.offset);
	      selection.addRange(range);
	    }
	  }
	}
	
	var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);
	
	var ReactDOMSelection = {
	  /**
	   * @param {DOMElement} node
	   */
	  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,
	
	  /**
	   * @param {DOMElement|DOMTextNode} node
	   * @param {object} offsets
	   */
	  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
	};
	
	module.exports = ReactDOMSelection;

/***/ }),
/* 155 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	/**
	 * Given any node return the first leaf node without children.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {DOMElement|DOMTextNode}
	 */
	
	function getLeafNode(node) {
	  while (node && node.firstChild) {
	    node = node.firstChild;
	  }
	  return node;
	}
	
	/**
	 * Get the next sibling within a container. This will walk up the
	 * DOM if a node's siblings have been exhausted.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {?DOMElement|DOMTextNode}
	 */
	function getSiblingNode(node) {
	  while (node) {
	    if (node.nextSibling) {
	      return node.nextSibling;
	    }
	    node = node.parentNode;
	  }
	}
	
	/**
	 * Get object describing the nodes which contain characters at offset.
	 *
	 * @param {DOMElement|DOMTextNode} root
	 * @param {number} offset
	 * @return {?object}
	 */
	function getNodeForCharacterOffset(root, offset) {
	  var node = getLeafNode(root);
	  var nodeStart = 0;
	  var nodeEnd = 0;
	
	  while (node) {
	    if (node.nodeType === 3) {
	      nodeEnd = nodeStart + node.textContent.length;
	
	      if (nodeStart <= offset && nodeEnd >= offset) {
	        return {
	          node: node,
	          offset: offset - nodeStart
	        };
	      }
	
	      nodeStart = nodeEnd;
	    }
	
	    node = getLeafNode(getSiblingNode(node));
	  }
	}
	
	module.exports = getNodeForCharacterOffset;

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	var isTextNode = __webpack_require__(157);
	
	/*eslint-disable no-bitwise */
	
	/**
	 * Checks if a given DOM node contains or is another DOM node.
	 */
	function containsNode(outerNode, innerNode) {
	  if (!outerNode || !innerNode) {
	    return false;
	  } else if (outerNode === innerNode) {
	    return true;
	  } else if (isTextNode(outerNode)) {
	    return false;
	  } else if (isTextNode(innerNode)) {
	    return containsNode(outerNode, innerNode.parentNode);
	  } else if ('contains' in outerNode) {
	    return outerNode.contains(innerNode);
	  } else if (outerNode.compareDocumentPosition) {
	    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
	  } else {
	    return false;
	  }
	}
	
	module.exports = containsNode;

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 */
	
	var isNode = __webpack_require__(158);
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM text node.
	 */
	function isTextNode(object) {
	  return isNode(object) && object.nodeType == 3;
	}
	
	module.exports = isTextNode;

/***/ }),
/* 158 */
/***/ (function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 */
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM node.
	 */
	function isNode(object) {
	  var doc = object ? object.ownerDocument || object : document;
	  var defaultView = doc.defaultView || window;
	  return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
	}
	
	module.exports = isNode;

/***/ }),
/* 159 */
/***/ (function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * @typechecks
	 */
	
	/* eslint-disable fb-www/typeof-undefined */
	
	/**
	 * Same as document.activeElement but wraps in a try-catch block. In IE it is
	 * not safe to call document.activeElement if there is nothing focused.
	 *
	 * The activeElement will be null only if the document or document body is not
	 * yet defined.
	 *
	 * @param {?DOMDocument} doc Defaults to current document.
	 * @return {?DOMElement}
	 */
	function getActiveElement(doc) /*?DOMElement*/{
	  doc = doc || (typeof document !== 'undefined' ? document : undefined);
	  if (typeof doc === 'undefined') {
	    return null;
	  }
	  try {
	    return doc.activeElement || doc.body;
	  } catch (e) {
	    return doc.body;
	  }
	}
	
	module.exports = getActiveElement;

/***/ }),
/* 160 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var NS = {
	  xlink: 'http://www.w3.org/1999/xlink',
	  xml: 'http://www.w3.org/XML/1998/namespace'
	};
	
	// We use attributes for everything SVG so let's avoid some duplication and run
	// code instead.
	// The following are all specified in the HTML config already so we exclude here.
	// - class (as className)
	// - color
	// - height
	// - id
	// - lang
	// - max
	// - media
	// - method
	// - min
	// - name
	// - style
	// - target
	// - type
	// - width
	var ATTRS = {
	  accentHeight: 'accent-height',
	  accumulate: 0,
	  additive: 0,
	  alignmentBaseline: 'alignment-baseline',
	  allowReorder: 'allowReorder',
	  alphabetic: 0,
	  amplitude: 0,
	  arabicForm: 'arabic-form',
	  ascent: 0,
	  attributeName: 'attributeName',
	  attributeType: 'attributeType',
	  autoReverse: 'autoReverse',
	  azimuth: 0,
	  baseFrequency: 'baseFrequency',
	  baseProfile: 'baseProfile',
	  baselineShift: 'baseline-shift',
	  bbox: 0,
	  begin: 0,
	  bias: 0,
	  by: 0,
	  calcMode: 'calcMode',
	  capHeight: 'cap-height',
	  clip: 0,
	  clipPath: 'clip-path',
	  clipRule: 'clip-rule',
	  clipPathUnits: 'clipPathUnits',
	  colorInterpolation: 'color-interpolation',
	  colorInterpolationFilters: 'color-interpolation-filters',
	  colorProfile: 'color-profile',
	  colorRendering: 'color-rendering',
	  contentScriptType: 'contentScriptType',
	  contentStyleType: 'contentStyleType',
	  cursor: 0,
	  cx: 0,
	  cy: 0,
	  d: 0,
	  decelerate: 0,
	  descent: 0,
	  diffuseConstant: 'diffuseConstant',
	  direction: 0,
	  display: 0,
	  divisor: 0,
	  dominantBaseline: 'dominant-baseline',
	  dur: 0,
	  dx: 0,
	  dy: 0,
	  edgeMode: 'edgeMode',
	  elevation: 0,
	  enableBackground: 'enable-background',
	  end: 0,
	  exponent: 0,
	  externalResourcesRequired: 'externalResourcesRequired',
	  fill: 0,
	  fillOpacity: 'fill-opacity',
	  fillRule: 'fill-rule',
	  filter: 0,
	  filterRes: 'filterRes',
	  filterUnits: 'filterUnits',
	  floodColor: 'flood-color',
	  floodOpacity: 'flood-opacity',
	  focusable: 0,
	  fontFamily: 'font-family',
	  fontSize: 'font-size',
	  fontSizeAdjust: 'font-size-adjust',
	  fontStretch: 'font-stretch',
	  fontStyle: 'font-style',
	  fontVariant: 'font-variant',
	  fontWeight: 'font-weight',
	  format: 0,
	  from: 0,
	  fx: 0,
	  fy: 0,
	  g1: 0,
	  g2: 0,
	  glyphName: 'glyph-name',
	  glyphOrientationHorizontal: 'glyph-orientation-horizontal',
	  glyphOrientationVertical: 'glyph-orientation-vertical',
	  glyphRef: 'glyphRef',
	  gradientTransform: 'gradientTransform',
	  gradientUnits: 'gradientUnits',
	  hanging: 0,
	  horizAdvX: 'horiz-adv-x',
	  horizOriginX: 'horiz-origin-x',
	  ideographic: 0,
	  imageRendering: 'image-rendering',
	  'in': 0,
	  in2: 0,
	  intercept: 0,
	  k: 0,
	  k1: 0,
	  k2: 0,
	  k3: 0,
	  k4: 0,
	  kernelMatrix: 'kernelMatrix',
	  kernelUnitLength: 'kernelUnitLength',
	  kerning: 0,
	  keyPoints: 'keyPoints',
	  keySplines: 'keySplines',
	  keyTimes: 'keyTimes',
	  lengthAdjust: 'lengthAdjust',
	  letterSpacing: 'letter-spacing',
	  lightingColor: 'lighting-color',
	  limitingConeAngle: 'limitingConeAngle',
	  local: 0,
	  markerEnd: 'marker-end',
	  markerMid: 'marker-mid',
	  markerStart: 'marker-start',
	  markerHeight: 'markerHeight',
	  markerUnits: 'markerUnits',
	  markerWidth: 'markerWidth',
	  mask: 0,
	  maskContentUnits: 'maskContentUnits',
	  maskUnits: 'maskUnits',
	  mathematical: 0,
	  mode: 0,
	  numOctaves: 'numOctaves',
	  offset: 0,
	  opacity: 0,
	  operator: 0,
	  order: 0,
	  orient: 0,
	  orientation: 0,
	  origin: 0,
	  overflow: 0,
	  overlinePosition: 'overline-position',
	  overlineThickness: 'overline-thickness',
	  paintOrder: 'paint-order',
	  panose1: 'panose-1',
	  pathLength: 'pathLength',
	  patternContentUnits: 'patternContentUnits',
	  patternTransform: 'patternTransform',
	  patternUnits: 'patternUnits',
	  pointerEvents: 'pointer-events',
	  points: 0,
	  pointsAtX: 'pointsAtX',
	  pointsAtY: 'pointsAtY',
	  pointsAtZ: 'pointsAtZ',
	  preserveAlpha: 'preserveAlpha',
	  preserveAspectRatio: 'preserveAspectRatio',
	  primitiveUnits: 'primitiveUnits',
	  r: 0,
	  radius: 0,
	  refX: 'refX',
	  refY: 'refY',
	  renderingIntent: 'rendering-intent',
	  repeatCount: 'repeatCount',
	  repeatDur: 'repeatDur',
	  requiredExtensions: 'requiredExtensions',
	  requiredFeatures: 'requiredFeatures',
	  restart: 0,
	  result: 0,
	  rotate: 0,
	  rx: 0,
	  ry: 0,
	  scale: 0,
	  seed: 0,
	  shapeRendering: 'shape-rendering',
	  slope: 0,
	  spacing: 0,
	  specularConstant: 'specularConstant',
	  specularExponent: 'specularExponent',
	  speed: 0,
	  spreadMethod: 'spreadMethod',
	  startOffset: 'startOffset',
	  stdDeviation: 'stdDeviation',
	  stemh: 0,
	  stemv: 0,
	  stitchTiles: 'stitchTiles',
	  stopColor: 'stop-color',
	  stopOpacity: 'stop-opacity',
	  strikethroughPosition: 'strikethrough-position',
	  strikethroughThickness: 'strikethrough-thickness',
	  string: 0,
	  stroke: 0,
	  strokeDasharray: 'stroke-dasharray',
	  strokeDashoffset: 'stroke-dashoffset',
	  strokeLinecap: 'stroke-linecap',
	  strokeLinejoin: 'stroke-linejoin',
	  strokeMiterlimit: 'stroke-miterlimit',
	  strokeOpacity: 'stroke-opacity',
	  strokeWidth: 'stroke-width',
	  surfaceScale: 'surfaceScale',
	  systemLanguage: 'systemLanguage',
	  tableValues: 'tableValues',
	  targetX: 'targetX',
	  targetY: 'targetY',
	  textAnchor: 'text-anchor',
	  textDecoration: 'text-decoration',
	  textRendering: 'text-rendering',
	  textLength: 'textLength',
	  to: 0,
	  transform: 0,
	  u1: 0,
	  u2: 0,
	  underlinePosition: 'underline-position',
	  underlineThickness: 'underline-thickness',
	  unicode: 0,
	  unicodeBidi: 'unicode-bidi',
	  unicodeRange: 'unicode-range',
	  unitsPerEm: 'units-per-em',
	  vAlphabetic: 'v-alphabetic',
	  vHanging: 'v-hanging',
	  vIdeographic: 'v-ideographic',
	  vMathematical: 'v-mathematical',
	  values: 0,
	  vectorEffect: 'vector-effect',
	  version: 0,
	  vertAdvY: 'vert-adv-y',
	  vertOriginX: 'vert-origin-x',
	  vertOriginY: 'vert-origin-y',
	  viewBox: 'viewBox',
	  viewTarget: 'viewTarget',
	  visibility: 0,
	  widths: 0,
	  wordSpacing: 'word-spacing',
	  writingMode: 'writing-mode',
	  x: 0,
	  xHeight: 'x-height',
	  x1: 0,
	  x2: 0,
	  xChannelSelector: 'xChannelSelector',
	  xlinkActuate: 'xlink:actuate',
	  xlinkArcrole: 'xlink:arcrole',
	  xlinkHref: 'xlink:href',
	  xlinkRole: 'xlink:role',
	  xlinkShow: 'xlink:show',
	  xlinkTitle: 'xlink:title',
	  xlinkType: 'xlink:type',
	  xmlBase: 'xml:base',
	  xmlns: 0,
	  xmlnsXlink: 'xmlns:xlink',
	  xmlLang: 'xml:lang',
	  xmlSpace: 'xml:space',
	  y: 0,
	  y1: 0,
	  y2: 0,
	  yChannelSelector: 'yChannelSelector',
	  z: 0,
	  zoomAndPan: 'zoomAndPan'
	};
	
	var SVGDOMPropertyConfig = {
	  Properties: {},
	  DOMAttributeNamespaces: {
	    xlinkActuate: NS.xlink,
	    xlinkArcrole: NS.xlink,
	    xlinkHref: NS.xlink,
	    xlinkRole: NS.xlink,
	    xlinkShow: NS.xlink,
	    xlinkTitle: NS.xlink,
	    xlinkType: NS.xlink,
	    xmlBase: NS.xml,
	    xmlLang: NS.xml,
	    xmlSpace: NS.xml
	  },
	  DOMAttributeNames: {}
	};
	
	Object.keys(ATTRS).forEach(function (key) {
	  SVGDOMPropertyConfig.Properties[key] = 0;
	  if (ATTRS[key]) {
	    SVGDOMPropertyConfig.DOMAttributeNames[key] = ATTRS[key];
	  }
	});
	
	module.exports = SVGDOMPropertyConfig;

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var EventPropagators = __webpack_require__(47);
	var ExecutionEnvironment = __webpack_require__(54);
	var ReactDOMComponentTree = __webpack_require__(40);
	var ReactInputSelection = __webpack_require__(153);
	var SyntheticEvent = __webpack_require__(59);
	
	var getActiveElement = __webpack_require__(159);
	var isTextInputElement = __webpack_require__(78);
	var shallowEqual = __webpack_require__(130);
	
	var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;
	
	var eventTypes = {
	  select: {
	    phasedRegistrationNames: {
	      bubbled: 'onSelect',
	      captured: 'onSelectCapture'
	    },
	    dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']
	  }
	};
	
	var activeElement = null;
	var activeElementInst = null;
	var lastSelection = null;
	var mouseDown = false;
	
	// Track whether a listener exists for this plugin. If none exist, we do
	// not extract events. See #3639.
	var hasListener = false;
	
	/**
	 * Get an object which is a unique representation of the current selection.
	 *
	 * The return value will not be consistent across nodes or browsers, but
	 * two identical selections on the same node will return identical objects.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getSelection(node) {
	  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
	    return {
	      start: node.selectionStart,
	      end: node.selectionEnd
	    };
	  } else if (window.getSelection) {
	    var selection = window.getSelection();
	    return {
	      anchorNode: selection.anchorNode,
	      anchorOffset: selection.anchorOffset,
	      focusNode: selection.focusNode,
	      focusOffset: selection.focusOffset
	    };
	  } else if (document.selection) {
	    var range = document.selection.createRange();
	    return {
	      parentElement: range.parentElement(),
	      text: range.text,
	      top: range.boundingTop,
	      left: range.boundingLeft
	    };
	  }
	}
	
	/**
	 * Poll selection to see whether it's changed.
	 *
	 * @param {object} nativeEvent
	 * @return {?SyntheticEvent}
	 */
	function constructSelectEvent(nativeEvent, nativeEventTarget) {
	  // Ensure we have the right element, and that the user is not dragging a
	  // selection (this matches native `select` event behavior). In HTML5, select
	  // fires only on input and textarea thus if there's no focused element we
	  // won't dispatch.
	  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
	    return null;
	  }
	
	  // Only fire when selection has actually changed.
	  var currentSelection = getSelection(activeElement);
	  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
	    lastSelection = currentSelection;
	
	    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementInst, nativeEvent, nativeEventTarget);
	
	    syntheticEvent.type = 'select';
	    syntheticEvent.target = activeElement;
	
	    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);
	
	    return syntheticEvent;
	  }
	
	  return null;
	}
	
	/**
	 * This plugin creates an `onSelect` event that normalizes select events
	 * across form elements.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - contentEditable
	 *
	 * This differs from native browser implementations in the following ways:
	 * - Fires on contentEditable fields as well as inputs.
	 * - Fires for collapsed selection.
	 * - Fires after user input.
	 */
	var SelectEventPlugin = {
	  eventTypes: eventTypes,
	
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    if (!hasListener) {
	      return null;
	    }
	
	    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;
	
	    switch (topLevelType) {
	      // Track the input node that has focus.
	      case 'topFocus':
	        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
	          activeElement = targetNode;
	          activeElementInst = targetInst;
	          lastSelection = null;
	        }
	        break;
	      case 'topBlur':
	        activeElement = null;
	        activeElementInst = null;
	        lastSelection = null;
	        break;
	      // Don't fire the event while the user is dragging. This matches the
	      // semantics of the native select event.
	      case 'topMouseDown':
	        mouseDown = true;
	        break;
	      case 'topContextMenu':
	      case 'topMouseUp':
	        mouseDown = false;
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	      // Chrome and IE fire non-standard event when selection is changed (and
	      // sometimes when it hasn't). IE's event fires out of order with respect
	      // to key and input events on deletion, so we discard it.
	      //
	      // Firefox doesn't support selectionchange, so check selection status
	      // after each key entry. The selection changes after keydown and before
	      // keyup, but we check on keydown as well in the case of holding down a
	      // key, when multiple keydown events are fired but only one keyup is.
	      // This is also our approach for IE handling, for the reason above.
	      case 'topSelectionChange':
	        if (skipSelectionChangeEvent) {
	          break;
	        }
	      // falls through
	      case 'topKeyDown':
	      case 'topKeyUp':
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	    }
	
	    return null;
	  },
	
	  didPutListener: function (inst, registrationName, listener) {
	    if (registrationName === 'onSelect') {
	      hasListener = true;
	    }
	  }
	};
	
	module.exports = SelectEventPlugin;

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(41);
	
	var EventListener = __webpack_require__(149);
	var EventPropagators = __webpack_require__(47);
	var ReactDOMComponentTree = __webpack_require__(40);
	var SyntheticAnimationEvent = __webpack_require__(163);
	var SyntheticClipboardEvent = __webpack_require__(164);
	var SyntheticEvent = __webpack_require__(59);
	var SyntheticFocusEvent = __webpack_require__(165);
	var SyntheticKeyboardEvent = __webpack_require__(166);
	var SyntheticMouseEvent = __webpack_require__(81);
	var SyntheticDragEvent = __webpack_require__(169);
	var SyntheticTouchEvent = __webpack_require__(170);
	var SyntheticTransitionEvent = __webpack_require__(171);
	var SyntheticUIEvent = __webpack_require__(82);
	var SyntheticWheelEvent = __webpack_require__(172);
	
	var emptyFunction = __webpack_require__(9);
	var getEventCharCode = __webpack_require__(167);
	var invariant = __webpack_require__(12);
	
	/**
	 * Turns
	 * ['abort', ...]
	 * into
	 * eventTypes = {
	 *   'abort': {
	 *     phasedRegistrationNames: {
	 *       bubbled: 'onAbort',
	 *       captured: 'onAbortCapture',
	 *     },
	 *     dependencies: ['topAbort'],
	 *   },
	 *   ...
	 * };
	 * topLevelEventsToDispatchConfig = {
	 *   'topAbort': { sameConfig }
	 * };
	 */
	var eventTypes = {};
	var topLevelEventsToDispatchConfig = {};
	['abort', 'animationEnd', 'animationIteration', 'animationStart', 'blur', 'canPlay', 'canPlayThrough', 'click', 'contextMenu', 'copy', 'cut', 'doubleClick', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'progress', 'rateChange', 'reset', 'scroll', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart', 'transitionEnd', 'volumeChange', 'waiting', 'wheel'].forEach(function (event) {
	  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
	  var onEvent = 'on' + capitalizedEvent;
	  var topEvent = 'top' + capitalizedEvent;
	
	  var type = {
	    phasedRegistrationNames: {
	      bubbled: onEvent,
	      captured: onEvent + 'Capture'
	    },
	    dependencies: [topEvent]
	  };
	  eventTypes[event] = type;
	  topLevelEventsToDispatchConfig[topEvent] = type;
	});
	
	var onClickListeners = {};
	
	function getDictionaryKey(inst) {
	  // Prevents V8 performance issue:
	  // https://github.com/facebook/react/pull/7232
	  return '.' + inst._rootNodeID;
	}
	
	function isInteractive(tag) {
	  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
	}
	
	var SimpleEventPlugin = {
	  eventTypes: eventTypes,
	
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
	    if (!dispatchConfig) {
	      return null;
	    }
	    var EventConstructor;
	    switch (topLevelType) {
	      case 'topAbort':
	      case 'topCanPlay':
	      case 'topCanPlayThrough':
	      case 'topDurationChange':
	      case 'topEmptied':
	      case 'topEncrypted':
	      case 'topEnded':
	      case 'topError':
	      case 'topInput':
	      case 'topInvalid':
	      case 'topLoad':
	      case 'topLoadedData':
	      case 'topLoadedMetadata':
	      case 'topLoadStart':
	      case 'topPause':
	      case 'topPlay':
	      case 'topPlaying':
	      case 'topProgress':
	      case 'topRateChange':
	      case 'topReset':
	      case 'topSeeked':
	      case 'topSeeking':
	      case 'topStalled':
	      case 'topSubmit':
	      case 'topSuspend':
	      case 'topTimeUpdate':
	      case 'topVolumeChange':
	      case 'topWaiting':
	        // HTML Events
	        // @see http://www.w3.org/TR/html5/index.html#events-0
	        EventConstructor = SyntheticEvent;
	        break;
	      case 'topKeyPress':
	        // Firefox creates a keypress event for function keys too. This removes
	        // the unwanted keypress events. Enter is however both printable and
	        // non-printable. One would expect Tab to be as well (but it isn't).
	        if (getEventCharCode(nativeEvent) === 0) {
	          return null;
	        }
	      /* falls through */
	      case 'topKeyDown':
	      case 'topKeyUp':
	        EventConstructor = SyntheticKeyboardEvent;
	        break;
	      case 'topBlur':
	      case 'topFocus':
	        EventConstructor = SyntheticFocusEvent;
	        break;
	      case 'topClick':
	        // Firefox creates a click event on right mouse clicks. This removes the
	        // unwanted click events.
	        if (nativeEvent.button === 2) {
	          return null;
	        }
	      /* falls through */
	      case 'topDoubleClick':
	      case 'topMouseDown':
	      case 'topMouseMove':
	      case 'topMouseUp':
	      // TODO: Disabled elements should not respond to mouse events
	      /* falls through */
	      case 'topMouseOut':
	      case 'topMouseOver':
	      case 'topContextMenu':
	        EventConstructor = SyntheticMouseEvent;
	        break;
	      case 'topDrag':
	      case 'topDragEnd':
	      case 'topDragEnter':
	      case 'topDragExit':
	      case 'topDragLeave':
	      case 'topDragOver':
	      case 'topDragStart':
	      case 'topDrop':
	        EventConstructor = SyntheticDragEvent;
	        break;
	      case 'topTouchCancel':
	      case 'topTouchEnd':
	      case 'topTouchMove':
	      case 'topTouchStart':
	        EventConstructor = SyntheticTouchEvent;
	        break;
	      case 'topAnimationEnd':
	      case 'topAnimationIteration':
	      case 'topAnimationStart':
	        EventConstructor = SyntheticAnimationEvent;
	        break;
	      case 'topTransitionEnd':
	        EventConstructor = SyntheticTransitionEvent;
	        break;
	      case 'topScroll':
	        EventConstructor = SyntheticUIEvent;
	        break;
	      case 'topWheel':
	        EventConstructor = SyntheticWheelEvent;
	        break;
	      case 'topCopy':
	      case 'topCut':
	      case 'topPaste':
	        EventConstructor = SyntheticClipboardEvent;
	        break;
	    }
	    !EventConstructor ?  true ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : _prodInvariant('86', topLevelType) : void 0;
	    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
	    EventPropagators.accumulateTwoPhaseDispatches(event);
	    return event;
	  },
	
	  didPutListener: function (inst, registrationName, listener) {
	    // Mobile Safari does not fire properly bubble click events on
	    // non-interactive elements, which means delegated click listeners do not
	    // fire. The workaround for this bug involves attaching an empty click
	    // listener on the target node.
	    // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	    if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
	      var key = getDictionaryKey(inst);
	      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	      if (!onClickListeners[key]) {
	        onClickListeners[key] = EventListener.listen(node, 'click', emptyFunction);
	      }
	    }
	  },
	
	  willDeleteListener: function (inst, registrationName) {
	    if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
	      var key = getDictionaryKey(inst);
	      onClickListeners[key].remove();
	      delete onClickListeners[key];
	    }
	  }
	};
	
	module.exports = SimpleEventPlugin;

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(59);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
	 */
	var AnimationEventInterface = {
	  animationName: null,
	  elapsedTime: null,
	  pseudoElement: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);
	
	module.exports = SyntheticAnimationEvent;

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(59);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/clipboard-apis/
	 */
	var ClipboardEventInterface = {
	  clipboardData: function (event) {
	    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);
	
	module.exports = SyntheticClipboardEvent;

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(82);
	
	/**
	 * @interface FocusEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var FocusEventInterface = {
	  relatedTarget: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
	
	module.exports = SyntheticFocusEvent;

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(82);
	
	var getEventCharCode = __webpack_require__(167);
	var getEventKey = __webpack_require__(168);
	var getEventModifierState = __webpack_require__(84);
	
	/**
	 * @interface KeyboardEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var KeyboardEventInterface = {
	  key: getEventKey,
	  location: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  repeat: null,
	  locale: null,
	  getModifierState: getEventModifierState,
	  // Legacy Interface
	  charCode: function (event) {
	    // `charCode` is the result of a KeyPress event and represents the value of
	    // the actual printable character.
	
	    // KeyPress is deprecated, but its replacement is not yet final and not
	    // implemented in any major browser. Only KeyPress has charCode.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    return 0;
	  },
	  keyCode: function (event) {
	    // `keyCode` is the result of a KeyDown/Up event and represents the value of
	    // physical keyboard key.
	
	    // The actual meaning of the value depends on the users' keyboard layout
	    // which cannot be detected. Assuming that it is a US keyboard layout
	    // provides a surprisingly accurate mapping for US and European users.
	    // Due to this, it is left to the user to implement at this time.
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  },
	  which: function (event) {
	    // `which` is an alias for either `keyCode` or `charCode` depending on the
	    // type of the event.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);
	
	module.exports = SyntheticKeyboardEvent;

/***/ }),
/* 167 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	/**
	 * `charCode` represents the actual "character code" and is safe to use with
	 * `String.fromCharCode`. As such, only keys that correspond to printable
	 * characters produce a valid `charCode`, the only exception to this is Enter.
	 * The Tab-key is considered non-printable and does not have a `charCode`,
	 * presumably because it does not produce a tab-character in browsers.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {number} Normalized `charCode` property.
	 */
	
	function getEventCharCode(nativeEvent) {
	  var charCode;
	  var keyCode = nativeEvent.keyCode;
	
	  if ('charCode' in nativeEvent) {
	    charCode = nativeEvent.charCode;
	
	    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
	    if (charCode === 0 && keyCode === 13) {
	      charCode = 13;
	    }
	  } else {
	    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
	    charCode = keyCode;
	  }
	
	  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
	  // Must not discard the (non-)printable Enter-key.
	  if (charCode >= 32 || charCode === 13) {
	    return charCode;
	  }
	
	  return 0;
	}
	
	module.exports = getEventCharCode;

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var getEventCharCode = __webpack_require__(167);
	
	/**
	 * Normalization of deprecated HTML5 `key` values
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var normalizeKey = {
	  Esc: 'Escape',
	  Spacebar: ' ',
	  Left: 'ArrowLeft',
	  Up: 'ArrowUp',
	  Right: 'ArrowRight',
	  Down: 'ArrowDown',
	  Del: 'Delete',
	  Win: 'OS',
	  Menu: 'ContextMenu',
	  Apps: 'ContextMenu',
	  Scroll: 'ScrollLock',
	  MozPrintableKey: 'Unidentified'
	};
	
	/**
	 * Translation from legacy `keyCode` to HTML5 `key`
	 * Only special keys supported, all others depend on keyboard layout or browser
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var translateToKey = {
	  8: 'Backspace',
	  9: 'Tab',
	  12: 'Clear',
	  13: 'Enter',
	  16: 'Shift',
	  17: 'Control',
	  18: 'Alt',
	  19: 'Pause',
	  20: 'CapsLock',
	  27: 'Escape',
	  32: ' ',
	  33: 'PageUp',
	  34: 'PageDown',
	  35: 'End',
	  36: 'Home',
	  37: 'ArrowLeft',
	  38: 'ArrowUp',
	  39: 'ArrowRight',
	  40: 'ArrowDown',
	  45: 'Insert',
	  46: 'Delete',
	  112: 'F1',
	  113: 'F2',
	  114: 'F3',
	  115: 'F4',
	  116: 'F5',
	  117: 'F6',
	  118: 'F7',
	  119: 'F8',
	  120: 'F9',
	  121: 'F10',
	  122: 'F11',
	  123: 'F12',
	  144: 'NumLock',
	  145: 'ScrollLock',
	  224: 'Meta'
	};
	
	/**
	 * @param {object} nativeEvent Native browser event.
	 * @return {string} Normalized `key` property.
	 */
	function getEventKey(nativeEvent) {
	  if (nativeEvent.key) {
	    // Normalize inconsistent values reported by browsers due to
	    // implementations of a working draft specification.
	
	    // FireFox implements `key` but returns `MozPrintableKey` for all
	    // printable characters (normalized to `Unidentified`), ignore it.
	    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
	    if (key !== 'Unidentified') {
	      return key;
	    }
	  }
	
	  // Browser does not implement `key`, polyfill as much of it as we can.
	  if (nativeEvent.type === 'keypress') {
	    var charCode = getEventCharCode(nativeEvent);
	
	    // The enter-key is technically both printable and non-printable and can
	    // thus be captured by `keypress`, no other non-printable key should.
	    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
	  }
	  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
	    // While user keyboard layout determines the actual meaning of each
	    // `keyCode` value, almost all function keys have a universal value.
	    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
	  }
	  return '';
	}
	
	module.exports = getEventKey;

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(81);
	
	/**
	 * @interface DragEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var DragEventInterface = {
	  dataTransfer: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
	
	module.exports = SyntheticDragEvent;

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(82);
	
	var getEventModifierState = __webpack_require__(84);
	
	/**
	 * @interface TouchEvent
	 * @see http://www.w3.org/TR/touch-events/
	 */
	var TouchEventInterface = {
	  touches: null,
	  targetTouches: null,
	  changedTouches: null,
	  altKey: null,
	  metaKey: null,
	  ctrlKey: null,
	  shiftKey: null,
	  getModifierState: getEventModifierState
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
	
	module.exports = SyntheticTouchEvent;

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(59);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
	 */
	var TransitionEventInterface = {
	  propertyName: null,
	  elapsedTime: null,
	  pseudoElement: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);
	
	module.exports = SyntheticTransitionEvent;

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(81);
	
	/**
	 * @interface WheelEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var WheelEventInterface = {
	  deltaX: function (event) {
	    return 'deltaX' in event ? event.deltaX : // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
	    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
	  },
	  deltaY: function (event) {
	    return 'deltaY' in event ? event.deltaY : // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
	    'wheelDeltaY' in event ? -event.wheelDeltaY : // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
	    'wheelDelta' in event ? -event.wheelDelta : 0;
	  },
	  deltaZ: null,
	
	  // Browsers without "deltaMode" is reporting in raw wheel delta where one
	  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
	  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
	  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
	  deltaMode: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticMouseEvent}
	 */
	function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
	
	module.exports = SyntheticWheelEvent;

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(41);
	
	var DOMLazyTree = __webpack_require__(88);
	var DOMProperty = __webpack_require__(42);
	var React = __webpack_require__(3);
	var ReactBrowserEventEmitter = __webpack_require__(112);
	var ReactCurrentOwner = __webpack_require__(17);
	var ReactDOMComponentTree = __webpack_require__(40);
	var ReactDOMContainerInfo = __webpack_require__(174);
	var ReactDOMFeatureFlags = __webpack_require__(175);
	var ReactFeatureFlags = __webpack_require__(64);
	var ReactInstanceMap = __webpack_require__(123);
	var ReactInstrumentation = __webpack_require__(68);
	var ReactMarkupChecksum = __webpack_require__(176);
	var ReactReconciler = __webpack_require__(65);
	var ReactUpdateQueue = __webpack_require__(142);
	var ReactUpdates = __webpack_require__(62);
	
	var emptyObject = __webpack_require__(11);
	var instantiateReactComponent = __webpack_require__(125);
	var invariant = __webpack_require__(12);
	var setInnerHTML = __webpack_require__(90);
	var shouldUpdateReactComponent = __webpack_require__(131);
	var warning = __webpack_require__(8);
	
	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var ROOT_ATTR_NAME = DOMProperty.ROOT_ATTRIBUTE_NAME;
	
	var ELEMENT_NODE_TYPE = 1;
	var DOC_NODE_TYPE = 9;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	var instancesByReactRootID = {};
	
	/**
	 * Finds the index of the first character
	 * that's not common between the two given strings.
	 *
	 * @return {number} the index of the character where the strings diverge
	 */
	function firstDifferenceIndex(string1, string2) {
	  var minLen = Math.min(string1.length, string2.length);
	  for (var i = 0; i < minLen; i++) {
	    if (string1.charAt(i) !== string2.charAt(i)) {
	      return i;
	    }
	  }
	  return string1.length === string2.length ? -1 : minLen;
	}
	
	/**
	 * @param {DOMElement|DOMDocument} container DOM element that may contain
	 * a React component
	 * @return {?*} DOM element that may have the reactRoot ID, or null.
	 */
	function getReactRootElementInContainer(container) {
	  if (!container) {
	    return null;
	  }
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    return container.documentElement;
	  } else {
	    return container.firstChild;
	  }
	}
	
	function internalGetID(node) {
	  // If node is something like a window, document, or text node, none of
	  // which support attributes or a .getAttribute method, gracefully return
	  // the empty string, as if the attribute were missing.
	  return node.getAttribute && node.getAttribute(ATTR_NAME) || '';
	}
	
	/**
	 * Mounts this component and inserts it into the DOM.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {ReactReconcileTransaction} transaction
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function mountComponentIntoNode(wrapperInstance, container, transaction, shouldReuseMarkup, context) {
	  var markerName;
	  if (ReactFeatureFlags.logTopLevelRenders) {
	    var wrappedElement = wrapperInstance._currentElement.props.child;
	    var type = wrappedElement.type;
	    markerName = 'React mount: ' + (typeof type === 'string' ? type : type.displayName || type.name);
	    console.time(markerName);
	  }
	
	  var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context, 0 /* parentDebugID */
	  );
	
	  if (markerName) {
	    console.timeEnd(markerName);
	  }
	
	  wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
	  ReactMount._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction);
	}
	
	/**
	 * Batched mount.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function batchedMountComponentIntoNode(componentInstance, container, shouldReuseMarkup, context) {
	  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* useCreateElement */
	  !shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement);
	  transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);
	  ReactUpdates.ReactReconcileTransaction.release(transaction);
	}
	
	/**
	 * Unmounts a component and removes it from the DOM.
	 *
	 * @param {ReactComponent} instance React component instance.
	 * @param {DOMElement} container DOM element to unmount from.
	 * @final
	 * @internal
	 * @see {ReactMount.unmountComponentAtNode}
	 */
	function unmountComponentFromNode(instance, container, safely) {
	  if (true) {
	    ReactInstrumentation.debugTool.onBeginFlush();
	  }
	  ReactReconciler.unmountComponent(instance, safely);
	  if (true) {
	    ReactInstrumentation.debugTool.onEndFlush();
	  }
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    container = container.documentElement;
	  }
	
	  // http://jsperf.com/emptying-a-node
	  while (container.lastChild) {
	    container.removeChild(container.lastChild);
	  }
	}
	
	/**
	 * True if the supplied DOM node has a direct React-rendered child that is
	 * not a React root element. Useful for warning in `render`,
	 * `unmountComponentAtNode`, etc.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM element contains a direct child that was
	 * rendered by React but is not a root element.
	 * @internal
	 */
	function hasNonRootReactChild(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  if (rootEl) {
	    var inst = ReactDOMComponentTree.getInstanceFromNode(rootEl);
	    return !!(inst && inst._hostParent);
	  }
	}
	
	/**
	 * True if the supplied DOM node is a React DOM element and
	 * it has been rendered by another copy of React.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM has been rendered by another copy of React
	 * @internal
	 */
	function nodeIsRenderedByOtherInstance(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  return !!(rootEl && isReactNode(rootEl) && !ReactDOMComponentTree.getInstanceFromNode(rootEl));
	}
	
	/**
	 * True if the supplied DOM node is a valid node element.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM is a valid DOM node.
	 * @internal
	 */
	function isValidContainer(node) {
	  return !!(node && (node.nodeType === ELEMENT_NODE_TYPE || node.nodeType === DOC_NODE_TYPE || node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE));
	}
	
	/**
	 * True if the supplied DOM node is a valid React node element.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM is a valid React DOM node.
	 * @internal
	 */
	function isReactNode(node) {
	  return isValidContainer(node) && (node.hasAttribute(ROOT_ATTR_NAME) || node.hasAttribute(ATTR_NAME));
	}
	
	function getHostRootInstanceInContainer(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  var prevHostInstance = rootEl && ReactDOMComponentTree.getInstanceFromNode(rootEl);
	  return prevHostInstance && !prevHostInstance._hostParent ? prevHostInstance : null;
	}
	
	function getTopLevelWrapperInContainer(container) {
	  var root = getHostRootInstanceInContainer(container);
	  return root ? root._hostContainerInfo._topLevelWrapper : null;
	}
	
	/**
	 * Temporary (?) hack so that we can store all top-level pending updates on
	 * composites instead of having to worry about different types of components
	 * here.
	 */
	var topLevelRootCounter = 1;
	var TopLevelWrapper = function () {
	  this.rootID = topLevelRootCounter++;
	};
	TopLevelWrapper.prototype.isReactComponent = {};
	if (true) {
	  TopLevelWrapper.displayName = 'TopLevelWrapper';
	}
	TopLevelWrapper.prototype.render = function () {
	  return this.props.child;
	};
	TopLevelWrapper.isReactTopLevelWrapper = true;
	
	/**
	 * Mounting is the process of initializing a React component by creating its
	 * representative DOM elements and inserting them into a supplied `container`.
	 * Any prior content inside `container` is destroyed in the process.
	 *
	 *   ReactMount.render(
	 *     component,
	 *     document.getElementById('container')
	 *   );
	 *
	 *   <div id="container">                   <-- Supplied `container`.
	 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
	 *       // ...                                 component.
	 *     </div>
	 *   </div>
	 *
	 * Inside of `container`, the first element rendered is the "reactRoot".
	 */
	var ReactMount = {
	  TopLevelWrapper: TopLevelWrapper,
	
	  /**
	   * Used by devtools. The keys are not important.
	   */
	  _instancesByReactRootID: instancesByReactRootID,
	
	  /**
	   * This is a hook provided to support rendering React components while
	   * ensuring that the apparent scroll position of its `container` does not
	   * change.
	   *
	   * @param {DOMElement} container The `container` being rendered into.
	   * @param {function} renderCallback This must be called once to do the render.
	   */
	  scrollMonitor: function (container, renderCallback) {
	    renderCallback();
	  },
	
	  /**
	   * Take a component that's already mounted into the DOM and replace its props
	   * @param {ReactComponent} prevComponent component instance already in the DOM
	   * @param {ReactElement} nextElement component instance to render
	   * @param {DOMElement} container container to render into
	   * @param {?function} callback function triggered on completion
	   */
	  _updateRootComponent: function (prevComponent, nextElement, nextContext, container, callback) {
	    ReactMount.scrollMonitor(container, function () {
	      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);
	      if (callback) {
	        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
	      }
	    });
	
	    return prevComponent;
	  },
	
	  /**
	   * Render a new component into the DOM. Hooked by hooks!
	   *
	   * @param {ReactElement} nextElement element to render
	   * @param {DOMElement} container container to render into
	   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
	   * @return {ReactComponent} nextComponent
	   */
	  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case.
	     true ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;
	
	    !isValidContainer(container) ?  true ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : _prodInvariant('37') : void 0;
	
	    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
	    var componentInstance = instantiateReactComponent(nextElement, false);
	
	    // The initial render is synchronous but any updates that happen during
	    // rendering, in componentWillMount or componentDidMount, will be batched
	    // according to the current batching strategy.
	
	    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);
	
	    var wrapperID = componentInstance._instance.rootID;
	    instancesByReactRootID[wrapperID] = componentInstance;
	
	    return componentInstance;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
	    !(parentComponent != null && ReactInstanceMap.has(parentComponent)) ?  true ? invariant(false, 'parentComponent must be a valid React Component') : _prodInvariant('38') : void 0;
	    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
	  },
	
	  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
	    ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');
	    !React.isValidElement(nextElement) ?  true ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? " Instead of passing a string like 'div', pass " + "React.createElement('div') or <div />." : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : // Check if it quacks like an element
	    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : _prodInvariant('39', typeof nextElement === 'string' ? " Instead of passing a string like 'div', pass " + "React.createElement('div') or <div />." : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : void 0;
	
	     true ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;
	
	    var nextWrappedElement = React.createElement(TopLevelWrapper, {
	      child: nextElement
	    });
	
	    var nextContext;
	    if (parentComponent) {
	      var parentInst = ReactInstanceMap.get(parentComponent);
	      nextContext = parentInst._processChildContext(parentInst._context);
	    } else {
	      nextContext = emptyObject;
	    }
	
	    var prevComponent = getTopLevelWrapperInContainer(container);
	
	    if (prevComponent) {
	      var prevWrappedElement = prevComponent._currentElement;
	      var prevElement = prevWrappedElement.props.child;
	      if (shouldUpdateReactComponent(prevElement, nextElement)) {
	        var publicInst = prevComponent._renderedComponent.getPublicInstance();
	        var updatedCallback = callback && function () {
	          callback.call(publicInst);
	        };
	        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
	        return publicInst;
	      } else {
	        ReactMount.unmountComponentAtNode(container);
	      }
	    }
	
	    var reactRootElement = getReactRootElementInContainer(container);
	    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
	    var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	    if (true) {
	       true ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;
	
	      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
	        var rootElementSibling = reactRootElement;
	        while (rootElementSibling) {
	          if (internalGetID(rootElementSibling)) {
	             true ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : void 0;
	            break;
	          }
	          rootElementSibling = rootElementSibling.nextSibling;
	        }
	      }
	    }
	
	    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
	    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();
	    if (callback) {
	      callback.call(component);
	    }
	    return component;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.render
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  render: function (nextElement, container, callback) {
	    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
	  },
	
	  /**
	   * Unmounts and destroys the React component rendered in the `container`.
	   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.unmountcomponentatnode
	   *
	   * @param {DOMElement} container DOM element containing a React component.
	   * @return {boolean} True if a component was found in and unmounted from
	   *                   `container`
	   */
	  unmountComponentAtNode: function (container) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case. (Strictly speaking, unmounting won't cause a
	    // render but we still don't expect to be in a render call here.)
	     true ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;
	
	    !isValidContainer(container) ?  true ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : _prodInvariant('40') : void 0;
	
	    if (true) {
	       true ? warning(!nodeIsRenderedByOtherInstance(container), "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by another copy of React.') : void 0;
	    }
	
	    var prevComponent = getTopLevelWrapperInContainer(container);
	    if (!prevComponent) {
	      // Check if the node being unmounted was rendered by React, but isn't a
	      // root node.
	      var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	      // Check if the container itself is a React root node.
	      var isContainerReactRoot = container.nodeType === 1 && container.hasAttribute(ROOT_ATTR_NAME);
	
	      if (true) {
	         true ? warning(!containerHasNonRootReactChild, "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;
	      }
	
	      return false;
	    }
	    delete instancesByReactRootID[prevComponent._instance.rootID];
	    ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);
	    return true;
	  },
	
	  _mountImageIntoNode: function (markup, container, instance, shouldReuseMarkup, transaction) {
	    !isValidContainer(container) ?  true ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : _prodInvariant('41') : void 0;
	
	    if (shouldReuseMarkup) {
	      var rootElement = getReactRootElementInContainer(container);
	      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
	        ReactDOMComponentTree.precacheNode(instance, rootElement);
	        return;
	      } else {
	        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	
	        var rootMarkup = rootElement.outerHTML;
	        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);
	
	        var normalizedMarkup = markup;
	        if (true) {
	          // because rootMarkup is retrieved from the DOM, various normalizations
	          // will have occurred which will not be present in `markup`. Here,
	          // insert markup into a <div> or <iframe> depending on the container
	          // type to perform the same normalizations before comparing.
	          var normalizer;
	          if (container.nodeType === ELEMENT_NODE_TYPE) {
	            normalizer = document.createElement('div');
	            normalizer.innerHTML = markup;
	            normalizedMarkup = normalizer.innerHTML;
	          } else {
	            normalizer = document.createElement('iframe');
	            document.body.appendChild(normalizer);
	            normalizer.contentDocument.write(markup);
	            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
	            document.body.removeChild(normalizer);
	          }
	        }
	
	        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
	        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);
	
	        !(container.nodeType !== DOC_NODE_TYPE) ?  true ? invariant(false, 'You\'re trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\n%s', difference) : _prodInvariant('42', difference) : void 0;
	
	        if (true) {
	           true ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : void 0;
	        }
	      }
	    }
	
	    !(container.nodeType !== DOC_NODE_TYPE) ?  true ? invariant(false, 'You\'re trying to render a component to the document but you didn\'t use server rendering. We can\'t do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('43') : void 0;
	
	    if (transaction.useCreateElement) {
	      while (container.lastChild) {
	        container.removeChild(container.lastChild);
	      }
	      DOMLazyTree.insertTreeBefore(container, markup, null);
	    } else {
	      setInnerHTML(container, markup);
	      ReactDOMComponentTree.precacheNode(instance, container.firstChild);
	    }
	
	    if (true) {
	      var hostNode = ReactDOMComponentTree.getInstanceFromNode(container.firstChild);
	      if (hostNode._debugID !== 0) {
	        ReactInstrumentation.debugTool.onHostOperation({
	          instanceID: hostNode._debugID,
	          type: 'mount',
	          payload: markup.toString()
	        });
	      }
	    }
	  }
	};
	
	module.exports = ReactMount;

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var validateDOMNesting = __webpack_require__(143);
	
	var DOC_NODE_TYPE = 9;
	
	function ReactDOMContainerInfo(topLevelWrapper, node) {
	  var info = {
	    _topLevelWrapper: topLevelWrapper,
	    _idCounter: 1,
	    _ownerDocument: node ? node.nodeType === DOC_NODE_TYPE ? node : node.ownerDocument : null,
	    _node: node,
	    _tag: node ? node.nodeName.toLowerCase() : null,
	    _namespaceURI: node ? node.namespaceURI : null
	  };
	  if (true) {
	    info._ancestorInfo = node ? validateDOMNesting.updatedAncestorInfo(null, info._tag, null) : null;
	  }
	  return info;
	}
	
	module.exports = ReactDOMContainerInfo;

/***/ }),
/* 175 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var ReactDOMFeatureFlags = {
	  useCreateElement: true,
	  useFiber: false
	};
	
	module.exports = ReactDOMFeatureFlags;

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var adler32 = __webpack_require__(177);
	
	var TAG_END = /\/?>/;
	var COMMENT_START = /^<\!\-\-/;
	
	var ReactMarkupChecksum = {
	  CHECKSUM_ATTR_NAME: 'data-react-checksum',
	
	  /**
	   * @param {string} markup Markup string
	   * @return {string} Markup string with checksum attribute attached
	   */
	  addChecksumToMarkup: function (markup) {
	    var checksum = adler32(markup);
	
	    // Add checksum (handle both parent tags, comments and self-closing tags)
	    if (COMMENT_START.test(markup)) {
	      return markup;
	    } else {
	      return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
	    }
	  },
	
	  /**
	   * @param {string} markup to use
	   * @param {DOMElement} element root React element
	   * @returns {boolean} whether or not the markup is the same
	   */
	  canReuseMarkup: function (markup, element) {
	    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
	    var markupChecksum = adler32(markup);
	    return markupChecksum === existingChecksum;
	  }
	};
	
	module.exports = ReactMarkupChecksum;

/***/ }),
/* 177 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */
	
	'use strict';
	
	var MOD = 65521;
	
	// adler32 is not cryptographically strong, and is only used to sanity check that
	// markup generated on the server matches the markup generated on the client.
	// This implementation (a modified version of the SheetJS version) has been optimized
	// for our use case, at the expense of conforming to the adler32 specification
	// for non-ascii inputs.
	function adler32(data) {
	  var a = 1;
	  var b = 0;
	  var i = 0;
	  var l = data.length;
	  var m = l & ~0x3;
	  while (i < m) {
	    var n = Math.min(i + 4096, m);
	    for (; i < n; i += 4) {
	      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
	    }
	    a %= MOD;
	    b %= MOD;
	  }
	  for (; i < l; i++) {
	    b += a += data.charCodeAt(i);
	  }
	  a %= MOD;
	  b %= MOD;
	  return a | b << 16;
	}
	
	module.exports = adler32;

/***/ }),
/* 178 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	module.exports = '15.6.2';

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(41);
	
	var ReactCurrentOwner = __webpack_require__(17);
	var ReactDOMComponentTree = __webpack_require__(40);
	var ReactInstanceMap = __webpack_require__(123);
	
	var getHostComponentFromComposite = __webpack_require__(180);
	var invariant = __webpack_require__(12);
	var warning = __webpack_require__(8);
	
	/**
	 * Returns the DOM node rendered by this element.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.finddomnode
	 *
	 * @param {ReactComponent|DOMElement} componentOrElement
	 * @return {?DOMElement} The root node of this element.
	 */
	function findDOMNode(componentOrElement) {
	  if (true) {
	    var owner = ReactCurrentOwner.current;
	    if (owner !== null) {
	       true ? warning(owner._warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
	      owner._warnedAboutRefsInRender = true;
	    }
	  }
	  if (componentOrElement == null) {
	    return null;
	  }
	  if (componentOrElement.nodeType === 1) {
	    return componentOrElement;
	  }
	
	  var inst = ReactInstanceMap.get(componentOrElement);
	  if (inst) {
	    inst = getHostComponentFromComposite(inst);
	    return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;
	  }
	
	  if (typeof componentOrElement.render === 'function') {
	     true ?  true ? invariant(false, 'findDOMNode was called on an unmounted component.') : _prodInvariant('44') : void 0;
	  } else {
	     true ?  true ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : _prodInvariant('45', Object.keys(componentOrElement)) : void 0;
	  }
	}
	
	module.exports = findDOMNode;

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var ReactNodeTypes = __webpack_require__(127);
	
	function getHostComponentFromComposite(inst) {
	  var type;
	
	  while ((type = inst._renderedNodeType) === ReactNodeTypes.COMPOSITE) {
	    inst = inst._renderedComponent;
	  }
	
	  if (type === ReactNodeTypes.HOST) {
	    return inst._renderedComponent;
	  } else if (type === ReactNodeTypes.EMPTY) {
	    return null;
	  }
	}
	
	module.exports = getHostComponentFromComposite;

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var ReactMount = __webpack_require__(173);
	
	module.exports = ReactMount.renderSubtreeIntoContainer;

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(42);
	var EventPluginRegistry = __webpack_require__(49);
	var ReactComponentTreeHook = __webpack_require__(24);
	
	var warning = __webpack_require__(8);
	
	if (true) {
	  var reactProps = {
	    children: true,
	    dangerouslySetInnerHTML: true,
	    key: true,
	    ref: true,
	
	    autoFocus: true,
	    defaultValue: true,
	    valueLink: true,
	    defaultChecked: true,
	    checkedLink: true,
	    innerHTML: true,
	    suppressContentEditableWarning: true,
	    onFocusIn: true,
	    onFocusOut: true
	  };
	  var warnedProperties = {};
	
	  var validateProperty = function (tagName, name, debugID) {
	    if (DOMProperty.properties.hasOwnProperty(name) || DOMProperty.isCustomAttribute(name)) {
	      return true;
	    }
	    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
	      return true;
	    }
	    if (EventPluginRegistry.registrationNameModules.hasOwnProperty(name)) {
	      return true;
	    }
	    warnedProperties[name] = true;
	    var lowerCasedName = name.toLowerCase();
	
	    // data-* attributes should be lowercase; suggest the lowercase version
	    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
	
	    var registrationName = EventPluginRegistry.possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? EventPluginRegistry.possibleRegistrationNames[lowerCasedName] : null;
	
	    if (standardName != null) {
	       true ? warning(false, 'Unknown DOM property %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	      return true;
	    } else if (registrationName != null) {
	       true ? warning(false, 'Unknown event handler property %s. Did you mean `%s`?%s', name, registrationName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	      return true;
	    } else {
	      // We were unable to guess which prop the user intended.
	      // It is likely that the user was just blindly spreading/forwarding props
	      // Components should be careful to only render valid props/attributes.
	      // Warning will be invoked in warnUnknownProperties to allow grouping.
	      return false;
	    }
	  };
	}
	
	var warnUnknownProperties = function (debugID, element) {
	  var unknownProps = [];
	  for (var key in element.props) {
	    var isValid = validateProperty(element.type, key, debugID);
	    if (!isValid) {
	      unknownProps.push(key);
	    }
	  }
	
	  var unknownPropString = unknownProps.map(function (prop) {
	    return '`' + prop + '`';
	  }).join(', ');
	
	  if (unknownProps.length === 1) {
	     true ? warning(false, 'Unknown prop %s on <%s> tag. Remove this prop from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  } else if (unknownProps.length > 1) {
	     true ? warning(false, 'Unknown props %s on <%s> tag. Remove these props from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  }
	};
	
	function handleElement(debugID, element) {
	  if (element == null || typeof element.type !== 'string') {
	    return;
	  }
	  if (element.type.indexOf('-') >= 0 || element.props.is) {
	    return;
	  }
	  warnUnknownProperties(debugID, element);
	}
	
	var ReactDOMUnknownPropertyHook = {
	  onBeforeMountComponent: function (debugID, element) {
	    handleElement(debugID, element);
	  },
	  onBeforeUpdateComponent: function (debugID, element) {
	    handleElement(debugID, element);
	  }
	};
	
	module.exports = ReactDOMUnknownPropertyHook;

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var ReactComponentTreeHook = __webpack_require__(24);
	
	var warning = __webpack_require__(8);
	
	var didWarnValueNull = false;
	
	function handleElement(debugID, element) {
	  if (element == null) {
	    return;
	  }
	  if (element.type !== 'input' && element.type !== 'textarea' && element.type !== 'select') {
	    return;
	  }
	  if (element.props != null && element.props.value === null && !didWarnValueNull) {
	     true ? warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using the empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	
	    didWarnValueNull = true;
	  }
	}
	
	var ReactDOMNullInputValuePropHook = {
	  onBeforeMountComponent: function (debugID, element) {
	    handleElement(debugID, element);
	  },
	  onBeforeUpdateComponent: function (debugID, element) {
	    handleElement(debugID, element);
	  }
	};
	
	module.exports = ReactDOMNullInputValuePropHook;

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(42);
	var ReactComponentTreeHook = __webpack_require__(24);
	
	var warning = __webpack_require__(8);
	
	var warnedProperties = {};
	var rARIA = new RegExp('^(aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
	
	function validateProperty(tagName, name, debugID) {
	  if (warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
	    return true;
	  }
	
	  if (rARIA.test(name)) {
	    var lowerCasedName = name.toLowerCase();
	    var standardName = DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
	
	    // If this is an aria-* attribute, but is not listed in the known DOM
	    // DOM properties, then it is an invalid aria-* attribute.
	    if (standardName == null) {
	      warnedProperties[name] = true;
	      return false;
	    }
	    // aria-* attributes should be lowercase; suggest the lowercase version.
	    if (name !== standardName) {
	       true ? warning(false, 'Unknown ARIA attribute %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	      warnedProperties[name] = true;
	      return true;
	    }
	  }
	
	  return true;
	}
	
	function warnInvalidARIAProps(debugID, element) {
	  var invalidProps = [];
	
	  for (var key in element.props) {
	    var isValid = validateProperty(element.type, key, debugID);
	    if (!isValid) {
	      invalidProps.push(key);
	    }
	  }
	
	  var unknownPropString = invalidProps.map(function (prop) {
	    return '`' + prop + '`';
	  }).join(', ');
	
	  if (invalidProps.length === 1) {
	     true ? warning(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  } else if (invalidProps.length > 1) {
	     true ? warning(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  }
	}
	
	function handleElement(debugID, element) {
	  if (element == null || typeof element.type !== 'string') {
	    return;
	  }
	  if (element.type.indexOf('-') >= 0 || element.props.is) {
	    return;
	  }
	
	  warnInvalidARIAProps(debugID, element);
	}
	
	var ReactDOMInvalidARIAHook = {
	  onBeforeMountComponent: function (debugID, element) {
	    if (true) {
	      handleElement(debugID, element);
	    }
	  },
	  onBeforeUpdateComponent: function (debugID, element) {
	    if (true) {
	      handleElement(debugID, element);
	    }
	  }
	};
	
	module.exports = ReactDOMInvalidARIAHook;

/***/ }),
/* 185 */,
/* 186 */,
/* 187 */,
/* 188 */,
/* 189 */,
/* 190 */,
/* 191 */,
/* 192 */,
/* 193 */,
/* 194 */,
/* 195 */,
/* 196 */,
/* 197 */,
/* 198 */,
/* 199 */,
/* 200 */,
/* 201 */,
/* 202 */,
/* 203 */,
/* 204 */,
/* 205 */,
/* 206 */,
/* 207 */,
/* 208 */,
/* 209 */,
/* 210 */,
/* 211 */,
/* 212 */,
/* 213 */,
/* 214 */,
/* 215 */,
/* 216 */,
/* 217 */,
/* 218 */,
/* 219 */,
/* 220 */,
/* 221 */,
/* 222 */,
/* 223 */,
/* 224 */,
/* 225 */,
/* 226 */,
/* 227 */,
/* 228 */,
/* 229 */,
/* 230 */,
/* 231 */,
/* 232 */,
/* 233 */,
/* 234 */,
/* 235 */,
/* 236 */,
/* 237 */,
/* 238 */,
/* 239 */,
/* 240 */,
/* 241 */,
/* 242 */,
/* 243 */,
/* 244 */,
/* 245 */,
/* 246 */,
/* 247 */,
/* 248 */,
/* 249 */,
/* 250 */,
/* 251 */,
/* 252 */,
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _redux = __webpack_require__(254);
	
	var _reactRouterRedux = __webpack_require__(248);
	
	var _lodash = __webpack_require__(275);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _reduxThunk = __webpack_require__(276);
	
	var _reduxThunk2 = _interopRequireDefault(_reduxThunk);
	
	var _reduxPromiseMiddleware = __webpack_require__(277);
	
	var _reduxPromiseMiddleware2 = _interopRequireDefault(_reduxPromiseMiddleware);
	
	var _reducers = __webpack_require__(279);
	
	var _reducers2 = _interopRequireDefault(_reducers);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// Create the ReduxGTM middleware
	// const analyticsMiddleware = createMiddleware(eventDefinitionsMap)
	
	/* eslint-disable no-param-reassign*/
	exports.default = function () {
	  var initialState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var history = arguments[1];
	
	  // ======================================================
	  // Middleware Configuration
	  // ======================================================
	  var middleware = [_reduxThunk2.default, (0, _reactRouterRedux.routerMiddleware)(history), (0, _reduxPromiseMiddleware2.default)()];
	
	  // ======================================================
	  // Store Enhancers
	  // ======================================================
	  var enhancers = [];
	  if (true) {
	    var devToolsExtension = window.devToolsExtension;
	    if (typeof devToolsExtension === 'function') {
	      enhancers.push(devToolsExtension());
	    }
	  }
	
	  // ======================================================
	  // Store Instantiation and HMR Setup
	  // ======================================================
	  var store = (0, _redux.createStore)((0, _reducers2.default)(), initialState, _redux.compose.apply(undefined, [_redux.applyMiddleware.apply(undefined, middleware)].concat(enhancers)));
	  store.asyncReducers = {};
	
	  if (true) {
	    module.hot.accept(279, function () {
	      var reducers = _reducers2.default;
	      store.replaceReducer(reducers);
	    });
	  }
	
	  return store;
	};

/***/ }),
/* 254 */,
/* 255 */,
/* 256 */,
/* 257 */,
/* 258 */,
/* 259 */,
/* 260 */,
/* 261 */,
/* 262 */,
/* 263 */,
/* 264 */,
/* 265 */,
/* 266 */,
/* 267 */,
/* 268 */,
/* 269 */,
/* 270 */,
/* 271 */,
/* 272 */,
/* 273 */,
/* 274 */,
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global, module) {/**
	 * @license
	 * Lodash <https://lodash.com/>
	 * Copyright JS Foundation and other contributors <https://js.foundation/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */
	;(function() {
	
	  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
	  var undefined;
	
	  /** Used as the semantic version number. */
	  var VERSION = '4.17.4';
	
	  /** Used as the size to enable large array optimizations. */
	  var LARGE_ARRAY_SIZE = 200;
	
	  /** Error message constants. */
	  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
	      FUNC_ERROR_TEXT = 'Expected a function';
	
	  /** Used to stand-in for `undefined` hash values. */
	  var HASH_UNDEFINED = '__lodash_hash_undefined__';
	
	  /** Used as the maximum memoize cache size. */
	  var MAX_MEMOIZE_SIZE = 500;
	
	  /** Used as the internal argument placeholder. */
	  var PLACEHOLDER = '__lodash_placeholder__';
	
	  /** Used to compose bitmasks for cloning. */
	  var CLONE_DEEP_FLAG = 1,
	      CLONE_FLAT_FLAG = 2,
	      CLONE_SYMBOLS_FLAG = 4;
	
	  /** Used to compose bitmasks for value comparisons. */
	  var COMPARE_PARTIAL_FLAG = 1,
	      COMPARE_UNORDERED_FLAG = 2;
	
	  /** Used to compose bitmasks for function metadata. */
	  var WRAP_BIND_FLAG = 1,
	      WRAP_BIND_KEY_FLAG = 2,
	      WRAP_CURRY_BOUND_FLAG = 4,
	      WRAP_CURRY_FLAG = 8,
	      WRAP_CURRY_RIGHT_FLAG = 16,
	      WRAP_PARTIAL_FLAG = 32,
	      WRAP_PARTIAL_RIGHT_FLAG = 64,
	      WRAP_ARY_FLAG = 128,
	      WRAP_REARG_FLAG = 256,
	      WRAP_FLIP_FLAG = 512;
	
	  /** Used as default options for `_.truncate`. */
	  var DEFAULT_TRUNC_LENGTH = 30,
	      DEFAULT_TRUNC_OMISSION = '...';
	
	  /** Used to detect hot functions by number of calls within a span of milliseconds. */
	  var HOT_COUNT = 800,
	      HOT_SPAN = 16;
	
	  /** Used to indicate the type of lazy iteratees. */
	  var LAZY_FILTER_FLAG = 1,
	      LAZY_MAP_FLAG = 2,
	      LAZY_WHILE_FLAG = 3;
	
	  /** Used as references for various `Number` constants. */
	  var INFINITY = 1 / 0,
	      MAX_SAFE_INTEGER = 9007199254740991,
	      MAX_INTEGER = 1.7976931348623157e+308,
	      NAN = 0 / 0;
	
	  /** Used as references for the maximum length and index of an array. */
	  var MAX_ARRAY_LENGTH = 4294967295,
	      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
	      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
	
	  /** Used to associate wrap methods with their bit flags. */
	  var wrapFlags = [
	    ['ary', WRAP_ARY_FLAG],
	    ['bind', WRAP_BIND_FLAG],
	    ['bindKey', WRAP_BIND_KEY_FLAG],
	    ['curry', WRAP_CURRY_FLAG],
	    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
	    ['flip', WRAP_FLIP_FLAG],
	    ['partial', WRAP_PARTIAL_FLAG],
	    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
	    ['rearg', WRAP_REARG_FLAG]
	  ];
	
	  /** `Object#toString` result references. */
	  var argsTag = '[object Arguments]',
	      arrayTag = '[object Array]',
	      asyncTag = '[object AsyncFunction]',
	      boolTag = '[object Boolean]',
	      dateTag = '[object Date]',
	      domExcTag = '[object DOMException]',
	      errorTag = '[object Error]',
	      funcTag = '[object Function]',
	      genTag = '[object GeneratorFunction]',
	      mapTag = '[object Map]',
	      numberTag = '[object Number]',
	      nullTag = '[object Null]',
	      objectTag = '[object Object]',
	      promiseTag = '[object Promise]',
	      proxyTag = '[object Proxy]',
	      regexpTag = '[object RegExp]',
	      setTag = '[object Set]',
	      stringTag = '[object String]',
	      symbolTag = '[object Symbol]',
	      undefinedTag = '[object Undefined]',
	      weakMapTag = '[object WeakMap]',
	      weakSetTag = '[object WeakSet]';
	
	  var arrayBufferTag = '[object ArrayBuffer]',
	      dataViewTag = '[object DataView]',
	      float32Tag = '[object Float32Array]',
	      float64Tag = '[object Float64Array]',
	      int8Tag = '[object Int8Array]',
	      int16Tag = '[object Int16Array]',
	      int32Tag = '[object Int32Array]',
	      uint8Tag = '[object Uint8Array]',
	      uint8ClampedTag = '[object Uint8ClampedArray]',
	      uint16Tag = '[object Uint16Array]',
	      uint32Tag = '[object Uint32Array]';
	
	  /** Used to match empty string literals in compiled template source. */
	  var reEmptyStringLeading = /\b__p \+= '';/g,
	      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
	      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
	
	  /** Used to match HTML entities and HTML characters. */
	  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
	      reUnescapedHtml = /[&<>"']/g,
	      reHasEscapedHtml = RegExp(reEscapedHtml.source),
	      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
	
	  /** Used to match template delimiters. */
	  var reEscape = /<%-([\s\S]+?)%>/g,
	      reEvaluate = /<%([\s\S]+?)%>/g,
	      reInterpolate = /<%=([\s\S]+?)%>/g;
	
	  /** Used to match property names within property paths. */
	  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	      reIsPlainProp = /^\w*$/,
	      reLeadingDot = /^\./,
	      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
	
	  /**
	   * Used to match `RegExp`
	   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	   */
	  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
	      reHasRegExpChar = RegExp(reRegExpChar.source);
	
	  /** Used to match leading and trailing whitespace. */
	  var reTrim = /^\s+|\s+$/g,
	      reTrimStart = /^\s+/,
	      reTrimEnd = /\s+$/;
	
	  /** Used to match wrap detail comments. */
	  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
	      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
	      reSplitDetails = /,? & /;
	
	  /** Used to match words composed of alphanumeric characters. */
	  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
	
	  /** Used to match backslashes in property paths. */
	  var reEscapeChar = /\\(\\)?/g;
	
	  /**
	   * Used to match
	   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
	   */
	  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
	
	  /** Used to match `RegExp` flags from their coerced string values. */
	  var reFlags = /\w*$/;
	
	  /** Used to detect bad signed hexadecimal string values. */
	  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
	
	  /** Used to detect binary string values. */
	  var reIsBinary = /^0b[01]+$/i;
	
	  /** Used to detect host constructors (Safari). */
	  var reIsHostCtor = /^\[object .+?Constructor\]$/;
	
	  /** Used to detect octal string values. */
	  var reIsOctal = /^0o[0-7]+$/i;
	
	  /** Used to detect unsigned integer values. */
	  var reIsUint = /^(?:0|[1-9]\d*)$/;
	
	  /** Used to match Latin Unicode letters (excluding mathematical operators). */
	  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
	
	  /** Used to ensure capturing order of template delimiters. */
	  var reNoMatch = /($^)/;
	
	  /** Used to match unescaped characters in compiled string literals. */
	  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
	
	  /** Used to compose unicode character classes. */
	  var rsAstralRange = '\\ud800-\\udfff',
	      rsComboMarksRange = '\\u0300-\\u036f',
	      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
	      rsComboSymbolsRange = '\\u20d0-\\u20ff',
	      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
	      rsDingbatRange = '\\u2700-\\u27bf',
	      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
	      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
	      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
	      rsPunctuationRange = '\\u2000-\\u206f',
	      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
	      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
	      rsVarRange = '\\ufe0e\\ufe0f',
	      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
	
	  /** Used to compose unicode capture groups. */
	  var rsApos = "['\u2019]",
	      rsAstral = '[' + rsAstralRange + ']',
	      rsBreak = '[' + rsBreakRange + ']',
	      rsCombo = '[' + rsComboRange + ']',
	      rsDigits = '\\d+',
	      rsDingbat = '[' + rsDingbatRange + ']',
	      rsLower = '[' + rsLowerRange + ']',
	      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
	      rsFitz = '\\ud83c[\\udffb-\\udfff]',
	      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
	      rsNonAstral = '[^' + rsAstralRange + ']',
	      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
	      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
	      rsUpper = '[' + rsUpperRange + ']',
	      rsZWJ = '\\u200d';
	
	  /** Used to compose unicode regexes. */
	  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
	      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
	      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
	      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
	      reOptMod = rsModifier + '?',
	      rsOptVar = '[' + rsVarRange + ']?',
	      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
	      rsOrdLower = '\\d*(?:(?:1st|2nd|3rd|(?![123])\\dth)\\b)',
	      rsOrdUpper = '\\d*(?:(?:1ST|2ND|3RD|(?![123])\\dTH)\\b)',
	      rsSeq = rsOptVar + reOptMod + rsOptJoin,
	      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
	      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
	
	  /** Used to match apostrophes. */
	  var reApos = RegExp(rsApos, 'g');
	
	  /**
	   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
	   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
	   */
	  var reComboMark = RegExp(rsCombo, 'g');
	
	  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
	  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
	
	  /** Used to match complex or compound words. */
	  var reUnicodeWord = RegExp([
	    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
	    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
	    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
	    rsUpper + '+' + rsOptContrUpper,
	    rsOrdUpper,
	    rsOrdLower,
	    rsDigits,
	    rsEmoji
	  ].join('|'), 'g');
	
	  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
	  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');
	
	  /** Used to detect strings that need a more robust regexp to match words. */
	  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
	
	  /** Used to assign default `context` object properties. */
	  var contextProps = [
	    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
	    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
	    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
	    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
	    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
	  ];
	
	  /** Used to make template sourceURLs easier to identify. */
	  var templateCounter = -1;
	
	  /** Used to identify `toStringTag` values of typed arrays. */
	  var typedArrayTags = {};
	  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	  typedArrayTags[uint32Tag] = true;
	  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	  typedArrayTags[setTag] = typedArrayTags[stringTag] =
	  typedArrayTags[weakMapTag] = false;
	
	  /** Used to identify `toStringTag` values supported by `_.clone`. */
	  var cloneableTags = {};
	  cloneableTags[argsTag] = cloneableTags[arrayTag] =
	  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
	  cloneableTags[boolTag] = cloneableTags[dateTag] =
	  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
	  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
	  cloneableTags[int32Tag] = cloneableTags[mapTag] =
	  cloneableTags[numberTag] = cloneableTags[objectTag] =
	  cloneableTags[regexpTag] = cloneableTags[setTag] =
	  cloneableTags[stringTag] = cloneableTags[symbolTag] =
	  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
	  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
	  cloneableTags[errorTag] = cloneableTags[funcTag] =
	  cloneableTags[weakMapTag] = false;
	
	  /** Used to map Latin Unicode letters to basic Latin letters. */
	  var deburredLetters = {
	    // Latin-1 Supplement block.
	    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
	    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
	    '\xc7': 'C',  '\xe7': 'c',
	    '\xd0': 'D',  '\xf0': 'd',
	    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
	    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
	    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
	    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
	    '\xd1': 'N',  '\xf1': 'n',
	    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
	    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
	    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
	    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
	    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
	    '\xc6': 'Ae', '\xe6': 'ae',
	    '\xde': 'Th', '\xfe': 'th',
	    '\xdf': 'ss',
	    // Latin Extended-A block.
	    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
	    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
	    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
	    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
	    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
	    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
	    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
	    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
	    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
	    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
	    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
	    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
	    '\u0134': 'J',  '\u0135': 'j',
	    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
	    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
	    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
	    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
	    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
	    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
	    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
	    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
	    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
	    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
	    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
	    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
	    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
	    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
	    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
	    '\u0174': 'W',  '\u0175': 'w',
	    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
	    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
	    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
	    '\u0132': 'IJ', '\u0133': 'ij',
	    '\u0152': 'Oe', '\u0153': 'oe',
	    '\u0149': "'n", '\u017f': 's'
	  };
	
	  /** Used to map characters to HTML entities. */
	  var htmlEscapes = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#39;'
	  };
	
	  /** Used to map HTML entities to characters. */
	  var htmlUnescapes = {
	    '&amp;': '&',
	    '&lt;': '<',
	    '&gt;': '>',
	    '&quot;': '"',
	    '&#39;': "'"
	  };
	
	  /** Used to escape characters for inclusion in compiled string literals. */
	  var stringEscapes = {
	    '\\': '\\',
	    "'": "'",
	    '\n': 'n',
	    '\r': 'r',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };
	
	  /** Built-in method references without a dependency on `root`. */
	  var freeParseFloat = parseFloat,
	      freeParseInt = parseInt;
	
	  /** Detect free variable `global` from Node.js. */
	  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
	
	  /** Detect free variable `self`. */
	  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
	
	  /** Used as a reference to the global object. */
	  var root = freeGlobal || freeSelf || Function('return this')();
	
	  /** Detect free variable `exports`. */
	  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
	
	  /** Detect free variable `module`. */
	  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
	
	  /** Detect the popular CommonJS extension `module.exports`. */
	  var moduleExports = freeModule && freeModule.exports === freeExports;
	
	  /** Detect free variable `process` from Node.js. */
	  var freeProcess = moduleExports && freeGlobal.process;
	
	  /** Used to access faster Node.js helpers. */
	  var nodeUtil = (function() {
	    try {
	      return freeProcess && freeProcess.binding && freeProcess.binding('util');
	    } catch (e) {}
	  }());
	
	  /* Node.js helper references. */
	  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
	      nodeIsDate = nodeUtil && nodeUtil.isDate,
	      nodeIsMap = nodeUtil && nodeUtil.isMap,
	      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
	      nodeIsSet = nodeUtil && nodeUtil.isSet,
	      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
	
	  /*--------------------------------------------------------------------------*/
	
	  /**
	   * Adds the key-value `pair` to `map`.
	   *
	   * @private
	   * @param {Object} map The map to modify.
	   * @param {Array} pair The key-value pair to add.
	   * @returns {Object} Returns `map`.
	   */
	  function addMapEntry(map, pair) {
	    // Don't return `map.set` because it's not chainable in IE 11.
	    map.set(pair[0], pair[1]);
	    return map;
	  }
	
	  /**
	   * Adds `value` to `set`.
	   *
	   * @private
	   * @param {Object} set The set to modify.
	   * @param {*} value The value to add.
	   * @returns {Object} Returns `set`.
	   */
	  function addSetEntry(set, value) {
	    // Don't return `set.add` because it's not chainable in IE 11.
	    set.add(value);
	    return set;
	  }
	
	  /**
	   * A faster alternative to `Function#apply`, this function invokes `func`
	   * with the `this` binding of `thisArg` and the arguments of `args`.
	   *
	   * @private
	   * @param {Function} func The function to invoke.
	   * @param {*} thisArg The `this` binding of `func`.
	   * @param {Array} args The arguments to invoke `func` with.
	   * @returns {*} Returns the result of `func`.
	   */
	  function apply(func, thisArg, args) {
	    switch (args.length) {
	      case 0: return func.call(thisArg);
	      case 1: return func.call(thisArg, args[0]);
	      case 2: return func.call(thisArg, args[0], args[1]);
	      case 3: return func.call(thisArg, args[0], args[1], args[2]);
	    }
	    return func.apply(thisArg, args);
	  }
	
	  /**
	   * A specialized version of `baseAggregator` for arrays.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} setter The function to set `accumulator` values.
	   * @param {Function} iteratee The iteratee to transform keys.
	   * @param {Object} accumulator The initial aggregated object.
	   * @returns {Function} Returns `accumulator`.
	   */
	  function arrayAggregator(array, setter, iteratee, accumulator) {
	    var index = -1,
	        length = array == null ? 0 : array.length;
	
	    while (++index < length) {
	      var value = array[index];
	      setter(accumulator, value, iteratee(value), array);
	    }
	    return accumulator;
	  }
	
	  /**
	   * A specialized version of `_.forEach` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns `array`.
	   */
	  function arrayEach(array, iteratee) {
	    var index = -1,
	        length = array == null ? 0 : array.length;
	
	    while (++index < length) {
	      if (iteratee(array[index], index, array) === false) {
	        break;
	      }
	    }
	    return array;
	  }
	
	  /**
	   * A specialized version of `_.forEachRight` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns `array`.
	   */
	  function arrayEachRight(array, iteratee) {
	    var length = array == null ? 0 : array.length;
	
	    while (length--) {
	      if (iteratee(array[length], length, array) === false) {
	        break;
	      }
	    }
	    return array;
	  }
	
	  /**
	   * A specialized version of `_.every` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {boolean} Returns `true` if all elements pass the predicate check,
	   *  else `false`.
	   */
	  function arrayEvery(array, predicate) {
	    var index = -1,
	        length = array == null ? 0 : array.length;
	
	    while (++index < length) {
	      if (!predicate(array[index], index, array)) {
	        return false;
	      }
	    }
	    return true;
	  }
	
	  /**
	   * A specialized version of `_.filter` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {Array} Returns the new filtered array.
	   */
	  function arrayFilter(array, predicate) {
	    var index = -1,
	        length = array == null ? 0 : array.length,
	        resIndex = 0,
	        result = [];
	
	    while (++index < length) {
	      var value = array[index];
	      if (predicate(value, index, array)) {
	        result[resIndex++] = value;
	      }
	    }
	    return result;
	  }
	
	  /**
	   * A specialized version of `_.includes` for arrays without support for
	   * specifying an index to search from.
	   *
	   * @private
	   * @param {Array} [array] The array to inspect.
	   * @param {*} target The value to search for.
	   * @returns {boolean} Returns `true` if `target` is found, else `false`.
	   */
	  function arrayIncludes(array, value) {
	    var length = array == null ? 0 : array.length;
	    return !!length && baseIndexOf(array, value, 0) > -1;
	  }
	
	  /**
	   * This function is like `arrayIncludes` except that it accepts a comparator.
	   *
	   * @private
	   * @param {Array} [array] The array to inspect.
	   * @param {*} target The value to search for.
	   * @param {Function} comparator The comparator invoked per element.
	   * @returns {boolean} Returns `true` if `target` is found, else `false`.
	   */
	  function arrayIncludesWith(array, value, comparator) {
	    var index = -1,
	        length = array == null ? 0 : array.length;
	
	    while (++index < length) {
	      if (comparator(value, array[index])) {
	        return true;
	      }
	    }
	    return false;
	  }
	
	  /**
	   * A specialized version of `_.map` for arrays without support for iteratee
	   * shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns the new mapped array.
	   */
	  function arrayMap(array, iteratee) {
	    var index = -1,
	        length = array == null ? 0 : array.length,
	        result = Array(length);
	
	    while (++index < length) {
	      result[index] = iteratee(array[index], index, array);
	    }
	    return result;
	  }
	
	  /**
	   * Appends the elements of `values` to `array`.
	   *
	   * @private
	   * @param {Array} array The array to modify.
	   * @param {Array} values The values to append.
	   * @returns {Array} Returns `array`.
	   */
	  function arrayPush(array, values) {
	    var index = -1,
	        length = values.length,
	        offset = array.length;
	
	    while (++index < length) {
	      array[offset + index] = values[index];
	    }
	    return array;
	  }
	
	  /**
	   * A specialized version of `_.reduce` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} [accumulator] The initial value.
	   * @param {boolean} [initAccum] Specify using the first element of `array` as
	   *  the initial value.
	   * @returns {*} Returns the accumulated value.
	   */
	  function arrayReduce(array, iteratee, accumulator, initAccum) {
	    var index = -1,
	        length = array == null ? 0 : array.length;
	
	    if (initAccum && length) {
	      accumulator = array[++index];
	    }
	    while (++index < length) {
	      accumulator = iteratee(accumulator, array[index], index, array);
	    }
	    return accumulator;
	  }
	
	  /**
	   * A specialized version of `_.reduceRight` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} [accumulator] The initial value.
	   * @param {boolean} [initAccum] Specify using the last element of `array` as
	   *  the initial value.
	   * @returns {*} Returns the accumulated value.
	   */
	  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
	    var length = array == null ? 0 : array.length;
	    if (initAccum && length) {
	      accumulator = array[--length];
	    }
	    while (length--) {
	      accumulator = iteratee(accumulator, array[length], length, array);
	    }
	    return accumulator;
	  }
	
	  /**
	   * A specialized version of `_.some` for arrays without support for iteratee
	   * shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {boolean} Returns `true` if any element passes the predicate check,
	   *  else `false`.
	   */
	  function arraySome(array, predicate) {
	    var index = -1,
	        length = array == null ? 0 : array.length;
	
	    while (++index < length) {
	      if (predicate(array[index], index, array)) {
	        return true;
	      }
	    }
	    return false;
	  }
	
	  /**
	   * Gets the size of an ASCII `string`.
	   *
	   * @private
	   * @param {string} string The string inspect.
	   * @returns {number} Returns the string size.
	   */
	  var asciiSize = baseProperty('length');
	
	  /**
	   * Converts an ASCII `string` to an array.
	   *
	   * @private
	   * @param {string} string The string to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function asciiToArray(string) {
	    return string.split('');
	  }
	
	  /**
	   * Splits an ASCII `string` into an array of its words.
	   *
	   * @private
	   * @param {string} The string to inspect.
	   * @returns {Array} Returns the words of `string`.
	   */
	  function asciiWords(string) {
	    return string.match(reAsciiWord) || [];
	  }
	
	  /**
	   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
	   * without support for iteratee shorthands, which iterates over `collection`
	   * using `eachFunc`.
	   *
	   * @private
	   * @param {Array|Object} collection The collection to inspect.
	   * @param {Function} predicate The function invoked per iteration.
	   * @param {Function} eachFunc The function to iterate over `collection`.
	   * @returns {*} Returns the found element or its key, else `undefined`.
	   */
	  function baseFindKey(collection, predicate, eachFunc) {
	    var result;
	    eachFunc(collection, function(value, key, collection) {
	      if (predicate(value, key, collection)) {
	        result = key;
	        return false;
	      }
	    });
	    return result;
	  }
	
	  /**
	   * The base implementation of `_.findIndex` and `_.findLastIndex` without
	   * support for iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {Function} predicate The function invoked per iteration.
	   * @param {number} fromIndex The index to search from.
	   * @param {boolean} [fromRight] Specify iterating from right to left.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseFindIndex(array, predicate, fromIndex, fromRight) {
	    var length = array.length,
	        index = fromIndex + (fromRight ? 1 : -1);
	
	    while ((fromRight ? index-- : ++index < length)) {
	      if (predicate(array[index], index, array)) {
	        return index;
	      }
	    }
	    return -1;
	  }
	
	  /**
	   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseIndexOf(array, value, fromIndex) {
	    return value === value
	      ? strictIndexOf(array, value, fromIndex)
	      : baseFindIndex(array, baseIsNaN, fromIndex);
	  }
	
	  /**
	   * This function is like `baseIndexOf` except that it accepts a comparator.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @param {Function} comparator The comparator invoked per element.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseIndexOfWith(array, value, fromIndex, comparator) {
	    var index = fromIndex - 1,
	        length = array.length;
	
	    while (++index < length) {
	      if (comparator(array[index], value)) {
	        return index;
	      }
	    }
	    return -1;
	  }
	
	  /**
	   * The base implementation of `_.isNaN` without support for number objects.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	   */
	  function baseIsNaN(value) {
	    return value !== value;
	  }
	
	  /**
	   * The base implementation of `_.mean` and `_.meanBy` without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {number} Returns the mean.
	   */
	  function baseMean(array, iteratee) {
	    var length = array == null ? 0 : array.length;
	    return length ? (baseSum(array, iteratee) / length) : NAN;
	  }
	
	  /**
	   * The base implementation of `_.property` without support for deep paths.
	   *
	   * @private
	   * @param {string} key The key of the property to get.
	   * @returns {Function} Returns the new accessor function.
	   */
	  function baseProperty(key) {
	    return function(object) {
	      return object == null ? undefined : object[key];
	    };
	  }
	
	  /**
	   * The base implementation of `_.propertyOf` without support for deep paths.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @returns {Function} Returns the new accessor function.
	   */
	  function basePropertyOf(object) {
	    return function(key) {
	      return object == null ? undefined : object[key];
	    };
	  }
	
	  /**
	   * The base implementation of `_.reduce` and `_.reduceRight`, without support
	   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
	   *
	   * @private
	   * @param {Array|Object} collection The collection to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} accumulator The initial value.
	   * @param {boolean} initAccum Specify using the first or last element of
	   *  `collection` as the initial value.
	   * @param {Function} eachFunc The function to iterate over `collection`.
	   * @returns {*} Returns the accumulated value.
	   */
	  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
	    eachFunc(collection, function(value, index, collection) {
	      accumulator = initAccum
	        ? (initAccum = false, value)
	        : iteratee(accumulator, value, index, collection);
	    });
	    return accumulator;
	  }
	
	  /**
	   * The base implementation of `_.sortBy` which uses `comparer` to define the
	   * sort order of `array` and replaces criteria objects with their corresponding
	   * values.
	   *
	   * @private
	   * @param {Array} array The array to sort.
	   * @param {Function} comparer The function to define sort order.
	   * @returns {Array} Returns `array`.
	   */
	  function baseSortBy(array, comparer) {
	    var length = array.length;
	
	    array.sort(comparer);
	    while (length--) {
	      array[length] = array[length].value;
	    }
	    return array;
	  }
	
	  /**
	   * The base implementation of `_.sum` and `_.sumBy` without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {number} Returns the sum.
	   */
	  function baseSum(array, iteratee) {
	    var result,
	        index = -1,
	        length = array.length;
	
	    while (++index < length) {
	      var current = iteratee(array[index]);
	      if (current !== undefined) {
	        result = result === undefined ? current : (result + current);
	      }
	    }
	    return result;
	  }
	
	  /**
	   * The base implementation of `_.times` without support for iteratee shorthands
	   * or max array length checks.
	   *
	   * @private
	   * @param {number} n The number of times to invoke `iteratee`.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns the array of results.
	   */
	  function baseTimes(n, iteratee) {
	    var index = -1,
	        result = Array(n);
	
	    while (++index < n) {
	      result[index] = iteratee(index);
	    }
	    return result;
	  }
	
	  /**
	   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
	   * of key-value pairs for `object` corresponding to the property names of `props`.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @param {Array} props The property names to get values for.
	   * @returns {Object} Returns the key-value pairs.
	   */
	  function baseToPairs(object, props) {
	    return arrayMap(props, function(key) {
	      return [key, object[key]];
	    });
	  }
	
	  /**
	   * The base implementation of `_.unary` without support for storing metadata.
	   *
	   * @private
	   * @param {Function} func The function to cap arguments for.
	   * @returns {Function} Returns the new capped function.
	   */
	  function baseUnary(func) {
	    return function(value) {
	      return func(value);
	    };
	  }
	
	  /**
	   * The base implementation of `_.values` and `_.valuesIn` which creates an
	   * array of `object` property values corresponding to the property names
	   * of `props`.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @param {Array} props The property names to get values for.
	   * @returns {Object} Returns the array of property values.
	   */
	  function baseValues(object, props) {
	    return arrayMap(props, function(key) {
	      return object[key];
	    });
	  }
	
	  /**
	   * Checks if a `cache` value for `key` exists.
	   *
	   * @private
	   * @param {Object} cache The cache to query.
	   * @param {string} key The key of the entry to check.
	   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	   */
	  function cacheHas(cache, key) {
	    return cache.has(key);
	  }
	
	  /**
	   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
	   * that is not found in the character symbols.
	   *
	   * @private
	   * @param {Array} strSymbols The string symbols to inspect.
	   * @param {Array} chrSymbols The character symbols to find.
	   * @returns {number} Returns the index of the first unmatched string symbol.
	   */
	  function charsStartIndex(strSymbols, chrSymbols) {
	    var index = -1,
	        length = strSymbols.length;
	
	    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
	    return index;
	  }
	
	  /**
	   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
	   * that is not found in the character symbols.
	   *
	   * @private
	   * @param {Array} strSymbols The string symbols to inspect.
	   * @param {Array} chrSymbols The character symbols to find.
	   * @returns {number} Returns the index of the last unmatched string symbol.
	   */
	  function charsEndIndex(strSymbols, chrSymbols) {
	    var index = strSymbols.length;
	
	    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
	    return index;
	  }
	
	  /**
	   * Gets the number of `placeholder` occurrences in `array`.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} placeholder The placeholder to search for.
	   * @returns {number} Returns the placeholder count.
	   */
	  function countHolders(array, placeholder) {
	    var length = array.length,
	        result = 0;
	
	    while (length--) {
	      if (array[length] === placeholder) {
	        ++result;
	      }
	    }
	    return result;
	  }
	
	  /**
	   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
	   * letters to basic Latin letters.
	   *
	   * @private
	   * @param {string} letter The matched letter to deburr.
	   * @returns {string} Returns the deburred letter.
	   */
	  var deburrLetter = basePropertyOf(deburredLetters);
	
	  /**
	   * Used by `_.escape` to convert characters to HTML entities.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  var escapeHtmlChar = basePropertyOf(htmlEscapes);
	
	  /**
	   * Used by `_.template` to escape characters for inclusion in compiled string literals.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeStringChar(chr) {
	    return '\\' + stringEscapes[chr];
	  }
	
	  /**
	   * Gets the value at `key` of `object`.
	   *
	   * @private
	   * @param {Object} [object] The object to query.
	   * @param {string} key The key of the property to get.
	   * @returns {*} Returns the property value.
	   */
	  function getValue(object, key) {
	    return object == null ? undefined : object[key];
	  }
	
	  /**
	   * Checks if `string` contains Unicode symbols.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
	   */
	  function hasUnicode(string) {
	    return reHasUnicode.test(string);
	  }
	
	  /**
	   * Checks if `string` contains a word composed of Unicode symbols.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {boolean} Returns `true` if a word is found, else `false`.
	   */
	  function hasUnicodeWord(string) {
	    return reHasUnicodeWord.test(string);
	  }
	
	  /**
	   * Converts `iterator` to an array.
	   *
	   * @private
	   * @param {Object} iterator The iterator to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function iteratorToArray(iterator) {
	    var data,
	        result = [];
	
	    while (!(data = iterator.next()).done) {
	      result.push(data.value);
	    }
	    return result;
	  }
	
	  /**
	   * Converts `map` to its key-value pairs.
	   *
	   * @private
	   * @param {Object} map The map to convert.
	   * @returns {Array} Returns the key-value pairs.
	   */
	  function mapToArray(map) {
	    var index = -1,
	        result = Array(map.size);
	
	    map.forEach(function(value, key) {
	      result[++index] = [key, value];
	    });
	    return result;
	  }
	
	  /**
	   * Creates a unary function that invokes `func` with its argument transformed.
	   *
	   * @private
	   * @param {Function} func The function to wrap.
	   * @param {Function} transform The argument transform.
	   * @returns {Function} Returns the new function.
	   */
	  function overArg(func, transform) {
	    return function(arg) {
	      return func(transform(arg));
	    };
	  }
	
	  /**
	   * Replaces all `placeholder` elements in `array` with an internal placeholder
	   * and returns an array of their indexes.
	   *
	   * @private
	   * @param {Array} array The array to modify.
	   * @param {*} placeholder The placeholder to replace.
	   * @returns {Array} Returns the new array of placeholder indexes.
	   */
	  function replaceHolders(array, placeholder) {
	    var index = -1,
	        length = array.length,
	        resIndex = 0,
	        result = [];
	
	    while (++index < length) {
	      var value = array[index];
	      if (value === placeholder || value === PLACEHOLDER) {
	        array[index] = PLACEHOLDER;
	        result[resIndex++] = index;
	      }
	    }
	    return result;
	  }
	
	  /**
	   * Converts `set` to an array of its values.
	   *
	   * @private
	   * @param {Object} set The set to convert.
	   * @returns {Array} Returns the values.
	   */
	  function setToArray(set) {
	    var index = -1,
	        result = Array(set.size);
	
	    set.forEach(function(value) {
	      result[++index] = value;
	    });
	    return result;
	  }
	
	  /**
	   * Converts `set` to its value-value pairs.
	   *
	   * @private
	   * @param {Object} set The set to convert.
	   * @returns {Array} Returns the value-value pairs.
	   */
	  function setToPairs(set) {
	    var index = -1,
	        result = Array(set.size);
	
	    set.forEach(function(value) {
	      result[++index] = [value, value];
	    });
	    return result;
	  }
	
	  /**
	   * A specialized version of `_.indexOf` which performs strict equality
	   * comparisons of values, i.e. `===`.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function strictIndexOf(array, value, fromIndex) {
	    var index = fromIndex - 1,
	        length = array.length;
	
	    while (++index < length) {
	      if (array[index] === value) {
	        return index;
	      }
	    }
	    return -1;
	  }
	
	  /**
	   * A specialized version of `_.lastIndexOf` which performs strict equality
	   * comparisons of values, i.e. `===`.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function strictLastIndexOf(array, value, fromIndex) {
	    var index = fromIndex + 1;
	    while (index--) {
	      if (array[index] === value) {
	        return index;
	      }
	    }
	    return index;
	  }
	
	  /**
	   * Gets the number of symbols in `string`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {number} Returns the string size.
	   */
	  function stringSize(string) {
	    return hasUnicode(string)
	      ? unicodeSize(string)
	      : asciiSize(string);
	  }
	
	  /**
	   * Converts `string` to an array.
	   *
	   * @private
	   * @param {string} string The string to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function stringToArray(string) {
	    return hasUnicode(string)
	      ? unicodeToArray(string)
	      : asciiToArray(string);
	  }
	
	  /**
	   * Used by `_.unescape` to convert HTML entities to characters.
	   *
	   * @private
	   * @param {string} chr The matched character to unescape.
	   * @returns {string} Returns the unescaped character.
	   */
	  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
	
	  /**
	   * Gets the size of a Unicode `string`.
	   *
	   * @private
	   * @param {string} string The string inspect.
	   * @returns {number} Returns the string size.
	   */
	  function unicodeSize(string) {
	    var result = reUnicode.lastIndex = 0;
	    while (reUnicode.test(string)) {
	      ++result;
	    }
	    return result;
	  }
	
	  /**
	   * Converts a Unicode `string` to an array.
	   *
	   * @private
	   * @param {string} string The string to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function unicodeToArray(string) {
	    return string.match(reUnicode) || [];
	  }
	
	  /**
	   * Splits a Unicode `string` into an array of its words.
	   *
	   * @private
	   * @param {string} The string to inspect.
	   * @returns {Array} Returns the words of `string`.
	   */
	  function unicodeWords(string) {
	    return string.match(reUnicodeWord) || [];
	  }
	
	  /*--------------------------------------------------------------------------*/
	
	  /**
	   * Create a new pristine `lodash` function using the `context` object.
	   *
	   * @static
	   * @memberOf _
	   * @since 1.1.0
	   * @category Util
	   * @param {Object} [context=root] The context object.
	   * @returns {Function} Returns a new `lodash` function.
	   * @example
	   *
	   * _.mixin({ 'foo': _.constant('foo') });
	   *
	   * var lodash = _.runInContext();
	   * lodash.mixin({ 'bar': lodash.constant('bar') });
	   *
	   * _.isFunction(_.foo);
	   * // => true
	   * _.isFunction(_.bar);
	   * // => false
	   *
	   * lodash.isFunction(lodash.foo);
	   * // => false
	   * lodash.isFunction(lodash.bar);
	   * // => true
	   *
	   * // Create a suped-up `defer` in Node.js.
	   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
	   */
	  var runInContext = (function runInContext(context) {
	    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
	
	    /** Built-in constructor references. */
	    var Array = context.Array,
	        Date = context.Date,
	        Error = context.Error,
	        Function = context.Function,
	        Math = context.Math,
	        Object = context.Object,
	        RegExp = context.RegExp,
	        String = context.String,
	        TypeError = context.TypeError;
	
	    /** Used for built-in method references. */
	    var arrayProto = Array.prototype,
	        funcProto = Function.prototype,
	        objectProto = Object.prototype;
	
	    /** Used to detect overreaching core-js shims. */
	    var coreJsData = context['__core-js_shared__'];
	
	    /** Used to resolve the decompiled source of functions. */
	    var funcToString = funcProto.toString;
	
	    /** Used to check objects for own properties. */
	    var hasOwnProperty = objectProto.hasOwnProperty;
	
	    /** Used to generate unique IDs. */
	    var idCounter = 0;
	
	    /** Used to detect methods masquerading as native. */
	    var maskSrcKey = (function() {
	      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	      return uid ? ('Symbol(src)_1.' + uid) : '';
	    }());
	
	    /**
	     * Used to resolve the
	     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	     * of values.
	     */
	    var nativeObjectToString = objectProto.toString;
	
	    /** Used to infer the `Object` constructor. */
	    var objectCtorString = funcToString.call(Object);
	
	    /** Used to restore the original `_` reference in `_.noConflict`. */
	    var oldDash = root._;
	
	    /** Used to detect if a method is native. */
	    var reIsNative = RegExp('^' +
	      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	    );
	
	    /** Built-in value references. */
	    var Buffer = moduleExports ? context.Buffer : undefined,
	        Symbol = context.Symbol,
	        Uint8Array = context.Uint8Array,
	        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
	        getPrototype = overArg(Object.getPrototypeOf, Object),
	        objectCreate = Object.create,
	        propertyIsEnumerable = objectProto.propertyIsEnumerable,
	        splice = arrayProto.splice,
	        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
	        symIterator = Symbol ? Symbol.iterator : undefined,
	        symToStringTag = Symbol ? Symbol.toStringTag : undefined;
	
	    var defineProperty = (function() {
	      try {
	        var func = getNative(Object, 'defineProperty');
	        func({}, '', {});
	        return func;
	      } catch (e) {}
	    }());
	
	    /** Mocked built-ins. */
	    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
	        ctxNow = Date && Date.now !== root.Date.now && Date.now,
	        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
	
	    /* Built-in method references for those with the same name as other `lodash` methods. */
	    var nativeCeil = Math.ceil,
	        nativeFloor = Math.floor,
	        nativeGetSymbols = Object.getOwnPropertySymbols,
	        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
	        nativeIsFinite = context.isFinite,
	        nativeJoin = arrayProto.join,
	        nativeKeys = overArg(Object.keys, Object),
	        nativeMax = Math.max,
	        nativeMin = Math.min,
	        nativeNow = Date.now,
	        nativeParseInt = context.parseInt,
	        nativeRandom = Math.random,
	        nativeReverse = arrayProto.reverse;
	
	    /* Built-in method references that are verified to be native. */
	    var DataView = getNative(context, 'DataView'),
	        Map = getNative(context, 'Map'),
	        Promise = getNative(context, 'Promise'),
	        Set = getNative(context, 'Set'),
	        WeakMap = getNative(context, 'WeakMap'),
	        nativeCreate = getNative(Object, 'create');
	
	    /** Used to store function metadata. */
	    var metaMap = WeakMap && new WeakMap;
	
	    /** Used to lookup unminified function names. */
	    var realNames = {};
	
	    /** Used to detect maps, sets, and weakmaps. */
	    var dataViewCtorString = toSource(DataView),
	        mapCtorString = toSource(Map),
	        promiseCtorString = toSource(Promise),
	        setCtorString = toSource(Set),
	        weakMapCtorString = toSource(WeakMap);
	
	    /** Used to convert symbols to primitives and strings. */
	    var symbolProto = Symbol ? Symbol.prototype : undefined,
	        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
	        symbolToString = symbolProto ? symbolProto.toString : undefined;
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates a `lodash` object which wraps `value` to enable implicit method
	     * chain sequences. Methods that operate on and return arrays, collections,
	     * and functions can be chained together. Methods that retrieve a single value
	     * or may return a primitive value will automatically end the chain sequence
	     * and return the unwrapped value. Otherwise, the value must be unwrapped
	     * with `_#value`.
	     *
	     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
	     * enabled using `_.chain`.
	     *
	     * The execution of chained methods is lazy, that is, it's deferred until
	     * `_#value` is implicitly or explicitly called.
	     *
	     * Lazy evaluation allows several methods to support shortcut fusion.
	     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
	     * the creation of intermediate arrays and can greatly reduce the number of
	     * iteratee executions. Sections of a chain sequence qualify for shortcut
	     * fusion if the section is applied to an array and iteratees accept only
	     * one argument. The heuristic for whether a section qualifies for shortcut
	     * fusion is subject to change.
	     *
	     * Chaining is supported in custom builds as long as the `_#value` method is
	     * directly or indirectly included in the build.
	     *
	     * In addition to lodash methods, wrappers have `Array` and `String` methods.
	     *
	     * The wrapper `Array` methods are:
	     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
	     *
	     * The wrapper `String` methods are:
	     * `replace` and `split`
	     *
	     * The wrapper methods that support shortcut fusion are:
	     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
	     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
	     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
	     *
	     * The chainable wrapper methods are:
	     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
	     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
	     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
	     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
	     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
	     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
	     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
	     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
	     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
	     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
	     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
	     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
	     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
	     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
	     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
	     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
	     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
	     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
	     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
	     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
	     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
	     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
	     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
	     * `zipObject`, `zipObjectDeep`, and `zipWith`
	     *
	     * The wrapper methods that are **not** chainable by default are:
	     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
	     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
	     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
	     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
	     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
	     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
	     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
	     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
	     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
	     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
	     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
	     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
	     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
	     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
	     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
	     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
	     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
	     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
	     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
	     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
	     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
	     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
	     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
	     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
	     * `upperFirst`, `value`, and `words`
	     *
	     * @name _
	     * @constructor
	     * @category Seq
	     * @param {*} value The value to wrap in a `lodash` instance.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var wrapped = _([1, 2, 3]);
	     *
	     * // Returns an unwrapped value.
	     * wrapped.reduce(_.add);
	     * // => 6
	     *
	     * // Returns a wrapped value.
	     * var squares = wrapped.map(square);
	     *
	     * _.isArray(squares);
	     * // => false
	     *
	     * _.isArray(squares.value());
	     * // => true
	     */
	    function lodash(value) {
	      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
	        if (value instanceof LodashWrapper) {
	          return value;
	        }
	        if (hasOwnProperty.call(value, '__wrapped__')) {
	          return wrapperClone(value);
	        }
	      }
	      return new LodashWrapper(value);
	    }
	
	    /**
	     * The base implementation of `_.create` without support for assigning
	     * properties to the created object.
	     *
	     * @private
	     * @param {Object} proto The object to inherit from.
	     * @returns {Object} Returns the new object.
	     */
	    var baseCreate = (function() {
	      function object() {}
	      return function(proto) {
	        if (!isObject(proto)) {
	          return {};
	        }
	        if (objectCreate) {
	          return objectCreate(proto);
	        }
	        object.prototype = proto;
	        var result = new object;
	        object.prototype = undefined;
	        return result;
	      };
	    }());
	
	    /**
	     * The function whose prototype chain sequence wrappers inherit from.
	     *
	     * @private
	     */
	    function baseLodash() {
	      // No operation performed.
	    }
	
	    /**
	     * The base constructor for creating `lodash` wrapper objects.
	     *
	     * @private
	     * @param {*} value The value to wrap.
	     * @param {boolean} [chainAll] Enable explicit method chain sequences.
	     */
	    function LodashWrapper(value, chainAll) {
	      this.__wrapped__ = value;
	      this.__actions__ = [];
	      this.__chain__ = !!chainAll;
	      this.__index__ = 0;
	      this.__values__ = undefined;
	    }
	
	    /**
	     * By default, the template delimiters used by lodash are like those in
	     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
	     * following template settings to use alternative delimiters.
	     *
	     * @static
	     * @memberOf _
	     * @type {Object}
	     */
	    lodash.templateSettings = {
	
	      /**
	       * Used to detect `data` property values to be HTML-escaped.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */
	      'escape': reEscape,
	
	      /**
	       * Used to detect code to be evaluated.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */
	      'evaluate': reEvaluate,
	
	      /**
	       * Used to detect `data` property values to inject.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */
	      'interpolate': reInterpolate,
	
	      /**
	       * Used to reference the data object in the template text.
	       *
	       * @memberOf _.templateSettings
	       * @type {string}
	       */
	      'variable': '',
	
	      /**
	       * Used to import variables into the compiled template.
	       *
	       * @memberOf _.templateSettings
	       * @type {Object}
	       */
	      'imports': {
	
	        /**
	         * A reference to the `lodash` function.
	         *
	         * @memberOf _.templateSettings.imports
	         * @type {Function}
	         */
	        '_': lodash
	      }
	    };
	
	    // Ensure wrappers are instances of `baseLodash`.
	    lodash.prototype = baseLodash.prototype;
	    lodash.prototype.constructor = lodash;
	
	    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
	    LodashWrapper.prototype.constructor = LodashWrapper;
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
	     *
	     * @private
	     * @constructor
	     * @param {*} value The value to wrap.
	     */
	    function LazyWrapper(value) {
	      this.__wrapped__ = value;
	      this.__actions__ = [];
	      this.__dir__ = 1;
	      this.__filtered__ = false;
	      this.__iteratees__ = [];
	      this.__takeCount__ = MAX_ARRAY_LENGTH;
	      this.__views__ = [];
	    }
	
	    /**
	     * Creates a clone of the lazy wrapper object.
	     *
	     * @private
	     * @name clone
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the cloned `LazyWrapper` object.
	     */
	    function lazyClone() {
	      var result = new LazyWrapper(this.__wrapped__);
	      result.__actions__ = copyArray(this.__actions__);
	      result.__dir__ = this.__dir__;
	      result.__filtered__ = this.__filtered__;
	      result.__iteratees__ = copyArray(this.__iteratees__);
	      result.__takeCount__ = this.__takeCount__;
	      result.__views__ = copyArray(this.__views__);
	      return result;
	    }
	
	    /**
	     * Reverses the direction of lazy iteration.
	     *
	     * @private
	     * @name reverse
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the new reversed `LazyWrapper` object.
	     */
	    function lazyReverse() {
	      if (this.__filtered__) {
	        var result = new LazyWrapper(this);
	        result.__dir__ = -1;
	        result.__filtered__ = true;
	      } else {
	        result = this.clone();
	        result.__dir__ *= -1;
	      }
	      return result;
	    }
	
	    /**
	     * Extracts the unwrapped value from its lazy wrapper.
	     *
	     * @private
	     * @name value
	     * @memberOf LazyWrapper
	     * @returns {*} Returns the unwrapped value.
	     */
	    function lazyValue() {
	      var array = this.__wrapped__.value(),
	          dir = this.__dir__,
	          isArr = isArray(array),
	          isRight = dir < 0,
	          arrLength = isArr ? array.length : 0,
	          view = getView(0, arrLength, this.__views__),
	          start = view.start,
	          end = view.end,
	          length = end - start,
	          index = isRight ? end : (start - 1),
	          iteratees = this.__iteratees__,
	          iterLength = iteratees.length,
	          resIndex = 0,
	          takeCount = nativeMin(length, this.__takeCount__);
	
	      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
	        return baseWrapperValue(array, this.__actions__);
	      }
	      var result = [];
	
	      outer:
	      while (length-- && resIndex < takeCount) {
	        index += dir;
	
	        var iterIndex = -1,
	            value = array[index];
	
	        while (++iterIndex < iterLength) {
	          var data = iteratees[iterIndex],
	              iteratee = data.iteratee,
	              type = data.type,
	              computed = iteratee(value);
	
	          if (type == LAZY_MAP_FLAG) {
	            value = computed;
	          } else if (!computed) {
	            if (type == LAZY_FILTER_FLAG) {
	              continue outer;
	            } else {
	              break outer;
	            }
	          }
	        }
	        result[resIndex++] = value;
	      }
	      return result;
	    }
	
	    // Ensure `LazyWrapper` is an instance of `baseLodash`.
	    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
	    LazyWrapper.prototype.constructor = LazyWrapper;
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates a hash object.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function Hash(entries) {
	      var index = -1,
	          length = entries == null ? 0 : entries.length;
	
	      this.clear();
	      while (++index < length) {
	        var entry = entries[index];
	        this.set(entry[0], entry[1]);
	      }
	    }
	
	    /**
	     * Removes all key-value entries from the hash.
	     *
	     * @private
	     * @name clear
	     * @memberOf Hash
	     */
	    function hashClear() {
	      this.__data__ = nativeCreate ? nativeCreate(null) : {};
	      this.size = 0;
	    }
	
	    /**
	     * Removes `key` and its value from the hash.
	     *
	     * @private
	     * @name delete
	     * @memberOf Hash
	     * @param {Object} hash The hash to modify.
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function hashDelete(key) {
	      var result = this.has(key) && delete this.__data__[key];
	      this.size -= result ? 1 : 0;
	      return result;
	    }
	
	    /**
	     * Gets the hash value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf Hash
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function hashGet(key) {
	      var data = this.__data__;
	      if (nativeCreate) {
	        var result = data[key];
	        return result === HASH_UNDEFINED ? undefined : result;
	      }
	      return hasOwnProperty.call(data, key) ? data[key] : undefined;
	    }
	
	    /**
	     * Checks if a hash value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf Hash
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function hashHas(key) {
	      var data = this.__data__;
	      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
	    }
	
	    /**
	     * Sets the hash `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf Hash
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the hash instance.
	     */
	    function hashSet(key, value) {
	      var data = this.__data__;
	      this.size += this.has(key) ? 0 : 1;
	      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	      return this;
	    }
	
	    // Add methods to `Hash`.
	    Hash.prototype.clear = hashClear;
	    Hash.prototype['delete'] = hashDelete;
	    Hash.prototype.get = hashGet;
	    Hash.prototype.has = hashHas;
	    Hash.prototype.set = hashSet;
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates an list cache object.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function ListCache(entries) {
	      var index = -1,
	          length = entries == null ? 0 : entries.length;
	
	      this.clear();
	      while (++index < length) {
	        var entry = entries[index];
	        this.set(entry[0], entry[1]);
	      }
	    }
	
	    /**
	     * Removes all key-value entries from the list cache.
	     *
	     * @private
	     * @name clear
	     * @memberOf ListCache
	     */
	    function listCacheClear() {
	      this.__data__ = [];
	      this.size = 0;
	    }
	
	    /**
	     * Removes `key` and its value from the list cache.
	     *
	     * @private
	     * @name delete
	     * @memberOf ListCache
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function listCacheDelete(key) {
	      var data = this.__data__,
	          index = assocIndexOf(data, key);
	
	      if (index < 0) {
	        return false;
	      }
	      var lastIndex = data.length - 1;
	      if (index == lastIndex) {
	        data.pop();
	      } else {
	        splice.call(data, index, 1);
	      }
	      --this.size;
	      return true;
	    }
	
	    /**
	     * Gets the list cache value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf ListCache
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function listCacheGet(key) {
	      var data = this.__data__,
	          index = assocIndexOf(data, key);
	
	      return index < 0 ? undefined : data[index][1];
	    }
	
	    /**
	     * Checks if a list cache value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf ListCache
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function listCacheHas(key) {
	      return assocIndexOf(this.__data__, key) > -1;
	    }
	
	    /**
	     * Sets the list cache `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf ListCache
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the list cache instance.
	     */
	    function listCacheSet(key, value) {
	      var data = this.__data__,
	          index = assocIndexOf(data, key);
	
	      if (index < 0) {
	        ++this.size;
	        data.push([key, value]);
	      } else {
	        data[index][1] = value;
	      }
	      return this;
	    }
	
	    // Add methods to `ListCache`.
	    ListCache.prototype.clear = listCacheClear;
	    ListCache.prototype['delete'] = listCacheDelete;
	    ListCache.prototype.get = listCacheGet;
	    ListCache.prototype.has = listCacheHas;
	    ListCache.prototype.set = listCacheSet;
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates a map cache object to store key-value pairs.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function MapCache(entries) {
	      var index = -1,
	          length = entries == null ? 0 : entries.length;
	
	      this.clear();
	      while (++index < length) {
	        var entry = entries[index];
	        this.set(entry[0], entry[1]);
	      }
	    }
	
	    /**
	     * Removes all key-value entries from the map.
	     *
	     * @private
	     * @name clear
	     * @memberOf MapCache
	     */
	    function mapCacheClear() {
	      this.size = 0;
	      this.__data__ = {
	        'hash': new Hash,
	        'map': new (Map || ListCache),
	        'string': new Hash
	      };
	    }
	
	    /**
	     * Removes `key` and its value from the map.
	     *
	     * @private
	     * @name delete
	     * @memberOf MapCache
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function mapCacheDelete(key) {
	      var result = getMapData(this, key)['delete'](key);
	      this.size -= result ? 1 : 0;
	      return result;
	    }
	
	    /**
	     * Gets the map value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf MapCache
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function mapCacheGet(key) {
	      return getMapData(this, key).get(key);
	    }
	
	    /**
	     * Checks if a map value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf MapCache
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function mapCacheHas(key) {
	      return getMapData(this, key).has(key);
	    }
	
	    /**
	     * Sets the map `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf MapCache
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the map cache instance.
	     */
	    function mapCacheSet(key, value) {
	      var data = getMapData(this, key),
	          size = data.size;
	
	      data.set(key, value);
	      this.size += data.size == size ? 0 : 1;
	      return this;
	    }
	
	    // Add methods to `MapCache`.
	    MapCache.prototype.clear = mapCacheClear;
	    MapCache.prototype['delete'] = mapCacheDelete;
	    MapCache.prototype.get = mapCacheGet;
	    MapCache.prototype.has = mapCacheHas;
	    MapCache.prototype.set = mapCacheSet;
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     *
	     * Creates an array cache object to store unique values.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [values] The values to cache.
	     */
	    function SetCache(values) {
	      var index = -1,
	          length = values == null ? 0 : values.length;
	
	      this.__data__ = new MapCache;
	      while (++index < length) {
	        this.add(values[index]);
	      }
	    }
	
	    /**
	     * Adds `value` to the array cache.
	     *
	     * @private
	     * @name add
	     * @memberOf SetCache
	     * @alias push
	     * @param {*} value The value to cache.
	     * @returns {Object} Returns the cache instance.
	     */
	    function setCacheAdd(value) {
	      this.__data__.set(value, HASH_UNDEFINED);
	      return this;
	    }
	
	    /**
	     * Checks if `value` is in the array cache.
	     *
	     * @private
	     * @name has
	     * @memberOf SetCache
	     * @param {*} value The value to search for.
	     * @returns {number} Returns `true` if `value` is found, else `false`.
	     */
	    function setCacheHas(value) {
	      return this.__data__.has(value);
	    }
	
	    // Add methods to `SetCache`.
	    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	    SetCache.prototype.has = setCacheHas;
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates a stack cache object to store key-value pairs.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function Stack(entries) {
	      var data = this.__data__ = new ListCache(entries);
	      this.size = data.size;
	    }
	
	    /**
	     * Removes all key-value entries from the stack.
	     *
	     * @private
	     * @name clear
	     * @memberOf Stack
	     */
	    function stackClear() {
	      this.__data__ = new ListCache;
	      this.size = 0;
	    }
	
	    /**
	     * Removes `key` and its value from the stack.
	     *
	     * @private
	     * @name delete
	     * @memberOf Stack
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function stackDelete(key) {
	      var data = this.__data__,
	          result = data['delete'](key);
	
	      this.size = data.size;
	      return result;
	    }
	
	    /**
	     * Gets the stack value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf Stack
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function stackGet(key) {
	      return this.__data__.get(key);
	    }
	
	    /**
	     * Checks if a stack value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf Stack
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function stackHas(key) {
	      return this.__data__.has(key);
	    }
	
	    /**
	     * Sets the stack `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf Stack
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the stack cache instance.
	     */
	    function stackSet(key, value) {
	      var data = this.__data__;
	      if (data instanceof ListCache) {
	        var pairs = data.__data__;
	        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	          pairs.push([key, value]);
	          this.size = ++data.size;
	          return this;
	        }
	        data = this.__data__ = new MapCache(pairs);
	      }
	      data.set(key, value);
	      this.size = data.size;
	      return this;
	    }
	
	    // Add methods to `Stack`.
	    Stack.prototype.clear = stackClear;
	    Stack.prototype['delete'] = stackDelete;
	    Stack.prototype.get = stackGet;
	    Stack.prototype.has = stackHas;
	    Stack.prototype.set = stackSet;
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates an array of the enumerable property names of the array-like `value`.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @param {boolean} inherited Specify returning inherited property names.
	     * @returns {Array} Returns the array of property names.
	     */
	    function arrayLikeKeys(value, inherited) {
	      var isArr = isArray(value),
	          isArg = !isArr && isArguments(value),
	          isBuff = !isArr && !isArg && isBuffer(value),
	          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	          skipIndexes = isArr || isArg || isBuff || isType,
	          result = skipIndexes ? baseTimes(value.length, String) : [],
	          length = result.length;
	
	      for (var key in value) {
	        if ((inherited || hasOwnProperty.call(value, key)) &&
	            !(skipIndexes && (
	               // Safari 9 has enumerable `arguments.length` in strict mode.
	               key == 'length' ||
	               // Node.js 0.10 has enumerable non-index properties on buffers.
	               (isBuff && (key == 'offset' || key == 'parent')) ||
	               // PhantomJS 2 has enumerable non-index properties on typed arrays.
	               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	               // Skip index properties.
	               isIndex(key, length)
	            ))) {
	          result.push(key);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * A specialized version of `_.sample` for arrays.
	     *
	     * @private
	     * @param {Array} array The array to sample.
	     * @returns {*} Returns the random element.
	     */
	    function arraySample(array) {
	      var length = array.length;
	      return length ? array[baseRandom(0, length - 1)] : undefined;
	    }
	
	    /**
	     * A specialized version of `_.sampleSize` for arrays.
	     *
	     * @private
	     * @param {Array} array The array to sample.
	     * @param {number} n The number of elements to sample.
	     * @returns {Array} Returns the random elements.
	     */
	    function arraySampleSize(array, n) {
	      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
	    }
	
	    /**
	     * A specialized version of `_.shuffle` for arrays.
	     *
	     * @private
	     * @param {Array} array The array to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     */
	    function arrayShuffle(array) {
	      return shuffleSelf(copyArray(array));
	    }
	
	    /**
	     * This function is like `assignValue` except that it doesn't assign
	     * `undefined` values.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */
	    function assignMergeValue(object, key, value) {
	      if ((value !== undefined && !eq(object[key], value)) ||
	          (value === undefined && !(key in object))) {
	        baseAssignValue(object, key, value);
	      }
	    }
	
	    /**
	     * Assigns `value` to `key` of `object` if the existing value is not equivalent
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */
	    function assignValue(object, key, value) {
	      var objValue = object[key];
	      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
	          (value === undefined && !(key in object))) {
	        baseAssignValue(object, key, value);
	      }
	    }
	
	    /**
	     * Gets the index at which the `key` is found in `array` of key-value pairs.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {*} key The key to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     */
	    function assocIndexOf(array, key) {
	      var length = array.length;
	      while (length--) {
	        if (eq(array[length][0], key)) {
	          return length;
	        }
	      }
	      return -1;
	    }
	
	    /**
	     * Aggregates elements of `collection` on `accumulator` with keys transformed
	     * by `iteratee` and values set by `setter`.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} setter The function to set `accumulator` values.
	     * @param {Function} iteratee The iteratee to transform keys.
	     * @param {Object} accumulator The initial aggregated object.
	     * @returns {Function} Returns `accumulator`.
	     */
	    function baseAggregator(collection, setter, iteratee, accumulator) {
	      baseEach(collection, function(value, key, collection) {
	        setter(accumulator, value, iteratee(value), collection);
	      });
	      return accumulator;
	    }
	
	    /**
	     * The base implementation of `_.assign` without support for multiple sources
	     * or `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @returns {Object} Returns `object`.
	     */
	    function baseAssign(object, source) {
	      return object && copyObject(source, keys(source), object);
	    }
	
	    /**
	     * The base implementation of `_.assignIn` without support for multiple sources
	     * or `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @returns {Object} Returns `object`.
	     */
	    function baseAssignIn(object, source) {
	      return object && copyObject(source, keysIn(source), object);
	    }
	
	    /**
	     * The base implementation of `assignValue` and `assignMergeValue` without
	     * value checks.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */
	    function baseAssignValue(object, key, value) {
	      if (key == '__proto__' && defineProperty) {
	        defineProperty(object, key, {
	          'configurable': true,
	          'enumerable': true,
	          'value': value,
	          'writable': true
	        });
	      } else {
	        object[key] = value;
	      }
	    }
	
	    /**
	     * The base implementation of `_.at` without support for individual paths.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {string[]} paths The property paths to pick.
	     * @returns {Array} Returns the picked elements.
	     */
	    function baseAt(object, paths) {
	      var index = -1,
	          length = paths.length,
	          result = Array(length),
	          skip = object == null;
	
	      while (++index < length) {
	        result[index] = skip ? undefined : get(object, paths[index]);
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.clamp` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {number} number The number to clamp.
	     * @param {number} [lower] The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the clamped number.
	     */
	    function baseClamp(number, lower, upper) {
	      if (number === number) {
	        if (upper !== undefined) {
	          number = number <= upper ? number : upper;
	        }
	        if (lower !== undefined) {
	          number = number >= lower ? number : lower;
	        }
	      }
	      return number;
	    }
	
	    /**
	     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
	     * traversed objects.
	     *
	     * @private
	     * @param {*} value The value to clone.
	     * @param {boolean} bitmask The bitmask flags.
	     *  1 - Deep clone
	     *  2 - Flatten inherited properties
	     *  4 - Clone symbols
	     * @param {Function} [customizer] The function to customize cloning.
	     * @param {string} [key] The key of `value`.
	     * @param {Object} [object] The parent object of `value`.
	     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
	     * @returns {*} Returns the cloned value.
	     */
	    function baseClone(value, bitmask, customizer, key, object, stack) {
	      var result,
	          isDeep = bitmask & CLONE_DEEP_FLAG,
	          isFlat = bitmask & CLONE_FLAT_FLAG,
	          isFull = bitmask & CLONE_SYMBOLS_FLAG;
	
	      if (customizer) {
	        result = object ? customizer(value, key, object, stack) : customizer(value);
	      }
	      if (result !== undefined) {
	        return result;
	      }
	      if (!isObject(value)) {
	        return value;
	      }
	      var isArr = isArray(value);
	      if (isArr) {
	        result = initCloneArray(value);
	        if (!isDeep) {
	          return copyArray(value, result);
	        }
	      } else {
	        var tag = getTag(value),
	            isFunc = tag == funcTag || tag == genTag;
	
	        if (isBuffer(value)) {
	          return cloneBuffer(value, isDeep);
	        }
	        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
	          result = (isFlat || isFunc) ? {} : initCloneObject(value);
	          if (!isDeep) {
	            return isFlat
	              ? copySymbolsIn(value, baseAssignIn(result, value))
	              : copySymbols(value, baseAssign(result, value));
	          }
	        } else {
	          if (!cloneableTags[tag]) {
	            return object ? value : {};
	          }
	          result = initCloneByTag(value, tag, baseClone, isDeep);
	        }
	      }
	      // Check for circular references and return its corresponding clone.
	      stack || (stack = new Stack);
	      var stacked = stack.get(value);
	      if (stacked) {
	        return stacked;
	      }
	      stack.set(value, result);
	
	      var keysFunc = isFull
	        ? (isFlat ? getAllKeysIn : getAllKeys)
	        : (isFlat ? keysIn : keys);
	
	      var props = isArr ? undefined : keysFunc(value);
	      arrayEach(props || value, function(subValue, key) {
	        if (props) {
	          key = subValue;
	          subValue = value[key];
	        }
	        // Recursively populate clone (susceptible to call stack limits).
	        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
	      });
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.conforms` which doesn't clone `source`.
	     *
	     * @private
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {Function} Returns the new spec function.
	     */
	    function baseConforms(source) {
	      var props = keys(source);
	      return function(object) {
	        return baseConformsTo(object, source, props);
	      };
	    }
	
	    /**
	     * The base implementation of `_.conformsTo` which accepts `props` to check.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
	     */
	    function baseConformsTo(object, source, props) {
	      var length = props.length;
	      if (object == null) {
	        return !length;
	      }
	      object = Object(object);
	      while (length--) {
	        var key = props[length],
	            predicate = source[key],
	            value = object[key];
	
	        if ((value === undefined && !(key in object)) || !predicate(value)) {
	          return false;
	        }
	      }
	      return true;
	    }
	
	    /**
	     * The base implementation of `_.delay` and `_.defer` which accepts `args`
	     * to provide to `func`.
	     *
	     * @private
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {Array} args The arguments to provide to `func`.
	     * @returns {number|Object} Returns the timer id or timeout object.
	     */
	    function baseDelay(func, wait, args) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return setTimeout(function() { func.apply(undefined, args); }, wait);
	    }
	
	    /**
	     * The base implementation of methods like `_.difference` without support
	     * for excluding multiple arrays or iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Array} values The values to exclude.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     */
	    function baseDifference(array, values, iteratee, comparator) {
	      var index = -1,
	          includes = arrayIncludes,
	          isCommon = true,
	          length = array.length,
	          result = [],
	          valuesLength = values.length;
	
	      if (!length) {
	        return result;
	      }
	      if (iteratee) {
	        values = arrayMap(values, baseUnary(iteratee));
	      }
	      if (comparator) {
	        includes = arrayIncludesWith;
	        isCommon = false;
	      }
	      else if (values.length >= LARGE_ARRAY_SIZE) {
	        includes = cacheHas;
	        isCommon = false;
	        values = new SetCache(values);
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee == null ? value : iteratee(value);
	
	        value = (comparator || value !== 0) ? value : 0;
	        if (isCommon && computed === computed) {
	          var valuesIndex = valuesLength;
	          while (valuesIndex--) {
	            if (values[valuesIndex] === computed) {
	              continue outer;
	            }
	          }
	          result.push(value);
	        }
	        else if (!includes(values, computed, comparator)) {
	          result.push(value);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.forEach` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     */
	    var baseEach = createBaseEach(baseForOwn);
	
	    /**
	     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     */
	    var baseEachRight = createBaseEach(baseForOwnRight, true);
	
	    /**
	     * The base implementation of `_.every` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`
	     */
	    function baseEvery(collection, predicate) {
	      var result = true;
	      baseEach(collection, function(value, index, collection) {
	        result = !!predicate(value, index, collection);
	        return result;
	      });
	      return result;
	    }
	
	    /**
	     * The base implementation of methods like `_.max` and `_.min` which accepts a
	     * `comparator` to determine the extremum value.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The iteratee invoked per iteration.
	     * @param {Function} comparator The comparator used to compare values.
	     * @returns {*} Returns the extremum value.
	     */
	    function baseExtremum(array, iteratee, comparator) {
	      var index = -1,
	          length = array.length;
	
	      while (++index < length) {
	        var value = array[index],
	            current = iteratee(value);
	
	        if (current != null && (computed === undefined
	              ? (current === current && !isSymbol(current))
	              : comparator(current, computed)
	            )) {
	          var computed = current,
	              result = value;
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.fill` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     */
	    function baseFill(array, value, start, end) {
	      var length = array.length;
	
	      start = toInteger(start);
	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = (end === undefined || end > length) ? length : toInteger(end);
	      if (end < 0) {
	        end += length;
	      }
	      end = start > end ? 0 : toLength(end);
	      while (start < end) {
	        array[start++] = value;
	      }
	      return array;
	    }
	
	    /**
	     * The base implementation of `_.filter` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     */
	    function baseFilter(collection, predicate) {
	      var result = [];
	      baseEach(collection, function(value, index, collection) {
	        if (predicate(value, index, collection)) {
	          result.push(value);
	        }
	      });
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.flatten` with support for restricting flattening.
	     *
	     * @private
	     * @param {Array} array The array to flatten.
	     * @param {number} depth The maximum recursion depth.
	     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
	     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
	     * @param {Array} [result=[]] The initial result value.
	     * @returns {Array} Returns the new flattened array.
	     */
	    function baseFlatten(array, depth, predicate, isStrict, result) {
	      var index = -1,
	          length = array.length;
	
	      predicate || (predicate = isFlattenable);
	      result || (result = []);
	
	      while (++index < length) {
	        var value = array[index];
	        if (depth > 0 && predicate(value)) {
	          if (depth > 1) {
	            // Recursively flatten arrays (susceptible to call stack limits).
	            baseFlatten(value, depth - 1, predicate, isStrict, result);
	          } else {
	            arrayPush(result, value);
	          }
	        } else if (!isStrict) {
	          result[result.length] = value;
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `baseForOwn` which iterates over `object`
	     * properties returned by `keysFunc` and invokes `iteratee` for each property.
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    var baseFor = createBaseFor();
	
	    /**
	     * This function is like `baseFor` except that it iterates over properties
	     * in the opposite order.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    var baseForRight = createBaseFor(true);
	
	    /**
	     * The base implementation of `_.forOwn` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwn(object, iteratee) {
	      return object && baseFor(object, iteratee, keys);
	    }
	
	    /**
	     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwnRight(object, iteratee) {
	      return object && baseForRight(object, iteratee, keys);
	    }
	
	    /**
	     * The base implementation of `_.functions` which creates an array of
	     * `object` function property names filtered from `props`.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Array} props The property names to filter.
	     * @returns {Array} Returns the function names.
	     */
	    function baseFunctions(object, props) {
	      return arrayFilter(props, function(key) {
	        return isFunction(object[key]);
	      });
	    }
	
	    /**
	     * The base implementation of `_.get` without support for default values.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to get.
	     * @returns {*} Returns the resolved value.
	     */
	    function baseGet(object, path) {
	      path = castPath(path, object);
	
	      var index = 0,
	          length = path.length;
	
	      while (object != null && index < length) {
	        object = object[toKey(path[index++])];
	      }
	      return (index && index == length) ? object : undefined;
	    }
	
	    /**
	     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	     * symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @param {Function} symbolsFunc The function to get the symbols of `object`.
	     * @returns {Array} Returns the array of property names and symbols.
	     */
	    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	      var result = keysFunc(object);
	      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
	    }
	
	    /**
	     * The base implementation of `getTag` without fallbacks for buggy environments.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @returns {string} Returns the `toStringTag`.
	     */
	    function baseGetTag(value) {
	      if (value == null) {
	        return value === undefined ? undefinedTag : nullTag;
	      }
	      return (symToStringTag && symToStringTag in Object(value))
	        ? getRawTag(value)
	        : objectToString(value);
	    }
	
	    /**
	     * The base implementation of `_.gt` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than `other`,
	     *  else `false`.
	     */
	    function baseGt(value, other) {
	      return value > other;
	    }
	
	    /**
	     * The base implementation of `_.has` without support for deep paths.
	     *
	     * @private
	     * @param {Object} [object] The object to query.
	     * @param {Array|string} key The key to check.
	     * @returns {boolean} Returns `true` if `key` exists, else `false`.
	     */
	    function baseHas(object, key) {
	      return object != null && hasOwnProperty.call(object, key);
	    }
	
	    /**
	     * The base implementation of `_.hasIn` without support for deep paths.
	     *
	     * @private
	     * @param {Object} [object] The object to query.
	     * @param {Array|string} key The key to check.
	     * @returns {boolean} Returns `true` if `key` exists, else `false`.
	     */
	    function baseHasIn(object, key) {
	      return object != null && key in Object(object);
	    }
	
	    /**
	     * The base implementation of `_.inRange` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {number} number The number to check.
	     * @param {number} start The start of the range.
	     * @param {number} end The end of the range.
	     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
	     */
	    function baseInRange(number, start, end) {
	      return number >= nativeMin(start, end) && number < nativeMax(start, end);
	    }
	
	    /**
	     * The base implementation of methods like `_.intersection`, without support
	     * for iteratee shorthands, that accepts an array of arrays to inspect.
	     *
	     * @private
	     * @param {Array} arrays The arrays to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of shared values.
	     */
	    function baseIntersection(arrays, iteratee, comparator) {
	      var includes = comparator ? arrayIncludesWith : arrayIncludes,
	          length = arrays[0].length,
	          othLength = arrays.length,
	          othIndex = othLength,
	          caches = Array(othLength),
	          maxLength = Infinity,
	          result = [];
	
	      while (othIndex--) {
	        var array = arrays[othIndex];
	        if (othIndex && iteratee) {
	          array = arrayMap(array, baseUnary(iteratee));
	        }
	        maxLength = nativeMin(array.length, maxLength);
	        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
	          ? new SetCache(othIndex && array)
	          : undefined;
	      }
	      array = arrays[0];
	
	      var index = -1,
	          seen = caches[0];
	
	      outer:
	      while (++index < length && result.length < maxLength) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value) : value;
	
	        value = (comparator || value !== 0) ? value : 0;
	        if (!(seen
	              ? cacheHas(seen, computed)
	              : includes(result, computed, comparator)
	            )) {
	          othIndex = othLength;
	          while (--othIndex) {
	            var cache = caches[othIndex];
	            if (!(cache
	                  ? cacheHas(cache, computed)
	                  : includes(arrays[othIndex], computed, comparator))
	                ) {
	              continue outer;
	            }
	          }
	          if (seen) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.invert` and `_.invertBy` which inverts
	     * `object` with values transformed by `iteratee` and set by `setter`.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} setter The function to set `accumulator` values.
	     * @param {Function} iteratee The iteratee to transform values.
	     * @param {Object} accumulator The initial inverted object.
	     * @returns {Function} Returns `accumulator`.
	     */
	    function baseInverter(object, setter, iteratee, accumulator) {
	      baseForOwn(object, function(value, key, object) {
	        setter(accumulator, iteratee(value), key, object);
	      });
	      return accumulator;
	    }
	
	    /**
	     * The base implementation of `_.invoke` without support for individual
	     * method arguments.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {Array} args The arguments to invoke the method with.
	     * @returns {*} Returns the result of the invoked method.
	     */
	    function baseInvoke(object, path, args) {
	      path = castPath(path, object);
	      object = parent(object, path);
	      var func = object == null ? object : object[toKey(last(path))];
	      return func == null ? undefined : apply(func, object, args);
	    }
	
	    /**
	     * The base implementation of `_.isArguments`.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	     */
	    function baseIsArguments(value) {
	      return isObjectLike(value) && baseGetTag(value) == argsTag;
	    }
	
	    /**
	     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
	     */
	    function baseIsArrayBuffer(value) {
	      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
	    }
	
	    /**
	     * The base implementation of `_.isDate` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
	     */
	    function baseIsDate(value) {
	      return isObjectLike(value) && baseGetTag(value) == dateTag;
	    }
	
	    /**
	     * The base implementation of `_.isEqual` which supports partial comparisons
	     * and tracks traversed objects.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {boolean} bitmask The bitmask flags.
	     *  1 - Unordered comparison
	     *  2 - Partial comparison
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     */
	    function baseIsEqual(value, other, bitmask, customizer, stack) {
	      if (value === other) {
	        return true;
	      }
	      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
	        return value !== value && other !== other;
	      }
	      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	    }
	
	    /**
	     * A specialized version of `baseIsEqual` for arrays and objects which performs
	     * deep comparisons and tracks traversed objects enabling objects with circular
	     * references to be compared.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	      var objIsArr = isArray(object),
	          othIsArr = isArray(other),
	          objTag = objIsArr ? arrayTag : getTag(object),
	          othTag = othIsArr ? arrayTag : getTag(other);
	
	      objTag = objTag == argsTag ? objectTag : objTag;
	      othTag = othTag == argsTag ? objectTag : othTag;
	
	      var objIsObj = objTag == objectTag,
	          othIsObj = othTag == objectTag,
	          isSameTag = objTag == othTag;
	
	      if (isSameTag && isBuffer(object)) {
	        if (!isBuffer(other)) {
	          return false;
	        }
	        objIsArr = true;
	        objIsObj = false;
	      }
	      if (isSameTag && !objIsObj) {
	        stack || (stack = new Stack);
	        return (objIsArr || isTypedArray(object))
	          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
	          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	      }
	      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
	        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
	
	        if (objIsWrapped || othIsWrapped) {
	          var objUnwrapped = objIsWrapped ? object.value() : object,
	              othUnwrapped = othIsWrapped ? other.value() : other;
	
	          stack || (stack = new Stack);
	          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	        }
	      }
	      if (!isSameTag) {
	        return false;
	      }
	      stack || (stack = new Stack);
	      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	    }
	
	    /**
	     * The base implementation of `_.isMap` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	     */
	    function baseIsMap(value) {
	      return isObjectLike(value) && getTag(value) == mapTag;
	    }
	
	    /**
	     * The base implementation of `_.isMatch` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @param {Array} matchData The property names, values, and compare flags to match.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     */
	    function baseIsMatch(object, source, matchData, customizer) {
	      var index = matchData.length,
	          length = index,
	          noCustomizer = !customizer;
	
	      if (object == null) {
	        return !length;
	      }
	      object = Object(object);
	      while (index--) {
	        var data = matchData[index];
	        if ((noCustomizer && data[2])
	              ? data[1] !== object[data[0]]
	              : !(data[0] in object)
	            ) {
	          return false;
	        }
	      }
	      while (++index < length) {
	        data = matchData[index];
	        var key = data[0],
	            objValue = object[key],
	            srcValue = data[1];
	
	        if (noCustomizer && data[2]) {
	          if (objValue === undefined && !(key in object)) {
	            return false;
	          }
	        } else {
	          var stack = new Stack;
	          if (customizer) {
	            var result = customizer(objValue, srcValue, key, object, source, stack);
	          }
	          if (!(result === undefined
	                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
	                : result
	              )) {
	            return false;
	          }
	        }
	      }
	      return true;
	    }
	
	    /**
	     * The base implementation of `_.isNative` without bad shim checks.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a native function,
	     *  else `false`.
	     */
	    function baseIsNative(value) {
	      if (!isObject(value) || isMasked(value)) {
	        return false;
	      }
	      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	      return pattern.test(toSource(value));
	    }
	
	    /**
	     * The base implementation of `_.isRegExp` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
	     */
	    function baseIsRegExp(value) {
	      return isObjectLike(value) && baseGetTag(value) == regexpTag;
	    }
	
	    /**
	     * The base implementation of `_.isSet` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	     */
	    function baseIsSet(value) {
	      return isObjectLike(value) && getTag(value) == setTag;
	    }
	
	    /**
	     * The base implementation of `_.isTypedArray` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	     */
	    function baseIsTypedArray(value) {
	      return isObjectLike(value) &&
	        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	    }
	
	    /**
	     * The base implementation of `_.iteratee`.
	     *
	     * @private
	     * @param {*} [value=_.identity] The value to convert to an iteratee.
	     * @returns {Function} Returns the iteratee.
	     */
	    function baseIteratee(value) {
	      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	      if (typeof value == 'function') {
	        return value;
	      }
	      if (value == null) {
	        return identity;
	      }
	      if (typeof value == 'object') {
	        return isArray(value)
	          ? baseMatchesProperty(value[0], value[1])
	          : baseMatches(value);
	      }
	      return property(value);
	    }
	
	    /**
	     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function baseKeys(object) {
	      if (!isPrototype(object)) {
	        return nativeKeys(object);
	      }
	      var result = [];
	      for (var key in Object(object)) {
	        if (hasOwnProperty.call(object, key) && key != 'constructor') {
	          result.push(key);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function baseKeysIn(object) {
	      if (!isObject(object)) {
	        return nativeKeysIn(object);
	      }
	      var isProto = isPrototype(object),
	          result = [];
	
	      for (var key in object) {
	        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	          result.push(key);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.lt` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than `other`,
	     *  else `false`.
	     */
	    function baseLt(value, other) {
	      return value < other;
	    }
	
	    /**
	     * The base implementation of `_.map` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     */
	    function baseMap(collection, iteratee) {
	      var index = -1,
	          result = isArrayLike(collection) ? Array(collection.length) : [];
	
	      baseEach(collection, function(value, key, collection) {
	        result[++index] = iteratee(value, key, collection);
	      });
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.matches` which doesn't clone `source`.
	     *
	     * @private
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new spec function.
	     */
	    function baseMatches(source) {
	      var matchData = getMatchData(source);
	      if (matchData.length == 1 && matchData[0][2]) {
	        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
	      }
	      return function(object) {
	        return object === source || baseIsMatch(object, source, matchData);
	      };
	    }
	
	    /**
	     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	     *
	     * @private
	     * @param {string} path The path of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new spec function.
	     */
	    function baseMatchesProperty(path, srcValue) {
	      if (isKey(path) && isStrictComparable(srcValue)) {
	        return matchesStrictComparable(toKey(path), srcValue);
	      }
	      return function(object) {
	        var objValue = get(object, path);
	        return (objValue === undefined && objValue === srcValue)
	          ? hasIn(object, path)
	          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
	      };
	    }
	
	    /**
	     * The base implementation of `_.merge` without support for multiple sources.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {number} srcIndex The index of `source`.
	     * @param {Function} [customizer] The function to customize merged values.
	     * @param {Object} [stack] Tracks traversed source values and their merged
	     *  counterparts.
	     */
	    function baseMerge(object, source, srcIndex, customizer, stack) {
	      if (object === source) {
	        return;
	      }
	      baseFor(source, function(srcValue, key) {
	        if (isObject(srcValue)) {
	          stack || (stack = new Stack);
	          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
	        }
	        else {
	          var newValue = customizer
	            ? customizer(object[key], srcValue, (key + ''), object, source, stack)
	            : undefined;
	
	          if (newValue === undefined) {
	            newValue = srcValue;
	          }
	          assignMergeValue(object, key, newValue);
	        }
	      }, keysIn);
	    }
	
	    /**
	     * A specialized version of `baseMerge` for arrays and objects which performs
	     * deep merges and tracks traversed objects enabling objects with circular
	     * references to be merged.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {string} key The key of the value to merge.
	     * @param {number} srcIndex The index of `source`.
	     * @param {Function} mergeFunc The function to merge values.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @param {Object} [stack] Tracks traversed source values and their merged
	     *  counterparts.
	     */
	    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
	      var objValue = object[key],
	          srcValue = source[key],
	          stacked = stack.get(srcValue);
	
	      if (stacked) {
	        assignMergeValue(object, key, stacked);
	        return;
	      }
	      var newValue = customizer
	        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
	        : undefined;
	
	      var isCommon = newValue === undefined;
	
	      if (isCommon) {
	        var isArr = isArray(srcValue),
	            isBuff = !isArr && isBuffer(srcValue),
	            isTyped = !isArr && !isBuff && isTypedArray(srcValue);
	
	        newValue = srcValue;
	        if (isArr || isBuff || isTyped) {
	          if (isArray(objValue)) {
	            newValue = objValue;
	          }
	          else if (isArrayLikeObject(objValue)) {
	            newValue = copyArray(objValue);
	          }
	          else if (isBuff) {
	            isCommon = false;
	            newValue = cloneBuffer(srcValue, true);
	          }
	          else if (isTyped) {
	            isCommon = false;
	            newValue = cloneTypedArray(srcValue, true);
	          }
	          else {
	            newValue = [];
	          }
	        }
	        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
	          newValue = objValue;
	          if (isArguments(objValue)) {
	            newValue = toPlainObject(objValue);
	          }
	          else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
	            newValue = initCloneObject(srcValue);
	          }
	        }
	        else {
	          isCommon = false;
	        }
	      }
	      if (isCommon) {
	        // Recursively merge objects and arrays (susceptible to call stack limits).
	        stack.set(srcValue, newValue);
	        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
	        stack['delete'](srcValue);
	      }
	      assignMergeValue(object, key, newValue);
	    }
	
	    /**
	     * The base implementation of `_.nth` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {Array} array The array to query.
	     * @param {number} n The index of the element to return.
	     * @returns {*} Returns the nth element of `array`.
	     */
	    function baseNth(array, n) {
	      var length = array.length;
	      if (!length) {
	        return;
	      }
	      n += n < 0 ? length : 0;
	      return isIndex(n, length) ? array[n] : undefined;
	    }
	
	    /**
	     * The base implementation of `_.orderBy` without param guards.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
	     * @param {string[]} orders The sort orders of `iteratees`.
	     * @returns {Array} Returns the new sorted array.
	     */
	    function baseOrderBy(collection, iteratees, orders) {
	      var index = -1;
	      iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));
	
	      var result = baseMap(collection, function(value, key, collection) {
	        var criteria = arrayMap(iteratees, function(iteratee) {
	          return iteratee(value);
	        });
	        return { 'criteria': criteria, 'index': ++index, 'value': value };
	      });
	
	      return baseSortBy(result, function(object, other) {
	        return compareMultiple(object, other, orders);
	      });
	    }
	
	    /**
	     * The base implementation of `_.pick` without support for individual
	     * property identifiers.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {string[]} paths The property paths to pick.
	     * @returns {Object} Returns the new object.
	     */
	    function basePick(object, paths) {
	      return basePickBy(object, paths, function(value, path) {
	        return hasIn(object, path);
	      });
	    }
	
	    /**
	     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {string[]} paths The property paths to pick.
	     * @param {Function} predicate The function invoked per property.
	     * @returns {Object} Returns the new object.
	     */
	    function basePickBy(object, paths, predicate) {
	      var index = -1,
	          length = paths.length,
	          result = {};
	
	      while (++index < length) {
	        var path = paths[index],
	            value = baseGet(object, path);
	
	        if (predicate(value, path)) {
	          baseSet(result, castPath(path, object), value);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * A specialized version of `baseProperty` which supports deep paths.
	     *
	     * @private
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new accessor function.
	     */
	    function basePropertyDeep(path) {
	      return function(object) {
	        return baseGet(object, path);
	      };
	    }
	
	    /**
	     * The base implementation of `_.pullAllBy` without support for iteratee
	     * shorthands.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns `array`.
	     */
	    function basePullAll(array, values, iteratee, comparator) {
	      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
	          index = -1,
	          length = values.length,
	          seen = array;
	
	      if (array === values) {
	        values = copyArray(values);
	      }
	      if (iteratee) {
	        seen = arrayMap(array, baseUnary(iteratee));
	      }
	      while (++index < length) {
	        var fromIndex = 0,
	            value = values[index],
	            computed = iteratee ? iteratee(value) : value;
	
	        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
	          if (seen !== array) {
	            splice.call(seen, fromIndex, 1);
	          }
	          splice.call(array, fromIndex, 1);
	        }
	      }
	      return array;
	    }
	
	    /**
	     * The base implementation of `_.pullAt` without support for individual
	     * indexes or capturing the removed elements.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {number[]} indexes The indexes of elements to remove.
	     * @returns {Array} Returns `array`.
	     */
	    function basePullAt(array, indexes) {
	      var length = array ? indexes.length : 0,
	          lastIndex = length - 1;
	
	      while (length--) {
	        var index = indexes[length];
	        if (length == lastIndex || index !== previous) {
	          var previous = index;
	          if (isIndex(index)) {
	            splice.call(array, index, 1);
	          } else {
	            baseUnset(array, index);
	          }
	        }
	      }
	      return array;
	    }
	
	    /**
	     * The base implementation of `_.random` without support for returning
	     * floating-point numbers.
	     *
	     * @private
	     * @param {number} lower The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the random number.
	     */
	    function baseRandom(lower, upper) {
	      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
	    }
	
	    /**
	     * The base implementation of `_.range` and `_.rangeRight` which doesn't
	     * coerce arguments.
	     *
	     * @private
	     * @param {number} start The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} step The value to increment or decrement by.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Array} Returns the range of numbers.
	     */
	    function baseRange(start, end, step, fromRight) {
	      var index = -1,
	          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
	          result = Array(length);
	
	      while (length--) {
	        result[fromRight ? length : ++index] = start;
	        start += step;
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.repeat` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {string} string The string to repeat.
	     * @param {number} n The number of times to repeat the string.
	     * @returns {string} Returns the repeated string.
	     */
	    function baseRepeat(string, n) {
	      var result = '';
	      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
	        return result;
	      }
	      // Leverage the exponentiation by squaring algorithm for a faster repeat.
	      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
	      do {
	        if (n % 2) {
	          result += string;
	        }
	        n = nativeFloor(n / 2);
	        if (n) {
	          string += string;
	        }
	      } while (n);
	
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	     *
	     * @private
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @returns {Function} Returns the new function.
	     */
	    function baseRest(func, start) {
	      return setToString(overRest(func, start, identity), func + '');
	    }
	
	    /**
	     * The base implementation of `_.sample`.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to sample.
	     * @returns {*} Returns the random element.
	     */
	    function baseSample(collection) {
	      return arraySample(values(collection));
	    }
	
	    /**
	     * The base implementation of `_.sampleSize` without param guards.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to sample.
	     * @param {number} n The number of elements to sample.
	     * @returns {Array} Returns the random elements.
	     */
	    function baseSampleSize(collection, n) {
	      var array = values(collection);
	      return shuffleSelf(array, baseClamp(n, 0, array.length));
	    }
	
	    /**
	     * The base implementation of `_.set`.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @param {Function} [customizer] The function to customize path creation.
	     * @returns {Object} Returns `object`.
	     */
	    function baseSet(object, path, value, customizer) {
	      if (!isObject(object)) {
	        return object;
	      }
	      path = castPath(path, object);
	
	      var index = -1,
	          length = path.length,
	          lastIndex = length - 1,
	          nested = object;
	
	      while (nested != null && ++index < length) {
	        var key = toKey(path[index]),
	            newValue = value;
	
	        if (index != lastIndex) {
	          var objValue = nested[key];
	          newValue = customizer ? customizer(objValue, key, nested) : undefined;
	          if (newValue === undefined) {
	            newValue = isObject(objValue)
	              ? objValue
	              : (isIndex(path[index + 1]) ? [] : {});
	          }
	        }
	        assignValue(nested, key, newValue);
	        nested = nested[key];
	      }
	      return object;
	    }
	
	    /**
	     * The base implementation of `setData` without support for hot loop shorting.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var baseSetData = !metaMap ? identity : function(func, data) {
	      metaMap.set(func, data);
	      return func;
	    };
	
	    /**
	     * The base implementation of `setToString` without support for hot loop shorting.
	     *
	     * @private
	     * @param {Function} func The function to modify.
	     * @param {Function} string The `toString` result.
	     * @returns {Function} Returns `func`.
	     */
	    var baseSetToString = !defineProperty ? identity : function(func, string) {
	      return defineProperty(func, 'toString', {
	        'configurable': true,
	        'enumerable': false,
	        'value': constant(string),
	        'writable': true
	      });
	    };
	
	    /**
	     * The base implementation of `_.shuffle`.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     */
	    function baseShuffle(collection) {
	      return shuffleSelf(values(collection));
	    }
	
	    /**
	     * The base implementation of `_.slice` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function baseSlice(array, start, end) {
	      var index = -1,
	          length = array.length;
	
	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = end > length ? length : end;
	      if (end < 0) {
	        end += length;
	      }
	      length = start > end ? 0 : ((end - start) >>> 0);
	      start >>>= 0;
	
	      var result = Array(length);
	      while (++index < length) {
	        result[index] = array[index + start];
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.some` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     */
	    function baseSome(collection, predicate) {
	      var result;
	
	      baseEach(collection, function(value, index, collection) {
	        result = predicate(value, index, collection);
	        return !result;
	      });
	      return !!result;
	    }
	
	    /**
	     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
	     * performs a binary search of `array` to determine the index at which `value`
	     * should be inserted into `array` in order to maintain its sort order.
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function baseSortedIndex(array, value, retHighest) {
	      var low = 0,
	          high = array == null ? low : array.length;
	
	      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
	        while (low < high) {
	          var mid = (low + high) >>> 1,
	              computed = array[mid];
	
	          if (computed !== null && !isSymbol(computed) &&
	              (retHighest ? (computed <= value) : (computed < value))) {
	            low = mid + 1;
	          } else {
	            high = mid;
	          }
	        }
	        return high;
	      }
	      return baseSortedIndexBy(array, value, identity, retHighest);
	    }
	
	    /**
	     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
	     * which invokes `iteratee` for `value` and each element of `array` to compute
	     * their sort ranking. The iteratee is invoked with one argument; (value).
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} iteratee The iteratee invoked per element.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function baseSortedIndexBy(array, value, iteratee, retHighest) {
	      value = iteratee(value);
	
	      var low = 0,
	          high = array == null ? 0 : array.length,
	          valIsNaN = value !== value,
	          valIsNull = value === null,
	          valIsSymbol = isSymbol(value),
	          valIsUndefined = value === undefined;
	
	      while (low < high) {
	        var mid = nativeFloor((low + high) / 2),
	            computed = iteratee(array[mid]),
	            othIsDefined = computed !== undefined,
	            othIsNull = computed === null,
	            othIsReflexive = computed === computed,
	            othIsSymbol = isSymbol(computed);
	
	        if (valIsNaN) {
	          var setLow = retHighest || othIsReflexive;
	        } else if (valIsUndefined) {
	          setLow = othIsReflexive && (retHighest || othIsDefined);
	        } else if (valIsNull) {
	          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
	        } else if (valIsSymbol) {
	          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
	        } else if (othIsNull || othIsSymbol) {
	          setLow = false;
	        } else {
	          setLow = retHighest ? (computed <= value) : (computed < value);
	        }
	        if (setLow) {
	          low = mid + 1;
	        } else {
	          high = mid;
	        }
	      }
	      return nativeMin(high, MAX_ARRAY_INDEX);
	    }
	
	    /**
	     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
	     * support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     */
	    function baseSortedUniq(array, iteratee) {
	      var index = -1,
	          length = array.length,
	          resIndex = 0,
	          result = [];
	
	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value) : value;
	
	        if (!index || !eq(computed, seen)) {
	          var seen = computed;
	          result[resIndex++] = value === 0 ? 0 : value;
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.toNumber` which doesn't ensure correct
	     * conversions of binary, hexadecimal, or octal string values.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {number} Returns the number.
	     */
	    function baseToNumber(value) {
	      if (typeof value == 'number') {
	        return value;
	      }
	      if (isSymbol(value)) {
	        return NAN;
	      }
	      return +value;
	    }
	
	    /**
	     * The base implementation of `_.toString` which doesn't convert nullish
	     * values to empty strings.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {string} Returns the string.
	     */
	    function baseToString(value) {
	      // Exit early for strings to avoid a performance hit in some environments.
	      if (typeof value == 'string') {
	        return value;
	      }
	      if (isArray(value)) {
	        // Recursively convert values (susceptible to call stack limits).
	        return arrayMap(value, baseToString) + '';
	      }
	      if (isSymbol(value)) {
	        return symbolToString ? symbolToString.call(value) : '';
	      }
	      var result = (value + '');
	      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	    }
	
	    /**
	     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     */
	    function baseUniq(array, iteratee, comparator) {
	      var index = -1,
	          includes = arrayIncludes,
	          length = array.length,
	          isCommon = true,
	          result = [],
	          seen = result;
	
	      if (comparator) {
	        isCommon = false;
	        includes = arrayIncludesWith;
	      }
	      else if (length >= LARGE_ARRAY_SIZE) {
	        var set = iteratee ? null : createSet(array);
	        if (set) {
	          return setToArray(set);
	        }
	        isCommon = false;
	        includes = cacheHas;
	        seen = new SetCache;
	      }
	      else {
	        seen = iteratee ? [] : result;
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value) : value;
	
	        value = (comparator || value !== 0) ? value : 0;
	        if (isCommon && computed === computed) {
	          var seenIndex = seen.length;
	          while (seenIndex--) {
	            if (seen[seenIndex] === computed) {
	              continue outer;
	            }
	          }
	          if (iteratee) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	        else if (!includes(seen, computed, comparator)) {
	          if (seen !== result) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.unset`.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The property path to unset.
	     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
	     */
	    function baseUnset(object, path) {
	      path = castPath(path, object);
	      object = parent(object, path);
	      return object == null || delete object[toKey(last(path))];
	    }
	
	    /**
	     * The base implementation of `_.update`.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to update.
	     * @param {Function} updater The function to produce the updated value.
	     * @param {Function} [customizer] The function to customize path creation.
	     * @returns {Object} Returns `object`.
	     */
	    function baseUpdate(object, path, updater, customizer) {
	      return baseSet(object, path, updater(baseGet(object, path)), customizer);
	    }
	
	    /**
	     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
	     * without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to query.
	     * @param {Function} predicate The function invoked per iteration.
	     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function baseWhile(array, predicate, isDrop, fromRight) {
	      var length = array.length,
	          index = fromRight ? length : -1;
	
	      while ((fromRight ? index-- : ++index < length) &&
	        predicate(array[index], index, array)) {}
	
	      return isDrop
	        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
	        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
	    }
	
	    /**
	     * The base implementation of `wrapperValue` which returns the result of
	     * performing a sequence of actions on the unwrapped `value`, where each
	     * successive action is supplied the return value of the previous.
	     *
	     * @private
	     * @param {*} value The unwrapped value.
	     * @param {Array} actions Actions to perform to resolve the unwrapped value.
	     * @returns {*} Returns the resolved value.
	     */
	    function baseWrapperValue(value, actions) {
	      var result = value;
	      if (result instanceof LazyWrapper) {
	        result = result.value();
	      }
	      return arrayReduce(actions, function(result, action) {
	        return action.func.apply(action.thisArg, arrayPush([result], action.args));
	      }, result);
	    }
	
	    /**
	     * The base implementation of methods like `_.xor`, without support for
	     * iteratee shorthands, that accepts an array of arrays to inspect.
	     *
	     * @private
	     * @param {Array} arrays The arrays to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of values.
	     */
	    function baseXor(arrays, iteratee, comparator) {
	      var length = arrays.length;
	      if (length < 2) {
	        return length ? baseUniq(arrays[0]) : [];
	      }
	      var index = -1,
	          result = Array(length);
	
	      while (++index < length) {
	        var array = arrays[index],
	            othIndex = -1;
	
	        while (++othIndex < length) {
	          if (othIndex != index) {
	            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
	          }
	        }
	      }
	      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
	    }
	
	    /**
	     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
	     *
	     * @private
	     * @param {Array} props The property identifiers.
	     * @param {Array} values The property values.
	     * @param {Function} assignFunc The function to assign values.
	     * @returns {Object} Returns the new object.
	     */
	    function baseZipObject(props, values, assignFunc) {
	      var index = -1,
	          length = props.length,
	          valsLength = values.length,
	          result = {};
	
	      while (++index < length) {
	        var value = index < valsLength ? values[index] : undefined;
	        assignFunc(result, props[index], value);
	      }
	      return result;
	    }
	
	    /**
	     * Casts `value` to an empty array if it's not an array like object.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {Array|Object} Returns the cast array-like object.
	     */
	    function castArrayLikeObject(value) {
	      return isArrayLikeObject(value) ? value : [];
	    }
	
	    /**
	     * Casts `value` to `identity` if it's not a function.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {Function} Returns cast function.
	     */
	    function castFunction(value) {
	      return typeof value == 'function' ? value : identity;
	    }
	
	    /**
	     * Casts `value` to a path array if it's not one.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @param {Object} [object] The object to query keys on.
	     * @returns {Array} Returns the cast property path array.
	     */
	    function castPath(value, object) {
	      if (isArray(value)) {
	        return value;
	      }
	      return isKey(value, object) ? [value] : stringToPath(toString(value));
	    }
	
	    /**
	     * A `baseRest` alias which can be replaced with `identity` by module
	     * replacement plugins.
	     *
	     * @private
	     * @type {Function}
	     * @param {Function} func The function to apply a rest parameter to.
	     * @returns {Function} Returns the new function.
	     */
	    var castRest = baseRest;
	
	    /**
	     * Casts `array` to a slice if it's needed.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {number} start The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the cast slice.
	     */
	    function castSlice(array, start, end) {
	      var length = array.length;
	      end = end === undefined ? length : end;
	      return (!start && end >= length) ? array : baseSlice(array, start, end);
	    }
	
	    /**
	     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
	     *
	     * @private
	     * @param {number|Object} id The timer id or timeout object of the timer to clear.
	     */
	    var clearTimeout = ctxClearTimeout || function(id) {
	      return root.clearTimeout(id);
	    };
	
	    /**
	     * Creates a clone of  `buffer`.
	     *
	     * @private
	     * @param {Buffer} buffer The buffer to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Buffer} Returns the cloned buffer.
	     */
	    function cloneBuffer(buffer, isDeep) {
	      if (isDeep) {
	        return buffer.slice();
	      }
	      var length = buffer.length,
	          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
	
	      buffer.copy(result);
	      return result;
	    }
	
	    /**
	     * Creates a clone of `arrayBuffer`.
	     *
	     * @private
	     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	     * @returns {ArrayBuffer} Returns the cloned array buffer.
	     */
	    function cloneArrayBuffer(arrayBuffer) {
	      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
	      return result;
	    }
	
	    /**
	     * Creates a clone of `dataView`.
	     *
	     * @private
	     * @param {Object} dataView The data view to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned data view.
	     */
	    function cloneDataView(dataView, isDeep) {
	      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
	      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
	    }
	
	    /**
	     * Creates a clone of `map`.
	     *
	     * @private
	     * @param {Object} map The map to clone.
	     * @param {Function} cloneFunc The function to clone values.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned map.
	     */
	    function cloneMap(map, isDeep, cloneFunc) {
	      var array = isDeep ? cloneFunc(mapToArray(map), CLONE_DEEP_FLAG) : mapToArray(map);
	      return arrayReduce(array, addMapEntry, new map.constructor);
	    }
	
	    /**
	     * Creates a clone of `regexp`.
	     *
	     * @private
	     * @param {Object} regexp The regexp to clone.
	     * @returns {Object} Returns the cloned regexp.
	     */
	    function cloneRegExp(regexp) {
	      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
	      result.lastIndex = regexp.lastIndex;
	      return result;
	    }
	
	    /**
	     * Creates a clone of `set`.
	     *
	     * @private
	     * @param {Object} set The set to clone.
	     * @param {Function} cloneFunc The function to clone values.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned set.
	     */
	    function cloneSet(set, isDeep, cloneFunc) {
	      var array = isDeep ? cloneFunc(setToArray(set), CLONE_DEEP_FLAG) : setToArray(set);
	      return arrayReduce(array, addSetEntry, new set.constructor);
	    }
	
	    /**
	     * Creates a clone of the `symbol` object.
	     *
	     * @private
	     * @param {Object} symbol The symbol object to clone.
	     * @returns {Object} Returns the cloned symbol object.
	     */
	    function cloneSymbol(symbol) {
	      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
	    }
	
	    /**
	     * Creates a clone of `typedArray`.
	     *
	     * @private
	     * @param {Object} typedArray The typed array to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned typed array.
	     */
	    function cloneTypedArray(typedArray, isDeep) {
	      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
	      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	    }
	
	    /**
	     * Compares values to sort them in ascending order.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {number} Returns the sort order indicator for `value`.
	     */
	    function compareAscending(value, other) {
	      if (value !== other) {
	        var valIsDefined = value !== undefined,
	            valIsNull = value === null,
	            valIsReflexive = value === value,
	            valIsSymbol = isSymbol(value);
	
	        var othIsDefined = other !== undefined,
	            othIsNull = other === null,
	            othIsReflexive = other === other,
	            othIsSymbol = isSymbol(other);
	
	        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
	            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
	            (valIsNull && othIsDefined && othIsReflexive) ||
	            (!valIsDefined && othIsReflexive) ||
	            !valIsReflexive) {
	          return 1;
	        }
	        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
	            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
	            (othIsNull && valIsDefined && valIsReflexive) ||
	            (!othIsDefined && valIsReflexive) ||
	            !othIsReflexive) {
	          return -1;
	        }
	      }
	      return 0;
	    }
	
	    /**
	     * Used by `_.orderBy` to compare multiple properties of a value to another
	     * and stable sort them.
	     *
	     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
	     * specify an order of "desc" for descending or "asc" for ascending sort order
	     * of corresponding values.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {boolean[]|string[]} orders The order to sort by for each property.
	     * @returns {number} Returns the sort order indicator for `object`.
	     */
	    function compareMultiple(object, other, orders) {
	      var index = -1,
	          objCriteria = object.criteria,
	          othCriteria = other.criteria,
	          length = objCriteria.length,
	          ordersLength = orders.length;
	
	      while (++index < length) {
	        var result = compareAscending(objCriteria[index], othCriteria[index]);
	        if (result) {
	          if (index >= ordersLength) {
	            return result;
	          }
	          var order = orders[index];
	          return result * (order == 'desc' ? -1 : 1);
	        }
	      }
	      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
	      // that causes it, under certain circumstances, to provide the same value for
	      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
	      // for more details.
	      //
	      // This also ensures a stable sort in V8 and other engines.
	      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
	      return object.index - other.index;
	    }
	
	    /**
	     * Creates an array that is the composition of partially applied arguments,
	     * placeholders, and provided arguments into a single array of arguments.
	     *
	     * @private
	     * @param {Array} args The provided arguments.
	     * @param {Array} partials The arguments to prepend to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @params {boolean} [isCurried] Specify composing for a curried function.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgs(args, partials, holders, isCurried) {
	      var argsIndex = -1,
	          argsLength = args.length,
	          holdersLength = holders.length,
	          leftIndex = -1,
	          leftLength = partials.length,
	          rangeLength = nativeMax(argsLength - holdersLength, 0),
	          result = Array(leftLength + rangeLength),
	          isUncurried = !isCurried;
	
	      while (++leftIndex < leftLength) {
	        result[leftIndex] = partials[leftIndex];
	      }
	      while (++argsIndex < holdersLength) {
	        if (isUncurried || argsIndex < argsLength) {
	          result[holders[argsIndex]] = args[argsIndex];
	        }
	      }
	      while (rangeLength--) {
	        result[leftIndex++] = args[argsIndex++];
	      }
	      return result;
	    }
	
	    /**
	     * This function is like `composeArgs` except that the arguments composition
	     * is tailored for `_.partialRight`.
	     *
	     * @private
	     * @param {Array} args The provided arguments.
	     * @param {Array} partials The arguments to append to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @params {boolean} [isCurried] Specify composing for a curried function.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgsRight(args, partials, holders, isCurried) {
	      var argsIndex = -1,
	          argsLength = args.length,
	          holdersIndex = -1,
	          holdersLength = holders.length,
	          rightIndex = -1,
	          rightLength = partials.length,
	          rangeLength = nativeMax(argsLength - holdersLength, 0),
	          result = Array(rangeLength + rightLength),
	          isUncurried = !isCurried;
	
	      while (++argsIndex < rangeLength) {
	        result[argsIndex] = args[argsIndex];
	      }
	      var offset = argsIndex;
	      while (++rightIndex < rightLength) {
	        result[offset + rightIndex] = partials[rightIndex];
	      }
	      while (++holdersIndex < holdersLength) {
	        if (isUncurried || argsIndex < argsLength) {
	          result[offset + holders[holdersIndex]] = args[argsIndex++];
	        }
	      }
	      return result;
	    }
	
	    /**
	     * Copies the values of `source` to `array`.
	     *
	     * @private
	     * @param {Array} source The array to copy values from.
	     * @param {Array} [array=[]] The array to copy values to.
	     * @returns {Array} Returns `array`.
	     */
	    function copyArray(source, array) {
	      var index = -1,
	          length = source.length;
	
	      array || (array = Array(length));
	      while (++index < length) {
	        array[index] = source[index];
	      }
	      return array;
	    }
	
	    /**
	     * Copies properties of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy properties from.
	     * @param {Array} props The property identifiers to copy.
	     * @param {Object} [object={}] The object to copy properties to.
	     * @param {Function} [customizer] The function to customize copied values.
	     * @returns {Object} Returns `object`.
	     */
	    function copyObject(source, props, object, customizer) {
	      var isNew = !object;
	      object || (object = {});
	
	      var index = -1,
	          length = props.length;
	
	      while (++index < length) {
	        var key = props[index];
	
	        var newValue = customizer
	          ? customizer(object[key], source[key], key, object, source)
	          : undefined;
	
	        if (newValue === undefined) {
	          newValue = source[key];
	        }
	        if (isNew) {
	          baseAssignValue(object, key, newValue);
	        } else {
	          assignValue(object, key, newValue);
	        }
	      }
	      return object;
	    }
	
	    /**
	     * Copies own symbols of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy symbols from.
	     * @param {Object} [object={}] The object to copy symbols to.
	     * @returns {Object} Returns `object`.
	     */
	    function copySymbols(source, object) {
	      return copyObject(source, getSymbols(source), object);
	    }
	
	    /**
	     * Copies own and inherited symbols of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy symbols from.
	     * @param {Object} [object={}] The object to copy symbols to.
	     * @returns {Object} Returns `object`.
	     */
	    function copySymbolsIn(source, object) {
	      return copyObject(source, getSymbolsIn(source), object);
	    }
	
	    /**
	     * Creates a function like `_.groupBy`.
	     *
	     * @private
	     * @param {Function} setter The function to set accumulator values.
	     * @param {Function} [initializer] The accumulator object initializer.
	     * @returns {Function} Returns the new aggregator function.
	     */
	    function createAggregator(setter, initializer) {
	      return function(collection, iteratee) {
	        var func = isArray(collection) ? arrayAggregator : baseAggregator,
	            accumulator = initializer ? initializer() : {};
	
	        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
	      };
	    }
	
	    /**
	     * Creates a function like `_.assign`.
	     *
	     * @private
	     * @param {Function} assigner The function to assign values.
	     * @returns {Function} Returns the new assigner function.
	     */
	    function createAssigner(assigner) {
	      return baseRest(function(object, sources) {
	        var index = -1,
	            length = sources.length,
	            customizer = length > 1 ? sources[length - 1] : undefined,
	            guard = length > 2 ? sources[2] : undefined;
	
	        customizer = (assigner.length > 3 && typeof customizer == 'function')
	          ? (length--, customizer)
	          : undefined;
	
	        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	          customizer = length < 3 ? undefined : customizer;
	          length = 1;
	        }
	        object = Object(object);
	        while (++index < length) {
	          var source = sources[index];
	          if (source) {
	            assigner(object, source, index, customizer);
	          }
	        }
	        return object;
	      });
	    }
	
	    /**
	     * Creates a `baseEach` or `baseEachRight` function.
	     *
	     * @private
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */
	    function createBaseEach(eachFunc, fromRight) {
	      return function(collection, iteratee) {
	        if (collection == null) {
	          return collection;
	        }
	        if (!isArrayLike(collection)) {
	          return eachFunc(collection, iteratee);
	        }
	        var length = collection.length,
	            index = fromRight ? length : -1,
	            iterable = Object(collection);
	
	        while ((fromRight ? index-- : ++index < length)) {
	          if (iteratee(iterable[index], index, iterable) === false) {
	            break;
	          }
	        }
	        return collection;
	      };
	    }
	
	    /**
	     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */
	    function createBaseFor(fromRight) {
	      return function(object, iteratee, keysFunc) {
	        var index = -1,
	            iterable = Object(object),
	            props = keysFunc(object),
	            length = props.length;
	
	        while (length--) {
	          var key = props[fromRight ? length : ++index];
	          if (iteratee(iterable[key], key, iterable) === false) {
	            break;
	          }
	        }
	        return object;
	      };
	    }
	
	    /**
	     * Creates a function that wraps `func` to invoke it with the optional `this`
	     * binding of `thisArg`.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createBind(func, bitmask, thisArg) {
	      var isBind = bitmask & WRAP_BIND_FLAG,
	          Ctor = createCtor(func);
	
	      function wrapper() {
	        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	        return fn.apply(isBind ? thisArg : this, arguments);
	      }
	      return wrapper;
	    }
	
	    /**
	     * Creates a function like `_.lowerFirst`.
	     *
	     * @private
	     * @param {string} methodName The name of the `String` case method to use.
	     * @returns {Function} Returns the new case function.
	     */
	    function createCaseFirst(methodName) {
	      return function(string) {
	        string = toString(string);
	
	        var strSymbols = hasUnicode(string)
	          ? stringToArray(string)
	          : undefined;
	
	        var chr = strSymbols
	          ? strSymbols[0]
	          : string.charAt(0);
	
	        var trailing = strSymbols
	          ? castSlice(strSymbols, 1).join('')
	          : string.slice(1);
	
	        return chr[methodName]() + trailing;
	      };
	    }
	
	    /**
	     * Creates a function like `_.camelCase`.
	     *
	     * @private
	     * @param {Function} callback The function to combine each word.
	     * @returns {Function} Returns the new compounder function.
	     */
	    function createCompounder(callback) {
	      return function(string) {
	        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
	      };
	    }
	
	    /**
	     * Creates a function that produces an instance of `Ctor` regardless of
	     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
	     *
	     * @private
	     * @param {Function} Ctor The constructor to wrap.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createCtor(Ctor) {
	      return function() {
	        // Use a `switch` statement to work with class constructors. See
	        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
	        // for more details.
	        var args = arguments;
	        switch (args.length) {
	          case 0: return new Ctor;
	          case 1: return new Ctor(args[0]);
	          case 2: return new Ctor(args[0], args[1]);
	          case 3: return new Ctor(args[0], args[1], args[2]);
	          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
	          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
	          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
	          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
	        }
	        var thisBinding = baseCreate(Ctor.prototype),
	            result = Ctor.apply(thisBinding, args);
	
	        // Mimic the constructor's `return` behavior.
	        // See https://es5.github.io/#x13.2.2 for more details.
	        return isObject(result) ? result : thisBinding;
	      };
	    }
	
	    /**
	     * Creates a function that wraps `func` to enable currying.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {number} arity The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createCurry(func, bitmask, arity) {
	      var Ctor = createCtor(func);
	
	      function wrapper() {
	        var length = arguments.length,
	            args = Array(length),
	            index = length,
	            placeholder = getHolder(wrapper);
	
	        while (index--) {
	          args[index] = arguments[index];
	        }
	        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
	          ? []
	          : replaceHolders(args, placeholder);
	
	        length -= holders.length;
	        if (length < arity) {
	          return createRecurry(
	            func, bitmask, createHybrid, wrapper.placeholder, undefined,
	            args, holders, undefined, undefined, arity - length);
	        }
	        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	        return apply(fn, this, args);
	      }
	      return wrapper;
	    }
	
	    /**
	     * Creates a `_.find` or `_.findLast` function.
	     *
	     * @private
	     * @param {Function} findIndexFunc The function to find the collection index.
	     * @returns {Function} Returns the new find function.
	     */
	    function createFind(findIndexFunc) {
	      return function(collection, predicate, fromIndex) {
	        var iterable = Object(collection);
	        if (!isArrayLike(collection)) {
	          var iteratee = getIteratee(predicate, 3);
	          collection = keys(collection);
	          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
	        }
	        var index = findIndexFunc(collection, predicate, fromIndex);
	        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
	      };
	    }
	
	    /**
	     * Creates a `_.flow` or `_.flowRight` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new flow function.
	     */
	    function createFlow(fromRight) {
	      return flatRest(function(funcs) {
	        var length = funcs.length,
	            index = length,
	            prereq = LodashWrapper.prototype.thru;
	
	        if (fromRight) {
	          funcs.reverse();
	        }
	        while (index--) {
	          var func = funcs[index];
	          if (typeof func != 'function') {
	            throw new TypeError(FUNC_ERROR_TEXT);
	          }
	          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
	            var wrapper = new LodashWrapper([], true);
	          }
	        }
	        index = wrapper ? index : length;
	        while (++index < length) {
	          func = funcs[index];
	
	          var funcName = getFuncName(func),
	              data = funcName == 'wrapper' ? getData(func) : undefined;
	
	          if (data && isLaziable(data[0]) &&
	                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
	                !data[4].length && data[9] == 1
	              ) {
	            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
	          } else {
	            wrapper = (func.length == 1 && isLaziable(func))
	              ? wrapper[funcName]()
	              : wrapper.thru(func);
	          }
	        }
	        return function() {
	          var args = arguments,
	              value = args[0];
	
	          if (wrapper && args.length == 1 && isArray(value)) {
	            return wrapper.plant(value).value();
	          }
	          var index = 0,
	              result = length ? funcs[index].apply(this, args) : value;
	
	          while (++index < length) {
	            result = funcs[index].call(this, result);
	          }
	          return result;
	        };
	      });
	    }
	
	    /**
	     * Creates a function that wraps `func` to invoke it with optional `this`
	     * binding of `thisArg`, partial application, and currying.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to prepend to those provided to
	     *  the new function.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [partialsRight] The arguments to append to those provided
	     *  to the new function.
	     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
	      var isAry = bitmask & WRAP_ARY_FLAG,
	          isBind = bitmask & WRAP_BIND_FLAG,
	          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
	          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
	          isFlip = bitmask & WRAP_FLIP_FLAG,
	          Ctor = isBindKey ? undefined : createCtor(func);
	
	      function wrapper() {
	        var length = arguments.length,
	            args = Array(length),
	            index = length;
	
	        while (index--) {
	          args[index] = arguments[index];
	        }
	        if (isCurried) {
	          var placeholder = getHolder(wrapper),
	              holdersCount = countHolders(args, placeholder);
	        }
	        if (partials) {
	          args = composeArgs(args, partials, holders, isCurried);
	        }
	        if (partialsRight) {
	          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
	        }
	        length -= holdersCount;
	        if (isCurried && length < arity) {
	          var newHolders = replaceHolders(args, placeholder);
	          return createRecurry(
	            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
	            args, newHolders, argPos, ary, arity - length
	          );
	        }
	        var thisBinding = isBind ? thisArg : this,
	            fn = isBindKey ? thisBinding[func] : func;
	
	        length = args.length;
	        if (argPos) {
	          args = reorder(args, argPos);
	        } else if (isFlip && length > 1) {
	          args.reverse();
	        }
	        if (isAry && ary < length) {
	          args.length = ary;
	        }
	        if (this && this !== root && this instanceof wrapper) {
	          fn = Ctor || createCtor(fn);
	        }
	        return fn.apply(thisBinding, args);
	      }
	      return wrapper;
	    }
	
	    /**
	     * Creates a function like `_.invertBy`.
	     *
	     * @private
	     * @param {Function} setter The function to set accumulator values.
	     * @param {Function} toIteratee The function to resolve iteratees.
	     * @returns {Function} Returns the new inverter function.
	     */
	    function createInverter(setter, toIteratee) {
	      return function(object, iteratee) {
	        return baseInverter(object, setter, toIteratee(iteratee), {});
	      };
	    }
	
	    /**
	     * Creates a function that performs a mathematical operation on two values.
	     *
	     * @private
	     * @param {Function} operator The function to perform the operation.
	     * @param {number} [defaultValue] The value used for `undefined` arguments.
	     * @returns {Function} Returns the new mathematical operation function.
	     */
	    function createMathOperation(operator, defaultValue) {
	      return function(value, other) {
	        var result;
	        if (value === undefined && other === undefined) {
	          return defaultValue;
	        }
	        if (value !== undefined) {
	          result = value;
	        }
	        if (other !== undefined) {
	          if (result === undefined) {
	            return other;
	          }
	          if (typeof value == 'string' || typeof other == 'string') {
	            value = baseToString(value);
	            other = baseToString(other);
	          } else {
	            value = baseToNumber(value);
	            other = baseToNumber(other);
	          }
	          result = operator(value, other);
	        }
	        return result;
	      };
	    }
	
	    /**
	     * Creates a function like `_.over`.
	     *
	     * @private
	     * @param {Function} arrayFunc The function to iterate over iteratees.
	     * @returns {Function} Returns the new over function.
	     */
	    function createOver(arrayFunc) {
	      return flatRest(function(iteratees) {
	        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
	        return baseRest(function(args) {
	          var thisArg = this;
	          return arrayFunc(iteratees, function(iteratee) {
	            return apply(iteratee, thisArg, args);
	          });
	        });
	      });
	    }
	
	    /**
	     * Creates the padding for `string` based on `length`. The `chars` string
	     * is truncated if the number of characters exceeds `length`.
	     *
	     * @private
	     * @param {number} length The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padding for `string`.
	     */
	    function createPadding(length, chars) {
	      chars = chars === undefined ? ' ' : baseToString(chars);
	
	      var charsLength = chars.length;
	      if (charsLength < 2) {
	        return charsLength ? baseRepeat(chars, length) : chars;
	      }
	      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
	      return hasUnicode(chars)
	        ? castSlice(stringToArray(result), 0, length).join('')
	        : result.slice(0, length);
	    }
	
	    /**
	     * Creates a function that wraps `func` to invoke it with the `this` binding
	     * of `thisArg` and `partials` prepended to the arguments it receives.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {Array} partials The arguments to prepend to those provided to
	     *  the new function.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createPartial(func, bitmask, thisArg, partials) {
	      var isBind = bitmask & WRAP_BIND_FLAG,
	          Ctor = createCtor(func);
	
	      function wrapper() {
	        var argsIndex = -1,
	            argsLength = arguments.length,
	            leftIndex = -1,
	            leftLength = partials.length,
	            args = Array(leftLength + argsLength),
	            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	
	        while (++leftIndex < leftLength) {
	          args[leftIndex] = partials[leftIndex];
	        }
	        while (argsLength--) {
	          args[leftIndex++] = arguments[++argsIndex];
	        }
	        return apply(fn, isBind ? thisArg : this, args);
	      }
	      return wrapper;
	    }
	
	    /**
	     * Creates a `_.range` or `_.rangeRight` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new range function.
	     */
	    function createRange(fromRight) {
	      return function(start, end, step) {
	        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
	          end = step = undefined;
	        }
	        // Ensure the sign of `-0` is preserved.
	        start = toFinite(start);
	        if (end === undefined) {
	          end = start;
	          start = 0;
	        } else {
	          end = toFinite(end);
	        }
	        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
	        return baseRange(start, end, step, fromRight);
	      };
	    }
	
	    /**
	     * Creates a function that performs a relational operation on two values.
	     *
	     * @private
	     * @param {Function} operator The function to perform the operation.
	     * @returns {Function} Returns the new relational operation function.
	     */
	    function createRelationalOperation(operator) {
	      return function(value, other) {
	        if (!(typeof value == 'string' && typeof other == 'string')) {
	          value = toNumber(value);
	          other = toNumber(other);
	        }
	        return operator(value, other);
	      };
	    }
	
	    /**
	     * Creates a function that wraps `func` to continue currying.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {Function} wrapFunc The function to create the `func` wrapper.
	     * @param {*} placeholder The placeholder value.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to prepend to those provided to
	     *  the new function.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
	      var isCurry = bitmask & WRAP_CURRY_FLAG,
	          newHolders = isCurry ? holders : undefined,
	          newHoldersRight = isCurry ? undefined : holders,
	          newPartials = isCurry ? partials : undefined,
	          newPartialsRight = isCurry ? undefined : partials;
	
	      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
	      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
	
	      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
	        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
	      }
	      var newData = [
	        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
	        newHoldersRight, argPos, ary, arity
	      ];
	
	      var result = wrapFunc.apply(undefined, newData);
	      if (isLaziable(func)) {
	        setData(result, newData);
	      }
	      result.placeholder = placeholder;
	      return setWrapToString(result, func, bitmask);
	    }
	
	    /**
	     * Creates a function like `_.round`.
	     *
	     * @private
	     * @param {string} methodName The name of the `Math` method to use when rounding.
	     * @returns {Function} Returns the new round function.
	     */
	    function createRound(methodName) {
	      var func = Math[methodName];
	      return function(number, precision) {
	        number = toNumber(number);
	        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
	        if (precision) {
	          // Shift with exponential notation to avoid floating-point issues.
	          // See [MDN](https://mdn.io/round#Examples) for more details.
	          var pair = (toString(number) + 'e').split('e'),
	              value = func(pair[0] + 'e' + (+pair[1] + precision));
	
	          pair = (toString(value) + 'e').split('e');
	          return +(pair[0] + 'e' + (+pair[1] - precision));
	        }
	        return func(number);
	      };
	    }
	
	    /**
	     * Creates a set object of `values`.
	     *
	     * @private
	     * @param {Array} values The values to add to the set.
	     * @returns {Object} Returns the new set.
	     */
	    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
	      return new Set(values);
	    };
	
	    /**
	     * Creates a `_.toPairs` or `_.toPairsIn` function.
	     *
	     * @private
	     * @param {Function} keysFunc The function to get the keys of a given object.
	     * @returns {Function} Returns the new pairs function.
	     */
	    function createToPairs(keysFunc) {
	      return function(object) {
	        var tag = getTag(object);
	        if (tag == mapTag) {
	          return mapToArray(object);
	        }
	        if (tag == setTag) {
	          return setToPairs(object);
	        }
	        return baseToPairs(object, keysFunc(object));
	      };
	    }
	
	    /**
	     * Creates a function that either curries or invokes `func` with optional
	     * `this` binding and partially applied arguments.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to wrap.
	     * @param {number} bitmask The bitmask flags.
	     *    1 - `_.bind`
	     *    2 - `_.bindKey`
	     *    4 - `_.curry` or `_.curryRight` of a bound function
	     *    8 - `_.curry`
	     *   16 - `_.curryRight`
	     *   32 - `_.partial`
	     *   64 - `_.partialRight`
	     *  128 - `_.rearg`
	     *  256 - `_.ary`
	     *  512 - `_.flip`
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to be partially applied.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
	      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
	      if (!isBindKey && typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var length = partials ? partials.length : 0;
	      if (!length) {
	        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
	        partials = holders = undefined;
	      }
	      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
	      arity = arity === undefined ? arity : toInteger(arity);
	      length -= holders ? holders.length : 0;
	
	      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
	        var partialsRight = partials,
	            holdersRight = holders;
	
	        partials = holders = undefined;
	      }
	      var data = isBindKey ? undefined : getData(func);
	
	      var newData = [
	        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
	        argPos, ary, arity
	      ];
	
	      if (data) {
	        mergeData(newData, data);
	      }
	      func = newData[0];
	      bitmask = newData[1];
	      thisArg = newData[2];
	      partials = newData[3];
	      holders = newData[4];
	      arity = newData[9] = newData[9] === undefined
	        ? (isBindKey ? 0 : func.length)
	        : nativeMax(newData[9] - length, 0);
	
	      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
	        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
	      }
	      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
	        var result = createBind(func, bitmask, thisArg);
	      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
	        result = createCurry(func, bitmask, arity);
	      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
	        result = createPartial(func, bitmask, thisArg, partials);
	      } else {
	        result = createHybrid.apply(undefined, newData);
	      }
	      var setter = data ? baseSetData : setData;
	      return setWrapToString(setter(result, newData), func, bitmask);
	    }
	
	    /**
	     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
	     * of source objects to the destination object for all destination properties
	     * that resolve to `undefined`.
	     *
	     * @private
	     * @param {*} objValue The destination value.
	     * @param {*} srcValue The source value.
	     * @param {string} key The key of the property to assign.
	     * @param {Object} object The parent object of `objValue`.
	     * @returns {*} Returns the value to assign.
	     */
	    function customDefaultsAssignIn(objValue, srcValue, key, object) {
	      if (objValue === undefined ||
	          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
	        return srcValue;
	      }
	      return objValue;
	    }
	
	    /**
	     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
	     * objects into destination objects that are passed thru.
	     *
	     * @private
	     * @param {*} objValue The destination value.
	     * @param {*} srcValue The source value.
	     * @param {string} key The key of the property to merge.
	     * @param {Object} object The parent object of `objValue`.
	     * @param {Object} source The parent object of `srcValue`.
	     * @param {Object} [stack] Tracks traversed source values and their merged
	     *  counterparts.
	     * @returns {*} Returns the value to assign.
	     */
	    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
	      if (isObject(objValue) && isObject(srcValue)) {
	        // Recursively merge objects and arrays (susceptible to call stack limits).
	        stack.set(srcValue, objValue);
	        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
	        stack['delete'](srcValue);
	      }
	      return objValue;
	    }
	
	    /**
	     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
	     * objects.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @param {string} key The key of the property to inspect.
	     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
	     */
	    function customOmitClone(value) {
	      return isPlainObject(value) ? undefined : value;
	    }
	
	    /**
	     * A specialized version of `baseIsEqualDeep` for arrays with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Array} array The array to compare.
	     * @param {Array} other The other array to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} stack Tracks traversed `array` and `other` objects.
	     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	     */
	    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	          arrLength = array.length,
	          othLength = other.length;
	
	      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(array);
	      if (stacked && stack.get(other)) {
	        return stacked == other;
	      }
	      var index = -1,
	          result = true,
	          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;
	
	      stack.set(array, other);
	      stack.set(other, array);
	
	      // Ignore non-index properties.
	      while (++index < arrLength) {
	        var arrValue = array[index],
	            othValue = other[index];
	
	        if (customizer) {
	          var compared = isPartial
	            ? customizer(othValue, arrValue, index, other, array, stack)
	            : customizer(arrValue, othValue, index, array, other, stack);
	        }
	        if (compared !== undefined) {
	          if (compared) {
	            continue;
	          }
	          result = false;
	          break;
	        }
	        // Recursively compare arrays (susceptible to call stack limits).
	        if (seen) {
	          if (!arraySome(other, function(othValue, othIndex) {
	                if (!cacheHas(seen, othIndex) &&
	                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	                  return seen.push(othIndex);
	                }
	              })) {
	            result = false;
	            break;
	          }
	        } else if (!(
	              arrValue === othValue ||
	                equalFunc(arrValue, othValue, bitmask, customizer, stack)
	            )) {
	          result = false;
	          break;
	        }
	      }
	      stack['delete'](array);
	      stack['delete'](other);
	      return result;
	    }
	
	    /**
	     * A specialized version of `baseIsEqualDeep` for comparing objects of
	     * the same `toStringTag`.
	     *
	     * **Note:** This function only supports comparing values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {string} tag The `toStringTag` of the objects to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} stack Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	      switch (tag) {
	        case dataViewTag:
	          if ((object.byteLength != other.byteLength) ||
	              (object.byteOffset != other.byteOffset)) {
	            return false;
	          }
	          object = object.buffer;
	          other = other.buffer;
	
	        case arrayBufferTag:
	          if ((object.byteLength != other.byteLength) ||
	              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	            return false;
	          }
	          return true;
	
	        case boolTag:
	        case dateTag:
	        case numberTag:
	          // Coerce booleans to `1` or `0` and dates to milliseconds.
	          // Invalid dates are coerced to `NaN`.
	          return eq(+object, +other);
	
	        case errorTag:
	          return object.name == other.name && object.message == other.message;
	
	        case regexpTag:
	        case stringTag:
	          // Coerce regexes to strings and treat strings, primitives and objects,
	          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	          // for more details.
	          return object == (other + '');
	
	        case mapTag:
	          var convert = mapToArray;
	
	        case setTag:
	          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
	          convert || (convert = setToArray);
	
	          if (object.size != other.size && !isPartial) {
	            return false;
	          }
	          // Assume cyclic values are equal.
	          var stacked = stack.get(object);
	          if (stacked) {
	            return stacked == other;
	          }
	          bitmask |= COMPARE_UNORDERED_FLAG;
	
	          // Recursively compare objects (susceptible to call stack limits).
	          stack.set(object, other);
	          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	          stack['delete'](object);
	          return result;
	
	        case symbolTag:
	          if (symbolValueOf) {
	            return symbolValueOf.call(object) == symbolValueOf.call(other);
	          }
	      }
	      return false;
	    }
	
	    /**
	     * A specialized version of `baseIsEqualDeep` for objects with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} stack Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	          objProps = getAllKeys(object),
	          objLength = objProps.length,
	          othProps = getAllKeys(other),
	          othLength = othProps.length;
	
	      if (objLength != othLength && !isPartial) {
	        return false;
	      }
	      var index = objLength;
	      while (index--) {
	        var key = objProps[index];
	        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	          return false;
	        }
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked && stack.get(other)) {
	        return stacked == other;
	      }
	      var result = true;
	      stack.set(object, other);
	      stack.set(other, object);
	
	      var skipCtor = isPartial;
	      while (++index < objLength) {
	        key = objProps[index];
	        var objValue = object[key],
	            othValue = other[key];
	
	        if (customizer) {
	          var compared = isPartial
	            ? customizer(othValue, objValue, key, other, object, stack)
	            : customizer(objValue, othValue, key, object, other, stack);
	        }
	        // Recursively compare objects (susceptible to call stack limits).
	        if (!(compared === undefined
	              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	              : compared
	            )) {
	          result = false;
	          break;
	        }
	        skipCtor || (skipCtor = key == 'constructor');
	      }
	      if (result && !skipCtor) {
	        var objCtor = object.constructor,
	            othCtor = other.constructor;
	
	        // Non `Object` object instances with different constructors are not equal.
	        if (objCtor != othCtor &&
	            ('constructor' in object && 'constructor' in other) &&
	            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	          result = false;
	        }
	      }
	      stack['delete'](object);
	      stack['delete'](other);
	      return result;
	    }
	
	    /**
	     * A specialized version of `baseRest` which flattens the rest array.
	     *
	     * @private
	     * @param {Function} func The function to apply a rest parameter to.
	     * @returns {Function} Returns the new function.
	     */
	    function flatRest(func) {
	      return setToString(overRest(func, undefined, flatten), func + '');
	    }
	
	    /**
	     * Creates an array of own enumerable property names and symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names and symbols.
	     */
	    function getAllKeys(object) {
	      return baseGetAllKeys(object, keys, getSymbols);
	    }
	
	    /**
	     * Creates an array of own and inherited enumerable property names and
	     * symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names and symbols.
	     */
	    function getAllKeysIn(object) {
	      return baseGetAllKeys(object, keysIn, getSymbolsIn);
	    }
	
	    /**
	     * Gets metadata for `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {*} Returns the metadata for `func`.
	     */
	    var getData = !metaMap ? noop : function(func) {
	      return metaMap.get(func);
	    };
	
	    /**
	     * Gets the name of `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {string} Returns the function name.
	     */
	    function getFuncName(func) {
	      var result = (func.name + ''),
	          array = realNames[result],
	          length = hasOwnProperty.call(realNames, result) ? array.length : 0;
	
	      while (length--) {
	        var data = array[length],
	            otherFunc = data.func;
	        if (otherFunc == null || otherFunc == func) {
	          return data.name;
	        }
	      }
	      return result;
	    }
	
	    /**
	     * Gets the argument placeholder value for `func`.
	     *
	     * @private
	     * @param {Function} func The function to inspect.
	     * @returns {*} Returns the placeholder value.
	     */
	    function getHolder(func) {
	      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
	      return object.placeholder;
	    }
	
	    /**
	     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
	     * this function returns the custom method, otherwise it returns `baseIteratee`.
	     * If arguments are provided, the chosen function is invoked with them and
	     * its result is returned.
	     *
	     * @private
	     * @param {*} [value] The value to convert to an iteratee.
	     * @param {number} [arity] The arity of the created iteratee.
	     * @returns {Function} Returns the chosen function or its result.
	     */
	    function getIteratee() {
	      var result = lodash.iteratee || iteratee;
	      result = result === iteratee ? baseIteratee : result;
	      return arguments.length ? result(arguments[0], arguments[1]) : result;
	    }
	
	    /**
	     * Gets the data for `map`.
	     *
	     * @private
	     * @param {Object} map The map to query.
	     * @param {string} key The reference key.
	     * @returns {*} Returns the map data.
	     */
	    function getMapData(map, key) {
	      var data = map.__data__;
	      return isKeyable(key)
	        ? data[typeof key == 'string' ? 'string' : 'hash']
	        : data.map;
	    }
	
	    /**
	     * Gets the property names, values, and compare flags of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the match data of `object`.
	     */
	    function getMatchData(object) {
	      var result = keys(object),
	          length = result.length;
	
	      while (length--) {
	        var key = result[length],
	            value = object[key];
	
	        result[length] = [key, value, isStrictComparable(value)];
	      }
	      return result;
	    }
	
	    /**
	     * Gets the native function at `key` of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {string} key The key of the method to get.
	     * @returns {*} Returns the function if it's native, else `undefined`.
	     */
	    function getNative(object, key) {
	      var value = getValue(object, key);
	      return baseIsNative(value) ? value : undefined;
	    }
	
	    /**
	     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @returns {string} Returns the raw `toStringTag`.
	     */
	    function getRawTag(value) {
	      var isOwn = hasOwnProperty.call(value, symToStringTag),
	          tag = value[symToStringTag];
	
	      try {
	        value[symToStringTag] = undefined;
	        var unmasked = true;
	      } catch (e) {}
	
	      var result = nativeObjectToString.call(value);
	      if (unmasked) {
	        if (isOwn) {
	          value[symToStringTag] = tag;
	        } else {
	          delete value[symToStringTag];
	        }
	      }
	      return result;
	    }
	
	    /**
	     * Creates an array of the own enumerable symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of symbols.
	     */
	    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
	      if (object == null) {
	        return [];
	      }
	      object = Object(object);
	      return arrayFilter(nativeGetSymbols(object), function(symbol) {
	        return propertyIsEnumerable.call(object, symbol);
	      });
	    };
	
	    /**
	     * Creates an array of the own and inherited enumerable symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of symbols.
	     */
	    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
	      var result = [];
	      while (object) {
	        arrayPush(result, getSymbols(object));
	        object = getPrototype(object);
	      }
	      return result;
	    };
	
	    /**
	     * Gets the `toStringTag` of `value`.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @returns {string} Returns the `toStringTag`.
	     */
	    var getTag = baseGetTag;
	
	    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	        (Map && getTag(new Map) != mapTag) ||
	        (Promise && getTag(Promise.resolve()) != promiseTag) ||
	        (Set && getTag(new Set) != setTag) ||
	        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	      getTag = function(value) {
	        var result = baseGetTag(value),
	            Ctor = result == objectTag ? value.constructor : undefined,
	            ctorString = Ctor ? toSource(Ctor) : '';
	
	        if (ctorString) {
	          switch (ctorString) {
	            case dataViewCtorString: return dataViewTag;
	            case mapCtorString: return mapTag;
	            case promiseCtorString: return promiseTag;
	            case setCtorString: return setTag;
	            case weakMapCtorString: return weakMapTag;
	          }
	        }
	        return result;
	      };
	    }
	
	    /**
	     * Gets the view, applying any `transforms` to the `start` and `end` positions.
	     *
	     * @private
	     * @param {number} start The start of the view.
	     * @param {number} end The end of the view.
	     * @param {Array} transforms The transformations to apply to the view.
	     * @returns {Object} Returns an object containing the `start` and `end`
	     *  positions of the view.
	     */
	    function getView(start, end, transforms) {
	      var index = -1,
	          length = transforms.length;
	
	      while (++index < length) {
	        var data = transforms[index],
	            size = data.size;
	
	        switch (data.type) {
	          case 'drop':      start += size; break;
	          case 'dropRight': end -= size; break;
	          case 'take':      end = nativeMin(end, start + size); break;
	          case 'takeRight': start = nativeMax(start, end - size); break;
	        }
	      }
	      return { 'start': start, 'end': end };
	    }
	
	    /**
	     * Extracts wrapper details from the `source` body comment.
	     *
	     * @private
	     * @param {string} source The source to inspect.
	     * @returns {Array} Returns the wrapper details.
	     */
	    function getWrapDetails(source) {
	      var match = source.match(reWrapDetails);
	      return match ? match[1].split(reSplitDetails) : [];
	    }
	
	    /**
	     * Checks if `path` exists on `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @param {Function} hasFunc The function to check properties.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     */
	    function hasPath(object, path, hasFunc) {
	      path = castPath(path, object);
	
	      var index = -1,
	          length = path.length,
	          result = false;
	
	      while (++index < length) {
	        var key = toKey(path[index]);
	        if (!(result = object != null && hasFunc(object, key))) {
	          break;
	        }
	        object = object[key];
	      }
	      if (result || ++index != length) {
	        return result;
	      }
	      length = object == null ? 0 : object.length;
	      return !!length && isLength(length) && isIndex(key, length) &&
	        (isArray(object) || isArguments(object));
	    }
	
	    /**
	     * Initializes an array clone.
	     *
	     * @private
	     * @param {Array} array The array to clone.
	     * @returns {Array} Returns the initialized clone.
	     */
	    function initCloneArray(array) {
	      var length = array.length,
	          result = array.constructor(length);
	
	      // Add properties assigned by `RegExp#exec`.
	      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
	        result.index = array.index;
	        result.input = array.input;
	      }
	      return result;
	    }
	
	    /**
	     * Initializes an object clone.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneObject(object) {
	      return (typeof object.constructor == 'function' && !isPrototype(object))
	        ? baseCreate(getPrototype(object))
	        : {};
	    }
	
	    /**
	     * Initializes an object clone based on its `toStringTag`.
	     *
	     * **Note:** This function only supports cloning values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @param {string} tag The `toStringTag` of the object to clone.
	     * @param {Function} cloneFunc The function to clone values.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneByTag(object, tag, cloneFunc, isDeep) {
	      var Ctor = object.constructor;
	      switch (tag) {
	        case arrayBufferTag:
	          return cloneArrayBuffer(object);
	
	        case boolTag:
	        case dateTag:
	          return new Ctor(+object);
	
	        case dataViewTag:
	          return cloneDataView(object, isDeep);
	
	        case float32Tag: case float64Tag:
	        case int8Tag: case int16Tag: case int32Tag:
	        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
	          return cloneTypedArray(object, isDeep);
	
	        case mapTag:
	          return cloneMap(object, isDeep, cloneFunc);
	
	        case numberTag:
	        case stringTag:
	          return new Ctor(object);
	
	        case regexpTag:
	          return cloneRegExp(object);
	
	        case setTag:
	          return cloneSet(object, isDeep, cloneFunc);
	
	        case symbolTag:
	          return cloneSymbol(object);
	      }
	    }
	
	    /**
	     * Inserts wrapper `details` in a comment at the top of the `source` body.
	     *
	     * @private
	     * @param {string} source The source to modify.
	     * @returns {Array} details The details to insert.
	     * @returns {string} Returns the modified source.
	     */
	    function insertWrapDetails(source, details) {
	      var length = details.length;
	      if (!length) {
	        return source;
	      }
	      var lastIndex = length - 1;
	      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
	      details = details.join(length > 2 ? ', ' : ' ');
	      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
	    }
	
	    /**
	     * Checks if `value` is a flattenable `arguments` object or array.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
	     */
	    function isFlattenable(value) {
	      return isArray(value) || isArguments(value) ||
	        !!(spreadableSymbol && value && value[spreadableSymbol]);
	    }
	
	    /**
	     * Checks if `value` is a valid array-like index.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	     */
	    function isIndex(value, length) {
	      length = length == null ? MAX_SAFE_INTEGER : length;
	      return !!length &&
	        (typeof value == 'number' || reIsUint.test(value)) &&
	        (value > -1 && value % 1 == 0 && value < length);
	    }
	
	    /**
	     * Checks if the given arguments are from an iteratee call.
	     *
	     * @private
	     * @param {*} value The potential iteratee value argument.
	     * @param {*} index The potential iteratee index or key argument.
	     * @param {*} object The potential iteratee object argument.
	     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	     *  else `false`.
	     */
	    function isIterateeCall(value, index, object) {
	      if (!isObject(object)) {
	        return false;
	      }
	      var type = typeof index;
	      if (type == 'number'
	            ? (isArrayLike(object) && isIndex(index, object.length))
	            : (type == 'string' && index in object)
	          ) {
	        return eq(object[index], value);
	      }
	      return false;
	    }
	
	    /**
	     * Checks if `value` is a property name and not a property path.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {Object} [object] The object to query keys on.
	     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	     */
	    function isKey(value, object) {
	      if (isArray(value)) {
	        return false;
	      }
	      var type = typeof value;
	      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	          value == null || isSymbol(value)) {
	        return true;
	      }
	      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	        (object != null && value in Object(object));
	    }
	
	    /**
	     * Checks if `value` is suitable for use as unique object key.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	     */
	    function isKeyable(value) {
	      var type = typeof value;
	      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	        ? (value !== '__proto__')
	        : (value === null);
	    }
	
	    /**
	     * Checks if `func` has a lazy counterpart.
	     *
	     * @private
	     * @param {Function} func The function to check.
	     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
	     *  else `false`.
	     */
	    function isLaziable(func) {
	      var funcName = getFuncName(func),
	          other = lodash[funcName];
	
	      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
	        return false;
	      }
	      if (func === other) {
	        return true;
	      }
	      var data = getData(other);
	      return !!data && func === data[0];
	    }
	
	    /**
	     * Checks if `func` has its source masked.
	     *
	     * @private
	     * @param {Function} func The function to check.
	     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	     */
	    function isMasked(func) {
	      return !!maskSrcKey && (maskSrcKey in func);
	    }
	
	    /**
	     * Checks if `func` is capable of being masked.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
	     */
	    var isMaskable = coreJsData ? isFunction : stubFalse;
	
	    /**
	     * Checks if `value` is likely a prototype object.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	     */
	    function isPrototype(value) {
	      var Ctor = value && value.constructor,
	          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
	
	      return value === proto;
	    }
	
	    /**
	     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` if suitable for strict
	     *  equality comparisons, else `false`.
	     */
	    function isStrictComparable(value) {
	      return value === value && !isObject(value);
	    }
	
	    /**
	     * A specialized version of `matchesProperty` for source values suitable
	     * for strict equality comparisons, i.e. `===`.
	     *
	     * @private
	     * @param {string} key The key of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new spec function.
	     */
	    function matchesStrictComparable(key, srcValue) {
	      return function(object) {
	        if (object == null) {
	          return false;
	        }
	        return object[key] === srcValue &&
	          (srcValue !== undefined || (key in Object(object)));
	      };
	    }
	
	    /**
	     * A specialized version of `_.memoize` which clears the memoized function's
	     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	     *
	     * @private
	     * @param {Function} func The function to have its output memoized.
	     * @returns {Function} Returns the new memoized function.
	     */
	    function memoizeCapped(func) {
	      var result = memoize(func, function(key) {
	        if (cache.size === MAX_MEMOIZE_SIZE) {
	          cache.clear();
	        }
	        return key;
	      });
	
	      var cache = result.cache;
	      return result;
	    }
	
	    /**
	     * Merges the function metadata of `source` into `data`.
	     *
	     * Merging metadata reduces the number of wrappers used to invoke a function.
	     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
	     * may be applied regardless of execution order. Methods like `_.ary` and
	     * `_.rearg` modify function arguments, making the order in which they are
	     * executed important, preventing the merging of metadata. However, we make
	     * an exception for a safe combined case where curried functions have `_.ary`
	     * and or `_.rearg` applied.
	     *
	     * @private
	     * @param {Array} data The destination metadata.
	     * @param {Array} source The source metadata.
	     * @returns {Array} Returns `data`.
	     */
	    function mergeData(data, source) {
	      var bitmask = data[1],
	          srcBitmask = source[1],
	          newBitmask = bitmask | srcBitmask,
	          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
	
	      var isCombo =
	        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
	        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
	        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));
	
	      // Exit early if metadata can't be merged.
	      if (!(isCommon || isCombo)) {
	        return data;
	      }
	      // Use source `thisArg` if available.
	      if (srcBitmask & WRAP_BIND_FLAG) {
	        data[2] = source[2];
	        // Set when currying a bound function.
	        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
	      }
	      // Compose partial arguments.
	      var value = source[3];
	      if (value) {
	        var partials = data[3];
	        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
	        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
	      }
	      // Compose partial right arguments.
	      value = source[5];
	      if (value) {
	        partials = data[5];
	        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
	        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
	      }
	      // Use source `argPos` if available.
	      value = source[7];
	      if (value) {
	        data[7] = value;
	      }
	      // Use source `ary` if it's smaller.
	      if (srcBitmask & WRAP_ARY_FLAG) {
	        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
	      }
	      // Use source `arity` if one is not provided.
	      if (data[9] == null) {
	        data[9] = source[9];
	      }
	      // Use source `func` and merge bitmasks.
	      data[0] = source[0];
	      data[1] = newBitmask;
	
	      return data;
	    }
	
	    /**
	     * This function is like
	     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	     * except that it includes inherited enumerable properties.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function nativeKeysIn(object) {
	      var result = [];
	      if (object != null) {
	        for (var key in Object(object)) {
	          result.push(key);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * Converts `value` to a string using `Object.prototype.toString`.
	     *
	     * @private
	     * @param {*} value The value to convert.
	     * @returns {string} Returns the converted string.
	     */
	    function objectToString(value) {
	      return nativeObjectToString.call(value);
	    }
	
	    /**
	     * A specialized version of `baseRest` which transforms the rest array.
	     *
	     * @private
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @param {Function} transform The rest array transform.
	     * @returns {Function} Returns the new function.
	     */
	    function overRest(func, start, transform) {
	      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	      return function() {
	        var args = arguments,
	            index = -1,
	            length = nativeMax(args.length - start, 0),
	            array = Array(length);
	
	        while (++index < length) {
	          array[index] = args[start + index];
	        }
	        index = -1;
	        var otherArgs = Array(start + 1);
	        while (++index < start) {
	          otherArgs[index] = args[index];
	        }
	        otherArgs[start] = transform(array);
	        return apply(func, this, otherArgs);
	      };
	    }
	
	    /**
	     * Gets the parent value at `path` of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array} path The path to get the parent value of.
	     * @returns {*} Returns the parent value.
	     */
	    function parent(object, path) {
	      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
	    }
	
	    /**
	     * Reorder `array` according to the specified indexes where the element at
	     * the first index is assigned as the first element, the element at
	     * the second index is assigned as the second element, and so on.
	     *
	     * @private
	     * @param {Array} array The array to reorder.
	     * @param {Array} indexes The arranged array indexes.
	     * @returns {Array} Returns `array`.
	     */
	    function reorder(array, indexes) {
	      var arrLength = array.length,
	          length = nativeMin(indexes.length, arrLength),
	          oldArray = copyArray(array);
	
	      while (length--) {
	        var index = indexes[length];
	        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
	      }
	      return array;
	    }
	
	    /**
	     * Sets metadata for `func`.
	     *
	     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
	     * period of time, it will trip its breaker and transition to an identity
	     * function to avoid garbage collection pauses in V8. See
	     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
	     * for more details.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var setData = shortOut(baseSetData);
	
	    /**
	     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
	     *
	     * @private
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @returns {number|Object} Returns the timer id or timeout object.
	     */
	    var setTimeout = ctxSetTimeout || function(func, wait) {
	      return root.setTimeout(func, wait);
	    };
	
	    /**
	     * Sets the `toString` method of `func` to return `string`.
	     *
	     * @private
	     * @param {Function} func The function to modify.
	     * @param {Function} string The `toString` result.
	     * @returns {Function} Returns `func`.
	     */
	    var setToString = shortOut(baseSetToString);
	
	    /**
	     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
	     * with wrapper details in a comment at the top of the source body.
	     *
	     * @private
	     * @param {Function} wrapper The function to modify.
	     * @param {Function} reference The reference function.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @returns {Function} Returns `wrapper`.
	     */
	    function setWrapToString(wrapper, reference, bitmask) {
	      var source = (reference + '');
	      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
	    }
	
	    /**
	     * Creates a function that'll short out and invoke `identity` instead
	     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	     * milliseconds.
	     *
	     * @private
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new shortable function.
	     */
	    function shortOut(func) {
	      var count = 0,
	          lastCalled = 0;
	
	      return function() {
	        var stamp = nativeNow(),
	            remaining = HOT_SPAN - (stamp - lastCalled);
	
	        lastCalled = stamp;
	        if (remaining > 0) {
	          if (++count >= HOT_COUNT) {
	            return arguments[0];
	          }
	        } else {
	          count = 0;
	        }
	        return func.apply(undefined, arguments);
	      };
	    }
	
	    /**
	     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
	     *
	     * @private
	     * @param {Array} array The array to shuffle.
	     * @param {number} [size=array.length] The size of `array`.
	     * @returns {Array} Returns `array`.
	     */
	    function shuffleSelf(array, size) {
	      var index = -1,
	          length = array.length,
	          lastIndex = length - 1;
	
	      size = size === undefined ? length : size;
	      while (++index < size) {
	        var rand = baseRandom(index, lastIndex),
	            value = array[rand];
	
	        array[rand] = array[index];
	        array[index] = value;
	      }
	      array.length = size;
	      return array;
	    }
	
	    /**
	     * Converts `string` to a property path array.
	     *
	     * @private
	     * @param {string} string The string to convert.
	     * @returns {Array} Returns the property path array.
	     */
	    var stringToPath = memoizeCapped(function(string) {
	      var result = [];
	      if (reLeadingDot.test(string)) {
	        result.push('');
	      }
	      string.replace(rePropName, function(match, number, quote, string) {
	        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	      });
	      return result;
	    });
	
	    /**
	     * Converts `value` to a string key if it's not a string or symbol.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {string|symbol} Returns the key.
	     */
	    function toKey(value) {
	      if (typeof value == 'string' || isSymbol(value)) {
	        return value;
	      }
	      var result = (value + '');
	      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	    }
	
	    /**
	     * Converts `func` to its source code.
	     *
	     * @private
	     * @param {Function} func The function to convert.
	     * @returns {string} Returns the source code.
	     */
	    function toSource(func) {
	      if (func != null) {
	        try {
	          return funcToString.call(func);
	        } catch (e) {}
	        try {
	          return (func + '');
	        } catch (e) {}
	      }
	      return '';
	    }
	
	    /**
	     * Updates wrapper `details` based on `bitmask` flags.
	     *
	     * @private
	     * @returns {Array} details The details to modify.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @returns {Array} Returns `details`.
	     */
	    function updateWrapDetails(details, bitmask) {
	      arrayEach(wrapFlags, function(pair) {
	        var value = '_.' + pair[0];
	        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
	          details.push(value);
	        }
	      });
	      return details.sort();
	    }
	
	    /**
	     * Creates a clone of `wrapper`.
	     *
	     * @private
	     * @param {Object} wrapper The wrapper to clone.
	     * @returns {Object} Returns the cloned wrapper.
	     */
	    function wrapperClone(wrapper) {
	      if (wrapper instanceof LazyWrapper) {
	        return wrapper.clone();
	      }
	      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
	      result.__actions__ = copyArray(wrapper.__actions__);
	      result.__index__  = wrapper.__index__;
	      result.__values__ = wrapper.__values__;
	      return result;
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates an array of elements split into groups the length of `size`.
	     * If `array` can't be split evenly, the final chunk will be the remaining
	     * elements.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to process.
	     * @param {number} [size=1] The length of each chunk
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the new array of chunks.
	     * @example
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 2);
	     * // => [['a', 'b'], ['c', 'd']]
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 3);
	     * // => [['a', 'b', 'c'], ['d']]
	     */
	    function chunk(array, size, guard) {
	      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
	        size = 1;
	      } else {
	        size = nativeMax(toInteger(size), 0);
	      }
	      var length = array == null ? 0 : array.length;
	      if (!length || size < 1) {
	        return [];
	      }
	      var index = 0,
	          resIndex = 0,
	          result = Array(nativeCeil(length / size));
	
	      while (index < length) {
	        result[resIndex++] = baseSlice(array, index, (index += size));
	      }
	      return result;
	    }
	
	    /**
	     * Creates an array with all falsey values removed. The values `false`, `null`,
	     * `0`, `""`, `undefined`, and `NaN` are falsey.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to compact.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.compact([0, 1, false, 2, '', 3]);
	     * // => [1, 2, 3]
	     */
	    function compact(array) {
	      var index = -1,
	          length = array == null ? 0 : array.length,
	          resIndex = 0,
	          result = [];
	
	      while (++index < length) {
	        var value = array[index];
	        if (value) {
	          result[resIndex++] = value;
	        }
	      }
	      return result;
	    }
	
	    /**
	     * Creates a new array concatenating `array` with any additional arrays
	     * and/or values.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to concatenate.
	     * @param {...*} [values] The values to concatenate.
	     * @returns {Array} Returns the new concatenated array.
	     * @example
	     *
	     * var array = [1];
	     * var other = _.concat(array, 2, [3], [[4]]);
	     *
	     * console.log(other);
	     * // => [1, 2, 3, [4]]
	     *
	     * console.log(array);
	     * // => [1]
	     */
	    function concat() {
	      var length = arguments.length;
	      if (!length) {
	        return [];
	      }
	      var args = Array(length - 1),
	          array = arguments[0],
	          index = length;
	
	      while (index--) {
	        args[index - 1] = arguments[index];
	      }
	      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
	    }
	
	    /**
	     * Creates an array of `array` values not included in the other given arrays
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons. The order and references of result values are
	     * determined by the first array.
	     *
	     * **Note:** Unlike `_.pullAll`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @see _.without, _.xor
	     * @example
	     *
	     * _.difference([2, 1], [2, 3]);
	     * // => [1]
	     */
	    var difference = baseRest(function(array, values) {
	      return isArrayLikeObject(array)
	        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
	        : [];
	    });
	
	    /**
	     * This method is like `_.difference` except that it accepts `iteratee` which
	     * is invoked for each element of `array` and `values` to generate the criterion
	     * by which they're compared. The order and references of result values are
	     * determined by the first array. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	     * // => [1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
	     * // => [{ 'x': 2 }]
	     */
	    var differenceBy = baseRest(function(array, values) {
	      var iteratee = last(values);
	      if (isArrayLikeObject(iteratee)) {
	        iteratee = undefined;
	      }
	      return isArrayLikeObject(array)
	        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
	        : [];
	    });
	
	    /**
	     * This method is like `_.difference` except that it accepts `comparator`
	     * which is invoked to compare elements of `array` to `values`. The order and
	     * references of result values are determined by the first array. The comparator
	     * is invoked with two arguments: (arrVal, othVal).
	     *
	     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     *
	     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
	     * // => [{ 'x': 2, 'y': 1 }]
	     */
	    var differenceWith = baseRest(function(array, values) {
	      var comparator = last(values);
	      if (isArrayLikeObject(comparator)) {
	        comparator = undefined;
	      }
	      return isArrayLikeObject(array)
	        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
	        : [];
	    });
	
	    /**
	     * Creates a slice of `array` with `n` elements dropped from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.5.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.drop([1, 2, 3]);
	     * // => [2, 3]
	     *
	     * _.drop([1, 2, 3], 2);
	     * // => [3]
	     *
	     * _.drop([1, 2, 3], 5);
	     * // => []
	     *
	     * _.drop([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function drop(array, n, guard) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      n = (guard || n === undefined) ? 1 : toInteger(n);
	      return baseSlice(array, n < 0 ? 0 : n, length);
	    }
	
	    /**
	     * Creates a slice of `array` with `n` elements dropped from the end.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropRight([1, 2, 3]);
	     * // => [1, 2]
	     *
	     * _.dropRight([1, 2, 3], 2);
	     * // => [1]
	     *
	     * _.dropRight([1, 2, 3], 5);
	     * // => []
	     *
	     * _.dropRight([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function dropRight(array, n, guard) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      n = (guard || n === undefined) ? 1 : toInteger(n);
	      n = length - n;
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }
	
	    /**
	     * Creates a slice of `array` excluding elements dropped from the end.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.dropRightWhile(users, function(o) { return !o.active; });
	     * // => objects for ['barney']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.dropRightWhile(users, ['active', false]);
	     * // => objects for ['barney']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.dropRightWhile(users, 'active');
	     * // => objects for ['barney', 'fred', 'pebbles']
	     */
	    function dropRightWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3), true, true)
	        : [];
	    }
	
	    /**
	     * Creates a slice of `array` excluding elements dropped from the beginning.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.dropWhile(users, function(o) { return !o.active; });
	     * // => objects for ['pebbles']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.dropWhile(users, { 'user': 'barney', 'active': false });
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.dropWhile(users, ['active', false]);
	     * // => objects for ['pebbles']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.dropWhile(users, 'active');
	     * // => objects for ['barney', 'fred', 'pebbles']
	     */
	    function dropWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3), true)
	        : [];
	    }
	
	    /**
	     * Fills elements of `array` with `value` from `start` up to, but not
	     * including, `end`.
	     *
	     * **Note:** This method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.2.0
	     * @category Array
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _.fill(array, 'a');
	     * console.log(array);
	     * // => ['a', 'a', 'a']
	     *
	     * _.fill(Array(3), 2);
	     * // => [2, 2, 2]
	     *
	     * _.fill([4, 6, 8, 10], '*', 1, 3);
	     * // => [4, '*', '*', 10]
	     */
	    function fill(array, value, start, end) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
	        start = 0;
	        end = length;
	      }
	      return baseFill(array, value, start, end);
	    }
	
	    /**
	     * This method is like `_.find` except that it returns the index of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.findIndex(users, function(o) { return o.user == 'barney'; });
	     * // => 0
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findIndex(users, { 'user': 'fred', 'active': false });
	     * // => 1
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findIndex(users, ['active', false]);
	     * // => 0
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findIndex(users, 'active');
	     * // => 2
	     */
	    function findIndex(array, predicate, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = fromIndex == null ? 0 : toInteger(fromIndex);
	      if (index < 0) {
	        index = nativeMax(length + index, 0);
	      }
	      return baseFindIndex(array, getIteratee(predicate, 3), index);
	    }
	
	    /**
	     * This method is like `_.findIndex` except that it iterates over elements
	     * of `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=array.length-1] The index to search from.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
	     * // => 2
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
	     * // => 0
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findLastIndex(users, ['active', false]);
	     * // => 2
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findLastIndex(users, 'active');
	     * // => 0
	     */
	    function findLastIndex(array, predicate, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = length - 1;
	      if (fromIndex !== undefined) {
	        index = toInteger(fromIndex);
	        index = fromIndex < 0
	          ? nativeMax(length + index, 0)
	          : nativeMin(index, length - 1);
	      }
	      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
	    }
	
	    /**
	     * Flattens `array` a single level deep.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flatten([1, [2, [3, [4]], 5]]);
	     * // => [1, 2, [3, [4]], 5]
	     */
	    function flatten(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseFlatten(array, 1) : [];
	    }
	
	    /**
	     * Recursively flattens `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flattenDeep([1, [2, [3, [4]], 5]]);
	     * // => [1, 2, 3, 4, 5]
	     */
	    function flattenDeep(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseFlatten(array, INFINITY) : [];
	    }
	
	    /**
	     * Recursively flatten `array` up to `depth` times.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.4.0
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @param {number} [depth=1] The maximum recursion depth.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * var array = [1, [2, [3, [4]], 5]];
	     *
	     * _.flattenDepth(array, 1);
	     * // => [1, 2, [3, [4]], 5]
	     *
	     * _.flattenDepth(array, 2);
	     * // => [1, 2, 3, [4], 5]
	     */
	    function flattenDepth(array, depth) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      depth = depth === undefined ? 1 : toInteger(depth);
	      return baseFlatten(array, depth);
	    }
	
	    /**
	     * The inverse of `_.toPairs`; this method returns an object composed
	     * from key-value `pairs`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} pairs The key-value pairs.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.fromPairs([['a', 1], ['b', 2]]);
	     * // => { 'a': 1, 'b': 2 }
	     */
	    function fromPairs(pairs) {
	      var index = -1,
	          length = pairs == null ? 0 : pairs.length,
	          result = {};
	
	      while (++index < length) {
	        var pair = pairs[index];
	        result[pair[0]] = pair[1];
	      }
	      return result;
	    }
	
	    /**
	     * Gets the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @alias first
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the first element of `array`.
	     * @example
	     *
	     * _.head([1, 2, 3]);
	     * // => 1
	     *
	     * _.head([]);
	     * // => undefined
	     */
	    function head(array) {
	      return (array && array.length) ? array[0] : undefined;
	    }
	
	    /**
	     * Gets the index at which the first occurrence of `value` is found in `array`
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons. If `fromIndex` is negative, it's used as the
	     * offset from the end of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.indexOf([1, 2, 1, 2], 2);
	     * // => 1
	     *
	     * // Search from the `fromIndex`.
	     * _.indexOf([1, 2, 1, 2], 2, 2);
	     * // => 3
	     */
	    function indexOf(array, value, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = fromIndex == null ? 0 : toInteger(fromIndex);
	      if (index < 0) {
	        index = nativeMax(length + index, 0);
	      }
	      return baseIndexOf(array, value, index);
	    }
	
	    /**
	     * Gets all but the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.initial([1, 2, 3]);
	     * // => [1, 2]
	     */
	    function initial(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseSlice(array, 0, -1) : [];
	    }
	
	    /**
	     * Creates an array of unique values that are included in all given arrays
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons. The order and references of result values are
	     * determined by the first array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of intersecting values.
	     * @example
	     *
	     * _.intersection([2, 1], [2, 3]);
	     * // => [2]
	     */
	    var intersection = baseRest(function(arrays) {
	      var mapped = arrayMap(arrays, castArrayLikeObject);
	      return (mapped.length && mapped[0] === arrays[0])
	        ? baseIntersection(mapped)
	        : [];
	    });
	
	    /**
	     * This method is like `_.intersection` except that it accepts `iteratee`
	     * which is invoked for each element of each `arrays` to generate the criterion
	     * by which they're compared. The order and references of result values are
	     * determined by the first array. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of intersecting values.
	     * @example
	     *
	     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	     * // => [2.1]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }]
	     */
	    var intersectionBy = baseRest(function(arrays) {
	      var iteratee = last(arrays),
	          mapped = arrayMap(arrays, castArrayLikeObject);
	
	      if (iteratee === last(mapped)) {
	        iteratee = undefined;
	      } else {
	        mapped.pop();
	      }
	      return (mapped.length && mapped[0] === arrays[0])
	        ? baseIntersection(mapped, getIteratee(iteratee, 2))
	        : [];
	    });
	
	    /**
	     * This method is like `_.intersection` except that it accepts `comparator`
	     * which is invoked to compare elements of `arrays`. The order and references
	     * of result values are determined by the first array. The comparator is
	     * invoked with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of intersecting values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.intersectionWith(objects, others, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }]
	     */
	    var intersectionWith = baseRest(function(arrays) {
	      var comparator = last(arrays),
	          mapped = arrayMap(arrays, castArrayLikeObject);
	
	      comparator = typeof comparator == 'function' ? comparator : undefined;
	      if (comparator) {
	        mapped.pop();
	      }
	      return (mapped.length && mapped[0] === arrays[0])
	        ? baseIntersection(mapped, undefined, comparator)
	        : [];
	    });
	
	    /**
	     * Converts all elements in `array` into a string separated by `separator`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to convert.
	     * @param {string} [separator=','] The element separator.
	     * @returns {string} Returns the joined string.
	     * @example
	     *
	     * _.join(['a', 'b', 'c'], '~');
	     * // => 'a~b~c'
	     */
	    function join(array, separator) {
	      return array == null ? '' : nativeJoin.call(array, separator);
	    }
	
	    /**
	     * Gets the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the last element of `array`.
	     * @example
	     *
	     * _.last([1, 2, 3]);
	     * // => 3
	     */
	    function last(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? array[length - 1] : undefined;
	    }
	
	    /**
	     * This method is like `_.indexOf` except that it iterates over elements of
	     * `array` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=array.length-1] The index to search from.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.lastIndexOf([1, 2, 1, 2], 2);
	     * // => 3
	     *
	     * // Search from the `fromIndex`.
	     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
	     * // => 1
	     */
	    function lastIndexOf(array, value, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = length;
	      if (fromIndex !== undefined) {
	        index = toInteger(fromIndex);
	        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
	      }
	      return value === value
	        ? strictLastIndexOf(array, value, index)
	        : baseFindIndex(array, baseIsNaN, index, true);
	    }
	
	    /**
	     * Gets the element at index `n` of `array`. If `n` is negative, the nth
	     * element from the end is returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.11.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=0] The index of the element to return.
	     * @returns {*} Returns the nth element of `array`.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'd'];
	     *
	     * _.nth(array, 1);
	     * // => 'b'
	     *
	     * _.nth(array, -2);
	     * // => 'c';
	     */
	    function nth(array, n) {
	      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
	    }
	
	    /**
	     * Removes all given values from `array` using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
	     * to remove elements from an array by predicate.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...*} [values] The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
	     *
	     * _.pull(array, 'a', 'c');
	     * console.log(array);
	     * // => ['b', 'b']
	     */
	    var pull = baseRest(pullAll);
	
	    /**
	     * This method is like `_.pull` except that it accepts an array of values to remove.
	     *
	     * **Note:** Unlike `_.difference`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
	     *
	     * _.pullAll(array, ['a', 'c']);
	     * console.log(array);
	     * // => ['b', 'b']
	     */
	    function pullAll(array, values) {
	      return (array && array.length && values && values.length)
	        ? basePullAll(array, values)
	        : array;
	    }
	
	    /**
	     * This method is like `_.pullAll` except that it accepts `iteratee` which is
	     * invoked for each element of `array` and `values` to generate the criterion
	     * by which they're compared. The iteratee is invoked with one argument: (value).
	     *
	     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
	     *
	     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
	     * console.log(array);
	     * // => [{ 'x': 2 }]
	     */
	    function pullAllBy(array, values, iteratee) {
	      return (array && array.length && values && values.length)
	        ? basePullAll(array, values, getIteratee(iteratee, 2))
	        : array;
	    }
	
	    /**
	     * This method is like `_.pullAll` except that it accepts `comparator` which
	     * is invoked to compare elements of `array` to `values`. The comparator is
	     * invoked with two arguments: (arrVal, othVal).
	     *
	     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.6.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
	     *
	     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
	     * console.log(array);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
	     */
	    function pullAllWith(array, values, comparator) {
	      return (array && array.length && values && values.length)
	        ? basePullAll(array, values, undefined, comparator)
	        : array;
	    }
	
	    /**
	     * Removes elements from `array` corresponding to `indexes` and returns an
	     * array of removed elements.
	     *
	     * **Note:** Unlike `_.at`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'd'];
	     * var pulled = _.pullAt(array, [1, 3]);
	     *
	     * console.log(array);
	     * // => ['a', 'c']
	     *
	     * console.log(pulled);
	     * // => ['b', 'd']
	     */
	    var pullAt = flatRest(function(array, indexes) {
	      var length = array == null ? 0 : array.length,
	          result = baseAt(array, indexes);
	
	      basePullAt(array, arrayMap(indexes, function(index) {
	        return isIndex(index, length) ? +index : index;
	      }).sort(compareAscending));
	
	      return result;
	    });
	
	    /**
	     * Removes all elements from `array` that `predicate` returns truthy for
	     * and returns an array of the removed elements. The predicate is invoked
	     * with three arguments: (value, index, array).
	     *
	     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
	     * to pull elements from an array by value.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = [1, 2, 3, 4];
	     * var evens = _.remove(array, function(n) {
	     *   return n % 2 == 0;
	     * });
	     *
	     * console.log(array);
	     * // => [1, 3]
	     *
	     * console.log(evens);
	     * // => [2, 4]
	     */
	    function remove(array, predicate) {
	      var result = [];
	      if (!(array && array.length)) {
	        return result;
	      }
	      var index = -1,
	          indexes = [],
	          length = array.length;
	
	      predicate = getIteratee(predicate, 3);
	      while (++index < length) {
	        var value = array[index];
	        if (predicate(value, index, array)) {
	          result.push(value);
	          indexes.push(index);
	        }
	      }
	      basePullAt(array, indexes);
	      return result;
	    }
	
	    /**
	     * Reverses `array` so that the first element becomes the last, the second
	     * element becomes the second to last, and so on.
	     *
	     * **Note:** This method mutates `array` and is based on
	     * [`Array#reverse`](https://mdn.io/Array/reverse).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _.reverse(array);
	     * // => [3, 2, 1]
	     *
	     * console.log(array);
	     * // => [3, 2, 1]
	     */
	    function reverse(array) {
	      return array == null ? array : nativeReverse.call(array);
	    }
	
	    /**
	     * Creates a slice of `array` from `start` up to, but not including, `end`.
	     *
	     * **Note:** This method is used instead of
	     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
	     * returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function slice(array, start, end) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
	        start = 0;
	        end = length;
	      }
	      else {
	        start = start == null ? 0 : toInteger(start);
	        end = end === undefined ? length : toInteger(end);
	      }
	      return baseSlice(array, start, end);
	    }
	
	    /**
	     * Uses a binary search to determine the lowest index at which `value`
	     * should be inserted into `array` in order to maintain its sort order.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedIndex([30, 50], 40);
	     * // => 1
	     */
	    function sortedIndex(array, value) {
	      return baseSortedIndex(array, value);
	    }
	
	    /**
	     * This method is like `_.sortedIndex` except that it accepts `iteratee`
	     * which is invoked for `value` and each element of `array` to compute their
	     * sort ranking. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * var objects = [{ 'x': 4 }, { 'x': 5 }];
	     *
	     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
	     * // => 0
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
	     * // => 0
	     */
	    function sortedIndexBy(array, value, iteratee) {
	      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
	    }
	
	    /**
	     * This method is like `_.indexOf` except that it performs a binary
	     * search on a sorted `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
	     * // => 1
	     */
	    function sortedIndexOf(array, value) {
	      var length = array == null ? 0 : array.length;
	      if (length) {
	        var index = baseSortedIndex(array, value);
	        if (index < length && eq(array[index], value)) {
	          return index;
	        }
	      }
	      return -1;
	    }
	
	    /**
	     * This method is like `_.sortedIndex` except that it returns the highest
	     * index at which `value` should be inserted into `array` in order to
	     * maintain its sort order.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
	     * // => 4
	     */
	    function sortedLastIndex(array, value) {
	      return baseSortedIndex(array, value, true);
	    }
	
	    /**
	     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
	     * which is invoked for `value` and each element of `array` to compute their
	     * sort ranking. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * var objects = [{ 'x': 4 }, { 'x': 5 }];
	     *
	     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
	     * // => 1
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
	     * // => 1
	     */
	    function sortedLastIndexBy(array, value, iteratee) {
	      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
	    }
	
	    /**
	     * This method is like `_.lastIndexOf` except that it performs a binary
	     * search on a sorted `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
	     * // => 3
	     */
	    function sortedLastIndexOf(array, value) {
	      var length = array == null ? 0 : array.length;
	      if (length) {
	        var index = baseSortedIndex(array, value, true) - 1;
	        if (eq(array[index], value)) {
	          return index;
	        }
	      }
	      return -1;
	    }
	
	    /**
	     * This method is like `_.uniq` except that it's designed and optimized
	     * for sorted arrays.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.sortedUniq([1, 1, 2]);
	     * // => [1, 2]
	     */
	    function sortedUniq(array) {
	      return (array && array.length)
	        ? baseSortedUniq(array)
	        : [];
	    }
	
	    /**
	     * This method is like `_.uniqBy` except that it's designed and optimized
	     * for sorted arrays.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
	     * // => [1.1, 2.3]
	     */
	    function sortedUniqBy(array, iteratee) {
	      return (array && array.length)
	        ? baseSortedUniq(array, getIteratee(iteratee, 2))
	        : [];
	    }
	
	    /**
	     * Gets all but the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.tail([1, 2, 3]);
	     * // => [2, 3]
	     */
	    function tail(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseSlice(array, 1, length) : [];
	    }
	
	    /**
	     * Creates a slice of `array` with `n` elements taken from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.take([1, 2, 3]);
	     * // => [1]
	     *
	     * _.take([1, 2, 3], 2);
	     * // => [1, 2]
	     *
	     * _.take([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.take([1, 2, 3], 0);
	     * // => []
	     */
	    function take(array, n, guard) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      n = (guard || n === undefined) ? 1 : toInteger(n);
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }
	
	    /**
	     * Creates a slice of `array` with `n` elements taken from the end.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeRight([1, 2, 3]);
	     * // => [3]
	     *
	     * _.takeRight([1, 2, 3], 2);
	     * // => [2, 3]
	     *
	     * _.takeRight([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.takeRight([1, 2, 3], 0);
	     * // => []
	     */
	    function takeRight(array, n, guard) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      n = (guard || n === undefined) ? 1 : toInteger(n);
	      n = length - n;
	      return baseSlice(array, n < 0 ? 0 : n, length);
	    }
	
	    /**
	     * Creates a slice of `array` with elements taken from the end. Elements are
	     * taken until `predicate` returns falsey. The predicate is invoked with
	     * three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.takeRightWhile(users, function(o) { return !o.active; });
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
	     * // => objects for ['pebbles']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.takeRightWhile(users, ['active', false]);
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.takeRightWhile(users, 'active');
	     * // => []
	     */
	    function takeRightWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3), false, true)
	        : [];
	    }
	
	    /**
	     * Creates a slice of `array` with elements taken from the beginning. Elements
	     * are taken until `predicate` returns falsey. The predicate is invoked with
	     * three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.takeWhile(users, function(o) { return !o.active; });
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.takeWhile(users, { 'user': 'barney', 'active': false });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.takeWhile(users, ['active', false]);
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.takeWhile(users, 'active');
	     * // => []
	     */
	    function takeWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3))
	        : [];
	    }
	
	    /**
	     * Creates an array of unique values, in order, from all given arrays using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * _.union([2], [1, 2]);
	     * // => [2, 1]
	     */
	    var union = baseRest(function(arrays) {
	      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
	    });
	
	    /**
	     * This method is like `_.union` except that it accepts `iteratee` which is
	     * invoked for each element of each `arrays` to generate the criterion by
	     * which uniqueness is computed. Result values are chosen from the first
	     * array in which the value occurs. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
	     * // => [2.1, 1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */
	    var unionBy = baseRest(function(arrays) {
	      var iteratee = last(arrays);
	      if (isArrayLikeObject(iteratee)) {
	        iteratee = undefined;
	      }
	      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
	    });
	
	    /**
	     * This method is like `_.union` except that it accepts `comparator` which
	     * is invoked to compare elements of `arrays`. Result values are chosen from
	     * the first array in which the value occurs. The comparator is invoked
	     * with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.unionWith(objects, others, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
	     */
	    var unionWith = baseRest(function(arrays) {
	      var comparator = last(arrays);
	      comparator = typeof comparator == 'function' ? comparator : undefined;
	      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
	    });
	
	    /**
	     * Creates a duplicate-free version of an array, using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons, in which only the first occurrence of each element
	     * is kept. The order of result values is determined by the order they occur
	     * in the array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.uniq([2, 1, 2]);
	     * // => [2, 1]
	     */
	    function uniq(array) {
	      return (array && array.length) ? baseUniq(array) : [];
	    }
	
	    /**
	     * This method is like `_.uniq` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * uniqueness is computed. The order of result values is determined by the
	     * order they occur in the array. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
	     * // => [2.1, 1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */
	    function uniqBy(array, iteratee) {
	      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
	    }
	
	    /**
	     * This method is like `_.uniq` except that it accepts `comparator` which
	     * is invoked to compare elements of `array`. The order of result values is
	     * determined by the order they occur in the array.The comparator is invoked
	     * with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.uniqWith(objects, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
	     */
	    function uniqWith(array, comparator) {
	      comparator = typeof comparator == 'function' ? comparator : undefined;
	      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
	    }
	
	    /**
	     * This method is like `_.zip` except that it accepts an array of grouped
	     * elements and creates an array regrouping the elements to their pre-zip
	     * configuration.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.2.0
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
	     * // => [['a', 1, true], ['b', 2, false]]
	     *
	     * _.unzip(zipped);
	     * // => [['a', 'b'], [1, 2], [true, false]]
	     */
	    function unzip(array) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      var length = 0;
	      array = arrayFilter(array, function(group) {
	        if (isArrayLikeObject(group)) {
	          length = nativeMax(group.length, length);
	          return true;
	        }
	      });
	      return baseTimes(length, function(index) {
	        return arrayMap(array, baseProperty(index));
	      });
	    }
	
	    /**
	     * This method is like `_.unzip` except that it accepts `iteratee` to specify
	     * how regrouped values should be combined. The iteratee is invoked with the
	     * elements of each group: (...group).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.8.0
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @param {Function} [iteratee=_.identity] The function to combine
	     *  regrouped values.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
	     * // => [[1, 10, 100], [2, 20, 200]]
	     *
	     * _.unzipWith(zipped, _.add);
	     * // => [3, 30, 300]
	     */
	    function unzipWith(array, iteratee) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      var result = unzip(array);
	      if (iteratee == null) {
	        return result;
	      }
	      return arrayMap(result, function(group) {
	        return apply(iteratee, undefined, group);
	      });
	    }
	
	    /**
	     * Creates an array excluding all given values using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * **Note:** Unlike `_.pull`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...*} [values] The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @see _.difference, _.xor
	     * @example
	     *
	     * _.without([2, 1, 2, 3], 1, 2);
	     * // => [3]
	     */
	    var without = baseRest(function(array, values) {
	      return isArrayLikeObject(array)
	        ? baseDifference(array, values)
	        : [];
	    });
	
	    /**
	     * Creates an array of unique values that is the
	     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
	     * of the given arrays. The order of result values is determined by the order
	     * they occur in the arrays.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of filtered values.
	     * @see _.difference, _.without
	     * @example
	     *
	     * _.xor([2, 1], [2, 3]);
	     * // => [1, 3]
	     */
	    var xor = baseRest(function(arrays) {
	      return baseXor(arrayFilter(arrays, isArrayLikeObject));
	    });
	
	    /**
	     * This method is like `_.xor` except that it accepts `iteratee` which is
	     * invoked for each element of each `arrays` to generate the criterion by
	     * which by which they're compared. The order of result values is determined
	     * by the order they occur in the arrays. The iteratee is invoked with one
	     * argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	     * // => [1.2, 3.4]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 2 }]
	     */
	    var xorBy = baseRest(function(arrays) {
	      var iteratee = last(arrays);
	      if (isArrayLikeObject(iteratee)) {
	        iteratee = undefined;
	      }
	      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
	    });
	
	    /**
	     * This method is like `_.xor` except that it accepts `comparator` which is
	     * invoked to compare elements of `arrays`. The order of result values is
	     * determined by the order they occur in the arrays. The comparator is invoked
	     * with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.xorWith(objects, others, _.isEqual);
	     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
	     */
	    var xorWith = baseRest(function(arrays) {
	      var comparator = last(arrays);
	      comparator = typeof comparator == 'function' ? comparator : undefined;
	      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
	    });
	
	    /**
	     * Creates an array of grouped elements, the first of which contains the
	     * first elements of the given arrays, the second of which contains the
	     * second elements of the given arrays, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zip(['a', 'b'], [1, 2], [true, false]);
	     * // => [['a', 1, true], ['b', 2, false]]
	     */
	    var zip = baseRest(unzip);
	
	    /**
	     * This method is like `_.fromPairs` except that it accepts two arrays,
	     * one of property identifiers and one of corresponding values.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.4.0
	     * @category Array
	     * @param {Array} [props=[]] The property identifiers.
	     * @param {Array} [values=[]] The property values.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.zipObject(['a', 'b'], [1, 2]);
	     * // => { 'a': 1, 'b': 2 }
	     */
	    function zipObject(props, values) {
	      return baseZipObject(props || [], values || [], assignValue);
	    }
	
	    /**
	     * This method is like `_.zipObject` except that it supports property paths.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.1.0
	     * @category Array
	     * @param {Array} [props=[]] The property identifiers.
	     * @param {Array} [values=[]] The property values.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
	     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
	     */
	    function zipObjectDeep(props, values) {
	      return baseZipObject(props || [], values || [], baseSet);
	    }
	
	    /**
	     * This method is like `_.zip` except that it accepts `iteratee` to specify
	     * how grouped values should be combined. The iteratee is invoked with the
	     * elements of each group: (...group).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.8.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @param {Function} [iteratee=_.identity] The function to combine
	     *  grouped values.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
	     *   return a + b + c;
	     * });
	     * // => [111, 222]
	     */
	    var zipWith = baseRest(function(arrays) {
	      var length = arrays.length,
	          iteratee = length > 1 ? arrays[length - 1] : undefined;
	
	      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
	      return unzipWith(arrays, iteratee);
	    });
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
	     * chain sequences enabled. The result of such sequences must be unwrapped
	     * with `_#value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.3.0
	     * @category Seq
	     * @param {*} value The value to wrap.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36 },
	     *   { 'user': 'fred',    'age': 40 },
	     *   { 'user': 'pebbles', 'age': 1 }
	     * ];
	     *
	     * var youngest = _
	     *   .chain(users)
	     *   .sortBy('age')
	     *   .map(function(o) {
	     *     return o.user + ' is ' + o.age;
	     *   })
	     *   .head()
	     *   .value();
	     * // => 'pebbles is 1'
	     */
	    function chain(value) {
	      var result = lodash(value);
	      result.__chain__ = true;
	      return result;
	    }
	
	    /**
	     * This method invokes `interceptor` and returns `value`. The interceptor
	     * is invoked with one argument; (value). The purpose of this method is to
	     * "tap into" a method chain sequence in order to modify intermediate results.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Seq
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * _([1, 2, 3])
	     *  .tap(function(array) {
	     *    // Mutate input array.
	     *    array.pop();
	     *  })
	     *  .reverse()
	     *  .value();
	     * // => [2, 1]
	     */
	    function tap(value, interceptor) {
	      interceptor(value);
	      return value;
	    }
	
	    /**
	     * This method is like `_.tap` except that it returns the result of `interceptor`.
	     * The purpose of this method is to "pass thru" values replacing intermediate
	     * results in a method chain sequence.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Seq
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @returns {*} Returns the result of `interceptor`.
	     * @example
	     *
	     * _('  abc  ')
	     *  .chain()
	     *  .trim()
	     *  .thru(function(value) {
	     *    return [value];
	     *  })
	     *  .value();
	     * // => ['abc']
	     */
	    function thru(value, interceptor) {
	      return interceptor(value);
	    }
	
	    /**
	     * This method is the wrapper version of `_.at`.
	     *
	     * @name at
	     * @memberOf _
	     * @since 1.0.0
	     * @category Seq
	     * @param {...(string|string[])} [paths] The property paths to pick.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
	     *
	     * _(object).at(['a[0].b.c', 'a[1]']).value();
	     * // => [3, 4]
	     */
	    var wrapperAt = flatRest(function(paths) {
	      var length = paths.length,
	          start = length ? paths[0] : 0,
	          value = this.__wrapped__,
	          interceptor = function(object) { return baseAt(object, paths); };
	
	      if (length > 1 || this.__actions__.length ||
	          !(value instanceof LazyWrapper) || !isIndex(start)) {
	        return this.thru(interceptor);
	      }
	      value = value.slice(start, +start + (length ? 1 : 0));
	      value.__actions__.push({
	        'func': thru,
	        'args': [interceptor],
	        'thisArg': undefined
	      });
	      return new LodashWrapper(value, this.__chain__).thru(function(array) {
	        if (length && !array.length) {
	          array.push(undefined);
	        }
	        return array;
	      });
	    });
	
	    /**
	     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
	     *
	     * @name chain
	     * @memberOf _
	     * @since 0.1.0
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * // A sequence without explicit chaining.
	     * _(users).head();
	     * // => { 'user': 'barney', 'age': 36 }
	     *
	     * // A sequence with explicit chaining.
	     * _(users)
	     *   .chain()
	     *   .head()
	     *   .pick('user')
	     *   .value();
	     * // => { 'user': 'barney' }
	     */
	    function wrapperChain() {
	      return chain(this);
	    }
	
	    /**
	     * Executes the chain sequence and returns the wrapped result.
	     *
	     * @name commit
	     * @memberOf _
	     * @since 3.2.0
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2];
	     * var wrapped = _(array).push(3);
	     *
	     * console.log(array);
	     * // => [1, 2]
	     *
	     * wrapped = wrapped.commit();
	     * console.log(array);
	     * // => [1, 2, 3]
	     *
	     * wrapped.last();
	     * // => 3
	     *
	     * console.log(array);
	     * // => [1, 2, 3]
	     */
	    function wrapperCommit() {
	      return new LodashWrapper(this.value(), this.__chain__);
	    }
	
	    /**
	     * Gets the next value on a wrapped object following the
	     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
	     *
	     * @name next
	     * @memberOf _
	     * @since 4.0.0
	     * @category Seq
	     * @returns {Object} Returns the next iterator value.
	     * @example
	     *
	     * var wrapped = _([1, 2]);
	     *
	     * wrapped.next();
	     * // => { 'done': false, 'value': 1 }
	     *
	     * wrapped.next();
	     * // => { 'done': false, 'value': 2 }
	     *
	     * wrapped.next();
	     * // => { 'done': true, 'value': undefined }
	     */
	    function wrapperNext() {
	      if (this.__values__ === undefined) {
	        this.__values__ = toArray(this.value());
	      }
	      var done = this.__index__ >= this.__values__.length,
	          value = done ? undefined : this.__values__[this.__index__++];
	
	      return { 'done': done, 'value': value };
	    }
	
	    /**
	     * Enables the wrapper to be iterable.
	     *
	     * @name Symbol.iterator
	     * @memberOf _
	     * @since 4.0.0
	     * @category Seq
	     * @returns {Object} Returns the wrapper object.
	     * @example
	     *
	     * var wrapped = _([1, 2]);
	     *
	     * wrapped[Symbol.iterator]() === wrapped;
	     * // => true
	     *
	     * Array.from(wrapped);
	     * // => [1, 2]
	     */
	    function wrapperToIterator() {
	      return this;
	    }
	
	    /**
	     * Creates a clone of the chain sequence planting `value` as the wrapped value.
	     *
	     * @name plant
	     * @memberOf _
	     * @since 3.2.0
	     * @category Seq
	     * @param {*} value The value to plant.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var wrapped = _([1, 2]).map(square);
	     * var other = wrapped.plant([3, 4]);
	     *
	     * other.value();
	     * // => [9, 16]
	     *
	     * wrapped.value();
	     * // => [1, 4]
	     */
	    function wrapperPlant(value) {
	      var result,
	          parent = this;
	
	      while (parent instanceof baseLodash) {
	        var clone = wrapperClone(parent);
	        clone.__index__ = 0;
	        clone.__values__ = undefined;
	        if (result) {
	          previous.__wrapped__ = clone;
	        } else {
	          result = clone;
	        }
	        var previous = clone;
	        parent = parent.__wrapped__;
	      }
	      previous.__wrapped__ = value;
	      return result;
	    }
	
	    /**
	     * This method is the wrapper version of `_.reverse`.
	     *
	     * **Note:** This method mutates the wrapped array.
	     *
	     * @name reverse
	     * @memberOf _
	     * @since 0.1.0
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _(array).reverse().value()
	     * // => [3, 2, 1]
	     *
	     * console.log(array);
	     * // => [3, 2, 1]
	     */
	    function wrapperReverse() {
	      var value = this.__wrapped__;
	      if (value instanceof LazyWrapper) {
	        var wrapped = value;
	        if (this.__actions__.length) {
	          wrapped = new LazyWrapper(this);
	        }
	        wrapped = wrapped.reverse();
	        wrapped.__actions__.push({
	          'func': thru,
	          'args': [reverse],
	          'thisArg': undefined
	        });
	        return new LodashWrapper(wrapped, this.__chain__);
	      }
	      return this.thru(reverse);
	    }
	
	    /**
	     * Executes the chain sequence to resolve the unwrapped value.
	     *
	     * @name value
	     * @memberOf _
	     * @since 0.1.0
	     * @alias toJSON, valueOf
	     * @category Seq
	     * @returns {*} Returns the resolved unwrapped value.
	     * @example
	     *
	     * _([1, 2, 3]).value();
	     * // => [1, 2, 3]
	     */
	    function wrapperValue() {
	      return baseWrapperValue(this.__wrapped__, this.__actions__);
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` thru `iteratee`. The corresponding value of
	     * each key is the number of times the key was returned by `iteratee`. The
	     * iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.5.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.countBy([6.1, 4.2, 6.3], Math.floor);
	     * // => { '4': 1, '6': 2 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.countBy(['one', 'two', 'three'], 'length');
	     * // => { '3': 2, '5': 1 }
	     */
	    var countBy = createAggregator(function(result, value, key) {
	      if (hasOwnProperty.call(result, key)) {
	        ++result[key];
	      } else {
	        baseAssignValue(result, key, 1);
	      }
	    });
	
	    /**
	     * Checks if `predicate` returns truthy for **all** elements of `collection`.
	     * Iteration is stopped once `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * **Note:** This method returns `true` for
	     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
	     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
	     * elements of empty collections.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.every([true, 1, null, 'yes'], Boolean);
	     * // => false
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.every(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.every(users, ['active', false]);
	     * // => true
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.every(users, 'active');
	     * // => false
	     */
	    function every(collection, predicate, guard) {
	      var func = isArray(collection) ? arrayEvery : baseEvery;
	      if (guard && isIterateeCall(collection, predicate, guard)) {
	        predicate = undefined;
	      }
	      return func(collection, getIteratee(predicate, 3));
	    }
	
	    /**
	     * Iterates over elements of `collection`, returning an array of all elements
	     * `predicate` returns truthy for. The predicate is invoked with three
	     * arguments: (value, index|key, collection).
	     *
	     * **Note:** Unlike `_.remove`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     * @see _.reject
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * _.filter(users, function(o) { return !o.active; });
	     * // => objects for ['fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.filter(users, { 'age': 36, 'active': true });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.filter(users, ['active', false]);
	     * // => objects for ['fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.filter(users, 'active');
	     * // => objects for ['barney']
	     */
	    function filter(collection, predicate) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      return func(collection, getIteratee(predicate, 3));
	    }
	
	    /**
	     * Iterates over elements of `collection`, returning the first element
	     * `predicate` returns truthy for. The predicate is invoked with three
	     * arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': true },
	     *   { 'user': 'fred',    'age': 40, 'active': false },
	     *   { 'user': 'pebbles', 'age': 1,  'active': true }
	     * ];
	     *
	     * _.find(users, function(o) { return o.age < 40; });
	     * // => object for 'barney'
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.find(users, { 'age': 1, 'active': true });
	     * // => object for 'pebbles'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.find(users, ['active', false]);
	     * // => object for 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.find(users, 'active');
	     * // => object for 'barney'
	     */
	    var find = createFind(findIndex);
	
	    /**
	     * This method is like `_.find` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=collection.length-1] The index to search from.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * _.findLast([1, 2, 3, 4], function(n) {
	     *   return n % 2 == 1;
	     * });
	     * // => 3
	     */
	    var findLast = createFind(findLastIndex);
	
	    /**
	     * Creates a flattened array of values by running each element in `collection`
	     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
	     * with three arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [n, n];
	     * }
	     *
	     * _.flatMap([1, 2], duplicate);
	     * // => [1, 1, 2, 2]
	     */
	    function flatMap(collection, iteratee) {
	      return baseFlatten(map(collection, iteratee), 1);
	    }
	
	    /**
	     * This method is like `_.flatMap` except that it recursively flattens the
	     * mapped results.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [[[n, n]]];
	     * }
	     *
	     * _.flatMapDeep([1, 2], duplicate);
	     * // => [1, 1, 2, 2]
	     */
	    function flatMapDeep(collection, iteratee) {
	      return baseFlatten(map(collection, iteratee), INFINITY);
	    }
	
	    /**
	     * This method is like `_.flatMap` except that it recursively flattens the
	     * mapped results up to `depth` times.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {number} [depth=1] The maximum recursion depth.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [[[n, n]]];
	     * }
	     *
	     * _.flatMapDepth([1, 2], duplicate, 2);
	     * // => [[1, 1], [2, 2]]
	     */
	    function flatMapDepth(collection, iteratee, depth) {
	      depth = depth === undefined ? 1 : toInteger(depth);
	      return baseFlatten(map(collection, iteratee), depth);
	    }
	
	    /**
	     * Iterates over elements of `collection` and invokes `iteratee` for each element.
	     * The iteratee is invoked with three arguments: (value, index|key, collection).
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * **Note:** As with other "Collections" methods, objects with a "length"
	     * property are iterated like arrays. To avoid this behavior use `_.forIn`
	     * or `_.forOwn` for object iteration.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @alias each
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     * @see _.forEachRight
	     * @example
	     *
	     * _.forEach([1, 2], function(value) {
	     *   console.log(value);
	     * });
	     * // => Logs `1` then `2`.
	     *
	     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
	     */
	    function forEach(collection, iteratee) {
	      var func = isArray(collection) ? arrayEach : baseEach;
	      return func(collection, getIteratee(iteratee, 3));
	    }
	
	    /**
	     * This method is like `_.forEach` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @alias eachRight
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     * @see _.forEach
	     * @example
	     *
	     * _.forEachRight([1, 2], function(value) {
	     *   console.log(value);
	     * });
	     * // => Logs `2` then `1`.
	     */
	    function forEachRight(collection, iteratee) {
	      var func = isArray(collection) ? arrayEachRight : baseEachRight;
	      return func(collection, getIteratee(iteratee, 3));
	    }
	
	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` thru `iteratee`. The order of grouped values
	     * is determined by the order they occur in `collection`. The corresponding
	     * value of each key is an array of elements responsible for generating the
	     * key. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
	     * // => { '4': [4.2], '6': [6.1, 6.3] }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.groupBy(['one', 'two', 'three'], 'length');
	     * // => { '3': ['one', 'two'], '5': ['three'] }
	     */
	    var groupBy = createAggregator(function(result, value, key) {
	      if (hasOwnProperty.call(result, key)) {
	        result[key].push(value);
	      } else {
	        baseAssignValue(result, key, [value]);
	      }
	    });
	
	    /**
	     * Checks if `value` is in `collection`. If `collection` is a string, it's
	     * checked for a substring of `value`, otherwise
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * is used for equality comparisons. If `fromIndex` is negative, it's used as
	     * the offset from the end of `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to inspect.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
	     * @returns {boolean} Returns `true` if `value` is found, else `false`.
	     * @example
	     *
	     * _.includes([1, 2, 3], 1);
	     * // => true
	     *
	     * _.includes([1, 2, 3], 1, 2);
	     * // => false
	     *
	     * _.includes({ 'a': 1, 'b': 2 }, 1);
	     * // => true
	     *
	     * _.includes('abcd', 'bc');
	     * // => true
	     */
	    function includes(collection, value, fromIndex, guard) {
	      collection = isArrayLike(collection) ? collection : values(collection);
	      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;
	
	      var length = collection.length;
	      if (fromIndex < 0) {
	        fromIndex = nativeMax(length + fromIndex, 0);
	      }
	      return isString(collection)
	        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
	        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
	    }
	
	    /**
	     * Invokes the method at `path` of each element in `collection`, returning
	     * an array of the results of each invoked method. Any additional arguments
	     * are provided to each invoked method. If `path` is a function, it's invoked
	     * for, and `this` bound to, each element in `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array|Function|string} path The path of the method to invoke or
	     *  the function invoked per iteration.
	     * @param {...*} [args] The arguments to invoke each method with.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
	     * // => [[1, 5, 7], [1, 2, 3]]
	     *
	     * _.invokeMap([123, 456], String.prototype.split, '');
	     * // => [['1', '2', '3'], ['4', '5', '6']]
	     */
	    var invokeMap = baseRest(function(collection, path, args) {
	      var index = -1,
	          isFunc = typeof path == 'function',
	          result = isArrayLike(collection) ? Array(collection.length) : [];
	
	      baseEach(collection, function(value) {
	        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
	      });
	      return result;
	    });
	
	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` thru `iteratee`. The corresponding value of
	     * each key is the last element responsible for generating the key. The
	     * iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * var array = [
	     *   { 'dir': 'left', 'code': 97 },
	     *   { 'dir': 'right', 'code': 100 }
	     * ];
	     *
	     * _.keyBy(array, function(o) {
	     *   return String.fromCharCode(o.code);
	     * });
	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	     *
	     * _.keyBy(array, 'dir');
	     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
	     */
	    var keyBy = createAggregator(function(result, value, key) {
	      baseAssignValue(result, key, value);
	    });
	
	    /**
	     * Creates an array of values by running each element in `collection` thru
	     * `iteratee`. The iteratee is invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
	     *
	     * The guarded methods are:
	     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
	     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
	     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
	     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * _.map([4, 8], square);
	     * // => [16, 64]
	     *
	     * _.map({ 'a': 4, 'b': 8 }, square);
	     * // => [16, 64] (iteration order is not guaranteed)
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.map(users, 'user');
	     * // => ['barney', 'fred']
	     */
	    function map(collection, iteratee) {
	      var func = isArray(collection) ? arrayMap : baseMap;
	      return func(collection, getIteratee(iteratee, 3));
	    }
	
	    /**
	     * This method is like `_.sortBy` except that it allows specifying the sort
	     * orders of the iteratees to sort by. If `orders` is unspecified, all values
	     * are sorted in ascending order. Otherwise, specify an order of "desc" for
	     * descending or "asc" for ascending sort order of corresponding values.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
	     *  The iteratees to sort by.
	     * @param {string[]} [orders] The sort orders of `iteratees`.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 34 },
	     *   { 'user': 'fred',   'age': 40 },
	     *   { 'user': 'barney', 'age': 36 }
	     * ];
	     *
	     * // Sort by `user` in ascending order and by `age` in descending order.
	     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
	     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
	     */
	    function orderBy(collection, iteratees, orders, guard) {
	      if (collection == null) {
	        return [];
	      }
	      if (!isArray(iteratees)) {
	        iteratees = iteratees == null ? [] : [iteratees];
	      }
	      orders = guard ? undefined : orders;
	      if (!isArray(orders)) {
	        orders = orders == null ? [] : [orders];
	      }
	      return baseOrderBy(collection, iteratees, orders);
	    }
	
	    /**
	     * Creates an array of elements split into two groups, the first of which
	     * contains elements `predicate` returns truthy for, the second of which
	     * contains elements `predicate` returns falsey for. The predicate is
	     * invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the array of grouped elements.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': false },
	     *   { 'user': 'fred',    'age': 40, 'active': true },
	     *   { 'user': 'pebbles', 'age': 1,  'active': false }
	     * ];
	     *
	     * _.partition(users, function(o) { return o.active; });
	     * // => objects for [['fred'], ['barney', 'pebbles']]
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.partition(users, { 'age': 1, 'active': false });
	     * // => objects for [['pebbles'], ['barney', 'fred']]
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.partition(users, ['active', false]);
	     * // => objects for [['barney', 'pebbles'], ['fred']]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.partition(users, 'active');
	     * // => objects for [['fred'], ['barney', 'pebbles']]
	     */
	    var partition = createAggregator(function(result, value, key) {
	      result[key ? 0 : 1].push(value);
	    }, function() { return [[], []]; });
	
	    /**
	     * Reduces `collection` to a value which is the accumulated result of running
	     * each element in `collection` thru `iteratee`, where each successive
	     * invocation is supplied the return value of the previous. If `accumulator`
	     * is not given, the first element of `collection` is used as the initial
	     * value. The iteratee is invoked with four arguments:
	     * (accumulator, value, index|key, collection).
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.reduce`, `_.reduceRight`, and `_.transform`.
	     *
	     * The guarded methods are:
	     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
	     * and `sortBy`
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @returns {*} Returns the accumulated value.
	     * @see _.reduceRight
	     * @example
	     *
	     * _.reduce([1, 2], function(sum, n) {
	     *   return sum + n;
	     * }, 0);
	     * // => 3
	     *
	     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
	     *   (result[value] || (result[value] = [])).push(key);
	     *   return result;
	     * }, {});
	     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
	     */
	    function reduce(collection, iteratee, accumulator) {
	      var func = isArray(collection) ? arrayReduce : baseReduce,
	          initAccum = arguments.length < 3;
	
	      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
	    }
	
	    /**
	     * This method is like `_.reduce` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @returns {*} Returns the accumulated value.
	     * @see _.reduce
	     * @example
	     *
	     * var array = [[0, 1], [2, 3], [4, 5]];
	     *
	     * _.reduceRight(array, function(flattened, other) {
	     *   return flattened.concat(other);
	     * }, []);
	     * // => [4, 5, 2, 3, 0, 1]
	     */
	    function reduceRight(collection, iteratee, accumulator) {
	      var func = isArray(collection) ? arrayReduceRight : baseReduce,
	          initAccum = arguments.length < 3;
	
	      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
	    }
	
	    /**
	     * The opposite of `_.filter`; this method returns the elements of `collection`
	     * that `predicate` does **not** return truthy for.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     * @see _.filter
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false },
	     *   { 'user': 'fred',   'age': 40, 'active': true }
	     * ];
	     *
	     * _.reject(users, function(o) { return !o.active; });
	     * // => objects for ['fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.reject(users, { 'age': 40, 'active': true });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.reject(users, ['active', false]);
	     * // => objects for ['fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.reject(users, 'active');
	     * // => objects for ['barney']
	     */
	    function reject(collection, predicate) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      return func(collection, negate(getIteratee(predicate, 3)));
	    }
	
	    /**
	     * Gets a random element from `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to sample.
	     * @returns {*} Returns the random element.
	     * @example
	     *
	     * _.sample([1, 2, 3, 4]);
	     * // => 2
	     */
	    function sample(collection) {
	      var func = isArray(collection) ? arraySample : baseSample;
	      return func(collection);
	    }
	
	    /**
	     * Gets `n` random elements at unique keys from `collection` up to the
	     * size of `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to sample.
	     * @param {number} [n=1] The number of elements to sample.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the random elements.
	     * @example
	     *
	     * _.sampleSize([1, 2, 3], 2);
	     * // => [3, 1]
	     *
	     * _.sampleSize([1, 2, 3], 4);
	     * // => [2, 3, 1]
	     */
	    function sampleSize(collection, n, guard) {
	      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
	        n = 1;
	      } else {
	        n = toInteger(n);
	      }
	      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
	      return func(collection, n);
	    }
	
	    /**
	     * Creates an array of shuffled values, using a version of the
	     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     * @example
	     *
	     * _.shuffle([1, 2, 3, 4]);
	     * // => [4, 1, 3, 2]
	     */
	    function shuffle(collection) {
	      var func = isArray(collection) ? arrayShuffle : baseShuffle;
	      return func(collection);
	    }
	
	    /**
	     * Gets the size of `collection` by returning its length for array-like
	     * values or the number of own enumerable string keyed properties for objects.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to inspect.
	     * @returns {number} Returns the collection size.
	     * @example
	     *
	     * _.size([1, 2, 3]);
	     * // => 3
	     *
	     * _.size({ 'a': 1, 'b': 2 });
	     * // => 2
	     *
	     * _.size('pebbles');
	     * // => 7
	     */
	    function size(collection) {
	      if (collection == null) {
	        return 0;
	      }
	      if (isArrayLike(collection)) {
	        return isString(collection) ? stringSize(collection) : collection.length;
	      }
	      var tag = getTag(collection);
	      if (tag == mapTag || tag == setTag) {
	        return collection.size;
	      }
	      return baseKeys(collection).length;
	    }
	
	    /**
	     * Checks if `predicate` returns truthy for **any** element of `collection`.
	     * Iteration is stopped once `predicate` returns truthy. The predicate is
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.some([null, 0, 'yes', false], Boolean);
	     * // => true
	     *
	     * var users = [
	     *   { 'user': 'barney', 'active': true },
	     *   { 'user': 'fred',   'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.some(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.some(users, ['active', false]);
	     * // => true
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.some(users, 'active');
	     * // => true
	     */
	    function some(collection, predicate, guard) {
	      var func = isArray(collection) ? arraySome : baseSome;
	      if (guard && isIterateeCall(collection, predicate, guard)) {
	        predicate = undefined;
	      }
	      return func(collection, getIteratee(predicate, 3));
	    }
	
	    /**
	     * Creates an array of elements, sorted in ascending order by the results of
	     * running each element in a collection thru each iteratee. This method
	     * performs a stable sort, that is, it preserves the original sort order of
	     * equal elements. The iteratees are invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {...(Function|Function[])} [iteratees=[_.identity]]
	     *  The iteratees to sort by.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 },
	     *   { 'user': 'barney', 'age': 34 }
	     * ];
	     *
	     * _.sortBy(users, [function(o) { return o.user; }]);
	     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
	     *
	     * _.sortBy(users, ['user', 'age']);
	     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
	     */
	    var sortBy = baseRest(function(collection, iteratees) {
	      if (collection == null) {
	        return [];
	      }
	      var length = iteratees.length;
	      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
	        iteratees = [];
	      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
	        iteratees = [iteratees[0]];
	      }
	      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
	    });
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Gets the timestamp of the number of milliseconds that have elapsed since
	     * the Unix epoch (1 January 1970 00:00:00 UTC).
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Date
	     * @returns {number} Returns the timestamp.
	     * @example
	     *
	     * _.defer(function(stamp) {
	     *   console.log(_.now() - stamp);
	     * }, _.now());
	     * // => Logs the number of milliseconds it took for the deferred invocation.
	     */
	    var now = ctxNow || function() {
	      return root.Date.now();
	    };
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * The opposite of `_.before`; this method creates a function that invokes
	     * `func` once it's called `n` or more times.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {number} n The number of calls before `func` is invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var saves = ['profile', 'settings'];
	     *
	     * var done = _.after(saves.length, function() {
	     *   console.log('done saving!');
	     * });
	     *
	     * _.forEach(saves, function(type) {
	     *   asyncSave({ 'type': type, 'complete': done });
	     * });
	     * // => Logs 'done saving!' after the two async saves have completed.
	     */
	    function after(n, func) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      n = toInteger(n);
	      return function() {
	        if (--n < 1) {
	          return func.apply(this, arguments);
	        }
	      };
	    }
	
	    /**
	     * Creates a function that invokes `func`, with up to `n` arguments,
	     * ignoring any additional arguments.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} func The function to cap arguments for.
	     * @param {number} [n=func.length] The arity cap.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the new capped function.
	     * @example
	     *
	     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
	     * // => [6, 8, 10]
	     */
	    function ary(func, n, guard) {
	      n = guard ? undefined : n;
	      n = (func && n == null) ? func.length : n;
	      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
	    }
	
	    /**
	     * Creates a function that invokes `func`, with the `this` binding and arguments
	     * of the created function, while it's called less than `n` times. Subsequent
	     * calls to the created function return the result of the last `func` invocation.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {number} n The number of calls at which `func` is no longer invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * jQuery(element).on('click', _.before(5, addContactToList));
	     * // => Allows adding up to 4 contacts to the list.
	     */
	    function before(n, func) {
	      var result;
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      n = toInteger(n);
	      return function() {
	        if (--n > 0) {
	          result = func.apply(this, arguments);
	        }
	        if (n <= 1) {
	          func = undefined;
	        }
	        return result;
	      };
	    }
	
	    /**
	     * Creates a function that invokes `func` with the `this` binding of `thisArg`
	     * and `partials` prepended to the arguments it receives.
	     *
	     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
	     * property of bound functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to bind.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * function greet(greeting, punctuation) {
	     *   return greeting + ' ' + this.user + punctuation;
	     * }
	     *
	     * var object = { 'user': 'fred' };
	     *
	     * var bound = _.bind(greet, object, 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * // Bound with placeholders.
	     * var bound = _.bind(greet, object, _, '!');
	     * bound('hi');
	     * // => 'hi fred!'
	     */
	    var bind = baseRest(function(func, thisArg, partials) {
	      var bitmask = WRAP_BIND_FLAG;
	      if (partials.length) {
	        var holders = replaceHolders(partials, getHolder(bind));
	        bitmask |= WRAP_PARTIAL_FLAG;
	      }
	      return createWrap(func, bitmask, thisArg, partials, holders);
	    });
	
	    /**
	     * Creates a function that invokes the method at `object[key]` with `partials`
	     * prepended to the arguments it receives.
	     *
	     * This method differs from `_.bind` by allowing bound functions to reference
	     * methods that may be redefined or don't yet exist. See
	     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
	     * for more details.
	     *
	     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.10.0
	     * @category Function
	     * @param {Object} object The object to invoke the method on.
	     * @param {string} key The key of the method.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var object = {
	     *   'user': 'fred',
	     *   'greet': function(greeting, punctuation) {
	     *     return greeting + ' ' + this.user + punctuation;
	     *   }
	     * };
	     *
	     * var bound = _.bindKey(object, 'greet', 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * object.greet = function(greeting, punctuation) {
	     *   return greeting + 'ya ' + this.user + punctuation;
	     * };
	     *
	     * bound('!');
	     * // => 'hiya fred!'
	     *
	     * // Bound with placeholders.
	     * var bound = _.bindKey(object, 'greet', _, '!');
	     * bound('hi');
	     * // => 'hiya fred!'
	     */
	    var bindKey = baseRest(function(object, key, partials) {
	      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
	      if (partials.length) {
	        var holders = replaceHolders(partials, getHolder(bindKey));
	        bitmask |= WRAP_PARTIAL_FLAG;
	      }
	      return createWrap(key, bitmask, object, partials, holders);
	    });
	
	    /**
	     * Creates a function that accepts arguments of `func` and either invokes
	     * `func` returning its result, if at least `arity` number of arguments have
	     * been provided, or returns a function that accepts the remaining `func`
	     * arguments, and so on. The arity of `func` may be specified if `func.length`
	     * is not sufficient.
	     *
	     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curry(abc);
	     *
	     * curried(1)(2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // Curried with placeholders.
	     * curried(1)(_, 3)(2);
	     * // => [1, 2, 3]
	     */
	    function curry(func, arity, guard) {
	      arity = guard ? undefined : arity;
	      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
	      result.placeholder = curry.placeholder;
	      return result;
	    }
	
	    /**
	     * This method is like `_.curry` except that arguments are applied to `func`
	     * in the manner of `_.partialRight` instead of `_.partial`.
	     *
	     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curryRight(abc);
	     *
	     * curried(3)(2)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(2, 3)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // Curried with placeholders.
	     * curried(3)(1, _)(2);
	     * // => [1, 2, 3]
	     */
	    function curryRight(func, arity, guard) {
	      arity = guard ? undefined : arity;
	      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
	      result.placeholder = curryRight.placeholder;
	      return result;
	    }
	
	    /**
	     * Creates a debounced function that delays invoking `func` until after `wait`
	     * milliseconds have elapsed since the last time the debounced function was
	     * invoked. The debounced function comes with a `cancel` method to cancel
	     * delayed `func` invocations and a `flush` method to immediately invoke them.
	     * Provide `options` to indicate whether `func` should be invoked on the
	     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
	     * with the last arguments provided to the debounced function. Subsequent
	     * calls to the debounced function return the result of the last `func`
	     * invocation.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is
	     * invoked on the trailing edge of the timeout only if the debounced function
	     * is invoked more than once during the `wait` timeout.
	     *
	     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	     *
	     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	     * for details over the differences between `_.debounce` and `_.throttle`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to debounce.
	     * @param {number} [wait=0] The number of milliseconds to delay.
	     * @param {Object} [options={}] The options object.
	     * @param {boolean} [options.leading=false]
	     *  Specify invoking on the leading edge of the timeout.
	     * @param {number} [options.maxWait]
	     *  The maximum time `func` is allowed to be delayed before it's invoked.
	     * @param {boolean} [options.trailing=true]
	     *  Specify invoking on the trailing edge of the timeout.
	     * @returns {Function} Returns the new debounced function.
	     * @example
	     *
	     * // Avoid costly calculations while the window size is in flux.
	     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	     *
	     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
	     * jQuery(element).on('click', _.debounce(sendMail, 300, {
	     *   'leading': true,
	     *   'trailing': false
	     * }));
	     *
	     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
	     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
	     * var source = new EventSource('/stream');
	     * jQuery(source).on('message', debounced);
	     *
	     * // Cancel the trailing debounced invocation.
	     * jQuery(window).on('popstate', debounced.cancel);
	     */
	    function debounce(func, wait, options) {
	      var lastArgs,
	          lastThis,
	          maxWait,
	          result,
	          timerId,
	          lastCallTime,
	          lastInvokeTime = 0,
	          leading = false,
	          maxing = false,
	          trailing = true;
	
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      wait = toNumber(wait) || 0;
	      if (isObject(options)) {
	        leading = !!options.leading;
	        maxing = 'maxWait' in options;
	        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	      }
	
	      function invokeFunc(time) {
	        var args = lastArgs,
	            thisArg = lastThis;
	
	        lastArgs = lastThis = undefined;
	        lastInvokeTime = time;
	        result = func.apply(thisArg, args);
	        return result;
	      }
	
	      function leadingEdge(time) {
	        // Reset any `maxWait` timer.
	        lastInvokeTime = time;
	        // Start the timer for the trailing edge.
	        timerId = setTimeout(timerExpired, wait);
	        // Invoke the leading edge.
	        return leading ? invokeFunc(time) : result;
	      }
	
	      function remainingWait(time) {
	        var timeSinceLastCall = time - lastCallTime,
	            timeSinceLastInvoke = time - lastInvokeTime,
	            result = wait - timeSinceLastCall;
	
	        return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
	      }
	
	      function shouldInvoke(time) {
	        var timeSinceLastCall = time - lastCallTime,
	            timeSinceLastInvoke = time - lastInvokeTime;
	
	        // Either this is the first call, activity has stopped and we're at the
	        // trailing edge, the system time has gone backwards and we're treating
	        // it as the trailing edge, or we've hit the `maxWait` limit.
	        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
	          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
	      }
	
	      function timerExpired() {
	        var time = now();
	        if (shouldInvoke(time)) {
	          return trailingEdge(time);
	        }
	        // Restart the timer.
	        timerId = setTimeout(timerExpired, remainingWait(time));
	      }
	
	      function trailingEdge(time) {
	        timerId = undefined;
	
	        // Only invoke if we have `lastArgs` which means `func` has been
	        // debounced at least once.
	        if (trailing && lastArgs) {
	          return invokeFunc(time);
	        }
	        lastArgs = lastThis = undefined;
	        return result;
	      }
	
	      function cancel() {
	        if (timerId !== undefined) {
	          clearTimeout(timerId);
	        }
	        lastInvokeTime = 0;
	        lastArgs = lastCallTime = lastThis = timerId = undefined;
	      }
	
	      function flush() {
	        return timerId === undefined ? result : trailingEdge(now());
	      }
	
	      function debounced() {
	        var time = now(),
	            isInvoking = shouldInvoke(time);
	
	        lastArgs = arguments;
	        lastThis = this;
	        lastCallTime = time;
	
	        if (isInvoking) {
	          if (timerId === undefined) {
	            return leadingEdge(lastCallTime);
	          }
	          if (maxing) {
	            // Handle invocations in a tight loop.
	            timerId = setTimeout(timerExpired, wait);
	            return invokeFunc(lastCallTime);
	          }
	        }
	        if (timerId === undefined) {
	          timerId = setTimeout(timerExpired, wait);
	        }
	        return result;
	      }
	      debounced.cancel = cancel;
	      debounced.flush = flush;
	      return debounced;
	    }
	
	    /**
	     * Defers invoking the `func` until the current call stack has cleared. Any
	     * additional arguments are provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to defer.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.defer(function(text) {
	     *   console.log(text);
	     * }, 'deferred');
	     * // => Logs 'deferred' after one millisecond.
	     */
	    var defer = baseRest(function(func, args) {
	      return baseDelay(func, 1, args);
	    });
	
	    /**
	     * Invokes `func` after `wait` milliseconds. Any additional arguments are
	     * provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.delay(function(text) {
	     *   console.log(text);
	     * }, 1000, 'later');
	     * // => Logs 'later' after one second.
	     */
	    var delay = baseRest(function(func, wait, args) {
	      return baseDelay(func, toNumber(wait) || 0, args);
	    });
	
	    /**
	     * Creates a function that invokes `func` with arguments reversed.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Function
	     * @param {Function} func The function to flip arguments for.
	     * @returns {Function} Returns the new flipped function.
	     * @example
	     *
	     * var flipped = _.flip(function() {
	     *   return _.toArray(arguments);
	     * });
	     *
	     * flipped('a', 'b', 'c', 'd');
	     * // => ['d', 'c', 'b', 'a']
	     */
	    function flip(func) {
	      return createWrap(func, WRAP_FLIP_FLAG);
	    }
	
	    /**
	     * Creates a function that memoizes the result of `func`. If `resolver` is
	     * provided, it determines the cache key for storing the result based on the
	     * arguments provided to the memoized function. By default, the first argument
	     * provided to the memoized function is used as the map cache key. The `func`
	     * is invoked with the `this` binding of the memoized function.
	     *
	     * **Note:** The cache is exposed as the `cache` property on the memoized
	     * function. Its creation may be customized by replacing the `_.memoize.Cache`
	     * constructor with one whose instances implement the
	     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to have its output memoized.
	     * @param {Function} [resolver] The function to resolve the cache key.
	     * @returns {Function} Returns the new memoized function.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2 };
	     * var other = { 'c': 3, 'd': 4 };
	     *
	     * var values = _.memoize(_.values);
	     * values(object);
	     * // => [1, 2]
	     *
	     * values(other);
	     * // => [3, 4]
	     *
	     * object.a = 2;
	     * values(object);
	     * // => [1, 2]
	     *
	     * // Modify the result cache.
	     * values.cache.set(object, ['a', 'b']);
	     * values(object);
	     * // => ['a', 'b']
	     *
	     * // Replace `_.memoize.Cache`.
	     * _.memoize.Cache = WeakMap;
	     */
	    function memoize(func, resolver) {
	      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var memoized = function() {
	        var args = arguments,
	            key = resolver ? resolver.apply(this, args) : args[0],
	            cache = memoized.cache;
	
	        if (cache.has(key)) {
	          return cache.get(key);
	        }
	        var result = func.apply(this, args);
	        memoized.cache = cache.set(key, result) || cache;
	        return result;
	      };
	      memoized.cache = new (memoize.Cache || MapCache);
	      return memoized;
	    }
	
	    // Expose `MapCache`.
	    memoize.Cache = MapCache;
	
	    /**
	     * Creates a function that negates the result of the predicate `func`. The
	     * `func` predicate is invoked with the `this` binding and arguments of the
	     * created function.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} predicate The predicate to negate.
	     * @returns {Function} Returns the new negated function.
	     * @example
	     *
	     * function isEven(n) {
	     *   return n % 2 == 0;
	     * }
	     *
	     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
	     * // => [1, 3, 5]
	     */
	    function negate(predicate) {
	      if (typeof predicate != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return function() {
	        var args = arguments;
	        switch (args.length) {
	          case 0: return !predicate.call(this);
	          case 1: return !predicate.call(this, args[0]);
	          case 2: return !predicate.call(this, args[0], args[1]);
	          case 3: return !predicate.call(this, args[0], args[1], args[2]);
	        }
	        return !predicate.apply(this, args);
	      };
	    }
	
	    /**
	     * Creates a function that is restricted to invoking `func` once. Repeat calls
	     * to the function return the value of the first invocation. The `func` is
	     * invoked with the `this` binding and arguments of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var initialize = _.once(createApplication);
	     * initialize();
	     * initialize();
	     * // => `createApplication` is invoked once
	     */
	    function once(func) {
	      return before(2, func);
	    }
	
	    /**
	     * Creates a function that invokes `func` with its arguments transformed.
	     *
	     * @static
	     * @since 4.0.0
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to wrap.
	     * @param {...(Function|Function[])} [transforms=[_.identity]]
	     *  The argument transforms.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function doubled(n) {
	     *   return n * 2;
	     * }
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var func = _.overArgs(function(x, y) {
	     *   return [x, y];
	     * }, [square, doubled]);
	     *
	     * func(9, 3);
	     * // => [81, 6]
	     *
	     * func(10, 5);
	     * // => [100, 10]
	     */
	    var overArgs = castRest(function(func, transforms) {
	      transforms = (transforms.length == 1 && isArray(transforms[0]))
	        ? arrayMap(transforms[0], baseUnary(getIteratee()))
	        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
	
	      var funcsLength = transforms.length;
	      return baseRest(function(args) {
	        var index = -1,
	            length = nativeMin(args.length, funcsLength);
	
	        while (++index < length) {
	          args[index] = transforms[index].call(this, args[index]);
	        }
	        return apply(func, this, args);
	      });
	    });
	
	    /**
	     * Creates a function that invokes `func` with `partials` prepended to the
	     * arguments it receives. This method is like `_.bind` except it does **not**
	     * alter the `this` binding.
	     *
	     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.2.0
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * function greet(greeting, name) {
	     *   return greeting + ' ' + name;
	     * }
	     *
	     * var sayHelloTo = _.partial(greet, 'hello');
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     *
	     * // Partially applied with placeholders.
	     * var greetFred = _.partial(greet, _, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     */
	    var partial = baseRest(function(func, partials) {
	      var holders = replaceHolders(partials, getHolder(partial));
	      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
	    });
	
	    /**
	     * This method is like `_.partial` except that partially applied arguments
	     * are appended to the arguments it receives.
	     *
	     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.0.0
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * function greet(greeting, name) {
	     *   return greeting + ' ' + name;
	     * }
	     *
	     * var greetFred = _.partialRight(greet, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     *
	     * // Partially applied with placeholders.
	     * var sayHelloTo = _.partialRight(greet, 'hello', _);
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     */
	    var partialRight = baseRest(function(func, partials) {
	      var holders = replaceHolders(partials, getHolder(partialRight));
	      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
	    });
	
	    /**
	     * Creates a function that invokes `func` with arguments arranged according
	     * to the specified `indexes` where the argument value at the first index is
	     * provided as the first argument, the argument value at the second index is
	     * provided as the second argument, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} func The function to rearrange arguments for.
	     * @param {...(number|number[])} indexes The arranged argument indexes.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var rearged = _.rearg(function(a, b, c) {
	     *   return [a, b, c];
	     * }, [2, 0, 1]);
	     *
	     * rearged('b', 'c', 'a')
	     * // => ['a', 'b', 'c']
	     */
	    var rearg = flatRest(function(func, indexes) {
	      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
	    });
	
	    /**
	     * Creates a function that invokes `func` with the `this` binding of the
	     * created function and arguments from `start` and beyond provided as
	     * an array.
	     *
	     * **Note:** This method is based on the
	     * [rest parameter](https://mdn.io/rest_parameters).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Function
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.rest(function(what, names) {
	     *   return what + ' ' + _.initial(names).join(', ') +
	     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
	     * });
	     *
	     * say('hello', 'fred', 'barney', 'pebbles');
	     * // => 'hello fred, barney, & pebbles'
	     */
	    function rest(func, start) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      start = start === undefined ? start : toInteger(start);
	      return baseRest(func, start);
	    }
	
	    /**
	     * Creates a function that invokes `func` with the `this` binding of the
	     * create function and an array of arguments much like
	     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
	     *
	     * **Note:** This method is based on the
	     * [spread operator](https://mdn.io/spread_operator).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.2.0
	     * @category Function
	     * @param {Function} func The function to spread arguments over.
	     * @param {number} [start=0] The start position of the spread.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.spread(function(who, what) {
	     *   return who + ' says ' + what;
	     * });
	     *
	     * say(['fred', 'hello']);
	     * // => 'fred says hello'
	     *
	     * var numbers = Promise.all([
	     *   Promise.resolve(40),
	     *   Promise.resolve(36)
	     * ]);
	     *
	     * numbers.then(_.spread(function(x, y) {
	     *   return x + y;
	     * }));
	     * // => a Promise of 76
	     */
	    function spread(func, start) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      start = start == null ? 0 : nativeMax(toInteger(start), 0);
	      return baseRest(function(args) {
	        var array = args[start],
	            otherArgs = castSlice(args, 0, start);
	
	        if (array) {
	          arrayPush(otherArgs, array);
	        }
	        return apply(func, this, otherArgs);
	      });
	    }
	
	    /**
	     * Creates a throttled function that only invokes `func` at most once per
	     * every `wait` milliseconds. The throttled function comes with a `cancel`
	     * method to cancel delayed `func` invocations and a `flush` method to
	     * immediately invoke them. Provide `options` to indicate whether `func`
	     * should be invoked on the leading and/or trailing edge of the `wait`
	     * timeout. The `func` is invoked with the last arguments provided to the
	     * throttled function. Subsequent calls to the throttled function return the
	     * result of the last `func` invocation.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is
	     * invoked on the trailing edge of the timeout only if the throttled function
	     * is invoked more than once during the `wait` timeout.
	     *
	     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	     *
	     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	     * for details over the differences between `_.throttle` and `_.debounce`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to throttle.
	     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
	     * @param {Object} [options={}] The options object.
	     * @param {boolean} [options.leading=true]
	     *  Specify invoking on the leading edge of the timeout.
	     * @param {boolean} [options.trailing=true]
	     *  Specify invoking on the trailing edge of the timeout.
	     * @returns {Function} Returns the new throttled function.
	     * @example
	     *
	     * // Avoid excessively updating the position while scrolling.
	     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
	     *
	     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
	     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
	     * jQuery(element).on('click', throttled);
	     *
	     * // Cancel the trailing throttled invocation.
	     * jQuery(window).on('popstate', throttled.cancel);
	     */
	    function throttle(func, wait, options) {
	      var leading = true,
	          trailing = true;
	
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      if (isObject(options)) {
	        leading = 'leading' in options ? !!options.leading : leading;
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	      }
	      return debounce(func, wait, {
	        'leading': leading,
	        'maxWait': wait,
	        'trailing': trailing
	      });
	    }
	
	    /**
	     * Creates a function that accepts up to one argument, ignoring any
	     * additional arguments.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Function
	     * @param {Function} func The function to cap arguments for.
	     * @returns {Function} Returns the new capped function.
	     * @example
	     *
	     * _.map(['6', '8', '10'], _.unary(parseInt));
	     * // => [6, 8, 10]
	     */
	    function unary(func) {
	      return ary(func, 1);
	    }
	
	    /**
	     * Creates a function that provides `value` to `wrapper` as its first
	     * argument. Any additional arguments provided to the function are appended
	     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
	     * binding of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {*} value The value to wrap.
	     * @param {Function} [wrapper=identity] The wrapper function.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var p = _.wrap(_.escape, function(func, text) {
	     *   return '<p>' + func(text) + '</p>';
	     * });
	     *
	     * p('fred, barney, & pebbles');
	     * // => '<p>fred, barney, &amp; pebbles</p>'
	     */
	    function wrap(value, wrapper) {
	      return partial(castFunction(wrapper), value);
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Casts `value` as an array if it's not one.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.4.0
	     * @category Lang
	     * @param {*} value The value to inspect.
	     * @returns {Array} Returns the cast array.
	     * @example
	     *
	     * _.castArray(1);
	     * // => [1]
	     *
	     * _.castArray({ 'a': 1 });
	     * // => [{ 'a': 1 }]
	     *
	     * _.castArray('abc');
	     * // => ['abc']
	     *
	     * _.castArray(null);
	     * // => [null]
	     *
	     * _.castArray(undefined);
	     * // => [undefined]
	     *
	     * _.castArray();
	     * // => []
	     *
	     * var array = [1, 2, 3];
	     * console.log(_.castArray(array) === array);
	     * // => true
	     */
	    function castArray() {
	      if (!arguments.length) {
	        return [];
	      }
	      var value = arguments[0];
	      return isArray(value) ? value : [value];
	    }
	
	    /**
	     * Creates a shallow clone of `value`.
	     *
	     * **Note:** This method is loosely based on the
	     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
	     * and supports cloning arrays, array buffers, booleans, date objects, maps,
	     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
	     * arrays. The own enumerable properties of `arguments` objects are cloned
	     * as plain objects. An empty object is returned for uncloneable values such
	     * as error objects, functions, DOM nodes, and WeakMaps.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to clone.
	     * @returns {*} Returns the cloned value.
	     * @see _.cloneDeep
	     * @example
	     *
	     * var objects = [{ 'a': 1 }, { 'b': 2 }];
	     *
	     * var shallow = _.clone(objects);
	     * console.log(shallow[0] === objects[0]);
	     * // => true
	     */
	    function clone(value) {
	      return baseClone(value, CLONE_SYMBOLS_FLAG);
	    }
	
	    /**
	     * This method is like `_.clone` except that it accepts `customizer` which
	     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
	     * cloning is handled by the method instead. The `customizer` is invoked with
	     * up to four arguments; (value [, index|key, object, stack]).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to clone.
	     * @param {Function} [customizer] The function to customize cloning.
	     * @returns {*} Returns the cloned value.
	     * @see _.cloneDeepWith
	     * @example
	     *
	     * function customizer(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(false);
	     *   }
	     * }
	     *
	     * var el = _.cloneWith(document.body, customizer);
	     *
	     * console.log(el === document.body);
	     * // => false
	     * console.log(el.nodeName);
	     * // => 'BODY'
	     * console.log(el.childNodes.length);
	     * // => 0
	     */
	    function cloneWith(value, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
	    }
	
	    /**
	     * This method is like `_.clone` except that it recursively clones `value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.0.0
	     * @category Lang
	     * @param {*} value The value to recursively clone.
	     * @returns {*} Returns the deep cloned value.
	     * @see _.clone
	     * @example
	     *
	     * var objects = [{ 'a': 1 }, { 'b': 2 }];
	     *
	     * var deep = _.cloneDeep(objects);
	     * console.log(deep[0] === objects[0]);
	     * // => false
	     */
	    function cloneDeep(value) {
	      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
	    }
	
	    /**
	     * This method is like `_.cloneWith` except that it recursively clones `value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to recursively clone.
	     * @param {Function} [customizer] The function to customize cloning.
	     * @returns {*} Returns the deep cloned value.
	     * @see _.cloneWith
	     * @example
	     *
	     * function customizer(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(true);
	     *   }
	     * }
	     *
	     * var el = _.cloneDeepWith(document.body, customizer);
	     *
	     * console.log(el === document.body);
	     * // => false
	     * console.log(el.nodeName);
	     * // => 'BODY'
	     * console.log(el.childNodes.length);
	     * // => 20
	     */
	    function cloneDeepWith(value, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
	    }
	
	    /**
	     * Checks if `object` conforms to `source` by invoking the predicate
	     * properties of `source` with the corresponding property values of `object`.
	     *
	     * **Note:** This method is equivalent to `_.conforms` when `source` is
	     * partially applied.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.14.0
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2 };
	     *
	     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
	     * // => true
	     *
	     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
	     * // => false
	     */
	    function conformsTo(object, source) {
	      return source == null || baseConformsTo(object, source, keys(source));
	    }
	
	    /**
	     * Performs a
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * comparison between two values to determine if they are equivalent.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1 };
	     * var other = { 'a': 1 };
	     *
	     * _.eq(object, object);
	     * // => true
	     *
	     * _.eq(object, other);
	     * // => false
	     *
	     * _.eq('a', 'a');
	     * // => true
	     *
	     * _.eq('a', Object('a'));
	     * // => false
	     *
	     * _.eq(NaN, NaN);
	     * // => true
	     */
	    function eq(value, other) {
	      return value === other || (value !== value && other !== other);
	    }
	
	    /**
	     * Checks if `value` is greater than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than `other`,
	     *  else `false`.
	     * @see _.lt
	     * @example
	     *
	     * _.gt(3, 1);
	     * // => true
	     *
	     * _.gt(3, 3);
	     * // => false
	     *
	     * _.gt(1, 3);
	     * // => false
	     */
	    var gt = createRelationalOperation(baseGt);
	
	    /**
	     * Checks if `value` is greater than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than or equal to
	     *  `other`, else `false`.
	     * @see _.lte
	     * @example
	     *
	     * _.gte(3, 1);
	     * // => true
	     *
	     * _.gte(3, 3);
	     * // => true
	     *
	     * _.gte(1, 3);
	     * // => false
	     */
	    var gte = createRelationalOperation(function(value, other) {
	      return value >= other;
	    });
	
	    /**
	     * Checks if `value` is likely an `arguments` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	     *  else `false`.
	     * @example
	     *
	     * _.isArguments(function() { return arguments; }());
	     * // => true
	     *
	     * _.isArguments([1, 2, 3]);
	     * // => false
	     */
	    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
	        !propertyIsEnumerable.call(value, 'callee');
	    };
	
	    /**
	     * Checks if `value` is classified as an `Array` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	     * @example
	     *
	     * _.isArray([1, 2, 3]);
	     * // => true
	     *
	     * _.isArray(document.body.children);
	     * // => false
	     *
	     * _.isArray('abc');
	     * // => false
	     *
	     * _.isArray(_.noop);
	     * // => false
	     */
	    var isArray = Array.isArray;
	
	    /**
	     * Checks if `value` is classified as an `ArrayBuffer` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
	     * @example
	     *
	     * _.isArrayBuffer(new ArrayBuffer(2));
	     * // => true
	     *
	     * _.isArrayBuffer(new Array(2));
	     * // => false
	     */
	    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
	
	    /**
	     * Checks if `value` is array-like. A value is considered array-like if it's
	     * not a function and has a `value.length` that's an integer greater than or
	     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	     * @example
	     *
	     * _.isArrayLike([1, 2, 3]);
	     * // => true
	     *
	     * _.isArrayLike(document.body.children);
	     * // => true
	     *
	     * _.isArrayLike('abc');
	     * // => true
	     *
	     * _.isArrayLike(_.noop);
	     * // => false
	     */
	    function isArrayLike(value) {
	      return value != null && isLength(value.length) && !isFunction(value);
	    }
	
	    /**
	     * This method is like `_.isArrayLike` except that it also checks if `value`
	     * is an object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array-like object,
	     *  else `false`.
	     * @example
	     *
	     * _.isArrayLikeObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isArrayLikeObject(document.body.children);
	     * // => true
	     *
	     * _.isArrayLikeObject('abc');
	     * // => false
	     *
	     * _.isArrayLikeObject(_.noop);
	     * // => false
	     */
	    function isArrayLikeObject(value) {
	      return isObjectLike(value) && isArrayLike(value);
	    }
	
	    /**
	     * Checks if `value` is classified as a boolean primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
	     * @example
	     *
	     * _.isBoolean(false);
	     * // => true
	     *
	     * _.isBoolean(null);
	     * // => false
	     */
	    function isBoolean(value) {
	      return value === true || value === false ||
	        (isObjectLike(value) && baseGetTag(value) == boolTag);
	    }
	
	    /**
	     * Checks if `value` is a buffer.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	     * @example
	     *
	     * _.isBuffer(new Buffer(2));
	     * // => true
	     *
	     * _.isBuffer(new Uint8Array(2));
	     * // => false
	     */
	    var isBuffer = nativeIsBuffer || stubFalse;
	
	    /**
	     * Checks if `value` is classified as a `Date` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
	     * @example
	     *
	     * _.isDate(new Date);
	     * // => true
	     *
	     * _.isDate('Mon April 23 2012');
	     * // => false
	     */
	    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
	
	    /**
	     * Checks if `value` is likely a DOM element.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
	     * @example
	     *
	     * _.isElement(document.body);
	     * // => true
	     *
	     * _.isElement('<body>');
	     * // => false
	     */
	    function isElement(value) {
	      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
	    }
	
	    /**
	     * Checks if `value` is an empty object, collection, map, or set.
	     *
	     * Objects are considered empty if they have no own enumerable string keyed
	     * properties.
	     *
	     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
	     * jQuery-like collections are considered empty if they have a `length` of `0`.
	     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
	     * @example
	     *
	     * _.isEmpty(null);
	     * // => true
	     *
	     * _.isEmpty(true);
	     * // => true
	     *
	     * _.isEmpty(1);
	     * // => true
	     *
	     * _.isEmpty([1, 2, 3]);
	     * // => false
	     *
	     * _.isEmpty({ 'a': 1 });
	     * // => false
	     */
	    function isEmpty(value) {
	      if (value == null) {
	        return true;
	      }
	      if (isArrayLike(value) &&
	          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
	            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
	        return !value.length;
	      }
	      var tag = getTag(value);
	      if (tag == mapTag || tag == setTag) {
	        return !value.size;
	      }
	      if (isPrototype(value)) {
	        return !baseKeys(value).length;
	      }
	      for (var key in value) {
	        if (hasOwnProperty.call(value, key)) {
	          return false;
	        }
	      }
	      return true;
	    }
	
	    /**
	     * Performs a deep comparison between two values to determine if they are
	     * equivalent.
	     *
	     * **Note:** This method supports comparing arrays, array buffers, booleans,
	     * date objects, error objects, maps, numbers, `Object` objects, regexes,
	     * sets, strings, symbols, and typed arrays. `Object` objects are compared
	     * by their own, not inherited, enumerable properties. Functions and DOM
	     * nodes are compared by strict equality, i.e. `===`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1 };
	     * var other = { 'a': 1 };
	     *
	     * _.isEqual(object, other);
	     * // => true
	     *
	     * object === other;
	     * // => false
	     */
	    function isEqual(value, other) {
	      return baseIsEqual(value, other);
	    }
	
	    /**
	     * This method is like `_.isEqual` except that it accepts `customizer` which
	     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
	     * are handled by the method instead. The `customizer` is invoked with up to
	     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * function isGreeting(value) {
	     *   return /^h(?:i|ello)$/.test(value);
	     * }
	     *
	     * function customizer(objValue, othValue) {
	     *   if (isGreeting(objValue) && isGreeting(othValue)) {
	     *     return true;
	     *   }
	     * }
	     *
	     * var array = ['hello', 'goodbye'];
	     * var other = ['hi', 'goodbye'];
	     *
	     * _.isEqualWith(array, other, customizer);
	     * // => true
	     */
	    function isEqualWith(value, other, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      var result = customizer ? customizer(value, other) : undefined;
	      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
	    }
	
	    /**
	     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
	     * `SyntaxError`, `TypeError`, or `URIError` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
	     * @example
	     *
	     * _.isError(new Error);
	     * // => true
	     *
	     * _.isError(Error);
	     * // => false
	     */
	    function isError(value) {
	      if (!isObjectLike(value)) {
	        return false;
	      }
	      var tag = baseGetTag(value);
	      return tag == errorTag || tag == domExcTag ||
	        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
	    }
	
	    /**
	     * Checks if `value` is a finite primitive number.
	     *
	     * **Note:** This method is based on
	     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
	     * @example
	     *
	     * _.isFinite(3);
	     * // => true
	     *
	     * _.isFinite(Number.MIN_VALUE);
	     * // => true
	     *
	     * _.isFinite(Infinity);
	     * // => false
	     *
	     * _.isFinite('3');
	     * // => false
	     */
	    function isFinite(value) {
	      return typeof value == 'number' && nativeIsFinite(value);
	    }
	
	    /**
	     * Checks if `value` is classified as a `Function` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	     * @example
	     *
	     * _.isFunction(_);
	     * // => true
	     *
	     * _.isFunction(/abc/);
	     * // => false
	     */
	    function isFunction(value) {
	      if (!isObject(value)) {
	        return false;
	      }
	      // The use of `Object#toString` avoids issues with the `typeof` operator
	      // in Safari 9 which returns 'object' for typed arrays and other constructors.
	      var tag = baseGetTag(value);
	      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	    }
	
	    /**
	     * Checks if `value` is an integer.
	     *
	     * **Note:** This method is based on
	     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
	     * @example
	     *
	     * _.isInteger(3);
	     * // => true
	     *
	     * _.isInteger(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isInteger(Infinity);
	     * // => false
	     *
	     * _.isInteger('3');
	     * // => false
	     */
	    function isInteger(value) {
	      return typeof value == 'number' && value == toInteger(value);
	    }
	
	    /**
	     * Checks if `value` is a valid array-like length.
	     *
	     * **Note:** This method is loosely based on
	     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	     * @example
	     *
	     * _.isLength(3);
	     * // => true
	     *
	     * _.isLength(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isLength(Infinity);
	     * // => false
	     *
	     * _.isLength('3');
	     * // => false
	     */
	    function isLength(value) {
	      return typeof value == 'number' &&
	        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	    }
	
	    /**
	     * Checks if `value` is the
	     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	     * @example
	     *
	     * _.isObject({});
	     * // => true
	     *
	     * _.isObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isObject(_.noop);
	     * // => true
	     *
	     * _.isObject(null);
	     * // => false
	     */
	    function isObject(value) {
	      var type = typeof value;
	      return value != null && (type == 'object' || type == 'function');
	    }
	
	    /**
	     * Checks if `value` is object-like. A value is object-like if it's not `null`
	     * and has a `typeof` result of "object".
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	     * @example
	     *
	     * _.isObjectLike({});
	     * // => true
	     *
	     * _.isObjectLike([1, 2, 3]);
	     * // => true
	     *
	     * _.isObjectLike(_.noop);
	     * // => false
	     *
	     * _.isObjectLike(null);
	     * // => false
	     */
	    function isObjectLike(value) {
	      return value != null && typeof value == 'object';
	    }
	
	    /**
	     * Checks if `value` is classified as a `Map` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	     * @example
	     *
	     * _.isMap(new Map);
	     * // => true
	     *
	     * _.isMap(new WeakMap);
	     * // => false
	     */
	    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
	
	    /**
	     * Performs a partial deep comparison between `object` and `source` to
	     * determine if `object` contains equivalent property values.
	     *
	     * **Note:** This method is equivalent to `_.matches` when `source` is
	     * partially applied.
	     *
	     * Partial comparisons will match empty array and empty object `source`
	     * values against any array or object value, respectively. See `_.isEqual`
	     * for a list of supported value comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2 };
	     *
	     * _.isMatch(object, { 'b': 2 });
	     * // => true
	     *
	     * _.isMatch(object, { 'b': 1 });
	     * // => false
	     */
	    function isMatch(object, source) {
	      return object === source || baseIsMatch(object, source, getMatchData(source));
	    }
	
	    /**
	     * This method is like `_.isMatch` except that it accepts `customizer` which
	     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
	     * are handled by the method instead. The `customizer` is invoked with five
	     * arguments: (objValue, srcValue, index|key, object, source).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     * @example
	     *
	     * function isGreeting(value) {
	     *   return /^h(?:i|ello)$/.test(value);
	     * }
	     *
	     * function customizer(objValue, srcValue) {
	     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
	     *     return true;
	     *   }
	     * }
	     *
	     * var object = { 'greeting': 'hello' };
	     * var source = { 'greeting': 'hi' };
	     *
	     * _.isMatchWith(object, source, customizer);
	     * // => true
	     */
	    function isMatchWith(object, source, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return baseIsMatch(object, source, getMatchData(source), customizer);
	    }
	
	    /**
	     * Checks if `value` is `NaN`.
	     *
	     * **Note:** This method is based on
	     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
	     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
	     * `undefined` and other non-number values.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	     * @example
	     *
	     * _.isNaN(NaN);
	     * // => true
	     *
	     * _.isNaN(new Number(NaN));
	     * // => true
	     *
	     * isNaN(undefined);
	     * // => true
	     *
	     * _.isNaN(undefined);
	     * // => false
	     */
	    function isNaN(value) {
	      // An `NaN` primitive is the only value that is not equal to itself.
	      // Perform the `toStringTag` check first to avoid errors with some
	      // ActiveX objects in IE.
	      return isNumber(value) && value != +value;
	    }
	
	    /**
	     * Checks if `value` is a pristine native function.
	     *
	     * **Note:** This method can't reliably detect native functions in the presence
	     * of the core-js package because core-js circumvents this kind of detection.
	     * Despite multiple requests, the core-js maintainer has made it clear: any
	     * attempt to fix the detection will be obstructed. As a result, we're left
	     * with little choice but to throw an error. Unfortunately, this also affects
	     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
	     * which rely on core-js.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a native function,
	     *  else `false`.
	     * @example
	     *
	     * _.isNative(Array.prototype.push);
	     * // => true
	     *
	     * _.isNative(_);
	     * // => false
	     */
	    function isNative(value) {
	      if (isMaskable(value)) {
	        throw new Error(CORE_ERROR_TEXT);
	      }
	      return baseIsNative(value);
	    }
	
	    /**
	     * Checks if `value` is `null`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
	     * @example
	     *
	     * _.isNull(null);
	     * // => true
	     *
	     * _.isNull(void 0);
	     * // => false
	     */
	    function isNull(value) {
	      return value === null;
	    }
	
	    /**
	     * Checks if `value` is `null` or `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
	     * @example
	     *
	     * _.isNil(null);
	     * // => true
	     *
	     * _.isNil(void 0);
	     * // => true
	     *
	     * _.isNil(NaN);
	     * // => false
	     */
	    function isNil(value) {
	      return value == null;
	    }
	
	    /**
	     * Checks if `value` is classified as a `Number` primitive or object.
	     *
	     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
	     * classified as numbers, use the `_.isFinite` method.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
	     * @example
	     *
	     * _.isNumber(3);
	     * // => true
	     *
	     * _.isNumber(Number.MIN_VALUE);
	     * // => true
	     *
	     * _.isNumber(Infinity);
	     * // => true
	     *
	     * _.isNumber('3');
	     * // => false
	     */
	    function isNumber(value) {
	      return typeof value == 'number' ||
	        (isObjectLike(value) && baseGetTag(value) == numberTag);
	    }
	
	    /**
	     * Checks if `value` is a plain object, that is, an object created by the
	     * `Object` constructor or one with a `[[Prototype]]` of `null`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.8.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * _.isPlainObject(new Foo);
	     * // => false
	     *
	     * _.isPlainObject([1, 2, 3]);
	     * // => false
	     *
	     * _.isPlainObject({ 'x': 0, 'y': 0 });
	     * // => true
	     *
	     * _.isPlainObject(Object.create(null));
	     * // => true
	     */
	    function isPlainObject(value) {
	      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
	        return false;
	      }
	      var proto = getPrototype(value);
	      if (proto === null) {
	        return true;
	      }
	      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	        funcToString.call(Ctor) == objectCtorString;
	    }
	
	    /**
	     * Checks if `value` is classified as a `RegExp` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
	     * @example
	     *
	     * _.isRegExp(/abc/);
	     * // => true
	     *
	     * _.isRegExp('/abc/');
	     * // => false
	     */
	    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
	
	    /**
	     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
	     * double precision number which isn't the result of a rounded unsafe integer.
	     *
	     * **Note:** This method is based on
	     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
	     * @example
	     *
	     * _.isSafeInteger(3);
	     * // => true
	     *
	     * _.isSafeInteger(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isSafeInteger(Infinity);
	     * // => false
	     *
	     * _.isSafeInteger('3');
	     * // => false
	     */
	    function isSafeInteger(value) {
	      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
	    }
	
	    /**
	     * Checks if `value` is classified as a `Set` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	     * @example
	     *
	     * _.isSet(new Set);
	     * // => true
	     *
	     * _.isSet(new WeakSet);
	     * // => false
	     */
	    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
	
	    /**
	     * Checks if `value` is classified as a `String` primitive or object.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
	     * @example
	     *
	     * _.isString('abc');
	     * // => true
	     *
	     * _.isString(1);
	     * // => false
	     */
	    function isString(value) {
	      return typeof value == 'string' ||
	        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
	    }
	
	    /**
	     * Checks if `value` is classified as a `Symbol` primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	     * @example
	     *
	     * _.isSymbol(Symbol.iterator);
	     * // => true
	     *
	     * _.isSymbol('abc');
	     * // => false
	     */
	    function isSymbol(value) {
	      return typeof value == 'symbol' ||
	        (isObjectLike(value) && baseGetTag(value) == symbolTag);
	    }
	
	    /**
	     * Checks if `value` is classified as a typed array.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	     * @example
	     *
	     * _.isTypedArray(new Uint8Array);
	     * // => true
	     *
	     * _.isTypedArray([]);
	     * // => false
	     */
	    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
	
	    /**
	     * Checks if `value` is `undefined`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
	     * @example
	     *
	     * _.isUndefined(void 0);
	     * // => true
	     *
	     * _.isUndefined(null);
	     * // => false
	     */
	    function isUndefined(value) {
	      return value === undefined;
	    }
	
	    /**
	     * Checks if `value` is classified as a `WeakMap` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
	     * @example
	     *
	     * _.isWeakMap(new WeakMap);
	     * // => true
	     *
	     * _.isWeakMap(new Map);
	     * // => false
	     */
	    function isWeakMap(value) {
	      return isObjectLike(value) && getTag(value) == weakMapTag;
	    }
	
	    /**
	     * Checks if `value` is classified as a `WeakSet` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
	     * @example
	     *
	     * _.isWeakSet(new WeakSet);
	     * // => true
	     *
	     * _.isWeakSet(new Set);
	     * // => false
	     */
	    function isWeakSet(value) {
	      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
	    }
	
	    /**
	     * Checks if `value` is less than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than `other`,
	     *  else `false`.
	     * @see _.gt
	     * @example
	     *
	     * _.lt(1, 3);
	     * // => true
	     *
	     * _.lt(3, 3);
	     * // => false
	     *
	     * _.lt(3, 1);
	     * // => false
	     */
	    var lt = createRelationalOperation(baseLt);
	
	    /**
	     * Checks if `value` is less than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than or equal to
	     *  `other`, else `false`.
	     * @see _.gte
	     * @example
	     *
	     * _.lte(1, 3);
	     * // => true
	     *
	     * _.lte(3, 3);
	     * // => true
	     *
	     * _.lte(3, 1);
	     * // => false
	     */
	    var lte = createRelationalOperation(function(value, other) {
	      return value <= other;
	    });
	
	    /**
	     * Converts `value` to an array.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Array} Returns the converted array.
	     * @example
	     *
	     * _.toArray({ 'a': 1, 'b': 2 });
	     * // => [1, 2]
	     *
	     * _.toArray('abc');
	     * // => ['a', 'b', 'c']
	     *
	     * _.toArray(1);
	     * // => []
	     *
	     * _.toArray(null);
	     * // => []
	     */
	    function toArray(value) {
	      if (!value) {
	        return [];
	      }
	      if (isArrayLike(value)) {
	        return isString(value) ? stringToArray(value) : copyArray(value);
	      }
	      if (symIterator && value[symIterator]) {
	        return iteratorToArray(value[symIterator]());
	      }
	      var tag = getTag(value),
	          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);
	
	      return func(value);
	    }
	
	    /**
	     * Converts `value` to a finite number.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.12.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted number.
	     * @example
	     *
	     * _.toFinite(3.2);
	     * // => 3.2
	     *
	     * _.toFinite(Number.MIN_VALUE);
	     * // => 5e-324
	     *
	     * _.toFinite(Infinity);
	     * // => 1.7976931348623157e+308
	     *
	     * _.toFinite('3.2');
	     * // => 3.2
	     */
	    function toFinite(value) {
	      if (!value) {
	        return value === 0 ? value : 0;
	      }
	      value = toNumber(value);
	      if (value === INFINITY || value === -INFINITY) {
	        var sign = (value < 0 ? -1 : 1);
	        return sign * MAX_INTEGER;
	      }
	      return value === value ? value : 0;
	    }
	
	    /**
	     * Converts `value` to an integer.
	     *
	     * **Note:** This method is loosely based on
	     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toInteger(3.2);
	     * // => 3
	     *
	     * _.toInteger(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toInteger(Infinity);
	     * // => 1.7976931348623157e+308
	     *
	     * _.toInteger('3.2');
	     * // => 3
	     */
	    function toInteger(value) {
	      var result = toFinite(value),
	          remainder = result % 1;
	
	      return result === result ? (remainder ? result - remainder : result) : 0;
	    }
	
	    /**
	     * Converts `value` to an integer suitable for use as the length of an
	     * array-like object.
	     *
	     * **Note:** This method is based on
	     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toLength(3.2);
	     * // => 3
	     *
	     * _.toLength(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toLength(Infinity);
	     * // => 4294967295
	     *
	     * _.toLength('3.2');
	     * // => 3
	     */
	    function toLength(value) {
	      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
	    }
	
	    /**
	     * Converts `value` to a number.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to process.
	     * @returns {number} Returns the number.
	     * @example
	     *
	     * _.toNumber(3.2);
	     * // => 3.2
	     *
	     * _.toNumber(Number.MIN_VALUE);
	     * // => 5e-324
	     *
	     * _.toNumber(Infinity);
	     * // => Infinity
	     *
	     * _.toNumber('3.2');
	     * // => 3.2
	     */
	    function toNumber(value) {
	      if (typeof value == 'number') {
	        return value;
	      }
	      if (isSymbol(value)) {
	        return NAN;
	      }
	      if (isObject(value)) {
	        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	        value = isObject(other) ? (other + '') : other;
	      }
	      if (typeof value != 'string') {
	        return value === 0 ? value : +value;
	      }
	      value = value.replace(reTrim, '');
	      var isBinary = reIsBinary.test(value);
	      return (isBinary || reIsOctal.test(value))
	        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	        : (reIsBadHex.test(value) ? NAN : +value);
	    }
	
	    /**
	     * Converts `value` to a plain object flattening inherited enumerable string
	     * keyed properties of `value` to own properties of the plain object.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Object} Returns the converted plain object.
	     * @example
	     *
	     * function Foo() {
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.assign({ 'a': 1 }, new Foo);
	     * // => { 'a': 1, 'b': 2 }
	     *
	     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	     * // => { 'a': 1, 'b': 2, 'c': 3 }
	     */
	    function toPlainObject(value) {
	      return copyObject(value, keysIn(value));
	    }
	
	    /**
	     * Converts `value` to a safe integer. A safe integer can be compared and
	     * represented correctly.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toSafeInteger(3.2);
	     * // => 3
	     *
	     * _.toSafeInteger(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toSafeInteger(Infinity);
	     * // => 9007199254740991
	     *
	     * _.toSafeInteger('3.2');
	     * // => 3
	     */
	    function toSafeInteger(value) {
	      return value
	        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
	        : (value === 0 ? value : 0);
	    }
	
	    /**
	     * Converts `value` to a string. An empty string is returned for `null`
	     * and `undefined` values. The sign of `-0` is preserved.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.toString(null);
	     * // => ''
	     *
	     * _.toString(-0);
	     * // => '-0'
	     *
	     * _.toString([1, 2, 3]);
	     * // => '1,2,3'
	     */
	    function toString(value) {
	      return value == null ? '' : baseToString(value);
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Assigns own enumerable string keyed properties of source objects to the
	     * destination object. Source objects are applied from left to right.
	     * Subsequent sources overwrite property assignments of previous sources.
	     *
	     * **Note:** This method mutates `object` and is loosely based on
	     * [`Object.assign`](https://mdn.io/Object/assign).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.10.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.assignIn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * function Bar() {
	     *   this.c = 3;
	     * }
	     *
	     * Foo.prototype.b = 2;
	     * Bar.prototype.d = 4;
	     *
	     * _.assign({ 'a': 0 }, new Foo, new Bar);
	     * // => { 'a': 1, 'c': 3 }
	     */
	    var assign = createAssigner(function(object, source) {
	      if (isPrototype(source) || isArrayLike(source)) {
	        copyObject(source, keys(source), object);
	        return;
	      }
	      for (var key in source) {
	        if (hasOwnProperty.call(source, key)) {
	          assignValue(object, key, source[key]);
	        }
	      }
	    });
	
	    /**
	     * This method is like `_.assign` except that it iterates over own and
	     * inherited source properties.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias extend
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.assign
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * function Bar() {
	     *   this.c = 3;
	     * }
	     *
	     * Foo.prototype.b = 2;
	     * Bar.prototype.d = 4;
	     *
	     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
	     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
	     */
	    var assignIn = createAssigner(function(object, source) {
	      copyObject(source, keysIn(source), object);
	    });
	
	    /**
	     * This method is like `_.assignIn` except that it accepts `customizer`
	     * which is invoked to produce the assigned values. If `customizer` returns
	     * `undefined`, assignment is handled by the method instead. The `customizer`
	     * is invoked with five arguments: (objValue, srcValue, key, object, source).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias extendWith
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @see _.assignWith
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   return _.isUndefined(objValue) ? srcValue : objValue;
	     * }
	     *
	     * var defaults = _.partialRight(_.assignInWith, customizer);
	     *
	     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */
	    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
	      copyObject(source, keysIn(source), object, customizer);
	    });
	
	    /**
	     * This method is like `_.assign` except that it accepts `customizer`
	     * which is invoked to produce the assigned values. If `customizer` returns
	     * `undefined`, assignment is handled by the method instead. The `customizer`
	     * is invoked with five arguments: (objValue, srcValue, key, object, source).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @see _.assignInWith
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   return _.isUndefined(objValue) ? srcValue : objValue;
	     * }
	     *
	     * var defaults = _.partialRight(_.assignWith, customizer);
	     *
	     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */
	    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
	      copyObject(source, keys(source), object, customizer);
	    });
	
	    /**
	     * Creates an array of values corresponding to `paths` of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.0.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {...(string|string[])} [paths] The property paths to pick.
	     * @returns {Array} Returns the picked values.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
	     *
	     * _.at(object, ['a[0].b.c', 'a[1]']);
	     * // => [3, 4]
	     */
	    var at = flatRest(baseAt);
	
	    /**
	     * Creates an object that inherits from the `prototype` object. If a
	     * `properties` object is given, its own enumerable string keyed properties
	     * are assigned to the created object.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.3.0
	     * @category Object
	     * @param {Object} prototype The object to inherit from.
	     * @param {Object} [properties] The properties to assign to the object.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * function Shape() {
	     *   this.x = 0;
	     *   this.y = 0;
	     * }
	     *
	     * function Circle() {
	     *   Shape.call(this);
	     * }
	     *
	     * Circle.prototype = _.create(Shape.prototype, {
	     *   'constructor': Circle
	     * });
	     *
	     * var circle = new Circle;
	     * circle instanceof Circle;
	     * // => true
	     *
	     * circle instanceof Shape;
	     * // => true
	     */
	    function create(prototype, properties) {
	      var result = baseCreate(prototype);
	      return properties == null ? result : baseAssign(result, properties);
	    }
	
	    /**
	     * Assigns own and inherited enumerable string keyed properties of source
	     * objects to the destination object for all destination properties that
	     * resolve to `undefined`. Source objects are applied from left to right.
	     * Once a property is set, additional values of the same property are ignored.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.defaultsDeep
	     * @example
	     *
	     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */
	    var defaults = baseRest(function(args) {
	      args.push(undefined, customDefaultsAssignIn);
	      return apply(assignInWith, undefined, args);
	    });
	
	    /**
	     * This method is like `_.defaults` except that it recursively assigns
	     * default properties.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.defaults
	     * @example
	     *
	     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
	     * // => { 'a': { 'b': 2, 'c': 3 } }
	     */
	    var defaultsDeep = baseRest(function(args) {
	      args.push(undefined, customDefaultsMerge);
	      return apply(mergeWith, undefined, args);
	    });
	
	    /**
	     * This method is like `_.find` except that it returns the key of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.1.0
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {string|undefined} Returns the key of the matched element,
	     *  else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findKey(users, function(o) { return o.age < 40; });
	     * // => 'barney' (iteration order is not guaranteed)
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findKey(users, { 'age': 1, 'active': true });
	     * // => 'pebbles'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findKey(users, ['active', false]);
	     * // => 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findKey(users, 'active');
	     * // => 'barney'
	     */
	    function findKey(object, predicate) {
	      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
	    }
	
	    /**
	     * This method is like `_.findKey` except that it iterates over elements of
	     * a collection in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {string|undefined} Returns the key of the matched element,
	     *  else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findLastKey(users, function(o) { return o.age < 40; });
	     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findLastKey(users, { 'age': 36, 'active': true });
	     * // => 'barney'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findLastKey(users, ['active', false]);
	     * // => 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findLastKey(users, 'active');
	     * // => 'pebbles'
	     */
	    function findLastKey(object, predicate) {
	      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
	    }
	
	    /**
	     * Iterates over own and inherited enumerable string keyed properties of an
	     * object and invokes `iteratee` for each property. The iteratee is invoked
	     * with three arguments: (value, key, object). Iteratee functions may exit
	     * iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.3.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forInRight
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forIn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
	     */
	    function forIn(object, iteratee) {
	      return object == null
	        ? object
	        : baseFor(object, getIteratee(iteratee, 3), keysIn);
	    }
	
	    /**
	     * This method is like `_.forIn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forIn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forInRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
	     */
	    function forInRight(object, iteratee) {
	      return object == null
	        ? object
	        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
	    }
	
	    /**
	     * Iterates over own enumerable string keyed properties of an object and
	     * invokes `iteratee` for each property. The iteratee is invoked with three
	     * arguments: (value, key, object). Iteratee functions may exit iteration
	     * early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.3.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forOwnRight
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
	     */
	    function forOwn(object, iteratee) {
	      return object && baseForOwn(object, getIteratee(iteratee, 3));
	    }
	
	    /**
	     * This method is like `_.forOwn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forOwn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwnRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
	     */
	    function forOwnRight(object, iteratee) {
	      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
	    }
	
	    /**
	     * Creates an array of function property names from own enumerable properties
	     * of `object`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the function names.
	     * @see _.functionsIn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = _.constant('a');
	     *   this.b = _.constant('b');
	     * }
	     *
	     * Foo.prototype.c = _.constant('c');
	     *
	     * _.functions(new Foo);
	     * // => ['a', 'b']
	     */
	    function functions(object) {
	      return object == null ? [] : baseFunctions(object, keys(object));
	    }
	
	    /**
	     * Creates an array of function property names from own and inherited
	     * enumerable properties of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the function names.
	     * @see _.functions
	     * @example
	     *
	     * function Foo() {
	     *   this.a = _.constant('a');
	     *   this.b = _.constant('b');
	     * }
	     *
	     * Foo.prototype.c = _.constant('c');
	     *
	     * _.functionsIn(new Foo);
	     * // => ['a', 'b', 'c']
	     */
	    function functionsIn(object) {
	      return object == null ? [] : baseFunctions(object, keysIn(object));
	    }
	
	    /**
	     * Gets the value at `path` of `object`. If the resolved value is
	     * `undefined`, the `defaultValue` is returned in its place.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.get(object, 'a[0].b.c');
	     * // => 3
	     *
	     * _.get(object, ['a', '0', 'b', 'c']);
	     * // => 3
	     *
	     * _.get(object, 'a.b.c', 'default');
	     * // => 'default'
	     */
	    function get(object, path, defaultValue) {
	      var result = object == null ? undefined : baseGet(object, path);
	      return result === undefined ? defaultValue : result;
	    }
	
	    /**
	     * Checks if `path` is a direct property of `object`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     * @example
	     *
	     * var object = { 'a': { 'b': 2 } };
	     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
	     *
	     * _.has(object, 'a');
	     * // => true
	     *
	     * _.has(object, 'a.b');
	     * // => true
	     *
	     * _.has(object, ['a', 'b']);
	     * // => true
	     *
	     * _.has(other, 'a');
	     * // => false
	     */
	    function has(object, path) {
	      return object != null && hasPath(object, path, baseHas);
	    }
	
	    /**
	     * Checks if `path` is a direct or inherited property of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     * @example
	     *
	     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	     *
	     * _.hasIn(object, 'a');
	     * // => true
	     *
	     * _.hasIn(object, 'a.b');
	     * // => true
	     *
	     * _.hasIn(object, ['a', 'b']);
	     * // => true
	     *
	     * _.hasIn(object, 'b');
	     * // => false
	     */
	    function hasIn(object, path) {
	      return object != null && hasPath(object, path, baseHasIn);
	    }
	
	    /**
	     * Creates an object composed of the inverted keys and values of `object`.
	     * If `object` contains duplicate values, subsequent values overwrite
	     * property assignments of previous values.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.7.0
	     * @category Object
	     * @param {Object} object The object to invert.
	     * @returns {Object} Returns the new inverted object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2, 'c': 1 };
	     *
	     * _.invert(object);
	     * // => { '1': 'c', '2': 'b' }
	     */
	    var invert = createInverter(function(result, value, key) {
	      result[value] = key;
	    }, constant(identity));
	
	    /**
	     * This method is like `_.invert` except that the inverted object is generated
	     * from the results of running each element of `object` thru `iteratee`. The
	     * corresponding inverted value of each inverted key is an array of keys
	     * responsible for generating the inverted value. The iteratee is invoked
	     * with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.1.0
	     * @category Object
	     * @param {Object} object The object to invert.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Object} Returns the new inverted object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2, 'c': 1 };
	     *
	     * _.invertBy(object);
	     * // => { '1': ['a', 'c'], '2': ['b'] }
	     *
	     * _.invertBy(object, function(value) {
	     *   return 'group' + value;
	     * });
	     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
	     */
	    var invertBy = createInverter(function(result, value, key) {
	      if (hasOwnProperty.call(result, value)) {
	        result[value].push(key);
	      } else {
	        result[value] = [key];
	      }
	    }, getIteratee);
	
	    /**
	     * Invokes the method at `path` of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {*} Returns the result of the invoked method.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
	     *
	     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
	     * // => [2, 3]
	     */
	    var invoke = baseRest(baseInvoke);
	
	    /**
	     * Creates an array of the own enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects. See the
	     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	     * for more details.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keys(new Foo);
	     * // => ['a', 'b'] (iteration order is not guaranteed)
	     *
	     * _.keys('hi');
	     * // => ['0', '1']
	     */
	    function keys(object) {
	      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	    }
	
	    /**
	     * Creates an array of the own and inherited enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keysIn(new Foo);
	     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	     */
	    function keysIn(object) {
	      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	    }
	
	    /**
	     * The opposite of `_.mapValues`; this method creates an object with the
	     * same values as `object` and keys generated by running each own enumerable
	     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
	     * with three arguments: (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.8.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns the new mapped object.
	     * @see _.mapValues
	     * @example
	     *
	     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
	     *   return key + value;
	     * });
	     * // => { 'a1': 1, 'b2': 2 }
	     */
	    function mapKeys(object, iteratee) {
	      var result = {};
	      iteratee = getIteratee(iteratee, 3);
	
	      baseForOwn(object, function(value, key, object) {
	        baseAssignValue(result, iteratee(value, key, object), value);
	      });
	      return result;
	    }
	
	    /**
	     * Creates an object with the same keys as `object` and values generated
	     * by running each own enumerable string keyed property of `object` thru
	     * `iteratee`. The iteratee is invoked with three arguments:
	     * (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns the new mapped object.
	     * @see _.mapKeys
	     * @example
	     *
	     * var users = {
	     *   'fred':    { 'user': 'fred',    'age': 40 },
	     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
	     * };
	     *
	     * _.mapValues(users, function(o) { return o.age; });
	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.mapValues(users, 'age');
	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	     */
	    function mapValues(object, iteratee) {
	      var result = {};
	      iteratee = getIteratee(iteratee, 3);
	
	      baseForOwn(object, function(value, key, object) {
	        baseAssignValue(result, key, iteratee(value, key, object));
	      });
	      return result;
	    }
	
	    /**
	     * This method is like `_.assign` except that it recursively merges own and
	     * inherited enumerable string keyed properties of source objects into the
	     * destination object. Source properties that resolve to `undefined` are
	     * skipped if a destination value exists. Array and plain object properties
	     * are merged recursively. Other objects and value types are overridden by
	     * assignment. Source objects are applied from left to right. Subsequent
	     * sources overwrite property assignments of previous sources.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.5.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = {
	     *   'a': [{ 'b': 2 }, { 'd': 4 }]
	     * };
	     *
	     * var other = {
	     *   'a': [{ 'c': 3 }, { 'e': 5 }]
	     * };
	     *
	     * _.merge(object, other);
	     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
	     */
	    var merge = createAssigner(function(object, source, srcIndex) {
	      baseMerge(object, source, srcIndex);
	    });
	
	    /**
	     * This method is like `_.merge` except that it accepts `customizer` which
	     * is invoked to produce the merged values of the destination and source
	     * properties. If `customizer` returns `undefined`, merging is handled by the
	     * method instead. The `customizer` is invoked with six arguments:
	     * (objValue, srcValue, key, object, source, stack).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} customizer The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   if (_.isArray(objValue)) {
	     *     return objValue.concat(srcValue);
	     *   }
	     * }
	     *
	     * var object = { 'a': [1], 'b': [2] };
	     * var other = { 'a': [3], 'b': [4] };
	     *
	     * _.mergeWith(object, other, customizer);
	     * // => { 'a': [1, 3], 'b': [2, 4] }
	     */
	    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
	      baseMerge(object, source, srcIndex, customizer);
	    });
	
	    /**
	     * The opposite of `_.pick`; this method creates an object composed of the
	     * own and inherited enumerable property paths of `object` that are not omitted.
	     *
	     * **Note:** This method is considerably slower than `_.pick`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {...(string|string[])} [paths] The property paths to omit.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.omit(object, ['a', 'c']);
	     * // => { 'b': '2' }
	     */
	    var omit = flatRest(function(object, paths) {
	      var result = {};
	      if (object == null) {
	        return result;
	      }
	      var isDeep = false;
	      paths = arrayMap(paths, function(path) {
	        path = castPath(path, object);
	        isDeep || (isDeep = path.length > 1);
	        return path;
	      });
	      copyObject(object, getAllKeysIn(object), result);
	      if (isDeep) {
	        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
	      }
	      var length = paths.length;
	      while (length--) {
	        baseUnset(result, paths[length]);
	      }
	      return result;
	    });
	
	    /**
	     * The opposite of `_.pickBy`; this method creates an object composed of
	     * the own and inherited enumerable string keyed properties of `object` that
	     * `predicate` doesn't return truthy for. The predicate is invoked with two
	     * arguments: (value, key).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function} [predicate=_.identity] The function invoked per property.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.omitBy(object, _.isNumber);
	     * // => { 'b': '2' }
	     */
	    function omitBy(object, predicate) {
	      return pickBy(object, negate(getIteratee(predicate)));
	    }
	
	    /**
	     * Creates an object composed of the picked `object` properties.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {...(string|string[])} [paths] The property paths to pick.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.pick(object, ['a', 'c']);
	     * // => { 'a': 1, 'c': 3 }
	     */
	    var pick = flatRest(function(object, paths) {
	      return object == null ? {} : basePick(object, paths);
	    });
	
	    /**
	     * Creates an object composed of the `object` properties `predicate` returns
	     * truthy for. The predicate is invoked with two arguments: (value, key).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function} [predicate=_.identity] The function invoked per property.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.pickBy(object, _.isNumber);
	     * // => { 'a': 1, 'c': 3 }
	     */
	    function pickBy(object, predicate) {
	      if (object == null) {
	        return {};
	      }
	      var props = arrayMap(getAllKeysIn(object), function(prop) {
	        return [prop];
	      });
	      predicate = getIteratee(predicate);
	      return basePickBy(object, props, function(value, path) {
	        return predicate(value, path[0]);
	      });
	    }
	
	    /**
	     * This method is like `_.get` except that if the resolved value is a
	     * function it's invoked with the `this` binding of its parent object and
	     * its result is returned.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to resolve.
	     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
	     *
	     * _.result(object, 'a[0].b.c1');
	     * // => 3
	     *
	     * _.result(object, 'a[0].b.c2');
	     * // => 4
	     *
	     * _.result(object, 'a[0].b.c3', 'default');
	     * // => 'default'
	     *
	     * _.result(object, 'a[0].b.c3', _.constant('default'));
	     * // => 'default'
	     */
	    function result(object, path, defaultValue) {
	      path = castPath(path, object);
	
	      var index = -1,
	          length = path.length;
	
	      // Ensure the loop is entered when path is empty.
	      if (!length) {
	        length = 1;
	        object = undefined;
	      }
	      while (++index < length) {
	        var value = object == null ? undefined : object[toKey(path[index])];
	        if (value === undefined) {
	          index = length;
	          value = defaultValue;
	        }
	        object = isFunction(value) ? value.call(object) : value;
	      }
	      return object;
	    }
	
	    /**
	     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
	     * it's created. Arrays are created for missing index properties while objects
	     * are created for all other missing properties. Use `_.setWith` to customize
	     * `path` creation.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.set(object, 'a[0].b.c', 4);
	     * console.log(object.a[0].b.c);
	     * // => 4
	     *
	     * _.set(object, ['x', '0', 'y', 'z'], 5);
	     * console.log(object.x[0].y.z);
	     * // => 5
	     */
	    function set(object, path, value) {
	      return object == null ? object : baseSet(object, path, value);
	    }
	
	    /**
	     * This method is like `_.set` except that it accepts `customizer` which is
	     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
	     * path creation is handled by the method instead. The `customizer` is invoked
	     * with three arguments: (nsValue, key, nsObject).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = {};
	     *
	     * _.setWith(object, '[0][1]', 'a', Object);
	     * // => { '0': { '1': 'a' } }
	     */
	    function setWith(object, path, value, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return object == null ? object : baseSet(object, path, value, customizer);
	    }
	
	    /**
	     * Creates an array of own enumerable string keyed-value pairs for `object`
	     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
	     * entries are returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias entries
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the key-value pairs.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.toPairs(new Foo);
	     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
	     */
	    var toPairs = createToPairs(keys);
	
	    /**
	     * Creates an array of own and inherited enumerable string keyed-value pairs
	     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
	     * or set, its entries are returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias entriesIn
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the key-value pairs.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.toPairsIn(new Foo);
	     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
	     */
	    var toPairsIn = createToPairs(keysIn);
	
	    /**
	     * An alternative to `_.reduce`; this method transforms `object` to a new
	     * `accumulator` object which is the result of running each of its own
	     * enumerable string keyed properties thru `iteratee`, with each invocation
	     * potentially mutating the `accumulator` object. If `accumulator` is not
	     * provided, a new object with the same `[[Prototype]]` will be used. The
	     * iteratee is invoked with four arguments: (accumulator, value, key, object).
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.3.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The custom accumulator value.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * _.transform([2, 3, 4], function(result, n) {
	     *   result.push(n *= n);
	     *   return n % 2 == 0;
	     * }, []);
	     * // => [4, 9]
	     *
	     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
	     *   (result[value] || (result[value] = [])).push(key);
	     * }, {});
	     * // => { '1': ['a', 'c'], '2': ['b'] }
	     */
	    function transform(object, iteratee, accumulator) {
	      var isArr = isArray(object),
	          isArrLike = isArr || isBuffer(object) || isTypedArray(object);
	
	      iteratee = getIteratee(iteratee, 4);
	      if (accumulator == null) {
	        var Ctor = object && object.constructor;
	        if (isArrLike) {
	          accumulator = isArr ? new Ctor : [];
	        }
	        else if (isObject(object)) {
	          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
	        }
	        else {
	          accumulator = {};
	        }
	      }
	      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
	        return iteratee(accumulator, value, index, object);
	      });
	      return accumulator;
	    }
	
	    /**
	     * Removes the property at `path` of `object`.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to unset.
	     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
	     * _.unset(object, 'a[0].b.c');
	     * // => true
	     *
	     * console.log(object);
	     * // => { 'a': [{ 'b': {} }] };
	     *
	     * _.unset(object, ['a', '0', 'b', 'c']);
	     * // => true
	     *
	     * console.log(object);
	     * // => { 'a': [{ 'b': {} }] };
	     */
	    function unset(object, path) {
	      return object == null ? true : baseUnset(object, path);
	    }
	
	    /**
	     * This method is like `_.set` except that accepts `updater` to produce the
	     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
	     * is invoked with one argument: (value).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.6.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {Function} updater The function to produce the updated value.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
	     * console.log(object.a[0].b.c);
	     * // => 9
	     *
	     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
	     * console.log(object.x[0].y.z);
	     * // => 0
	     */
	    function update(object, path, updater) {
	      return object == null ? object : baseUpdate(object, path, castFunction(updater));
	    }
	
	    /**
	     * This method is like `_.update` except that it accepts `customizer` which is
	     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
	     * path creation is handled by the method instead. The `customizer` is invoked
	     * with three arguments: (nsValue, key, nsObject).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.6.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {Function} updater The function to produce the updated value.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = {};
	     *
	     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
	     * // => { '0': { '1': 'a' } }
	     */
	    function updateWith(object, path, updater, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
	    }
	
	    /**
	     * Creates an array of the own enumerable string keyed property values of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.values(new Foo);
	     * // => [1, 2] (iteration order is not guaranteed)
	     *
	     * _.values('hi');
	     * // => ['h', 'i']
	     */
	    function values(object) {
	      return object == null ? [] : baseValues(object, keys(object));
	    }
	
	    /**
	     * Creates an array of the own and inherited enumerable string keyed property
	     * values of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.valuesIn(new Foo);
	     * // => [1, 2, 3] (iteration order is not guaranteed)
	     */
	    function valuesIn(object) {
	      return object == null ? [] : baseValues(object, keysIn(object));
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Clamps `number` within the inclusive `lower` and `upper` bounds.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Number
	     * @param {number} number The number to clamp.
	     * @param {number} [lower] The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the clamped number.
	     * @example
	     *
	     * _.clamp(-10, -5, 5);
	     * // => -5
	     *
	     * _.clamp(10, -5, 5);
	     * // => 5
	     */
	    function clamp(number, lower, upper) {
	      if (upper === undefined) {
	        upper = lower;
	        lower = undefined;
	      }
	      if (upper !== undefined) {
	        upper = toNumber(upper);
	        upper = upper === upper ? upper : 0;
	      }
	      if (lower !== undefined) {
	        lower = toNumber(lower);
	        lower = lower === lower ? lower : 0;
	      }
	      return baseClamp(toNumber(number), lower, upper);
	    }
	
	    /**
	     * Checks if `n` is between `start` and up to, but not including, `end`. If
	     * `end` is not specified, it's set to `start` with `start` then set to `0`.
	     * If `start` is greater than `end` the params are swapped to support
	     * negative ranges.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.3.0
	     * @category Number
	     * @param {number} number The number to check.
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
	     * @see _.range, _.rangeRight
	     * @example
	     *
	     * _.inRange(3, 2, 4);
	     * // => true
	     *
	     * _.inRange(4, 8);
	     * // => true
	     *
	     * _.inRange(4, 2);
	     * // => false
	     *
	     * _.inRange(2, 2);
	     * // => false
	     *
	     * _.inRange(1.2, 2);
	     * // => true
	     *
	     * _.inRange(5.2, 4);
	     * // => false
	     *
	     * _.inRange(-3, -2, -6);
	     * // => true
	     */
	    function inRange(number, start, end) {
	      start = toFinite(start);
	      if (end === undefined) {
	        end = start;
	        start = 0;
	      } else {
	        end = toFinite(end);
	      }
	      number = toNumber(number);
	      return baseInRange(number, start, end);
	    }
	
	    /**
	     * Produces a random number between the inclusive `lower` and `upper` bounds.
	     * If only one argument is provided a number between `0` and the given number
	     * is returned. If `floating` is `true`, or either `lower` or `upper` are
	     * floats, a floating-point number is returned instead of an integer.
	     *
	     * **Note:** JavaScript follows the IEEE-754 standard for resolving
	     * floating-point values which can produce unexpected results.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.7.0
	     * @category Number
	     * @param {number} [lower=0] The lower bound.
	     * @param {number} [upper=1] The upper bound.
	     * @param {boolean} [floating] Specify returning a floating-point number.
	     * @returns {number} Returns the random number.
	     * @example
	     *
	     * _.random(0, 5);
	     * // => an integer between 0 and 5
	     *
	     * _.random(5);
	     * // => also an integer between 0 and 5
	     *
	     * _.random(5, true);
	     * // => a floating-point number between 0 and 5
	     *
	     * _.random(1.2, 5.2);
	     * // => a floating-point number between 1.2 and 5.2
	     */
	    function random(lower, upper, floating) {
	      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
	        upper = floating = undefined;
	      }
	      if (floating === undefined) {
	        if (typeof upper == 'boolean') {
	          floating = upper;
	          upper = undefined;
	        }
	        else if (typeof lower == 'boolean') {
	          floating = lower;
	          lower = undefined;
	        }
	      }
	      if (lower === undefined && upper === undefined) {
	        lower = 0;
	        upper = 1;
	      }
	      else {
	        lower = toFinite(lower);
	        if (upper === undefined) {
	          upper = lower;
	          lower = 0;
	        } else {
	          upper = toFinite(upper);
	        }
	      }
	      if (lower > upper) {
	        var temp = lower;
	        lower = upper;
	        upper = temp;
	      }
	      if (floating || lower % 1 || upper % 1) {
	        var rand = nativeRandom();
	        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
	      }
	      return baseRandom(lower, upper);
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the camel cased string.
	     * @example
	     *
	     * _.camelCase('Foo Bar');
	     * // => 'fooBar'
	     *
	     * _.camelCase('--foo-bar--');
	     * // => 'fooBar'
	     *
	     * _.camelCase('__FOO_BAR__');
	     * // => 'fooBar'
	     */
	    var camelCase = createCompounder(function(result, word, index) {
	      word = word.toLowerCase();
	      return result + (index ? capitalize(word) : word);
	    });
	
	    /**
	     * Converts the first character of `string` to upper case and the remaining
	     * to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to capitalize.
	     * @returns {string} Returns the capitalized string.
	     * @example
	     *
	     * _.capitalize('FRED');
	     * // => 'Fred'
	     */
	    function capitalize(string) {
	      return upperFirst(toString(string).toLowerCase());
	    }
	
	    /**
	     * Deburrs `string` by converting
	     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
	     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
	     * letters to basic Latin letters and removing
	     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to deburr.
	     * @returns {string} Returns the deburred string.
	     * @example
	     *
	     * _.deburr('déjà vu');
	     * // => 'deja vu'
	     */
	    function deburr(string) {
	      string = toString(string);
	      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
	    }
	
	    /**
	     * Checks if `string` ends with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=string.length] The position to search up to.
	     * @returns {boolean} Returns `true` if `string` ends with `target`,
	     *  else `false`.
	     * @example
	     *
	     * _.endsWith('abc', 'c');
	     * // => true
	     *
	     * _.endsWith('abc', 'b');
	     * // => false
	     *
	     * _.endsWith('abc', 'b', 2);
	     * // => true
	     */
	    function endsWith(string, target, position) {
	      string = toString(string);
	      target = baseToString(target);
	
	      var length = string.length;
	      position = position === undefined
	        ? length
	        : baseClamp(toInteger(position), 0, length);
	
	      var end = position;
	      position -= target.length;
	      return position >= 0 && string.slice(position, end) == target;
	    }
	
	    /**
	     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
	     * corresponding HTML entities.
	     *
	     * **Note:** No other characters are escaped. To escape additional
	     * characters use a third-party library like [_he_](https://mths.be/he).
	     *
	     * Though the ">" character is escaped for symmetry, characters like
	     * ">" and "/" don't need escaping in HTML and have no special meaning
	     * unless they're part of a tag or unquoted attribute value. See
	     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
	     * (under "semi-related fun fact") for more details.
	     *
	     * When working with HTML you should always
	     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
	     * XSS vectors.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escape('fred, barney, & pebbles');
	     * // => 'fred, barney, &amp; pebbles'
	     */
	    function escape(string) {
	      string = toString(string);
	      return (string && reHasUnescapedHtml.test(string))
	        ? string.replace(reUnescapedHtml, escapeHtmlChar)
	        : string;
	    }
	
	    /**
	     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
	     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escapeRegExp('[lodash](https://lodash.com/)');
	     * // => '\[lodash\]\(https://lodash\.com/\)'
	     */
	    function escapeRegExp(string) {
	      string = toString(string);
	      return (string && reHasRegExpChar.test(string))
	        ? string.replace(reRegExpChar, '\\$&')
	        : string;
	    }
	
	    /**
	     * Converts `string` to
	     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the kebab cased string.
	     * @example
	     *
	     * _.kebabCase('Foo Bar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('fooBar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('__FOO_BAR__');
	     * // => 'foo-bar'
	     */
	    var kebabCase = createCompounder(function(result, word, index) {
	      return result + (index ? '-' : '') + word.toLowerCase();
	    });
	
	    /**
	     * Converts `string`, as space separated words, to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the lower cased string.
	     * @example
	     *
	     * _.lowerCase('--Foo-Bar--');
	     * // => 'foo bar'
	     *
	     * _.lowerCase('fooBar');
	     * // => 'foo bar'
	     *
	     * _.lowerCase('__FOO_BAR__');
	     * // => 'foo bar'
	     */
	    var lowerCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + word.toLowerCase();
	    });
	
	    /**
	     * Converts the first character of `string` to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.lowerFirst('Fred');
	     * // => 'fred'
	     *
	     * _.lowerFirst('FRED');
	     * // => 'fRED'
	     */
	    var lowerFirst = createCaseFirst('toLowerCase');
	
	    /**
	     * Pads `string` on the left and right sides if it's shorter than `length`.
	     * Padding characters are truncated if they can't be evenly divided by `length`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.pad('abc', 8);
	     * // => '  abc   '
	     *
	     * _.pad('abc', 8, '_-');
	     * // => '_-abc_-_'
	     *
	     * _.pad('abc', 3);
	     * // => 'abc'
	     */
	    function pad(string, length, chars) {
	      string = toString(string);
	      length = toInteger(length);
	
	      var strLength = length ? stringSize(string) : 0;
	      if (!length || strLength >= length) {
	        return string;
	      }
	      var mid = (length - strLength) / 2;
	      return (
	        createPadding(nativeFloor(mid), chars) +
	        string +
	        createPadding(nativeCeil(mid), chars)
	      );
	    }
	
	    /**
	     * Pads `string` on the right side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padEnd('abc', 6);
	     * // => 'abc   '
	     *
	     * _.padEnd('abc', 6, '_-');
	     * // => 'abc_-_'
	     *
	     * _.padEnd('abc', 3);
	     * // => 'abc'
	     */
	    function padEnd(string, length, chars) {
	      string = toString(string);
	      length = toInteger(length);
	
	      var strLength = length ? stringSize(string) : 0;
	      return (length && strLength < length)
	        ? (string + createPadding(length - strLength, chars))
	        : string;
	    }
	
	    /**
	     * Pads `string` on the left side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padStart('abc', 6);
	     * // => '   abc'
	     *
	     * _.padStart('abc', 6, '_-');
	     * // => '_-_abc'
	     *
	     * _.padStart('abc', 3);
	     * // => 'abc'
	     */
	    function padStart(string, length, chars) {
	      string = toString(string);
	      length = toInteger(length);
	
	      var strLength = length ? stringSize(string) : 0;
	      return (length && strLength < length)
	        ? (createPadding(length - strLength, chars) + string)
	        : string;
	    }
	
	    /**
	     * Converts `string` to an integer of the specified radix. If `radix` is
	     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
	     * hexadecimal, in which case a `radix` of `16` is used.
	     *
	     * **Note:** This method aligns with the
	     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.1.0
	     * @category String
	     * @param {string} string The string to convert.
	     * @param {number} [radix=10] The radix to interpret `value` by.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.parseInt('08');
	     * // => 8
	     *
	     * _.map(['6', '08', '10'], _.parseInt);
	     * // => [6, 8, 10]
	     */
	    function parseInt(string, radix, guard) {
	      if (guard || radix == null) {
	        radix = 0;
	      } else if (radix) {
	        radix = +radix;
	      }
	      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
	    }
	
	    /**
	     * Repeats the given string `n` times.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to repeat.
	     * @param {number} [n=1] The number of times to repeat the string.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the repeated string.
	     * @example
	     *
	     * _.repeat('*', 3);
	     * // => '***'
	     *
	     * _.repeat('abc', 2);
	     * // => 'abcabc'
	     *
	     * _.repeat('abc', 0);
	     * // => ''
	     */
	    function repeat(string, n, guard) {
	      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
	        n = 1;
	      } else {
	        n = toInteger(n);
	      }
	      return baseRepeat(toString(string), n);
	    }
	
	    /**
	     * Replaces matches for `pattern` in `string` with `replacement`.
	     *
	     * **Note:** This method is based on
	     * [`String#replace`](https://mdn.io/String/replace).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to modify.
	     * @param {RegExp|string} pattern The pattern to replace.
	     * @param {Function|string} replacement The match replacement.
	     * @returns {string} Returns the modified string.
	     * @example
	     *
	     * _.replace('Hi Fred', 'Fred', 'Barney');
	     * // => 'Hi Barney'
	     */
	    function replace() {
	      var args = arguments,
	          string = toString(args[0]);
	
	      return args.length < 3 ? string : string.replace(args[1], args[2]);
	    }
	
	    /**
	     * Converts `string` to
	     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the snake cased string.
	     * @example
	     *
	     * _.snakeCase('Foo Bar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('fooBar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('--FOO-BAR--');
	     * // => 'foo_bar'
	     */
	    var snakeCase = createCompounder(function(result, word, index) {
	      return result + (index ? '_' : '') + word.toLowerCase();
	    });
	
	    /**
	     * Splits `string` by `separator`.
	     *
	     * **Note:** This method is based on
	     * [`String#split`](https://mdn.io/String/split).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to split.
	     * @param {RegExp|string} separator The separator pattern to split by.
	     * @param {number} [limit] The length to truncate results to.
	     * @returns {Array} Returns the string segments.
	     * @example
	     *
	     * _.split('a-b-c', '-', 2);
	     * // => ['a', 'b']
	     */
	    function split(string, separator, limit) {
	      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
	        separator = limit = undefined;
	      }
	      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
	      if (!limit) {
	        return [];
	      }
	      string = toString(string);
	      if (string && (
	            typeof separator == 'string' ||
	            (separator != null && !isRegExp(separator))
	          )) {
	        separator = baseToString(separator);
	        if (!separator && hasUnicode(string)) {
	          return castSlice(stringToArray(string), 0, limit);
	        }
	      }
	      return string.split(separator, limit);
	    }
	
	    /**
	     * Converts `string` to
	     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.1.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the start cased string.
	     * @example
	     *
	     * _.startCase('--foo-bar--');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('fooBar');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('__FOO_BAR__');
	     * // => 'FOO BAR'
	     */
	    var startCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + upperFirst(word);
	    });
	
	    /**
	     * Checks if `string` starts with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=0] The position to search from.
	     * @returns {boolean} Returns `true` if `string` starts with `target`,
	     *  else `false`.
	     * @example
	     *
	     * _.startsWith('abc', 'a');
	     * // => true
	     *
	     * _.startsWith('abc', 'b');
	     * // => false
	     *
	     * _.startsWith('abc', 'b', 1);
	     * // => true
	     */
	    function startsWith(string, target, position) {
	      string = toString(string);
	      position = position == null
	        ? 0
	        : baseClamp(toInteger(position), 0, string.length);
	
	      target = baseToString(target);
	      return string.slice(position, position + target.length) == target;
	    }
	
	    /**
	     * Creates a compiled template function that can interpolate data properties
	     * in "interpolate" delimiters, HTML-escape interpolated data properties in
	     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
	     * properties may be accessed as free variables in the template. If a setting
	     * object is given, it takes precedence over `_.templateSettings` values.
	     *
	     * **Note:** In the development build `_.template` utilizes
	     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
	     * for easier debugging.
	     *
	     * For more information on precompiling templates see
	     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
	     *
	     * For more information on Chrome extension sandboxes see
	     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The template string.
	     * @param {Object} [options={}] The options object.
	     * @param {RegExp} [options.escape=_.templateSettings.escape]
	     *  The HTML "escape" delimiter.
	     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
	     *  The "evaluate" delimiter.
	     * @param {Object} [options.imports=_.templateSettings.imports]
	     *  An object to import into the template as free variables.
	     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
	     *  The "interpolate" delimiter.
	     * @param {string} [options.sourceURL='lodash.templateSources[n]']
	     *  The sourceURL of the compiled template.
	     * @param {string} [options.variable='obj']
	     *  The data object variable name.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the compiled template function.
	     * @example
	     *
	     * // Use the "interpolate" delimiter to create a compiled template.
	     * var compiled = _.template('hello <%= user %>!');
	     * compiled({ 'user': 'fred' });
	     * // => 'hello fred!'
	     *
	     * // Use the HTML "escape" delimiter to escape data property values.
	     * var compiled = _.template('<b><%- value %></b>');
	     * compiled({ 'value': '<script>' });
	     * // => '<b>&lt;script&gt;</b>'
	     *
	     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
	     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // Use the internal `print` function in "evaluate" delimiters.
	     * var compiled = _.template('<% print("hello " + user); %>!');
	     * compiled({ 'user': 'barney' });
	     * // => 'hello barney!'
	     *
	     * // Use the ES template literal delimiter as an "interpolate" delimiter.
	     * // Disable support by replacing the "interpolate" delimiter.
	     * var compiled = _.template('hello ${ user }!');
	     * compiled({ 'user': 'pebbles' });
	     * // => 'hello pebbles!'
	     *
	     * // Use backslashes to treat delimiters as plain text.
	     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
	     * compiled({ 'value': 'ignored' });
	     * // => '<%- value %>'
	     *
	     * // Use the `imports` option to import `jQuery` as `jq`.
	     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
	     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
	     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
	     * compiled(data);
	     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
	     *
	     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
	     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
	     * compiled.source;
	     * // => function(data) {
	     * //   var __t, __p = '';
	     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
	     * //   return __p;
	     * // }
	     *
	     * // Use custom template delimiters.
	     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
	     * var compiled = _.template('hello {{ user }}!');
	     * compiled({ 'user': 'mustache' });
	     * // => 'hello mustache!'
	     *
	     * // Use the `source` property to inline compiled templates for meaningful
	     * // line numbers in error messages and stack traces.
	     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
	     *   var JST = {\
	     *     "main": ' + _.template(mainText).source + '\
	     *   };\
	     * ');
	     */
	    function template(string, options, guard) {
	      // Based on John Resig's `tmpl` implementation
	      // (http://ejohn.org/blog/javascript-micro-templating/)
	      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
	      var settings = lodash.templateSettings;
	
	      if (guard && isIterateeCall(string, options, guard)) {
	        options = undefined;
	      }
	      string = toString(string);
	      options = assignInWith({}, options, settings, customDefaultsAssignIn);
	
	      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
	          importsKeys = keys(imports),
	          importsValues = baseValues(imports, importsKeys);
	
	      var isEscaping,
	          isEvaluating,
	          index = 0,
	          interpolate = options.interpolate || reNoMatch,
	          source = "__p += '";
	
	      // Compile the regexp to match each delimiter.
	      var reDelimiters = RegExp(
	        (options.escape || reNoMatch).source + '|' +
	        interpolate.source + '|' +
	        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
	        (options.evaluate || reNoMatch).source + '|$'
	      , 'g');
	
	      // Use a sourceURL for easier debugging.
	      var sourceURL = '//# sourceURL=' +
	        ('sourceURL' in options
	          ? options.sourceURL
	          : ('lodash.templateSources[' + (++templateCounter) + ']')
	        ) + '\n';
	
	      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
	        interpolateValue || (interpolateValue = esTemplateValue);
	
	        // Escape characters that can't be included in string literals.
	        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
	
	        // Replace delimiters with snippets.
	        if (escapeValue) {
	          isEscaping = true;
	          source += "' +\n__e(" + escapeValue + ") +\n'";
	        }
	        if (evaluateValue) {
	          isEvaluating = true;
	          source += "';\n" + evaluateValue + ";\n__p += '";
	        }
	        if (interpolateValue) {
	          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
	        }
	        index = offset + match.length;
	
	        // The JS engine embedded in Adobe products needs `match` returned in
	        // order to produce the correct `offset` value.
	        return match;
	      });
	
	      source += "';\n";
	
	      // If `variable` is not specified wrap a with-statement around the generated
	      // code to add the data object to the top of the scope chain.
	      var variable = options.variable;
	      if (!variable) {
	        source = 'with (obj) {\n' + source + '\n}\n';
	      }
	      // Cleanup code by stripping empty strings.
	      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
	        .replace(reEmptyStringMiddle, '$1')
	        .replace(reEmptyStringTrailing, '$1;');
	
	      // Frame code as the function body.
	      source = 'function(' + (variable || 'obj') + ') {\n' +
	        (variable
	          ? ''
	          : 'obj || (obj = {});\n'
	        ) +
	        "var __t, __p = ''" +
	        (isEscaping
	           ? ', __e = _.escape'
	           : ''
	        ) +
	        (isEvaluating
	          ? ', __j = Array.prototype.join;\n' +
	            "function print() { __p += __j.call(arguments, '') }\n"
	          : ';\n'
	        ) +
	        source +
	        'return __p\n}';
	
	      var result = attempt(function() {
	        return Function(importsKeys, sourceURL + 'return ' + source)
	          .apply(undefined, importsValues);
	      });
	
	      // Provide the compiled function's source by its `toString` method or
	      // the `source` property as a convenience for inlining compiled templates.
	      result.source = source;
	      if (isError(result)) {
	        throw result;
	      }
	      return result;
	    }
	
	    /**
	     * Converts `string`, as a whole, to lower case just like
	     * [String#toLowerCase](https://mdn.io/toLowerCase).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the lower cased string.
	     * @example
	     *
	     * _.toLower('--Foo-Bar--');
	     * // => '--foo-bar--'
	     *
	     * _.toLower('fooBar');
	     * // => 'foobar'
	     *
	     * _.toLower('__FOO_BAR__');
	     * // => '__foo_bar__'
	     */
	    function toLower(value) {
	      return toString(value).toLowerCase();
	    }
	
	    /**
	     * Converts `string`, as a whole, to upper case just like
	     * [String#toUpperCase](https://mdn.io/toUpperCase).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the upper cased string.
	     * @example
	     *
	     * _.toUpper('--foo-bar--');
	     * // => '--FOO-BAR--'
	     *
	     * _.toUpper('fooBar');
	     * // => 'FOOBAR'
	     *
	     * _.toUpper('__foo_bar__');
	     * // => '__FOO_BAR__'
	     */
	    function toUpper(value) {
	      return toString(value).toUpperCase();
	    }
	
	    /**
	     * Removes leading and trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trim('  abc  ');
	     * // => 'abc'
	     *
	     * _.trim('-_-abc-_-', '_-');
	     * // => 'abc'
	     *
	     * _.map(['  foo  ', '  bar  '], _.trim);
	     * // => ['foo', 'bar']
	     */
	    function trim(string, chars, guard) {
	      string = toString(string);
	      if (string && (guard || chars === undefined)) {
	        return string.replace(reTrim, '');
	      }
	      if (!string || !(chars = baseToString(chars))) {
	        return string;
	      }
	      var strSymbols = stringToArray(string),
	          chrSymbols = stringToArray(chars),
	          start = charsStartIndex(strSymbols, chrSymbols),
	          end = charsEndIndex(strSymbols, chrSymbols) + 1;
	
	      return castSlice(strSymbols, start, end).join('');
	    }
	
	    /**
	     * Removes trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimEnd('  abc  ');
	     * // => '  abc'
	     *
	     * _.trimEnd('-_-abc-_-', '_-');
	     * // => '-_-abc'
	     */
	    function trimEnd(string, chars, guard) {
	      string = toString(string);
	      if (string && (guard || chars === undefined)) {
	        return string.replace(reTrimEnd, '');
	      }
	      if (!string || !(chars = baseToString(chars))) {
	        return string;
	      }
	      var strSymbols = stringToArray(string),
	          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
	
	      return castSlice(strSymbols, 0, end).join('');
	    }
	
	    /**
	     * Removes leading whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimStart('  abc  ');
	     * // => 'abc  '
	     *
	     * _.trimStart('-_-abc-_-', '_-');
	     * // => 'abc-_-'
	     */
	    function trimStart(string, chars, guard) {
	      string = toString(string);
	      if (string && (guard || chars === undefined)) {
	        return string.replace(reTrimStart, '');
	      }
	      if (!string || !(chars = baseToString(chars))) {
	        return string;
	      }
	      var strSymbols = stringToArray(string),
	          start = charsStartIndex(strSymbols, stringToArray(chars));
	
	      return castSlice(strSymbols, start).join('');
	    }
	
	    /**
	     * Truncates `string` if it's longer than the given maximum string length.
	     * The last characters of the truncated string are replaced with the omission
	     * string which defaults to "...".
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to truncate.
	     * @param {Object} [options={}] The options object.
	     * @param {number} [options.length=30] The maximum string length.
	     * @param {string} [options.omission='...'] The string to indicate text is omitted.
	     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
	     * @returns {string} Returns the truncated string.
	     * @example
	     *
	     * _.truncate('hi-diddly-ho there, neighborino');
	     * // => 'hi-diddly-ho there, neighbo...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': ' '
	     * });
	     * // => 'hi-diddly-ho there,...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': /,? +/
	     * });
	     * // => 'hi-diddly-ho there...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'omission': ' [...]'
	     * });
	     * // => 'hi-diddly-ho there, neig [...]'
	     */
	    function truncate(string, options) {
	      var length = DEFAULT_TRUNC_LENGTH,
	          omission = DEFAULT_TRUNC_OMISSION;
	
	      if (isObject(options)) {
	        var separator = 'separator' in options ? options.separator : separator;
	        length = 'length' in options ? toInteger(options.length) : length;
	        omission = 'omission' in options ? baseToString(options.omission) : omission;
	      }
	      string = toString(string);
	
	      var strLength = string.length;
	      if (hasUnicode(string)) {
	        var strSymbols = stringToArray(string);
	        strLength = strSymbols.length;
	      }
	      if (length >= strLength) {
	        return string;
	      }
	      var end = length - stringSize(omission);
	      if (end < 1) {
	        return omission;
	      }
	      var result = strSymbols
	        ? castSlice(strSymbols, 0, end).join('')
	        : string.slice(0, end);
	
	      if (separator === undefined) {
	        return result + omission;
	      }
	      if (strSymbols) {
	        end += (result.length - end);
	      }
	      if (isRegExp(separator)) {
	        if (string.slice(end).search(separator)) {
	          var match,
	              substring = result;
	
	          if (!separator.global) {
	            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
	          }
	          separator.lastIndex = 0;
	          while ((match = separator.exec(substring))) {
	            var newEnd = match.index;
	          }
	          result = result.slice(0, newEnd === undefined ? end : newEnd);
	        }
	      } else if (string.indexOf(baseToString(separator), end) != end) {
	        var index = result.lastIndexOf(separator);
	        if (index > -1) {
	          result = result.slice(0, index);
	        }
	      }
	      return result + omission;
	    }
	
	    /**
	     * The inverse of `_.escape`; this method converts the HTML entities
	     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
	     * their corresponding characters.
	     *
	     * **Note:** No other HTML entities are unescaped. To unescape additional
	     * HTML entities use a third-party library like [_he_](https://mths.be/he).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.6.0
	     * @category String
	     * @param {string} [string=''] The string to unescape.
	     * @returns {string} Returns the unescaped string.
	     * @example
	     *
	     * _.unescape('fred, barney, &amp; pebbles');
	     * // => 'fred, barney, & pebbles'
	     */
	    function unescape(string) {
	      string = toString(string);
	      return (string && reHasEscapedHtml.test(string))
	        ? string.replace(reEscapedHtml, unescapeHtmlChar)
	        : string;
	    }
	
	    /**
	     * Converts `string`, as space separated words, to upper case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the upper cased string.
	     * @example
	     *
	     * _.upperCase('--foo-bar');
	     * // => 'FOO BAR'
	     *
	     * _.upperCase('fooBar');
	     * // => 'FOO BAR'
	     *
	     * _.upperCase('__foo_bar__');
	     * // => 'FOO BAR'
	     */
	    var upperCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + word.toUpperCase();
	    });
	
	    /**
	     * Converts the first character of `string` to upper case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.upperFirst('fred');
	     * // => 'Fred'
	     *
	     * _.upperFirst('FRED');
	     * // => 'FRED'
	     */
	    var upperFirst = createCaseFirst('toUpperCase');
	
	    /**
	     * Splits `string` into an array of its words.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {RegExp|string} [pattern] The pattern to match words.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the words of `string`.
	     * @example
	     *
	     * _.words('fred, barney, & pebbles');
	     * // => ['fred', 'barney', 'pebbles']
	     *
	     * _.words('fred, barney, & pebbles', /[^, ]+/g);
	     * // => ['fred', 'barney', '&', 'pebbles']
	     */
	    function words(string, pattern, guard) {
	      string = toString(string);
	      pattern = guard ? undefined : pattern;
	
	      if (pattern === undefined) {
	        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
	      }
	      return string.match(pattern) || [];
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Attempts to invoke `func`, returning either the result or the caught error
	     * object. Any additional arguments are provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {Function} func The function to attempt.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {*} Returns the `func` result or error object.
	     * @example
	     *
	     * // Avoid throwing errors for invalid selectors.
	     * var elements = _.attempt(function(selector) {
	     *   return document.querySelectorAll(selector);
	     * }, '>_>');
	     *
	     * if (_.isError(elements)) {
	     *   elements = [];
	     * }
	     */
	    var attempt = baseRest(function(func, args) {
	      try {
	        return apply(func, undefined, args);
	      } catch (e) {
	        return isError(e) ? e : new Error(e);
	      }
	    });
	
	    /**
	     * Binds methods of an object to the object itself, overwriting the existing
	     * method.
	     *
	     * **Note:** This method doesn't set the "length" property of bound functions.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {Object} object The object to bind and assign the bound methods to.
	     * @param {...(string|string[])} methodNames The object method names to bind.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var view = {
	     *   'label': 'docs',
	     *   'click': function() {
	     *     console.log('clicked ' + this.label);
	     *   }
	     * };
	     *
	     * _.bindAll(view, ['click']);
	     * jQuery(element).on('click', view.click);
	     * // => Logs 'clicked docs' when clicked.
	     */
	    var bindAll = flatRest(function(object, methodNames) {
	      arrayEach(methodNames, function(key) {
	        key = toKey(key);
	        baseAssignValue(object, key, bind(object[key], object));
	      });
	      return object;
	    });
	
	    /**
	     * Creates a function that iterates over `pairs` and invokes the corresponding
	     * function of the first predicate to return truthy. The predicate-function
	     * pairs are invoked with the `this` binding and arguments of the created
	     * function.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {Array} pairs The predicate-function pairs.
	     * @returns {Function} Returns the new composite function.
	     * @example
	     *
	     * var func = _.cond([
	     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
	     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
	     *   [_.stubTrue,                      _.constant('no match')]
	     * ]);
	     *
	     * func({ 'a': 1, 'b': 2 });
	     * // => 'matches A'
	     *
	     * func({ 'a': 0, 'b': 1 });
	     * // => 'matches B'
	     *
	     * func({ 'a': '1', 'b': '2' });
	     * // => 'no match'
	     */
	    function cond(pairs) {
	      var length = pairs == null ? 0 : pairs.length,
	          toIteratee = getIteratee();
	
	      pairs = !length ? [] : arrayMap(pairs, function(pair) {
	        if (typeof pair[1] != 'function') {
	          throw new TypeError(FUNC_ERROR_TEXT);
	        }
	        return [toIteratee(pair[0]), pair[1]];
	      });
	
	      return baseRest(function(args) {
	        var index = -1;
	        while (++index < length) {
	          var pair = pairs[index];
	          if (apply(pair[0], this, args)) {
	            return apply(pair[1], this, args);
	          }
	        }
	      });
	    }
	
	    /**
	     * Creates a function that invokes the predicate properties of `source` with
	     * the corresponding property values of a given object, returning `true` if
	     * all predicates return truthy, else `false`.
	     *
	     * **Note:** The created function is equivalent to `_.conformsTo` with
	     * `source` partially applied.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {Function} Returns the new spec function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': 2, 'b': 1 },
	     *   { 'a': 1, 'b': 2 }
	     * ];
	     *
	     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
	     * // => [{ 'a': 1, 'b': 2 }]
	     */
	    function conforms(source) {
	      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
	    }
	
	    /**
	     * Creates a function that returns `value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Util
	     * @param {*} value The value to return from the new function.
	     * @returns {Function} Returns the new constant function.
	     * @example
	     *
	     * var objects = _.times(2, _.constant({ 'a': 1 }));
	     *
	     * console.log(objects);
	     * // => [{ 'a': 1 }, { 'a': 1 }]
	     *
	     * console.log(objects[0] === objects[1]);
	     * // => true
	     */
	    function constant(value) {
	      return function() {
	        return value;
	      };
	    }
	
	    /**
	     * Checks `value` to determine whether a default value should be returned in
	     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
	     * or `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.14.0
	     * @category Util
	     * @param {*} value The value to check.
	     * @param {*} defaultValue The default value.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * _.defaultTo(1, 10);
	     * // => 1
	     *
	     * _.defaultTo(undefined, 10);
	     * // => 10
	     */
	    function defaultTo(value, defaultValue) {
	      return (value == null || value !== value) ? defaultValue : value;
	    }
	
	    /**
	     * Creates a function that returns the result of invoking the given functions
	     * with the `this` binding of the created function, where each successive
	     * invocation is supplied the return value of the previous.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [funcs] The functions to invoke.
	     * @returns {Function} Returns the new composite function.
	     * @see _.flowRight
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flow([_.add, square]);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    var flow = createFlow();
	
	    /**
	     * This method is like `_.flow` except that it creates a function that
	     * invokes the given functions from right to left.
	     *
	     * @static
	     * @since 3.0.0
	     * @memberOf _
	     * @category Util
	     * @param {...(Function|Function[])} [funcs] The functions to invoke.
	     * @returns {Function} Returns the new composite function.
	     * @see _.flow
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flowRight([square, _.add]);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    var flowRight = createFlow(true);
	
	    /**
	     * This method returns the first argument it receives.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {*} value Any value.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * var object = { 'a': 1 };
	     *
	     * console.log(_.identity(object) === object);
	     * // => true
	     */
	    function identity(value) {
	      return value;
	    }
	
	    /**
	     * Creates a function that invokes `func` with the arguments of the created
	     * function. If `func` is a property name, the created function returns the
	     * property value for a given element. If `func` is an array or object, the
	     * created function returns `true` for elements that contain the equivalent
	     * source properties, otherwise it returns `false`.
	     *
	     * @static
	     * @since 4.0.0
	     * @memberOf _
	     * @category Util
	     * @param {*} [func=_.identity] The value to convert to a callback.
	     * @returns {Function} Returns the callback.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
	     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.filter(users, _.iteratee(['user', 'fred']));
	     * // => [{ 'user': 'fred', 'age': 40 }]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.map(users, _.iteratee('user'));
	     * // => ['barney', 'fred']
	     *
	     * // Create custom iteratee shorthands.
	     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
	     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
	     *     return func.test(string);
	     *   };
	     * });
	     *
	     * _.filter(['abc', 'def'], /ef/);
	     * // => ['def']
	     */
	    function iteratee(func) {
	      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
	    }
	
	    /**
	     * Creates a function that performs a partial deep comparison between a given
	     * object and `source`, returning `true` if the given object has equivalent
	     * property values, else `false`.
	     *
	     * **Note:** The created function is equivalent to `_.isMatch` with `source`
	     * partially applied.
	     *
	     * Partial comparisons will match empty array and empty object `source`
	     * values against any array or object value, respectively. See `_.isEqual`
	     * for a list of supported value comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new spec function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': 1, 'b': 2, 'c': 3 },
	     *   { 'a': 4, 'b': 5, 'c': 6 }
	     * ];
	     *
	     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
	     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
	     */
	    function matches(source) {
	      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
	    }
	
	    /**
	     * Creates a function that performs a partial deep comparison between the
	     * value at `path` of a given object to `srcValue`, returning `true` if the
	     * object value is equivalent, else `false`.
	     *
	     * **Note:** Partial comparisons will match empty array and empty object
	     * `srcValue` values against any array or object value, respectively. See
	     * `_.isEqual` for a list of supported value comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.2.0
	     * @category Util
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new spec function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': 1, 'b': 2, 'c': 3 },
	     *   { 'a': 4, 'b': 5, 'c': 6 }
	     * ];
	     *
	     * _.find(objects, _.matchesProperty('a', 4));
	     * // => { 'a': 4, 'b': 5, 'c': 6 }
	     */
	    function matchesProperty(path, srcValue) {
	      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
	    }
	
	    /**
	     * Creates a function that invokes the method at `path` of a given object.
	     * Any additional arguments are provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Util
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new invoker function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': _.constant(2) } },
	     *   { 'a': { 'b': _.constant(1) } }
	     * ];
	     *
	     * _.map(objects, _.method('a.b'));
	     * // => [2, 1]
	     *
	     * _.map(objects, _.method(['a', 'b']));
	     * // => [2, 1]
	     */
	    var method = baseRest(function(path, args) {
	      return function(object) {
	        return baseInvoke(object, path, args);
	      };
	    });
	
	    /**
	     * The opposite of `_.method`; this method creates a function that invokes
	     * the method at a given path of `object`. Any additional arguments are
	     * provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Util
	     * @param {Object} object The object to query.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new invoker function.
	     * @example
	     *
	     * var array = _.times(3, _.constant),
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
	     * // => [2, 0]
	     */
	    var methodOf = baseRest(function(object, args) {
	      return function(path) {
	        return baseInvoke(object, path, args);
	      };
	    });
	
	    /**
	     * Adds all own enumerable string keyed function properties of a source
	     * object to the destination object. If `object` is a function, then methods
	     * are added to its prototype as well.
	     *
	     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
	     * avoid conflicts caused by modifying the original.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {Function|Object} [object=lodash] The destination object.
	     * @param {Object} source The object of functions to add.
	     * @param {Object} [options={}] The options object.
	     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
	     * @returns {Function|Object} Returns `object`.
	     * @example
	     *
	     * function vowels(string) {
	     *   return _.filter(string, function(v) {
	     *     return /[aeiou]/i.test(v);
	     *   });
	     * }
	     *
	     * _.mixin({ 'vowels': vowels });
	     * _.vowels('fred');
	     * // => ['e']
	     *
	     * _('fred').vowels().value();
	     * // => ['e']
	     *
	     * _.mixin({ 'vowels': vowels }, { 'chain': false });
	     * _('fred').vowels();
	     * // => ['e']
	     */
	    function mixin(object, source, options) {
	      var props = keys(source),
	          methodNames = baseFunctions(source, props);
	
	      if (options == null &&
	          !(isObject(source) && (methodNames.length || !props.length))) {
	        options = source;
	        source = object;
	        object = this;
	        methodNames = baseFunctions(source, keys(source));
	      }
	      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
	          isFunc = isFunction(object);
	
	      arrayEach(methodNames, function(methodName) {
	        var func = source[methodName];
	        object[methodName] = func;
	        if (isFunc) {
	          object.prototype[methodName] = function() {
	            var chainAll = this.__chain__;
	            if (chain || chainAll) {
	              var result = object(this.__wrapped__),
	                  actions = result.__actions__ = copyArray(this.__actions__);
	
	              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
	              result.__chain__ = chainAll;
	              return result;
	            }
	            return func.apply(object, arrayPush([this.value()], arguments));
	          };
	        }
	      });
	
	      return object;
	    }
	
	    /**
	     * Reverts the `_` variable to its previous value and returns a reference to
	     * the `lodash` function.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @returns {Function} Returns the `lodash` function.
	     * @example
	     *
	     * var lodash = _.noConflict();
	     */
	    function noConflict() {
	      if (root._ === this) {
	        root._ = oldDash;
	      }
	      return this;
	    }
	
	    /**
	     * This method returns `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.3.0
	     * @category Util
	     * @example
	     *
	     * _.times(2, _.noop);
	     * // => [undefined, undefined]
	     */
	    function noop() {
	      // No operation performed.
	    }
	
	    /**
	     * Creates a function that gets the argument at index `n`. If `n` is negative,
	     * the nth argument from the end is returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {number} [n=0] The index of the argument to return.
	     * @returns {Function} Returns the new pass-thru function.
	     * @example
	     *
	     * var func = _.nthArg(1);
	     * func('a', 'b', 'c', 'd');
	     * // => 'b'
	     *
	     * var func = _.nthArg(-2);
	     * func('a', 'b', 'c', 'd');
	     * // => 'c'
	     */
	    function nthArg(n) {
	      n = toInteger(n);
	      return baseRest(function(args) {
	        return baseNth(args, n);
	      });
	    }
	
	    /**
	     * Creates a function that invokes `iteratees` with the arguments it receives
	     * and returns their results.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [iteratees=[_.identity]]
	     *  The iteratees to invoke.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.over([Math.max, Math.min]);
	     *
	     * func(1, 2, 3, 4);
	     * // => [4, 1]
	     */
	    var over = createOver(arrayMap);
	
	    /**
	     * Creates a function that checks if **all** of the `predicates` return
	     * truthy when invoked with the arguments it receives.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [predicates=[_.identity]]
	     *  The predicates to check.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.overEvery([Boolean, isFinite]);
	     *
	     * func('1');
	     * // => true
	     *
	     * func(null);
	     * // => false
	     *
	     * func(NaN);
	     * // => false
	     */
	    var overEvery = createOver(arrayEvery);
	
	    /**
	     * Creates a function that checks if **any** of the `predicates` return
	     * truthy when invoked with the arguments it receives.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [predicates=[_.identity]]
	     *  The predicates to check.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.overSome([Boolean, isFinite]);
	     *
	     * func('1');
	     * // => true
	     *
	     * func(null);
	     * // => true
	     *
	     * func(NaN);
	     * // => false
	     */
	    var overSome = createOver(arraySome);
	
	    /**
	     * Creates a function that returns the value at `path` of a given object.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Util
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new accessor function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': 2 } },
	     *   { 'a': { 'b': 1 } }
	     * ];
	     *
	     * _.map(objects, _.property('a.b'));
	     * // => [2, 1]
	     *
	     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	     * // => [1, 2]
	     */
	    function property(path) {
	      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
	    }
	
	    /**
	     * The opposite of `_.property`; this method creates a function that returns
	     * the value at a given path of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {Object} object The object to query.
	     * @returns {Function} Returns the new accessor function.
	     * @example
	     *
	     * var array = [0, 1, 2],
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
	     * // => [2, 0]
	     */
	    function propertyOf(object) {
	      return function(path) {
	        return object == null ? undefined : baseGet(object, path);
	      };
	    }
	
	    /**
	     * Creates an array of numbers (positive and/or negative) progressing from
	     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
	     * `start` is specified without an `end` or `step`. If `end` is not specified,
	     * it's set to `start` with `start` then set to `0`.
	     *
	     * **Note:** JavaScript follows the IEEE-754 standard for resolving
	     * floating-point values which can produce unexpected results.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns the range of numbers.
	     * @see _.inRange, _.rangeRight
	     * @example
	     *
	     * _.range(4);
	     * // => [0, 1, 2, 3]
	     *
	     * _.range(-4);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 5);
	     * // => [1, 2, 3, 4]
	     *
	     * _.range(0, 20, 5);
	     * // => [0, 5, 10, 15]
	     *
	     * _.range(0, -4, -1);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.range(0);
	     * // => []
	     */
	    var range = createRange();
	
	    /**
	     * This method is like `_.range` except that it populates values in
	     * descending order.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns the range of numbers.
	     * @see _.inRange, _.range
	     * @example
	     *
	     * _.rangeRight(4);
	     * // => [3, 2, 1, 0]
	     *
	     * _.rangeRight(-4);
	     * // => [-3, -2, -1, 0]
	     *
	     * _.rangeRight(1, 5);
	     * // => [4, 3, 2, 1]
	     *
	     * _.rangeRight(0, 20, 5);
	     * // => [15, 10, 5, 0]
	     *
	     * _.rangeRight(0, -4, -1);
	     * // => [-3, -2, -1, 0]
	     *
	     * _.rangeRight(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.rangeRight(0);
	     * // => []
	     */
	    var rangeRight = createRange(true);
	
	    /**
	     * This method returns a new empty array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {Array} Returns the new empty array.
	     * @example
	     *
	     * var arrays = _.times(2, _.stubArray);
	     *
	     * console.log(arrays);
	     * // => [[], []]
	     *
	     * console.log(arrays[0] === arrays[1]);
	     * // => false
	     */
	    function stubArray() {
	      return [];
	    }
	
	    /**
	     * This method returns `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {boolean} Returns `false`.
	     * @example
	     *
	     * _.times(2, _.stubFalse);
	     * // => [false, false]
	     */
	    function stubFalse() {
	      return false;
	    }
	
	    /**
	     * This method returns a new empty object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {Object} Returns the new empty object.
	     * @example
	     *
	     * var objects = _.times(2, _.stubObject);
	     *
	     * console.log(objects);
	     * // => [{}, {}]
	     *
	     * console.log(objects[0] === objects[1]);
	     * // => false
	     */
	    function stubObject() {
	      return {};
	    }
	
	    /**
	     * This method returns an empty string.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {string} Returns the empty string.
	     * @example
	     *
	     * _.times(2, _.stubString);
	     * // => ['', '']
	     */
	    function stubString() {
	      return '';
	    }
	
	    /**
	     * This method returns `true`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {boolean} Returns `true`.
	     * @example
	     *
	     * _.times(2, _.stubTrue);
	     * // => [true, true]
	     */
	    function stubTrue() {
	      return true;
	    }
	
	    /**
	     * Invokes the iteratee `n` times, returning an array of the results of
	     * each invocation. The iteratee is invoked with one argument; (index).
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {number} n The number of times to invoke `iteratee`.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * _.times(3, String);
	     * // => ['0', '1', '2']
	     *
	     *  _.times(4, _.constant(0));
	     * // => [0, 0, 0, 0]
	     */
	    function times(n, iteratee) {
	      n = toInteger(n);
	      if (n < 1 || n > MAX_SAFE_INTEGER) {
	        return [];
	      }
	      var index = MAX_ARRAY_LENGTH,
	          length = nativeMin(n, MAX_ARRAY_LENGTH);
	
	      iteratee = getIteratee(iteratee);
	      n -= MAX_ARRAY_LENGTH;
	
	      var result = baseTimes(length, iteratee);
	      while (++index < n) {
	        iteratee(index);
	      }
	      return result;
	    }
	
	    /**
	     * Converts `value` to a property path array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {*} value The value to convert.
	     * @returns {Array} Returns the new property path array.
	     * @example
	     *
	     * _.toPath('a.b.c');
	     * // => ['a', 'b', 'c']
	     *
	     * _.toPath('a[0].b.c');
	     * // => ['a', '0', 'b', 'c']
	     */
	    function toPath(value) {
	      if (isArray(value)) {
	        return arrayMap(value, toKey);
	      }
	      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
	    }
	
	    /**
	     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {string} [prefix=''] The value to prefix the ID with.
	     * @returns {string} Returns the unique ID.
	     * @example
	     *
	     * _.uniqueId('contact_');
	     * // => 'contact_104'
	     *
	     * _.uniqueId();
	     * // => '105'
	     */
	    function uniqueId(prefix) {
	      var id = ++idCounter;
	      return toString(prefix) + id;
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Adds two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.4.0
	     * @category Math
	     * @param {number} augend The first number in an addition.
	     * @param {number} addend The second number in an addition.
	     * @returns {number} Returns the total.
	     * @example
	     *
	     * _.add(6, 4);
	     * // => 10
	     */
	    var add = createMathOperation(function(augend, addend) {
	      return augend + addend;
	    }, 0);
	
	    /**
	     * Computes `number` rounded up to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Math
	     * @param {number} number The number to round up.
	     * @param {number} [precision=0] The precision to round up to.
	     * @returns {number} Returns the rounded up number.
	     * @example
	     *
	     * _.ceil(4.006);
	     * // => 5
	     *
	     * _.ceil(6.004, 2);
	     * // => 6.01
	     *
	     * _.ceil(6040, -2);
	     * // => 6100
	     */
	    var ceil = createRound('ceil');
	
	    /**
	     * Divide two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Math
	     * @param {number} dividend The first number in a division.
	     * @param {number} divisor The second number in a division.
	     * @returns {number} Returns the quotient.
	     * @example
	     *
	     * _.divide(6, 4);
	     * // => 1.5
	     */
	    var divide = createMathOperation(function(dividend, divisor) {
	      return dividend / divisor;
	    }, 1);
	
	    /**
	     * Computes `number` rounded down to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Math
	     * @param {number} number The number to round down.
	     * @param {number} [precision=0] The precision to round down to.
	     * @returns {number} Returns the rounded down number.
	     * @example
	     *
	     * _.floor(4.006);
	     * // => 4
	     *
	     * _.floor(0.046, 2);
	     * // => 0.04
	     *
	     * _.floor(4060, -2);
	     * // => 4000
	     */
	    var floor = createRound('floor');
	
	    /**
	     * Computes the maximum value of `array`. If `array` is empty or falsey,
	     * `undefined` is returned.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * _.max([4, 2, 8, 6]);
	     * // => 8
	     *
	     * _.max([]);
	     * // => undefined
	     */
	    function max(array) {
	      return (array && array.length)
	        ? baseExtremum(array, identity, baseGt)
	        : undefined;
	    }
	
	    /**
	     * This method is like `_.max` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * the value is ranked. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * var objects = [{ 'n': 1 }, { 'n': 2 }];
	     *
	     * _.maxBy(objects, function(o) { return o.n; });
	     * // => { 'n': 2 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.maxBy(objects, 'n');
	     * // => { 'n': 2 }
	     */
	    function maxBy(array, iteratee) {
	      return (array && array.length)
	        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
	        : undefined;
	    }
	
	    /**
	     * Computes the mean of the values in `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {number} Returns the mean.
	     * @example
	     *
	     * _.mean([4, 2, 8, 6]);
	     * // => 5
	     */
	    function mean(array) {
	      return baseMean(array, identity);
	    }
	
	    /**
	     * This method is like `_.mean` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the value to be averaged.
	     * The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the mean.
	     * @example
	     *
	     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
	     *
	     * _.meanBy(objects, function(o) { return o.n; });
	     * // => 5
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.meanBy(objects, 'n');
	     * // => 5
	     */
	    function meanBy(array, iteratee) {
	      return baseMean(array, getIteratee(iteratee, 2));
	    }
	
	    /**
	     * Computes the minimum value of `array`. If `array` is empty or falsey,
	     * `undefined` is returned.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * _.min([4, 2, 8, 6]);
	     * // => 2
	     *
	     * _.min([]);
	     * // => undefined
	     */
	    function min(array) {
	      return (array && array.length)
	        ? baseExtremum(array, identity, baseLt)
	        : undefined;
	    }
	
	    /**
	     * This method is like `_.min` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * the value is ranked. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * var objects = [{ 'n': 1 }, { 'n': 2 }];
	     *
	     * _.minBy(objects, function(o) { return o.n; });
	     * // => { 'n': 1 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.minBy(objects, 'n');
	     * // => { 'n': 1 }
	     */
	    function minBy(array, iteratee) {
	      return (array && array.length)
	        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
	        : undefined;
	    }
	
	    /**
	     * Multiply two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Math
	     * @param {number} multiplier The first number in a multiplication.
	     * @param {number} multiplicand The second number in a multiplication.
	     * @returns {number} Returns the product.
	     * @example
	     *
	     * _.multiply(6, 4);
	     * // => 24
	     */
	    var multiply = createMathOperation(function(multiplier, multiplicand) {
	      return multiplier * multiplicand;
	    }, 1);
	
	    /**
	     * Computes `number` rounded to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Math
	     * @param {number} number The number to round.
	     * @param {number} [precision=0] The precision to round to.
	     * @returns {number} Returns the rounded number.
	     * @example
	     *
	     * _.round(4.006);
	     * // => 4
	     *
	     * _.round(4.006, 2);
	     * // => 4.01
	     *
	     * _.round(4060, -2);
	     * // => 4100
	     */
	    var round = createRound('round');
	
	    /**
	     * Subtract two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {number} minuend The first number in a subtraction.
	     * @param {number} subtrahend The second number in a subtraction.
	     * @returns {number} Returns the difference.
	     * @example
	     *
	     * _.subtract(6, 4);
	     * // => 2
	     */
	    var subtract = createMathOperation(function(minuend, subtrahend) {
	      return minuend - subtrahend;
	    }, 0);
	
	    /**
	     * Computes the sum of the values in `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.4.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * _.sum([4, 2, 8, 6]);
	     * // => 20
	     */
	    function sum(array) {
	      return (array && array.length)
	        ? baseSum(array, identity)
	        : 0;
	    }
	
	    /**
	     * This method is like `_.sum` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the value to be summed.
	     * The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
	     *
	     * _.sumBy(objects, function(o) { return o.n; });
	     * // => 20
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sumBy(objects, 'n');
	     * // => 20
	     */
	    function sumBy(array, iteratee) {
	      return (array && array.length)
	        ? baseSum(array, getIteratee(iteratee, 2))
	        : 0;
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    // Add methods that return wrapped values in chain sequences.
	    lodash.after = after;
	    lodash.ary = ary;
	    lodash.assign = assign;
	    lodash.assignIn = assignIn;
	    lodash.assignInWith = assignInWith;
	    lodash.assignWith = assignWith;
	    lodash.at = at;
	    lodash.before = before;
	    lodash.bind = bind;
	    lodash.bindAll = bindAll;
	    lodash.bindKey = bindKey;
	    lodash.castArray = castArray;
	    lodash.chain = chain;
	    lodash.chunk = chunk;
	    lodash.compact = compact;
	    lodash.concat = concat;
	    lodash.cond = cond;
	    lodash.conforms = conforms;
	    lodash.constant = constant;
	    lodash.countBy = countBy;
	    lodash.create = create;
	    lodash.curry = curry;
	    lodash.curryRight = curryRight;
	    lodash.debounce = debounce;
	    lodash.defaults = defaults;
	    lodash.defaultsDeep = defaultsDeep;
	    lodash.defer = defer;
	    lodash.delay = delay;
	    lodash.difference = difference;
	    lodash.differenceBy = differenceBy;
	    lodash.differenceWith = differenceWith;
	    lodash.drop = drop;
	    lodash.dropRight = dropRight;
	    lodash.dropRightWhile = dropRightWhile;
	    lodash.dropWhile = dropWhile;
	    lodash.fill = fill;
	    lodash.filter = filter;
	    lodash.flatMap = flatMap;
	    lodash.flatMapDeep = flatMapDeep;
	    lodash.flatMapDepth = flatMapDepth;
	    lodash.flatten = flatten;
	    lodash.flattenDeep = flattenDeep;
	    lodash.flattenDepth = flattenDepth;
	    lodash.flip = flip;
	    lodash.flow = flow;
	    lodash.flowRight = flowRight;
	    lodash.fromPairs = fromPairs;
	    lodash.functions = functions;
	    lodash.functionsIn = functionsIn;
	    lodash.groupBy = groupBy;
	    lodash.initial = initial;
	    lodash.intersection = intersection;
	    lodash.intersectionBy = intersectionBy;
	    lodash.intersectionWith = intersectionWith;
	    lodash.invert = invert;
	    lodash.invertBy = invertBy;
	    lodash.invokeMap = invokeMap;
	    lodash.iteratee = iteratee;
	    lodash.keyBy = keyBy;
	    lodash.keys = keys;
	    lodash.keysIn = keysIn;
	    lodash.map = map;
	    lodash.mapKeys = mapKeys;
	    lodash.mapValues = mapValues;
	    lodash.matches = matches;
	    lodash.matchesProperty = matchesProperty;
	    lodash.memoize = memoize;
	    lodash.merge = merge;
	    lodash.mergeWith = mergeWith;
	    lodash.method = method;
	    lodash.methodOf = methodOf;
	    lodash.mixin = mixin;
	    lodash.negate = negate;
	    lodash.nthArg = nthArg;
	    lodash.omit = omit;
	    lodash.omitBy = omitBy;
	    lodash.once = once;
	    lodash.orderBy = orderBy;
	    lodash.over = over;
	    lodash.overArgs = overArgs;
	    lodash.overEvery = overEvery;
	    lodash.overSome = overSome;
	    lodash.partial = partial;
	    lodash.partialRight = partialRight;
	    lodash.partition = partition;
	    lodash.pick = pick;
	    lodash.pickBy = pickBy;
	    lodash.property = property;
	    lodash.propertyOf = propertyOf;
	    lodash.pull = pull;
	    lodash.pullAll = pullAll;
	    lodash.pullAllBy = pullAllBy;
	    lodash.pullAllWith = pullAllWith;
	    lodash.pullAt = pullAt;
	    lodash.range = range;
	    lodash.rangeRight = rangeRight;
	    lodash.rearg = rearg;
	    lodash.reject = reject;
	    lodash.remove = remove;
	    lodash.rest = rest;
	    lodash.reverse = reverse;
	    lodash.sampleSize = sampleSize;
	    lodash.set = set;
	    lodash.setWith = setWith;
	    lodash.shuffle = shuffle;
	    lodash.slice = slice;
	    lodash.sortBy = sortBy;
	    lodash.sortedUniq = sortedUniq;
	    lodash.sortedUniqBy = sortedUniqBy;
	    lodash.split = split;
	    lodash.spread = spread;
	    lodash.tail = tail;
	    lodash.take = take;
	    lodash.takeRight = takeRight;
	    lodash.takeRightWhile = takeRightWhile;
	    lodash.takeWhile = takeWhile;
	    lodash.tap = tap;
	    lodash.throttle = throttle;
	    lodash.thru = thru;
	    lodash.toArray = toArray;
	    lodash.toPairs = toPairs;
	    lodash.toPairsIn = toPairsIn;
	    lodash.toPath = toPath;
	    lodash.toPlainObject = toPlainObject;
	    lodash.transform = transform;
	    lodash.unary = unary;
	    lodash.union = union;
	    lodash.unionBy = unionBy;
	    lodash.unionWith = unionWith;
	    lodash.uniq = uniq;
	    lodash.uniqBy = uniqBy;
	    lodash.uniqWith = uniqWith;
	    lodash.unset = unset;
	    lodash.unzip = unzip;
	    lodash.unzipWith = unzipWith;
	    lodash.update = update;
	    lodash.updateWith = updateWith;
	    lodash.values = values;
	    lodash.valuesIn = valuesIn;
	    lodash.without = without;
	    lodash.words = words;
	    lodash.wrap = wrap;
	    lodash.xor = xor;
	    lodash.xorBy = xorBy;
	    lodash.xorWith = xorWith;
	    lodash.zip = zip;
	    lodash.zipObject = zipObject;
	    lodash.zipObjectDeep = zipObjectDeep;
	    lodash.zipWith = zipWith;
	
	    // Add aliases.
	    lodash.entries = toPairs;
	    lodash.entriesIn = toPairsIn;
	    lodash.extend = assignIn;
	    lodash.extendWith = assignInWith;
	
	    // Add methods to `lodash.prototype`.
	    mixin(lodash, lodash);
	
	    /*------------------------------------------------------------------------*/
	
	    // Add methods that return unwrapped values in chain sequences.
	    lodash.add = add;
	    lodash.attempt = attempt;
	    lodash.camelCase = camelCase;
	    lodash.capitalize = capitalize;
	    lodash.ceil = ceil;
	    lodash.clamp = clamp;
	    lodash.clone = clone;
	    lodash.cloneDeep = cloneDeep;
	    lodash.cloneDeepWith = cloneDeepWith;
	    lodash.cloneWith = cloneWith;
	    lodash.conformsTo = conformsTo;
	    lodash.deburr = deburr;
	    lodash.defaultTo = defaultTo;
	    lodash.divide = divide;
	    lodash.endsWith = endsWith;
	    lodash.eq = eq;
	    lodash.escape = escape;
	    lodash.escapeRegExp = escapeRegExp;
	    lodash.every = every;
	    lodash.find = find;
	    lodash.findIndex = findIndex;
	    lodash.findKey = findKey;
	    lodash.findLast = findLast;
	    lodash.findLastIndex = findLastIndex;
	    lodash.findLastKey = findLastKey;
	    lodash.floor = floor;
	    lodash.forEach = forEach;
	    lodash.forEachRight = forEachRight;
	    lodash.forIn = forIn;
	    lodash.forInRight = forInRight;
	    lodash.forOwn = forOwn;
	    lodash.forOwnRight = forOwnRight;
	    lodash.get = get;
	    lodash.gt = gt;
	    lodash.gte = gte;
	    lodash.has = has;
	    lodash.hasIn = hasIn;
	    lodash.head = head;
	    lodash.identity = identity;
	    lodash.includes = includes;
	    lodash.indexOf = indexOf;
	    lodash.inRange = inRange;
	    lodash.invoke = invoke;
	    lodash.isArguments = isArguments;
	    lodash.isArray = isArray;
	    lodash.isArrayBuffer = isArrayBuffer;
	    lodash.isArrayLike = isArrayLike;
	    lodash.isArrayLikeObject = isArrayLikeObject;
	    lodash.isBoolean = isBoolean;
	    lodash.isBuffer = isBuffer;
	    lodash.isDate = isDate;
	    lodash.isElement = isElement;
	    lodash.isEmpty = isEmpty;
	    lodash.isEqual = isEqual;
	    lodash.isEqualWith = isEqualWith;
	    lodash.isError = isError;
	    lodash.isFinite = isFinite;
	    lodash.isFunction = isFunction;
	    lodash.isInteger = isInteger;
	    lodash.isLength = isLength;
	    lodash.isMap = isMap;
	    lodash.isMatch = isMatch;
	    lodash.isMatchWith = isMatchWith;
	    lodash.isNaN = isNaN;
	    lodash.isNative = isNative;
	    lodash.isNil = isNil;
	    lodash.isNull = isNull;
	    lodash.isNumber = isNumber;
	    lodash.isObject = isObject;
	    lodash.isObjectLike = isObjectLike;
	    lodash.isPlainObject = isPlainObject;
	    lodash.isRegExp = isRegExp;
	    lodash.isSafeInteger = isSafeInteger;
	    lodash.isSet = isSet;
	    lodash.isString = isString;
	    lodash.isSymbol = isSymbol;
	    lodash.isTypedArray = isTypedArray;
	    lodash.isUndefined = isUndefined;
	    lodash.isWeakMap = isWeakMap;
	    lodash.isWeakSet = isWeakSet;
	    lodash.join = join;
	    lodash.kebabCase = kebabCase;
	    lodash.last = last;
	    lodash.lastIndexOf = lastIndexOf;
	    lodash.lowerCase = lowerCase;
	    lodash.lowerFirst = lowerFirst;
	    lodash.lt = lt;
	    lodash.lte = lte;
	    lodash.max = max;
	    lodash.maxBy = maxBy;
	    lodash.mean = mean;
	    lodash.meanBy = meanBy;
	    lodash.min = min;
	    lodash.minBy = minBy;
	    lodash.stubArray = stubArray;
	    lodash.stubFalse = stubFalse;
	    lodash.stubObject = stubObject;
	    lodash.stubString = stubString;
	    lodash.stubTrue = stubTrue;
	    lodash.multiply = multiply;
	    lodash.nth = nth;
	    lodash.noConflict = noConflict;
	    lodash.noop = noop;
	    lodash.now = now;
	    lodash.pad = pad;
	    lodash.padEnd = padEnd;
	    lodash.padStart = padStart;
	    lodash.parseInt = parseInt;
	    lodash.random = random;
	    lodash.reduce = reduce;
	    lodash.reduceRight = reduceRight;
	    lodash.repeat = repeat;
	    lodash.replace = replace;
	    lodash.result = result;
	    lodash.round = round;
	    lodash.runInContext = runInContext;
	    lodash.sample = sample;
	    lodash.size = size;
	    lodash.snakeCase = snakeCase;
	    lodash.some = some;
	    lodash.sortedIndex = sortedIndex;
	    lodash.sortedIndexBy = sortedIndexBy;
	    lodash.sortedIndexOf = sortedIndexOf;
	    lodash.sortedLastIndex = sortedLastIndex;
	    lodash.sortedLastIndexBy = sortedLastIndexBy;
	    lodash.sortedLastIndexOf = sortedLastIndexOf;
	    lodash.startCase = startCase;
	    lodash.startsWith = startsWith;
	    lodash.subtract = subtract;
	    lodash.sum = sum;
	    lodash.sumBy = sumBy;
	    lodash.template = template;
	    lodash.times = times;
	    lodash.toFinite = toFinite;
	    lodash.toInteger = toInteger;
	    lodash.toLength = toLength;
	    lodash.toLower = toLower;
	    lodash.toNumber = toNumber;
	    lodash.toSafeInteger = toSafeInteger;
	    lodash.toString = toString;
	    lodash.toUpper = toUpper;
	    lodash.trim = trim;
	    lodash.trimEnd = trimEnd;
	    lodash.trimStart = trimStart;
	    lodash.truncate = truncate;
	    lodash.unescape = unescape;
	    lodash.uniqueId = uniqueId;
	    lodash.upperCase = upperCase;
	    lodash.upperFirst = upperFirst;
	
	    // Add aliases.
	    lodash.each = forEach;
	    lodash.eachRight = forEachRight;
	    lodash.first = head;
	
	    mixin(lodash, (function() {
	      var source = {};
	      baseForOwn(lodash, function(func, methodName) {
	        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
	          source[methodName] = func;
	        }
	      });
	      return source;
	    }()), { 'chain': false });
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * The semantic version number.
	     *
	     * @static
	     * @memberOf _
	     * @type {string}
	     */
	    lodash.VERSION = VERSION;
	
	    // Assign default placeholders.
	    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
	      lodash[methodName].placeholder = lodash;
	    });
	
	    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
	    arrayEach(['drop', 'take'], function(methodName, index) {
	      LazyWrapper.prototype[methodName] = function(n) {
	        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);
	
	        var result = (this.__filtered__ && !index)
	          ? new LazyWrapper(this)
	          : this.clone();
	
	        if (result.__filtered__) {
	          result.__takeCount__ = nativeMin(n, result.__takeCount__);
	        } else {
	          result.__views__.push({
	            'size': nativeMin(n, MAX_ARRAY_LENGTH),
	            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
	          });
	        }
	        return result;
	      };
	
	      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
	        return this.reverse()[methodName](n).reverse();
	      };
	    });
	
	    // Add `LazyWrapper` methods that accept an `iteratee` value.
	    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
	      var type = index + 1,
	          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
	
	      LazyWrapper.prototype[methodName] = function(iteratee) {
	        var result = this.clone();
	        result.__iteratees__.push({
	          'iteratee': getIteratee(iteratee, 3),
	          'type': type
	        });
	        result.__filtered__ = result.__filtered__ || isFilter;
	        return result;
	      };
	    });
	
	    // Add `LazyWrapper` methods for `_.head` and `_.last`.
	    arrayEach(['head', 'last'], function(methodName, index) {
	      var takeName = 'take' + (index ? 'Right' : '');
	
	      LazyWrapper.prototype[methodName] = function() {
	        return this[takeName](1).value()[0];
	      };
	    });
	
	    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
	    arrayEach(['initial', 'tail'], function(methodName, index) {
	      var dropName = 'drop' + (index ? '' : 'Right');
	
	      LazyWrapper.prototype[methodName] = function() {
	        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
	      };
	    });
	
	    LazyWrapper.prototype.compact = function() {
	      return this.filter(identity);
	    };
	
	    LazyWrapper.prototype.find = function(predicate) {
	      return this.filter(predicate).head();
	    };
	
	    LazyWrapper.prototype.findLast = function(predicate) {
	      return this.reverse().find(predicate);
	    };
	
	    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
	      if (typeof path == 'function') {
	        return new LazyWrapper(this);
	      }
	      return this.map(function(value) {
	        return baseInvoke(value, path, args);
	      });
	    });
	
	    LazyWrapper.prototype.reject = function(predicate) {
	      return this.filter(negate(getIteratee(predicate)));
	    };
	
	    LazyWrapper.prototype.slice = function(start, end) {
	      start = toInteger(start);
	
	      var result = this;
	      if (result.__filtered__ && (start > 0 || end < 0)) {
	        return new LazyWrapper(result);
	      }
	      if (start < 0) {
	        result = result.takeRight(-start);
	      } else if (start) {
	        result = result.drop(start);
	      }
	      if (end !== undefined) {
	        end = toInteger(end);
	        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
	      }
	      return result;
	    };
	
	    LazyWrapper.prototype.takeRightWhile = function(predicate) {
	      return this.reverse().takeWhile(predicate).reverse();
	    };
	
	    LazyWrapper.prototype.toArray = function() {
	      return this.take(MAX_ARRAY_LENGTH);
	    };
	
	    // Add `LazyWrapper` methods to `lodash.prototype`.
	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
	          isTaker = /^(?:head|last)$/.test(methodName),
	          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
	          retUnwrapped = isTaker || /^find/.test(methodName);
	
	      if (!lodashFunc) {
	        return;
	      }
	      lodash.prototype[methodName] = function() {
	        var value = this.__wrapped__,
	            args = isTaker ? [1] : arguments,
	            isLazy = value instanceof LazyWrapper,
	            iteratee = args[0],
	            useLazy = isLazy || isArray(value);
	
	        var interceptor = function(value) {
	          var result = lodashFunc.apply(lodash, arrayPush([value], args));
	          return (isTaker && chainAll) ? result[0] : result;
	        };
	
	        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
	          // Avoid lazy use if the iteratee has a "length" value other than `1`.
	          isLazy = useLazy = false;
	        }
	        var chainAll = this.__chain__,
	            isHybrid = !!this.__actions__.length,
	            isUnwrapped = retUnwrapped && !chainAll,
	            onlyLazy = isLazy && !isHybrid;
	
	        if (!retUnwrapped && useLazy) {
	          value = onlyLazy ? value : new LazyWrapper(this);
	          var result = func.apply(value, args);
	          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
	          return new LodashWrapper(result, chainAll);
	        }
	        if (isUnwrapped && onlyLazy) {
	          return func.apply(this, args);
	        }
	        result = this.thru(interceptor);
	        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
	      };
	    });
	
	    // Add `Array` methods to `lodash.prototype`.
	    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
	      var func = arrayProto[methodName],
	          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
	          retUnwrapped = /^(?:pop|shift)$/.test(methodName);
	
	      lodash.prototype[methodName] = function() {
	        var args = arguments;
	        if (retUnwrapped && !this.__chain__) {
	          var value = this.value();
	          return func.apply(isArray(value) ? value : [], args);
	        }
	        return this[chainName](function(value) {
	          return func.apply(isArray(value) ? value : [], args);
	        });
	      };
	    });
	
	    // Map minified method names to their real names.
	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	      var lodashFunc = lodash[methodName];
	      if (lodashFunc) {
	        var key = (lodashFunc.name + ''),
	            names = realNames[key] || (realNames[key] = []);
	
	        names.push({ 'name': methodName, 'func': lodashFunc });
	      }
	    });
	
	    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
	      'name': 'wrapper',
	      'func': undefined
	    }];
	
	    // Add methods to `LazyWrapper`.
	    LazyWrapper.prototype.clone = lazyClone;
	    LazyWrapper.prototype.reverse = lazyReverse;
	    LazyWrapper.prototype.value = lazyValue;
	
	    // Add chain sequence methods to the `lodash` wrapper.
	    lodash.prototype.at = wrapperAt;
	    lodash.prototype.chain = wrapperChain;
	    lodash.prototype.commit = wrapperCommit;
	    lodash.prototype.next = wrapperNext;
	    lodash.prototype.plant = wrapperPlant;
	    lodash.prototype.reverse = wrapperReverse;
	    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
	
	    // Add lazy aliases.
	    lodash.prototype.first = lodash.prototype.head;
	
	    if (symIterator) {
	      lodash.prototype[symIterator] = wrapperToIterator;
	    }
	    return lodash;
	  });
	
	  /*--------------------------------------------------------------------------*/
	
	  // Export lodash.
	  var _ = runInContext();
	
	  // Some AMD build optimizers, like r.js, check for condition patterns like:
	  if (true) {
	    // Expose Lodash on the global object to prevent errors when Lodash is
	    // loaded by a script tag in the presence of an AMD loader.
	    // See http://requirejs.org/docs/errors.html#mismatch for more details.
	    // Use `_.noConflict` to remove Lodash from the global object.
	    root._ = _;
	
	    // Define as an anonymous module so, through path mapping, it can be
	    // referenced as the "underscore" module.
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	  // Check for `exports` after `define` in case a build optimizer adds it.
	  else if (freeModule) {
	    // Export for Node.js.
	    (freeModule.exports = _)._ = _;
	    // Export for CommonJS support.
	    freeExports._ = _;
	  }
	  else {
	    // Export to the global object.
	    root._ = _;
	  }
	}.call(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(268)(module)))

/***/ }),
/* 276 */
/***/ (function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	function createThunkMiddleware(extraArgument) {
	  return function (_ref) {
	    var dispatch = _ref.dispatch,
	        getState = _ref.getState;
	    return function (next) {
	      return function (action) {
	        if (typeof action === 'function') {
	          return action(dispatch, getState, extraArgument);
	        }
	
	        return next(action);
	      };
	    };
	  };
	}
	
	var thunk = createThunkMiddleware();
	thunk.withExtraArgument = createThunkMiddleware;
	
	exports['default'] = thunk;

/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.REJECTED = exports.FULFILLED = exports.PENDING = undefined;
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	exports.default = promiseMiddleware;
	
	var _isPromise = __webpack_require__(278);
	
	var _isPromise2 = _interopRequireDefault(_isPromise);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var PENDING = exports.PENDING = 'PENDING';
	var FULFILLED = exports.FULFILLED = 'FULFILLED';
	var REJECTED = exports.REJECTED = 'REJECTED';
	
	var defaultTypes = [PENDING, FULFILLED, REJECTED];
	
	/**
	 * @function promiseMiddleware
	 * @description
	 * @returns {function} thunk
	 */
	function promiseMiddleware() {
	  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	
	  var promiseTypeSuffixes = config.promiseTypeSuffixes || defaultTypes;
	  var promiseTypeSeparator = config.promiseTypeSeparator || '_';
	
	  return function (ref) {
	    var dispatch = ref.dispatch;
	
	
	    return function (next) {
	      return function (action) {
	        if (action.payload) {
	          if (!(0, _isPromise2.default)(action.payload) && !(0, _isPromise2.default)(action.payload.promise)) {
	            return next(action);
	          }
	        } else {
	          return next(action);
	        }
	
	        // Deconstruct the properties of the original action object to constants
	        var type = action.type,
	            payload = action.payload,
	            meta = action.meta;
	
	        // Assign values for promise type suffixes
	
	        var _promiseTypeSuffixes = _slicedToArray(promiseTypeSuffixes, 3),
	            _PENDING = _promiseTypeSuffixes[0],
	            _FULFILLED = _promiseTypeSuffixes[1],
	            _REJECTED = _promiseTypeSuffixes[2];
	
	        /**
	         * @function getAction
	         * @description Utility function for creating a rejected or fulfilled
	         * flux standard action object.
	         * @param {boolean} Is the action rejected?
	         * @returns {object} action
	         */
	
	
	        var getAction = function getAction(newPayload, isRejected) {
	          return _extends({
	            type: [type, isRejected ? _REJECTED : _FULFILLED].join(promiseTypeSeparator)
	          }, newPayload === null || typeof newPayload === 'undefined' ? {} : {
	            payload: newPayload
	          }, meta !== undefined ? { meta: meta } : {}, isRejected ? {
	            error: true
	          } : {});
	        };
	
	        /**
	         * Assign values for promise and data variables. In the case the payload
	         * is an object with a `promise` and `data` property, the values of those
	         * properties will be used. In the case the payload is a promise, the
	         * value of the payload will be used and data will be null.
	         */
	        var promise = void 0;
	        var data = void 0;
	
	        if (!(0, _isPromise2.default)(action.payload) && _typeof(action.payload) === 'object') {
	          promise = payload.promise;
	          data = payload.data;
	        } else {
	          promise = payload;
	          data = undefined;
	        }
	
	        /**
	         * First, dispatch the pending action. This flux standard action object
	         * describes the pending state of a promise and will include any data
	         * (for optimistic updates) and/or meta from the original action.
	         */
	        next(_extends({
	          type: [type, _PENDING].join(promiseTypeSeparator)
	        }, data !== undefined ? { payload: data } : {}, meta !== undefined ? { meta: meta } : {}));
	
	        /*
	         * @function handleReject
	         * @description Dispatch the rejected action and return
	         * an error object. The error object is the original error
	         * that was thrown. The user of the library is responsible for
	         * best practices in ensure that they are throwing an Error object.
	         * @params reason The reason the promise was rejected
	         * @returns {object}
	         */
	        var handleReject = function handleReject(reason) {
	          var rejectedAction = getAction(reason, true);
	          dispatch(rejectedAction);
	
	          throw reason;
	        };
	
	        /*
	         * @function handleFulfill
	         * @description Dispatch the fulfilled action and
	         * return the success object. The success object should
	         * contain the value and the dispatched action.
	         * @param value The value the promise was resloved with
	         * @returns {object}
	         */
	        var handleFulfill = function handleFulfill() {
	          var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	
	          var resolvedAction = getAction(value, false);
	          dispatch(resolvedAction);
	
	          return { value: value, action: resolvedAction };
	        };
	
	        /**
	         * Second, dispatch a rejected or fulfilled action. This flux standard
	         * action object will describe the resolved state of the promise. In
	         * the case of a rejected promise, it will include an `error` property.
	         *
	         * In order to allow proper chaining of actions using `then`, a new
	         * promise is constructed and returned. This promise will resolve
	         * with two properties: (1) the value (if fulfilled) or reason
	         * (if rejected) and (2) the flux standard action.
	         *
	         * Rejected object:
	         * {
	         *   reason: ...
	         *   action: {
	         *     error: true,
	         *     type: 'ACTION_REJECTED',
	         *     payload: ...
	         *   }
	         * }
	         *
	         * Fulfilled object:
	         * {
	         *   value: ...
	         *   action: {
	         *     type: 'ACTION_FULFILLED',
	         *     payload: ...
	         *   }
	         * }
	         */
	        return promise.then(handleFulfill, handleReject);
	      };
	    };
	  };
	}

/***/ }),
/* 278 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.default = isPromise;
	function isPromise(value) {
	  if (value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
	    return value && typeof value.then === 'function';
	  }
	
	  return false;
	}

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.injectReducer = undefined;
	
	var _extends2 = __webpack_require__(280);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _redux = __webpack_require__(254);
	
	var _reactRouterRedux = __webpack_require__(248);
	
	var _common = __webpack_require__(318);
	
	var _common2 = _interopRequireDefault(_common);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var makeRootReducer = function makeRootReducer(asyncReducers) {
	  return (0, _redux.combineReducers)((0, _extends3.default)({
	    // Add sync reducers here
	    router: _reactRouterRedux.routerReducer,
	    commonData: _common2.default
	  }, asyncReducers));
	}; /* eslint-disable no-param-reassign*/
	var injectReducer = exports.injectReducer = function injectReducer(store, _ref) {
	  var key = _ref.key,
	      reducer = _ref.reducer;
	
	  store.asyncReducers[key] = reducer;
	  store.replaceReducer(makeRootReducer(store.asyncReducers));
	};
	
	exports.default = makeRootReducer;

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _assign = __webpack_require__(281);
	
	var _assign2 = _interopRequireDefault(_assign);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = _assign2.default || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];
	
	    for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }
	
	  return target;
	};

/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(282), __esModule: true };

/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(283);
	module.exports = __webpack_require__(286).Object.assign;


/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(284);
	
	$export($export.S + $export.F, 'Object', { assign: __webpack_require__(299) });


/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(285);
	var core = __webpack_require__(286);
	var ctx = __webpack_require__(287);
	var hide = __webpack_require__(289);
	var PROTOTYPE = 'prototype';
	
	var $export = function (type, name, source) {
	  var IS_FORCED = type & $export.F;
	  var IS_GLOBAL = type & $export.G;
	  var IS_STATIC = type & $export.S;
	  var IS_PROTO = type & $export.P;
	  var IS_BIND = type & $export.B;
	  var IS_WRAP = type & $export.W;
	  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
	  var expProto = exports[PROTOTYPE];
	  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
	  var key, own, out;
	  if (IS_GLOBAL) source = name;
	  for (key in source) {
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if (own && key in exports) continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function (C) {
	      var F = function (a, b, c) {
	        if (this instanceof C) {
	          switch (arguments.length) {
	            case 0: return new C();
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
	    if (IS_PROTO) {
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
	      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
	    }
	  }
	};
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library`
	module.exports = $export;


/***/ }),
/* 285 */
/***/ (function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self
	  // eslint-disable-next-line no-new-func
	  : Function('return this')();
	if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),
/* 286 */
/***/ (function(module, exports) {

	var core = module.exports = { version: '2.5.1' };
	if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(288);
	module.exports = function (fn, that, length) {
	  aFunction(fn);
	  if (that === undefined) return fn;
	  switch (length) {
	    case 1: return function (a) {
	      return fn.call(that, a);
	    };
	    case 2: return function (a, b) {
	      return fn.call(that, a, b);
	    };
	    case 3: return function (a, b, c) {
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function (/* ...args */) {
	    return fn.apply(that, arguments);
	  };
	};


/***/ }),
/* 288 */
/***/ (function(module, exports) {

	module.exports = function (it) {
	  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
	  return it;
	};


/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

	var dP = __webpack_require__(290);
	var createDesc = __webpack_require__(298);
	module.exports = __webpack_require__(294) ? function (object, key, value) {
	  return dP.f(object, key, createDesc(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};


/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

	var anObject = __webpack_require__(291);
	var IE8_DOM_DEFINE = __webpack_require__(293);
	var toPrimitive = __webpack_require__(297);
	var dP = Object.defineProperty;
	
	exports.f = __webpack_require__(294) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if (IE8_DOM_DEFINE) try {
	    return dP(O, P, Attributes);
	  } catch (e) { /* empty */ }
	  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};


/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(292);
	module.exports = function (it) {
	  if (!isObject(it)) throw TypeError(it + ' is not an object!');
	  return it;
	};


/***/ }),
/* 292 */
/***/ (function(module, exports) {

	module.exports = function (it) {
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};


/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(294) && !__webpack_require__(295)(function () {
	  return Object.defineProperty(__webpack_require__(296)('div'), 'a', { get: function () { return 7; } }).a != 7;
	});


/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(295)(function () {
	  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
	});


/***/ }),
/* 295 */
/***/ (function(module, exports) {

	module.exports = function (exec) {
	  try {
	    return !!exec();
	  } catch (e) {
	    return true;
	  }
	};


/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(292);
	var document = __webpack_require__(285).document;
	// typeof document.createElement is 'object' in old IE
	var is = isObject(document) && isObject(document.createElement);
	module.exports = function (it) {
	  return is ? document.createElement(it) : {};
	};


/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(292);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function (it, S) {
	  if (!isObject(it)) return it;
	  var fn, val;
	  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
	  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
	  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
	  throw TypeError("Can't convert object to primitive value");
	};


/***/ }),
/* 298 */
/***/ (function(module, exports) {

	module.exports = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};


/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.2.1 Object.assign(target, source, ...)
	var getKeys = __webpack_require__(300);
	var gOPS = __webpack_require__(315);
	var pIE = __webpack_require__(316);
	var toObject = __webpack_require__(317);
	var IObject = __webpack_require__(304);
	var $assign = Object.assign;
	
	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || __webpack_require__(295)(function () {
	  var A = {};
	  var B = {};
	  // eslint-disable-next-line no-undef
	  var S = Symbol();
	  var K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function (k) { B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
	  var T = toObject(target);
	  var aLen = arguments.length;
	  var index = 1;
	  var getSymbols = gOPS.f;
	  var isEnum = pIE.f;
	  while (aLen > index) {
	    var S = IObject(arguments[index++]);
	    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
	    var length = keys.length;
	    var j = 0;
	    var key;
	    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
	  } return T;
	} : $assign;


/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys = __webpack_require__(301);
	var enumBugKeys = __webpack_require__(314);
	
	module.exports = Object.keys || function keys(O) {
	  return $keys(O, enumBugKeys);
	};


/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

	var has = __webpack_require__(302);
	var toIObject = __webpack_require__(303);
	var arrayIndexOf = __webpack_require__(307)(false);
	var IE_PROTO = __webpack_require__(311)('IE_PROTO');
	
	module.exports = function (object, names) {
	  var O = toIObject(object);
	  var i = 0;
	  var result = [];
	  var key;
	  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while (names.length > i) if (has(O, key = names[i++])) {
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};


/***/ }),
/* 302 */
/***/ (function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function (it, key) {
	  return hasOwnProperty.call(it, key);
	};


/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(304);
	var defined = __webpack_require__(306);
	module.exports = function (it) {
	  return IObject(defined(it));
	};


/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(305);
	// eslint-disable-next-line no-prototype-builtins
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};


/***/ }),
/* 305 */
/***/ (function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function (it) {
	  return toString.call(it).slice(8, -1);
	};


/***/ }),
/* 306 */
/***/ (function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function (it) {
	  if (it == undefined) throw TypeError("Can't call method on  " + it);
	  return it;
	};


/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(303);
	var toLength = __webpack_require__(308);
	var toAbsoluteIndex = __webpack_require__(310);
	module.exports = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = toIObject($this);
	    var length = toLength(O.length);
	    var index = toAbsoluteIndex(fromIndex, length);
	    var value;
	    // Array#includes uses SameValueZero equality algorithm
	    // eslint-disable-next-line no-self-compare
	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++];
	      // eslint-disable-next-line no-self-compare
	      if (value != value) return true;
	    // Array#indexOf ignores holes, Array#includes - not
	    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
	      if (O[index] === el) return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};


/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(309);
	var min = Math.min;
	module.exports = function (it) {
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};


/***/ }),
/* 309 */
/***/ (function(module, exports) {

	// 7.1.4 ToInteger
	var ceil = Math.ceil;
	var floor = Math.floor;
	module.exports = function (it) {
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};


/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(309);
	var max = Math.max;
	var min = Math.min;
	module.exports = function (index, length) {
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};


/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(312)('keys');
	var uid = __webpack_require__(313);
	module.exports = function (key) {
	  return shared[key] || (shared[key] = uid(key));
	};


/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(285);
	var SHARED = '__core-js_shared__';
	var store = global[SHARED] || (global[SHARED] = {});
	module.exports = function (key) {
	  return store[key] || (store[key] = {});
	};


/***/ }),
/* 313 */
/***/ (function(module, exports) {

	var id = 0;
	var px = Math.random();
	module.exports = function (key) {
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};


/***/ }),
/* 314 */
/***/ (function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');


/***/ }),
/* 315 */
/***/ (function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;


/***/ }),
/* 316 */
/***/ (function(module, exports) {

	exports.f = {}.propertyIsEnumerable;


/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(306);
	module.exports = function (it) {
	  return Object(defined(it));
	};


/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends2 = __webpack_require__(280);
	
	var _extends3 = _interopRequireDefault(_extends2);
	
	var _promise = __webpack_require__(319);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	exports.getMatches = getMatches;
	exports.default = commonReducer;
	
	var _axios = __webpack_require__(358);
	
	var _axios2 = _interopRequireDefault(_axios);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var GET_DATA = 'GET_DATA';
	var LOADING_START = 'LOADING_START';
	var LOADING_STOP = 'LOADING_STOP';
	
	function getMatches(store) {
	  return function (dispatch) {
	    return new _promise2.default(function () {
	      dispatch({ type: LOADING_START });
	      _axios2.default.all([_axios2.default.request('https://api.myjson.com/bins/9jn19').catch(), _axios2.default.request('https://jsonblob.com/api/jsonBlob/98e3de4e-a6d3-11e7-acad-c77b9e32153b').catch(), _axios2.default.request('https://jsonblob.com/api/jsonBlob/e704a1fc-a6d3-11e7-acad-6d8871ee3b12').catch(), _axios2.default.request('https://jsonblob.com/api/jsonBlob/a776fca4-a6d4-11e7-acad-0b4151cfe1c1').catch(), _axios2.default.request('https://jsonblob.com/api/jsonBlob/0925db31-a6d5-11e7-acad-2b52067e4f5d').catch(), _axios2.default.request('https://jsonblob.com/api/jsonBlob/6eabb154-a6d5-11e7-acad-99a9a2abc49e').catch(), _axios2.default.request('https://jsonblob.com/api/jsonBlob/c592172c-a6d5-11e7-acad-d33b7745d885').catch(), _axios2.default.request('https://jsonblob.com/api/jsonBlob/34fb843e-a6d6-11e7-acad-5599337f4149').catch(), _axios2.default.request('https://jsonblob.com/api/jsonBlob/9520b46e-a6d6-11e7-acad-2fdb9a868fc2').catch(), _axios2.default.request('https://jsonblob.com/api/jsonBlob/e69fbe4e-a6d6-11e7-acad-47b404222ff3').catch()]).then(_axios2.default.spread(function (res1, res2, res3, res4, res5, res6, res7, res8, res9, res10) {
	        dispatch({
	          type: GET_DATA,
	          matches: res1,
	          2008: res2,
	          2009: res3,
	          2010: res4,
	          2011: res5,
	          2012: res6,
	          2013: res7,
	          2014: res8,
	          2015: res9,
	          2016: res10
	        });
	        dispatch({ type: LOADING_STOP });
	      }));
	    });
	  };
	}
	
	var ACTION_HANDLER = {
	  GET_DATA: function GET_DATA(state, action) {
	    return (0, _extends3.default)({}, state, {
	      matches: action.matches,
	      2008: action['2008'],
	      2009: action['2009'],
	      2010: action['2010'],
	      2011: action['2011'],
	      2012: action['2012'],
	      2013: action['2013'],
	      2014: action['2014'],
	      2015: action['2015'],
	      2016: action['2016']
	    });
	  },
	  LOADING_START: function LOADING_START(state) {
	    return (0, _extends3.default)({}, state, {
	      loaderVisibility: true
	    });
	  },
	  LOADING_STOP: function LOADING_STOP(state) {
	    return (0, _extends3.default)({}, state, {
	      loaderVisibility: false
	    });
	  }
	};
	
	var initialState = {
	  matches: [],
	  loaderVisibility: false
	};
	
	function commonReducer() {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
	  var action = arguments[1];
	
	  var handler = ACTION_HANDLER[action.type];
	  return handler ? handler(state, action) : state;
	}

/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(320), __esModule: true };

/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(321);
	__webpack_require__(322);
	__webpack_require__(335);
	__webpack_require__(339);
	__webpack_require__(356);
	__webpack_require__(357);
	module.exports = __webpack_require__(286).Promise;


/***/ }),
/* 321 */
/***/ (function(module, exports) {



/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $at = __webpack_require__(323)(true);
	
	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(324)(String, 'String', function (iterated) {
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function () {
	  var O = this._t;
	  var index = this._i;
	  var point;
	  if (index >= O.length) return { value: undefined, done: true };
	  point = $at(O, index);
	  this._i += point.length;
	  return { value: point, done: false };
	});


/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(309);
	var defined = __webpack_require__(306);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function (TO_STRING) {
	  return function (that, pos) {
	    var s = String(defined(that));
	    var i = toInteger(pos);
	    var l = s.length;
	    var a, b;
	    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};


/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY = __webpack_require__(325);
	var $export = __webpack_require__(284);
	var redefine = __webpack_require__(326);
	var hide = __webpack_require__(289);
	var has = __webpack_require__(302);
	var Iterators = __webpack_require__(327);
	var $iterCreate = __webpack_require__(328);
	var setToStringTag = __webpack_require__(332);
	var getPrototypeOf = __webpack_require__(334);
	var ITERATOR = __webpack_require__(333)('iterator');
	var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
	var FF_ITERATOR = '@@iterator';
	var KEYS = 'keys';
	var VALUES = 'values';
	
	var returnThis = function () { return this; };
	
	module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function (kind) {
	    if (!BUGGY && kind in proto) return proto[kind];
	    switch (kind) {
	      case KEYS: return function keys() { return new Constructor(this, kind); };
	      case VALUES: return function values() { return new Constructor(this, kind); };
	    } return function entries() { return new Constructor(this, kind); };
	  };
	  var TAG = NAME + ' Iterator';
	  var DEF_VALUES = DEFAULT == VALUES;
	  var VALUES_BUG = false;
	  var proto = Base.prototype;
	  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
	  var $default = $native || getMethod(DEFAULT);
	  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
	  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
	  var methods, key, IteratorPrototype;
	  // Fix native
	  if ($anyNative) {
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
	    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if (DEF_VALUES && $native && $native.name !== VALUES) {
	    VALUES_BUG = true;
	    $default = function values() { return $native.call(this); };
	  }
	  // Define iterator
	  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG] = returnThis;
	  if (DEFAULT) {
	    methods = {
	      values: DEF_VALUES ? $default : getMethod(VALUES),
	      keys: IS_SET ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if (FORCED) for (key in methods) {
	      if (!(key in proto)) redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};


/***/ }),
/* 325 */
/***/ (function(module, exports) {

	module.exports = true;


/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(289);


/***/ }),
/* 327 */
/***/ (function(module, exports) {

	module.exports = {};


/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var create = __webpack_require__(329);
	var descriptor = __webpack_require__(298);
	var setToStringTag = __webpack_require__(332);
	var IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(289)(IteratorPrototype, __webpack_require__(333)('iterator'), function () { return this; });
	
	module.exports = function (Constructor, NAME, next) {
	  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
	  setToStringTag(Constructor, NAME + ' Iterator');
	};


/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject = __webpack_require__(291);
	var dPs = __webpack_require__(330);
	var enumBugKeys = __webpack_require__(314);
	var IE_PROTO = __webpack_require__(311)('IE_PROTO');
	var Empty = function () { /* empty */ };
	var PROTOTYPE = 'prototype';
	
	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function () {
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(296)('iframe');
	  var i = enumBugKeys.length;
	  var lt = '<';
	  var gt = '>';
	  var iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(331).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};
	
	module.exports = Object.create || function create(O, Properties) {
	  var result;
	  if (O !== null) {
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty();
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};


/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

	var dP = __webpack_require__(290);
	var anObject = __webpack_require__(291);
	var getKeys = __webpack_require__(300);
	
	module.exports = __webpack_require__(294) ? Object.defineProperties : function defineProperties(O, Properties) {
	  anObject(O);
	  var keys = getKeys(Properties);
	  var length = keys.length;
	  var i = 0;
	  var P;
	  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};


/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

	var document = __webpack_require__(285).document;
	module.exports = document && document.documentElement;


/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

	var def = __webpack_require__(290).f;
	var has = __webpack_require__(302);
	var TAG = __webpack_require__(333)('toStringTag');
	
	module.exports = function (it, tag, stat) {
	  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
	};


/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

	var store = __webpack_require__(312)('wks');
	var uid = __webpack_require__(313);
	var Symbol = __webpack_require__(285).Symbol;
	var USE_SYMBOL = typeof Symbol == 'function';
	
	var $exports = module.exports = function (name) {
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};
	
	$exports.store = store;


/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has = __webpack_require__(302);
	var toObject = __webpack_require__(317);
	var IE_PROTO = __webpack_require__(311)('IE_PROTO');
	var ObjectProto = Object.prototype;
	
	module.exports = Object.getPrototypeOf || function (O) {
	  O = toObject(O);
	  if (has(O, IE_PROTO)) return O[IE_PROTO];
	  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};


/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(336);
	var global = __webpack_require__(285);
	var hide = __webpack_require__(289);
	var Iterators = __webpack_require__(327);
	var TO_STRING_TAG = __webpack_require__(333)('toStringTag');
	
	var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
	  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
	  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
	  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
	  'TextTrackList,TouchList').split(',');
	
	for (var i = 0; i < DOMIterables.length; i++) {
	  var NAME = DOMIterables[i];
	  var Collection = global[NAME];
	  var proto = Collection && Collection.prototype;
	  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
	  Iterators[NAME] = Iterators.Array;
	}


/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(337);
	var step = __webpack_require__(338);
	var Iterators = __webpack_require__(327);
	var toIObject = __webpack_require__(303);
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(324)(Array, 'Array', function (iterated, kind) {
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function () {
	  var O = this._t;
	  var kind = this._k;
	  var index = this._i++;
	  if (!O || index >= O.length) {
	    this._t = undefined;
	    return step(1);
	  }
	  if (kind == 'keys') return step(0, index);
	  if (kind == 'values') return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');


/***/ }),
/* 337 */
/***/ (function(module, exports) {

	module.exports = function () { /* empty */ };


/***/ }),
/* 338 */
/***/ (function(module, exports) {

	module.exports = function (done, value) {
	  return { value: value, done: !!done };
	};


/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY = __webpack_require__(325);
	var global = __webpack_require__(285);
	var ctx = __webpack_require__(287);
	var classof = __webpack_require__(340);
	var $export = __webpack_require__(284);
	var isObject = __webpack_require__(292);
	var aFunction = __webpack_require__(288);
	var anInstance = __webpack_require__(341);
	var forOf = __webpack_require__(342);
	var speciesConstructor = __webpack_require__(346);
	var task = __webpack_require__(347).set;
	var microtask = __webpack_require__(349)();
	var newPromiseCapabilityModule = __webpack_require__(350);
	var perform = __webpack_require__(351);
	var promiseResolve = __webpack_require__(352);
	var PROMISE = 'Promise';
	var TypeError = global.TypeError;
	var process = global.process;
	var $Promise = global[PROMISE];
	var isNode = classof(process) == 'process';
	var empty = function () { /* empty */ };
	var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
	var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;
	
	var USE_NATIVE = !!function () {
	  try {
	    // correct subclassing with @@species support
	    var promise = $Promise.resolve(1);
	    var FakePromise = (promise.constructor = {})[__webpack_require__(333)('species')] = function (exec) {
	      exec(empty, empty);
	    };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
	  } catch (e) { /* empty */ }
	}();
	
	// helpers
	var isThenable = function (it) {
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var notify = function (promise, isReject) {
	  if (promise._n) return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function () {
	    var value = promise._v;
	    var ok = promise._s == 1;
	    var i = 0;
	    var run = function (reaction) {
	      var handler = ok ? reaction.ok : reaction.fail;
	      var resolve = reaction.resolve;
	      var reject = reaction.reject;
	      var domain = reaction.domain;
	      var result, then;
	      try {
	        if (handler) {
	          if (!ok) {
	            if (promise._h == 2) onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if (handler === true) result = value;
	          else {
	            if (domain) domain.enter();
	            result = handler(value);
	            if (domain) domain.exit();
	          }
	          if (result === reaction.promise) {
	            reject(TypeError('Promise-chain cycle'));
	          } else if (then = isThenable(result)) {
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch (e) {
	        reject(e);
	      }
	    };
	    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if (isReject && !promise._h) onUnhandled(promise);
	  });
	};
	var onUnhandled = function (promise) {
	  task.call(global, function () {
	    var value = promise._v;
	    var unhandled = isUnhandled(promise);
	    var result, handler, console;
	    if (unhandled) {
	      result = perform(function () {
	        if (isNode) {
	          process.emit('unhandledRejection', value, promise);
	        } else if (handler = global.onunhandledrejection) {
	          handler({ promise: promise, reason: value });
	        } else if ((console = global.console) && console.error) {
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if (unhandled && result.e) throw result.v;
	  });
	};
	var isUnhandled = function (promise) {
	  if (promise._h == 1) return false;
	  var chain = promise._a || promise._c;
	  var i = 0;
	  var reaction;
	  while (chain.length > i) {
	    reaction = chain[i++];
	    if (reaction.fail || !isUnhandled(reaction.promise)) return false;
	  } return true;
	};
	var onHandleUnhandled = function (promise) {
	  task.call(global, function () {
	    var handler;
	    if (isNode) {
	      process.emit('rejectionHandled', promise);
	    } else if (handler = global.onrejectionhandled) {
	      handler({ promise: promise, reason: promise._v });
	    }
	  });
	};
	var $reject = function (value) {
	  var promise = this;
	  if (promise._d) return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if (!promise._a) promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function (value) {
	  var promise = this;
	  var then;
	  if (promise._d) return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if (promise === value) throw TypeError("Promise can't be resolved itself");
	    if (then = isThenable(value)) {
	      microtask(function () {
	        var wrapper = { _w: promise, _d: false }; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch (e) {
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch (e) {
	    $reject.call({ _w: promise, _d: false }, e); // wrap
	  }
	};
	
	// constructor polyfill
	if (!USE_NATIVE) {
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor) {
	    anInstance(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	    } catch (err) {
	      $reject.call(this, err);
	    }
	  };
	  // eslint-disable-next-line no-unused-vars
	  Internal = function Promise(executor) {
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = __webpack_require__(353)($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected) {
	      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
	      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode ? process.domain : undefined;
	      this._c.push(reaction);
	      if (this._a) this._a.push(reaction);
	      if (this._s) notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function (onRejected) {
	      return this.then(undefined, onRejected);
	    }
	  });
	  OwnPromiseCapability = function () {
	    var promise = new Internal();
	    this.promise = promise;
	    this.resolve = ctx($resolve, promise, 1);
	    this.reject = ctx($reject, promise, 1);
	  };
	  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
	    return C === $Promise || C === Wrapper
	      ? new OwnPromiseCapability(C)
	      : newGenericPromiseCapability(C);
	  };
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
	__webpack_require__(332)($Promise, PROMISE);
	__webpack_require__(354)(PROMISE);
	Wrapper = __webpack_require__(286)[PROMISE];
	
	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r) {
	    var capability = newPromiseCapability(this);
	    var $$reject = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x) {
	    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(355)(function (iter) {
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable) {
	    var C = this;
	    var capability = newPromiseCapability(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = perform(function () {
	      var values = [];
	      var index = 0;
	      var remaining = 1;
	      forOf(iterable, false, function (promise) {
	        var $index = index++;
	        var alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function (value) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if (result.e) reject(result.v);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable) {
	    var C = this;
	    var capability = newPromiseCapability(C);
	    var reject = capability.reject;
	    var result = perform(function () {
	      forOf(iterable, false, function (promise) {
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if (result.e) reject(result.v);
	    return capability.promise;
	  }
	});


/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(305);
	var TAG = __webpack_require__(333)('toStringTag');
	// ES3 wrong here
	var ARG = cof(function () { return arguments; }()) == 'Arguments';
	
	// fallback for IE11 Script Access Denied error
	var tryGet = function (it, key) {
	  try {
	    return it[key];
	  } catch (e) { /* empty */ }
	};
	
	module.exports = function (it) {
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};


/***/ }),
/* 341 */
/***/ (function(module, exports) {

	module.exports = function (it, Constructor, name, forbiddenField) {
	  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};


/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

	var ctx = __webpack_require__(287);
	var call = __webpack_require__(343);
	var isArrayIter = __webpack_require__(344);
	var anObject = __webpack_require__(291);
	var toLength = __webpack_require__(308);
	var getIterFn = __webpack_require__(345);
	var BREAK = {};
	var RETURN = {};
	var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
	  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
	  var f = ctx(fn, that, entries ? 2 : 1);
	  var index = 0;
	  var length, step, iterator, result;
	  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
	    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if (result === BREAK || result === RETURN) return result;
	  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
	    result = call(iterator, f, step.value, entries);
	    if (result === BREAK || result === RETURN) return result;
	  }
	};
	exports.BREAK = BREAK;
	exports.RETURN = RETURN;


/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(291);
	module.exports = function (iterator, fn, value, entries) {
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch (e) {
	    var ret = iterator['return'];
	    if (ret !== undefined) anObject(ret.call(iterator));
	    throw e;
	  }
	};


/***/ }),
/* 344 */
/***/ (function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators = __webpack_require__(327);
	var ITERATOR = __webpack_require__(333)('iterator');
	var ArrayProto = Array.prototype;
	
	module.exports = function (it) {
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};


/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

	var classof = __webpack_require__(340);
	var ITERATOR = __webpack_require__(333)('iterator');
	var Iterators = __webpack_require__(327);
	module.exports = __webpack_require__(286).getIteratorMethod = function (it) {
	  if (it != undefined) return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};


/***/ }),
/* 346 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject = __webpack_require__(291);
	var aFunction = __webpack_require__(288);
	var SPECIES = __webpack_require__(333)('species');
	module.exports = function (O, D) {
	  var C = anObject(O).constructor;
	  var S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};


/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

	var ctx = __webpack_require__(287);
	var invoke = __webpack_require__(348);
	var html = __webpack_require__(331);
	var cel = __webpack_require__(296);
	var global = __webpack_require__(285);
	var process = global.process;
	var setTask = global.setImmediate;
	var clearTask = global.clearImmediate;
	var MessageChannel = global.MessageChannel;
	var Dispatch = global.Dispatch;
	var counter = 0;
	var queue = {};
	var ONREADYSTATECHANGE = 'onreadystatechange';
	var defer, channel, port;
	var run = function () {
	  var id = +this;
	  // eslint-disable-next-line no-prototype-builtins
	  if (queue.hasOwnProperty(id)) {
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function (event) {
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if (!setTask || !clearTask) {
	  setTask = function setImmediate(fn) {
	    var args = [];
	    var i = 1;
	    while (arguments.length > i) args.push(arguments[i++]);
	    queue[++counter] = function () {
	      // eslint-disable-next-line no-new-func
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id) {
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if (__webpack_require__(305)(process) == 'process') {
	    defer = function (id) {
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Sphere (JS game engine) Dispatch API
	  } else if (Dispatch && Dispatch.now) {
	    defer = function (id) {
	      Dispatch.now(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if (MessageChannel) {
	    channel = new MessageChannel();
	    port = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
	    defer = function (id) {
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listener, false);
	  // IE8-
	  } else if (ONREADYSTATECHANGE in cel('script')) {
	    defer = function (id) {
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function (id) {
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set: setTask,
	  clear: clearTask
	};


/***/ }),
/* 348 */
/***/ (function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function (fn, args, that) {
	  var un = that === undefined;
	  switch (args.length) {
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return fn.apply(that, args);
	};


/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(285);
	var macrotask = __webpack_require__(347).set;
	var Observer = global.MutationObserver || global.WebKitMutationObserver;
	var process = global.process;
	var Promise = global.Promise;
	var isNode = __webpack_require__(305)(process) == 'process';
	
	module.exports = function () {
	  var head, last, notify;
	
	  var flush = function () {
	    var parent, fn;
	    if (isNode && (parent = process.domain)) parent.exit();
	    while (head) {
	      fn = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch (e) {
	        if (head) notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if (parent) parent.enter();
	  };
	
	  // Node.js
	  if (isNode) {
	    notify = function () {
	      process.nextTick(flush);
	    };
	  // browsers with MutationObserver
	  } else if (Observer) {
	    var toggle = true;
	    var node = document.createTextNode('');
	    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
	    notify = function () {
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if (Promise && Promise.resolve) {
	    var promise = Promise.resolve();
	    notify = function () {
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function () {
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global, flush);
	    };
	  }
	
	  return function (fn) {
	    var task = { fn: fn, next: undefined };
	    if (last) last.next = task;
	    if (!head) {
	      head = task;
	      notify();
	    } last = task;
	  };
	};


/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 25.4.1.5 NewPromiseCapability(C)
	var aFunction = __webpack_require__(288);
	
	function PromiseCapability(C) {
	  var resolve, reject;
	  this.promise = new C(function ($$resolve, $$reject) {
	    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject = aFunction(reject);
	}
	
	module.exports.f = function (C) {
	  return new PromiseCapability(C);
	};


/***/ }),
/* 351 */
/***/ (function(module, exports) {

	module.exports = function (exec) {
	  try {
	    return { e: false, v: exec() };
	  } catch (e) {
	    return { e: true, v: e };
	  }
	};


/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

	var anObject = __webpack_require__(291);
	var isObject = __webpack_require__(292);
	var newPromiseCapability = __webpack_require__(350);
	
	module.exports = function (C, x) {
	  anObject(C);
	  if (isObject(x) && x.constructor === C) return x;
	  var promiseCapability = newPromiseCapability.f(C);
	  var resolve = promiseCapability.resolve;
	  resolve(x);
	  return promiseCapability.promise;
	};


/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

	var hide = __webpack_require__(289);
	module.exports = function (target, src, safe) {
	  for (var key in src) {
	    if (safe && target[key]) target[key] = src[key];
	    else hide(target, key, src[key]);
	  } return target;
	};


/***/ }),
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var global = __webpack_require__(285);
	var core = __webpack_require__(286);
	var dP = __webpack_require__(290);
	var DESCRIPTORS = __webpack_require__(294);
	var SPECIES = __webpack_require__(333)('species');
	
	module.exports = function (KEY) {
	  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
	  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
	    configurable: true,
	    get: function () { return this; }
	  });
	};


/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

	var ITERATOR = __webpack_require__(333)('iterator');
	var SAFE_CLOSING = false;
	
	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function () { SAFE_CLOSING = true; };
	  // eslint-disable-next-line no-throw-literal
	  Array.from(riter, function () { throw 2; });
	} catch (e) { /* empty */ }
	
	module.exports = function (exec, skipClosing) {
	  if (!skipClosing && !SAFE_CLOSING) return false;
	  var safe = false;
	  try {
	    var arr = [7];
	    var iter = arr[ITERATOR]();
	    iter.next = function () { return { done: safe = true }; };
	    arr[ITERATOR] = function () { return iter; };
	    exec(arr);
	  } catch (e) { /* empty */ }
	  return safe;
	};


/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-promise-finally
	'use strict';
	var $export = __webpack_require__(284);
	var core = __webpack_require__(286);
	var global = __webpack_require__(285);
	var speciesConstructor = __webpack_require__(346);
	var promiseResolve = __webpack_require__(352);
	
	$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
	  var C = speciesConstructor(this, core.Promise || global.Promise);
	  var isFunction = typeof onFinally == 'function';
	  return this.then(
	    isFunction ? function (x) {
	      return promiseResolve(C, onFinally()).then(function () { return x; });
	    } : onFinally,
	    isFunction ? function (e) {
	      return promiseResolve(C, onFinally()).then(function () { throw e; });
	    } : onFinally
	  );
	} });


/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/proposal-promise-try
	var $export = __webpack_require__(284);
	var newPromiseCapability = __webpack_require__(350);
	var perform = __webpack_require__(351);
	
	$export($export.S, 'Promise', { 'try': function (callbackfn) {
	  var promiseCapability = newPromiseCapability.f(this);
	  var result = perform(callbackfn);
	  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
	  return promiseCapability.promise;
	} });


/***/ }),
/* 358 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(359);

/***/ }),
/* 359 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(360);
	var bind = __webpack_require__(361);
	var Axios = __webpack_require__(362);
	var defaults = __webpack_require__(363);
	
	/**
	 * Create an instance of Axios
	 *
	 * @param {Object} defaultConfig The default config for the instance
	 * @return {Axios} A new instance of Axios
	 */
	function createInstance(defaultConfig) {
	  var context = new Axios(defaultConfig);
	  var instance = bind(Axios.prototype.request, context);
	
	  // Copy axios.prototype to instance
	  utils.extend(instance, Axios.prototype, context);
	
	  // Copy context to instance
	  utils.extend(instance, context);
	
	  return instance;
	}
	
	// Create the default instance to be exported
	var axios = createInstance(defaults);
	
	// Expose Axios class to allow class inheritance
	axios.Axios = Axios;
	
	// Factory for creating new instances
	axios.create = function create(instanceConfig) {
	  return createInstance(utils.merge(defaults, instanceConfig));
	};
	
	// Expose Cancel & CancelToken
	axios.Cancel = __webpack_require__(380);
	axios.CancelToken = __webpack_require__(381);
	axios.isCancel = __webpack_require__(377);
	
	// Expose all/spread
	axios.all = function all(promises) {
	  return Promise.all(promises);
	};
	axios.spread = __webpack_require__(382);
	
	module.exports = axios;
	
	// Allow use of default import syntax in TypeScript
	module.exports.default = axios;


/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var bind = __webpack_require__(361);
	
	/*global toString:true*/
	
	// utils is a library of generic helper functions non-specific to axios
	
	var toString = Object.prototype.toString;
	
	/**
	 * Determine if a value is an Array
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Array, otherwise false
	 */
	function isArray(val) {
	  return toString.call(val) === '[object Array]';
	}
	
	/**
	 * Determine if a value is an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
	 */
	function isArrayBuffer(val) {
	  return toString.call(val) === '[object ArrayBuffer]';
	}
	
	/**
	 * Determine if a value is a FormData
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an FormData, otherwise false
	 */
	function isFormData(val) {
	  return (typeof FormData !== 'undefined') && (val instanceof FormData);
	}
	
	/**
	 * Determine if a value is a view on an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
	 */
	function isArrayBufferView(val) {
	  var result;
	  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
	    result = ArrayBuffer.isView(val);
	  } else {
	    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
	  }
	  return result;
	}
	
	/**
	 * Determine if a value is a String
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a String, otherwise false
	 */
	function isString(val) {
	  return typeof val === 'string';
	}
	
	/**
	 * Determine if a value is a Number
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Number, otherwise false
	 */
	function isNumber(val) {
	  return typeof val === 'number';
	}
	
	/**
	 * Determine if a value is undefined
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if the value is undefined, otherwise false
	 */
	function isUndefined(val) {
	  return typeof val === 'undefined';
	}
	
	/**
	 * Determine if a value is an Object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Object, otherwise false
	 */
	function isObject(val) {
	  return val !== null && typeof val === 'object';
	}
	
	/**
	 * Determine if a value is a Date
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Date, otherwise false
	 */
	function isDate(val) {
	  return toString.call(val) === '[object Date]';
	}
	
	/**
	 * Determine if a value is a File
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a File, otherwise false
	 */
	function isFile(val) {
	  return toString.call(val) === '[object File]';
	}
	
	/**
	 * Determine if a value is a Blob
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Blob, otherwise false
	 */
	function isBlob(val) {
	  return toString.call(val) === '[object Blob]';
	}
	
	/**
	 * Determine if a value is a Function
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Function, otherwise false
	 */
	function isFunction(val) {
	  return toString.call(val) === '[object Function]';
	}
	
	/**
	 * Determine if a value is a Stream
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Stream, otherwise false
	 */
	function isStream(val) {
	  return isObject(val) && isFunction(val.pipe);
	}
	
	/**
	 * Determine if a value is a URLSearchParams object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
	 */
	function isURLSearchParams(val) {
	  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
	}
	
	/**
	 * Trim excess whitespace off the beginning and end of a string
	 *
	 * @param {String} str The String to trim
	 * @returns {String} The String freed of excess whitespace
	 */
	function trim(str) {
	  return str.replace(/^\s*/, '').replace(/\s*$/, '');
	}
	
	/**
	 * Determine if we're running in a standard browser environment
	 *
	 * This allows axios to run in a web worker, and react-native.
	 * Both environments support XMLHttpRequest, but not fully standard globals.
	 *
	 * web workers:
	 *  typeof window -> undefined
	 *  typeof document -> undefined
	 *
	 * react-native:
	 *  typeof document.createElement -> undefined
	 */
	function isStandardBrowserEnv() {
	  return (
	    typeof window !== 'undefined' &&
	    typeof document !== 'undefined' &&
	    typeof document.createElement === 'function'
	  );
	}
	
	/**
	 * Iterate over an Array or an Object invoking a function for each item.
	 *
	 * If `obj` is an Array callback will be called passing
	 * the value, index, and complete array for each item.
	 *
	 * If 'obj' is an Object callback will be called passing
	 * the value, key, and complete object for each property.
	 *
	 * @param {Object|Array} obj The object to iterate
	 * @param {Function} fn The callback to invoke for each item
	 */
	function forEach(obj, fn) {
	  // Don't bother if no value provided
	  if (obj === null || typeof obj === 'undefined') {
	    return;
	  }
	
	  // Force an array if not already something iterable
	  if (typeof obj !== 'object' && !isArray(obj)) {
	    /*eslint no-param-reassign:0*/
	    obj = [obj];
	  }
	
	  if (isArray(obj)) {
	    // Iterate over array values
	    for (var i = 0, l = obj.length; i < l; i++) {
	      fn.call(null, obj[i], i, obj);
	    }
	  } else {
	    // Iterate over object keys
	    for (var key in obj) {
	      if (Object.prototype.hasOwnProperty.call(obj, key)) {
	        fn.call(null, obj[key], key, obj);
	      }
	    }
	  }
	}
	
	/**
	 * Accepts varargs expecting each argument to be an object, then
	 * immutably merges the properties of each object and returns result.
	 *
	 * When multiple objects contain the same key the later object in
	 * the arguments list will take precedence.
	 *
	 * Example:
	 *
	 * ```js
	 * var result = merge({foo: 123}, {foo: 456});
	 * console.log(result.foo); // outputs 456
	 * ```
	 *
	 * @param {Object} obj1 Object to merge
	 * @returns {Object} Result of all merge properties
	 */
	function merge(/* obj1, obj2, obj3, ... */) {
	  var result = {};
	  function assignValue(val, key) {
	    if (typeof result[key] === 'object' && typeof val === 'object') {
	      result[key] = merge(result[key], val);
	    } else {
	      result[key] = val;
	    }
	  }
	
	  for (var i = 0, l = arguments.length; i < l; i++) {
	    forEach(arguments[i], assignValue);
	  }
	  return result;
	}
	
	/**
	 * Extends object a by mutably adding to it the properties of object b.
	 *
	 * @param {Object} a The object to be extended
	 * @param {Object} b The object to copy properties from
	 * @param {Object} thisArg The object to bind function to
	 * @return {Object} The resulting value of object a
	 */
	function extend(a, b, thisArg) {
	  forEach(b, function assignValue(val, key) {
	    if (thisArg && typeof val === 'function') {
	      a[key] = bind(val, thisArg);
	    } else {
	      a[key] = val;
	    }
	  });
	  return a;
	}
	
	module.exports = {
	  isArray: isArray,
	  isArrayBuffer: isArrayBuffer,
	  isFormData: isFormData,
	  isArrayBufferView: isArrayBufferView,
	  isString: isString,
	  isNumber: isNumber,
	  isObject: isObject,
	  isUndefined: isUndefined,
	  isDate: isDate,
	  isFile: isFile,
	  isBlob: isBlob,
	  isFunction: isFunction,
	  isStream: isStream,
	  isURLSearchParams: isURLSearchParams,
	  isStandardBrowserEnv: isStandardBrowserEnv,
	  forEach: forEach,
	  merge: merge,
	  extend: extend,
	  trim: trim
	};


/***/ }),
/* 361 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = function bind(fn, thisArg) {
	  return function wrap() {
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	    return fn.apply(thisArg, args);
	  };
	};


/***/ }),
/* 362 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var defaults = __webpack_require__(363);
	var utils = __webpack_require__(360);
	var InterceptorManager = __webpack_require__(374);
	var dispatchRequest = __webpack_require__(375);
	var isAbsoluteURL = __webpack_require__(378);
	var combineURLs = __webpack_require__(379);
	
	/**
	 * Create a new instance of Axios
	 *
	 * @param {Object} instanceConfig The default config for the instance
	 */
	function Axios(instanceConfig) {
	  this.defaults = instanceConfig;
	  this.interceptors = {
	    request: new InterceptorManager(),
	    response: new InterceptorManager()
	  };
	}
	
	/**
	 * Dispatch a request
	 *
	 * @param {Object} config The config specific for this request (merged with this.defaults)
	 */
	Axios.prototype.request = function request(config) {
	  /*eslint no-param-reassign:0*/
	  // Allow for axios('example/url'[, config]) a la fetch API
	  if (typeof config === 'string') {
	    config = utils.merge({
	      url: arguments[0]
	    }, arguments[1]);
	  }
	
	  config = utils.merge(defaults, this.defaults, { method: 'get' }, config);
	
	  // Support baseURL config
	  if (config.baseURL && !isAbsoluteURL(config.url)) {
	    config.url = combineURLs(config.baseURL, config.url);
	  }
	
	  // Hook up interceptors middleware
	  var chain = [dispatchRequest, undefined];
	  var promise = Promise.resolve(config);
	
	  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
	    chain.unshift(interceptor.fulfilled, interceptor.rejected);
	  });
	
	  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
	    chain.push(interceptor.fulfilled, interceptor.rejected);
	  });
	
	  while (chain.length) {
	    promise = promise.then(chain.shift(), chain.shift());
	  }
	
	  return promise;
	};
	
	// Provide aliases for supported request methods
	utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
	  /*eslint func-names:0*/
	  Axios.prototype[method] = function(url, config) {
	    return this.request(utils.merge(config || {}, {
	      method: method,
	      url: url
	    }));
	  };
	});
	
	utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  /*eslint func-names:0*/
	  Axios.prototype[method] = function(url, data, config) {
	    return this.request(utils.merge(config || {}, {
	      method: method,
	      url: url,
	      data: data
	    }));
	  };
	});
	
	module.exports = Axios;


/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var utils = __webpack_require__(360);
	var normalizeHeaderName = __webpack_require__(364);
	
	var PROTECTION_PREFIX = /^\)\]\}',?\n/;
	var DEFAULT_CONTENT_TYPE = {
	  'Content-Type': 'application/x-www-form-urlencoded'
	};
	
	function setContentTypeIfUnset(headers, value) {
	  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
	    headers['Content-Type'] = value;
	  }
	}
	
	function getDefaultAdapter() {
	  var adapter;
	  if (typeof XMLHttpRequest !== 'undefined') {
	    // For browsers use XHR adapter
	    adapter = __webpack_require__(365);
	  } else if (typeof process !== 'undefined') {
	    // For node use HTTP adapter
	    adapter = __webpack_require__(365);
	  }
	  return adapter;
	}
	
	var defaults = {
	  adapter: getDefaultAdapter(),
	
	  transformRequest: [function transformRequest(data, headers) {
	    normalizeHeaderName(headers, 'Content-Type');
	    if (utils.isFormData(data) ||
	      utils.isArrayBuffer(data) ||
	      utils.isStream(data) ||
	      utils.isFile(data) ||
	      utils.isBlob(data)
	    ) {
	      return data;
	    }
	    if (utils.isArrayBufferView(data)) {
	      return data.buffer;
	    }
	    if (utils.isURLSearchParams(data)) {
	      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
	      return data.toString();
	    }
	    if (utils.isObject(data)) {
	      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
	      return JSON.stringify(data);
	    }
	    return data;
	  }],
	
	  transformResponse: [function transformResponse(data) {
	    /*eslint no-param-reassign:0*/
	    if (typeof data === 'string') {
	      data = data.replace(PROTECTION_PREFIX, '');
	      try {
	        data = JSON.parse(data);
	      } catch (e) { /* Ignore */ }
	    }
	    return data;
	  }],
	
	  timeout: 0,
	
	  xsrfCookieName: 'XSRF-TOKEN',
	  xsrfHeaderName: 'X-XSRF-TOKEN',
	
	  maxContentLength: -1,
	
	  validateStatus: function validateStatus(status) {
	    return status >= 200 && status < 300;
	  }
	};
	
	defaults.headers = {
	  common: {
	    'Accept': 'application/json, text/plain, */*'
	  }
	};
	
	utils.forEach(['delete', 'get', 'head'], function forEachMehtodNoData(method) {
	  defaults.headers[method] = {};
	});
	
	utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
	});
	
	module.exports = defaults;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(360);
	
	module.exports = function normalizeHeaderName(headers, normalizedName) {
	  utils.forEach(headers, function processHeader(value, name) {
	    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
	      headers[normalizedName] = value;
	      delete headers[name];
	    }
	  });
	};


/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(360);
	var settle = __webpack_require__(366);
	var buildURL = __webpack_require__(369);
	var parseHeaders = __webpack_require__(370);
	var isURLSameOrigin = __webpack_require__(371);
	var createError = __webpack_require__(367);
	var btoa = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || __webpack_require__(372);
	
	module.exports = function xhrAdapter(config) {
	  return new Promise(function dispatchXhrRequest(resolve, reject) {
	    var requestData = config.data;
	    var requestHeaders = config.headers;
	
	    if (utils.isFormData(requestData)) {
	      delete requestHeaders['Content-Type']; // Let the browser set it
	    }
	
	    var request = new XMLHttpRequest();
	    var loadEvent = 'onreadystatechange';
	    var xDomain = false;
	
	    // For IE 8/9 CORS support
	    // Only supports POST and GET calls and doesn't returns the response headers.
	    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
	    if (("development") !== 'test' &&
	        typeof window !== 'undefined' &&
	        window.XDomainRequest && !('withCredentials' in request) &&
	        !isURLSameOrigin(config.url)) {
	      request = new window.XDomainRequest();
	      loadEvent = 'onload';
	      xDomain = true;
	      request.onprogress = function handleProgress() {};
	      request.ontimeout = function handleTimeout() {};
	    }
	
	    // HTTP basic authentication
	    if (config.auth) {
	      var username = config.auth.username || '';
	      var password = config.auth.password || '';
	      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
	    }
	
	    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);
	
	    // Set the request timeout in MS
	    request.timeout = config.timeout;
	
	    // Listen for ready state
	    request[loadEvent] = function handleLoad() {
	      if (!request || (request.readyState !== 4 && !xDomain)) {
	        return;
	      }
	
	      // The request errored out and we didn't get a response, this will be
	      // handled by onerror instead
	      // With one exception: request that using file: protocol, most browsers
	      // will return status as 0 even though it's a successful request
	      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
	        return;
	      }
	
	      // Prepare the response
	      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
	      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
	      var response = {
	        data: responseData,
	        // IE sends 1223 instead of 204 (https://github.com/mzabriskie/axios/issues/201)
	        status: request.status === 1223 ? 204 : request.status,
	        statusText: request.status === 1223 ? 'No Content' : request.statusText,
	        headers: responseHeaders,
	        config: config,
	        request: request
	      };
	
	      settle(resolve, reject, response);
	
	      // Clean up request
	      request = null;
	    };
	
	    // Handle low level network errors
	    request.onerror = function handleError() {
	      // Real errors are hidden from us by the browser
	      // onerror should only fire if it's a network error
	      reject(createError('Network Error', config));
	
	      // Clean up request
	      request = null;
	    };
	
	    // Handle timeout
	    request.ontimeout = function handleTimeout() {
	      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED'));
	
	      // Clean up request
	      request = null;
	    };
	
	    // Add xsrf header
	    // This is only done if running in a standard browser environment.
	    // Specifically not if we're in a web worker, or react-native.
	    if (utils.isStandardBrowserEnv()) {
	      var cookies = __webpack_require__(373);
	
	      // Add xsrf header
	      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?
	          cookies.read(config.xsrfCookieName) :
	          undefined;
	
	      if (xsrfValue) {
	        requestHeaders[config.xsrfHeaderName] = xsrfValue;
	      }
	    }
	
	    // Add headers to the request
	    if ('setRequestHeader' in request) {
	      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
	        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
	          // Remove Content-Type if data is undefined
	          delete requestHeaders[key];
	        } else {
	          // Otherwise add header to the request
	          request.setRequestHeader(key, val);
	        }
	      });
	    }
	
	    // Add withCredentials to request if needed
	    if (config.withCredentials) {
	      request.withCredentials = true;
	    }
	
	    // Add responseType to request if needed
	    if (config.responseType) {
	      try {
	        request.responseType = config.responseType;
	      } catch (e) {
	        if (request.responseType !== 'json') {
	          throw e;
	        }
	      }
	    }
	
	    // Handle progress if needed
	    if (typeof config.onDownloadProgress === 'function') {
	      request.addEventListener('progress', config.onDownloadProgress);
	    }
	
	    // Not all browsers support upload events
	    if (typeof config.onUploadProgress === 'function' && request.upload) {
	      request.upload.addEventListener('progress', config.onUploadProgress);
	    }
	
	    if (config.cancelToken) {
	      // Handle cancellation
	      config.cancelToken.promise.then(function onCanceled(cancel) {
	        if (!request) {
	          return;
	        }
	
	        request.abort();
	        reject(cancel);
	        // Clean up request
	        request = null;
	      });
	    }
	
	    if (requestData === undefined) {
	      requestData = null;
	    }
	
	    // Send the request
	    request.send(requestData);
	  });
	};


/***/ }),
/* 366 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var createError = __webpack_require__(367);
	
	/**
	 * Resolve or reject a Promise based on response status.
	 *
	 * @param {Function} resolve A function that resolves the promise.
	 * @param {Function} reject A function that rejects the promise.
	 * @param {object} response The response.
	 */
	module.exports = function settle(resolve, reject, response) {
	  var validateStatus = response.config.validateStatus;
	  // Note: status is not exposed by XDomainRequest
	  if (!response.status || !validateStatus || validateStatus(response.status)) {
	    resolve(response);
	  } else {
	    reject(createError(
	      'Request failed with status code ' + response.status,
	      response.config,
	      null,
	      response
	    ));
	  }
	};


/***/ }),
/* 367 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var enhanceError = __webpack_require__(368);
	
	/**
	 * Create an Error with the specified message, config, error code, and response.
	 *
	 * @param {string} message The error message.
	 * @param {Object} config The config.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 @ @param {Object} [response] The response.
	 * @returns {Error} The created error.
	 */
	module.exports = function createError(message, config, code, response) {
	  var error = new Error(message);
	  return enhanceError(error, config, code, response);
	};


/***/ }),
/* 368 */
/***/ (function(module, exports) {

	'use strict';
	
	/**
	 * Update an Error with the specified config, error code, and response.
	 *
	 * @param {Error} error The error to update.
	 * @param {Object} config The config.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 @ @param {Object} [response] The response.
	 * @returns {Error} The error.
	 */
	module.exports = function enhanceError(error, config, code, response) {
	  error.config = config;
	  if (code) {
	    error.code = code;
	  }
	  error.response = response;
	  return error;
	};


/***/ }),
/* 369 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(360);
	
	function encode(val) {
	  return encodeURIComponent(val).
	    replace(/%40/gi, '@').
	    replace(/%3A/gi, ':').
	    replace(/%24/g, '$').
	    replace(/%2C/gi, ',').
	    replace(/%20/g, '+').
	    replace(/%5B/gi, '[').
	    replace(/%5D/gi, ']');
	}
	
	/**
	 * Build a URL by appending params to the end
	 *
	 * @param {string} url The base of the url (e.g., http://www.google.com)
	 * @param {object} [params] The params to be appended
	 * @returns {string} The formatted url
	 */
	module.exports = function buildURL(url, params, paramsSerializer) {
	  /*eslint no-param-reassign:0*/
	  if (!params) {
	    return url;
	  }
	
	  var serializedParams;
	  if (paramsSerializer) {
	    serializedParams = paramsSerializer(params);
	  } else if (utils.isURLSearchParams(params)) {
	    serializedParams = params.toString();
	  } else {
	    var parts = [];
	
	    utils.forEach(params, function serialize(val, key) {
	      if (val === null || typeof val === 'undefined') {
	        return;
	      }
	
	      if (utils.isArray(val)) {
	        key = key + '[]';
	      }
	
	      if (!utils.isArray(val)) {
	        val = [val];
	      }
	
	      utils.forEach(val, function parseValue(v) {
	        if (utils.isDate(v)) {
	          v = v.toISOString();
	        } else if (utils.isObject(v)) {
	          v = JSON.stringify(v);
	        }
	        parts.push(encode(key) + '=' + encode(v));
	      });
	    });
	
	    serializedParams = parts.join('&');
	  }
	
	  if (serializedParams) {
	    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
	  }
	
	  return url;
	};


/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(360);
	
	/**
	 * Parse headers into an object
	 *
	 * ```
	 * Date: Wed, 27 Aug 2014 08:58:49 GMT
	 * Content-Type: application/json
	 * Connection: keep-alive
	 * Transfer-Encoding: chunked
	 * ```
	 *
	 * @param {String} headers Headers needing to be parsed
	 * @returns {Object} Headers parsed into an object
	 */
	module.exports = function parseHeaders(headers) {
	  var parsed = {};
	  var key;
	  var val;
	  var i;
	
	  if (!headers) { return parsed; }
	
	  utils.forEach(headers.split('\n'), function parser(line) {
	    i = line.indexOf(':');
	    key = utils.trim(line.substr(0, i)).toLowerCase();
	    val = utils.trim(line.substr(i + 1));
	
	    if (key) {
	      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
	    }
	  });
	
	  return parsed;
	};


/***/ }),
/* 371 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(360);
	
	module.exports = (
	  utils.isStandardBrowserEnv() ?
	
	  // Standard browser envs have full support of the APIs needed to test
	  // whether the request URL is of the same origin as current location.
	  (function standardBrowserEnv() {
	    var msie = /(msie|trident)/i.test(navigator.userAgent);
	    var urlParsingNode = document.createElement('a');
	    var originURL;
	
	    /**
	    * Parse a URL to discover it's components
	    *
	    * @param {String} url The URL to be parsed
	    * @returns {Object}
	    */
	    function resolveURL(url) {
	      var href = url;
	
	      if (msie) {
	        // IE needs attribute set twice to normalize properties
	        urlParsingNode.setAttribute('href', href);
	        href = urlParsingNode.href;
	      }
	
	      urlParsingNode.setAttribute('href', href);
	
	      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
	      return {
	        href: urlParsingNode.href,
	        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
	        host: urlParsingNode.host,
	        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
	        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
	        hostname: urlParsingNode.hostname,
	        port: urlParsingNode.port,
	        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
	                  urlParsingNode.pathname :
	                  '/' + urlParsingNode.pathname
	      };
	    }
	
	    originURL = resolveURL(window.location.href);
	
	    /**
	    * Determine if a URL shares the same origin as the current location
	    *
	    * @param {String} requestURL The URL to test
	    * @returns {boolean} True if URL shares the same origin, otherwise false
	    */
	    return function isURLSameOrigin(requestURL) {
	      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
	      return (parsed.protocol === originURL.protocol &&
	            parsed.host === originURL.host);
	    };
	  })() :
	
	  // Non standard browser envs (web workers, react-native) lack needed support.
	  (function nonStandardBrowserEnv() {
	    return function isURLSameOrigin() {
	      return true;
	    };
	  })()
	);


/***/ }),
/* 372 */
/***/ (function(module, exports) {

	'use strict';
	
	// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js
	
	var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
	
	function E() {
	  this.message = 'String contains an invalid character';
	}
	E.prototype = new Error;
	E.prototype.code = 5;
	E.prototype.name = 'InvalidCharacterError';
	
	function btoa(input) {
	  var str = String(input);
	  var output = '';
	  for (
	    // initialize result and counter
	    var block, charCode, idx = 0, map = chars;
	    // if the next str index does not exist:
	    //   change the mapping table to "="
	    //   check if d has no fractional digits
	    str.charAt(idx | 0) || (map = '=', idx % 1);
	    // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
	    output += map.charAt(63 & block >> 8 - idx % 1 * 8)
	  ) {
	    charCode = str.charCodeAt(idx += 3 / 4);
	    if (charCode > 0xFF) {
	      throw new E();
	    }
	    block = block << 8 | charCode;
	  }
	  return output;
	}
	
	module.exports = btoa;


/***/ }),
/* 373 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(360);
	
	module.exports = (
	  utils.isStandardBrowserEnv() ?
	
	  // Standard browser envs support document.cookie
	  (function standardBrowserEnv() {
	    return {
	      write: function write(name, value, expires, path, domain, secure) {
	        var cookie = [];
	        cookie.push(name + '=' + encodeURIComponent(value));
	
	        if (utils.isNumber(expires)) {
	          cookie.push('expires=' + new Date(expires).toGMTString());
	        }
	
	        if (utils.isString(path)) {
	          cookie.push('path=' + path);
	        }
	
	        if (utils.isString(domain)) {
	          cookie.push('domain=' + domain);
	        }
	
	        if (secure === true) {
	          cookie.push('secure');
	        }
	
	        document.cookie = cookie.join('; ');
	      },
	
	      read: function read(name) {
	        var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
	        return (match ? decodeURIComponent(match[3]) : null);
	      },
	
	      remove: function remove(name) {
	        this.write(name, '', Date.now() - 86400000);
	      }
	    };
	  })() :
	
	  // Non standard browser env (web workers, react-native) lack needed support.
	  (function nonStandardBrowserEnv() {
	    return {
	      write: function write() {},
	      read: function read() { return null; },
	      remove: function remove() {}
	    };
	  })()
	);


/***/ }),
/* 374 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(360);
	
	function InterceptorManager() {
	  this.handlers = [];
	}
	
	/**
	 * Add a new interceptor to the stack
	 *
	 * @param {Function} fulfilled The function to handle `then` for a `Promise`
	 * @param {Function} rejected The function to handle `reject` for a `Promise`
	 *
	 * @return {Number} An ID used to remove interceptor later
	 */
	InterceptorManager.prototype.use = function use(fulfilled, rejected) {
	  this.handlers.push({
	    fulfilled: fulfilled,
	    rejected: rejected
	  });
	  return this.handlers.length - 1;
	};
	
	/**
	 * Remove an interceptor from the stack
	 *
	 * @param {Number} id The ID that was returned by `use`
	 */
	InterceptorManager.prototype.eject = function eject(id) {
	  if (this.handlers[id]) {
	    this.handlers[id] = null;
	  }
	};
	
	/**
	 * Iterate over all the registered interceptors
	 *
	 * This method is particularly useful for skipping over any
	 * interceptors that may have become `null` calling `eject`.
	 *
	 * @param {Function} fn The function to call for each interceptor
	 */
	InterceptorManager.prototype.forEach = function forEach(fn) {
	  utils.forEach(this.handlers, function forEachHandler(h) {
	    if (h !== null) {
	      fn(h);
	    }
	  });
	};
	
	module.exports = InterceptorManager;


/***/ }),
/* 375 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(360);
	var transformData = __webpack_require__(376);
	var isCancel = __webpack_require__(377);
	var defaults = __webpack_require__(363);
	
	/**
	 * Throws a `Cancel` if cancellation has been requested.
	 */
	function throwIfCancellationRequested(config) {
	  if (config.cancelToken) {
	    config.cancelToken.throwIfRequested();
	  }
	}
	
	/**
	 * Dispatch a request to the server using the configured adapter.
	 *
	 * @param {object} config The config that is to be used for the request
	 * @returns {Promise} The Promise to be fulfilled
	 */
	module.exports = function dispatchRequest(config) {
	  throwIfCancellationRequested(config);
	
	  // Ensure headers exist
	  config.headers = config.headers || {};
	
	  // Transform request data
	  config.data = transformData(
	    config.data,
	    config.headers,
	    config.transformRequest
	  );
	
	  // Flatten headers
	  config.headers = utils.merge(
	    config.headers.common || {},
	    config.headers[config.method] || {},
	    config.headers || {}
	  );
	
	  utils.forEach(
	    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
	    function cleanHeaderConfig(method) {
	      delete config.headers[method];
	    }
	  );
	
	  var adapter = config.adapter || defaults.adapter;
	
	  return adapter(config).then(function onAdapterResolution(response) {
	    throwIfCancellationRequested(config);
	
	    // Transform response data
	    response.data = transformData(
	      response.data,
	      response.headers,
	      config.transformResponse
	    );
	
	    return response;
	  }, function onAdapterRejection(reason) {
	    if (!isCancel(reason)) {
	      throwIfCancellationRequested(config);
	
	      // Transform response data
	      if (reason && reason.response) {
	        reason.response.data = transformData(
	          reason.response.data,
	          reason.response.headers,
	          config.transformResponse
	        );
	      }
	    }
	
	    return Promise.reject(reason);
	  });
	};


/***/ }),
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(360);
	
	/**
	 * Transform the data for a request or a response
	 *
	 * @param {Object|String} data The data to be transformed
	 * @param {Array} headers The headers for the request or response
	 * @param {Array|Function} fns A single function or Array of functions
	 * @returns {*} The resulting transformed data
	 */
	module.exports = function transformData(data, headers, fns) {
	  /*eslint no-param-reassign:0*/
	  utils.forEach(fns, function transform(fn) {
	    data = fn(data, headers);
	  });
	
	  return data;
	};


/***/ }),
/* 377 */
/***/ (function(module, exports) {

	'use strict';
	
	module.exports = function isCancel(value) {
	  return !!(value && value.__CANCEL__);
	};


/***/ }),
/* 378 */
/***/ (function(module, exports) {

	'use strict';
	
	/**
	 * Determines whether the specified URL is absolute
	 *
	 * @param {string} url The URL to test
	 * @returns {boolean} True if the specified URL is absolute, otherwise false
	 */
	module.exports = function isAbsoluteURL(url) {
	  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
	  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
	  // by any combination of letters, digits, plus, period, or hyphen.
	  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
	};


/***/ }),
/* 379 */
/***/ (function(module, exports) {

	'use strict';
	
	/**
	 * Creates a new URL by combining the specified URLs
	 *
	 * @param {string} baseURL The base URL
	 * @param {string} relativeURL The relative URL
	 * @returns {string} The combined URL
	 */
	module.exports = function combineURLs(baseURL, relativeURL) {
	  return baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '');
	};


/***/ }),
/* 380 */
/***/ (function(module, exports) {

	'use strict';
	
	/**
	 * A `Cancel` is an object that is thrown when an operation is canceled.
	 *
	 * @class
	 * @param {string=} message The message.
	 */
	function Cancel(message) {
	  this.message = message;
	}
	
	Cancel.prototype.toString = function toString() {
	  return 'Cancel' + (this.message ? ': ' + this.message : '');
	};
	
	Cancel.prototype.__CANCEL__ = true;
	
	module.exports = Cancel;


/***/ }),
/* 381 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var Cancel = __webpack_require__(380);
	
	/**
	 * A `CancelToken` is an object that can be used to request cancellation of an operation.
	 *
	 * @class
	 * @param {Function} executor The executor function.
	 */
	function CancelToken(executor) {
	  if (typeof executor !== 'function') {
	    throw new TypeError('executor must be a function.');
	  }
	
	  var resolvePromise;
	  this.promise = new Promise(function promiseExecutor(resolve) {
	    resolvePromise = resolve;
	  });
	
	  var token = this;
	  executor(function cancel(message) {
	    if (token.reason) {
	      // Cancellation has already been requested
	      return;
	    }
	
	    token.reason = new Cancel(message);
	    resolvePromise(token.reason);
	  });
	}
	
	/**
	 * Throws a `Cancel` if cancellation has been requested.
	 */
	CancelToken.prototype.throwIfRequested = function throwIfRequested() {
	  if (this.reason) {
	    throw this.reason;
	  }
	};
	
	/**
	 * Returns an object that contains a new `CancelToken` and a function that, when called,
	 * cancels the `CancelToken`.
	 */
	CancelToken.source = function source() {
	  var cancel;
	  var token = new CancelToken(function executor(c) {
	    cancel = c;
	  });
	  return {
	    token: token,
	    cancel: cancel
	  };
	};
	
	module.exports = CancelToken;


/***/ }),
/* 382 */
/***/ (function(module, exports) {

	'use strict';
	
	/**
	 * Syntactic sugar for invoking a function and expanding an array for arguments.
	 *
	 * Common use case would be to use `Function.prototype.apply`.
	 *
	 *  ```js
	 *  function f(x, y, z) {}
	 *  var args = [1, 2, 3];
	 *  f.apply(null, args);
	 *  ```
	 *
	 * With `spread` this example can be re-written.
	 *
	 *  ```js
	 *  spread(function(x, y, z) {})([1, 2, 3]);
	 *  ```
	 *
	 * @param {Function} callback
	 * @returns {Function}
	 */
	module.exports = function spread(callback) {
	  return function wrap(arr) {
	    return callback.apply(null, arr);
	  };
	};


/***/ }),
/* 383 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(384);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(388);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(389);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(393);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(410);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRouter = __webpack_require__(202);
	
	var _reactRedux = __webpack_require__(418);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var AppContainer = function (_Component) {
	  (0, _inherits3.default)(AppContainer, _Component);
	
	  function AppContainer() {
	    (0, _classCallCheck3.default)(this, AppContainer);
	    return (0, _possibleConstructorReturn3.default)(this, (AppContainer.__proto__ || (0, _getPrototypeOf2.default)(AppContainer)).apply(this, arguments));
	  }
	
	  (0, _createClass3.default)(AppContainer, [{
	    key: 'render',
	    value: function render() {
	      var _props = this.props,
	          history = _props.history,
	          routes = _props.routes,
	          store = _props.store;
	
	      return _react2.default.createElement(
	        _reactRedux.Provider,
	        { store: store },
	        _react2.default.createElement(
	          'div',
	          { style: { height: '100%' } },
	          _react2.default.createElement(_reactRouter.Router, { history: history, children: routes })
	        )
	      );
	    }
	  }]);
	  return AppContainer;
	}(_react.Component);
	
	AppContainer.propTypes = {
	  history: _react.PropTypes.object.isRequired,
	  routes: _react.PropTypes.object.isRequired,
	  store: _react.PropTypes.object.isRequired
	};
	exports.default = AppContainer;

/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(385), __esModule: true };

/***/ }),
/* 385 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(386);
	module.exports = __webpack_require__(286).Object.getPrototypeOf;


/***/ }),
/* 386 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.9 Object.getPrototypeOf(O)
	var toObject = __webpack_require__(317);
	var $getPrototypeOf = __webpack_require__(334);
	
	__webpack_require__(387)('getPrototypeOf', function () {
	  return function getPrototypeOf(it) {
	    return $getPrototypeOf(toObject(it));
	  };
	});


/***/ }),
/* 387 */
/***/ (function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(284);
	var core = __webpack_require__(286);
	var fails = __webpack_require__(295);
	module.exports = function (KEY, exec) {
	  var fn = (core.Object || {})[KEY] || Object[KEY];
	  var exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
	};


/***/ }),
/* 388 */
/***/ (function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	
	exports.default = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

/***/ }),
/* 389 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _defineProperty = __webpack_require__(390);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
	    }
	  }
	
	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

/***/ }),
/* 390 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(391), __esModule: true };

/***/ }),
/* 391 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(392);
	var $Object = __webpack_require__(286).Object;
	module.exports = function defineProperty(it, key, desc) {
	  return $Object.defineProperty(it, key, desc);
	};


/***/ }),
/* 392 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(284);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(294), 'Object', { defineProperty: __webpack_require__(290).f });


/***/ }),
/* 393 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _typeof2 = __webpack_require__(394);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }
	
	  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
	};

/***/ }),
/* 394 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _iterator = __webpack_require__(395);
	
	var _iterator2 = _interopRequireDefault(_iterator);
	
	var _symbol = __webpack_require__(398);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
	} : function (obj) {
	  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
	};

/***/ }),
/* 395 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(396), __esModule: true };

/***/ }),
/* 396 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(322);
	__webpack_require__(335);
	module.exports = __webpack_require__(397).f('iterator');


/***/ }),
/* 397 */
/***/ (function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(333);


/***/ }),
/* 398 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(399), __esModule: true };

/***/ }),
/* 399 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(400);
	__webpack_require__(321);
	__webpack_require__(408);
	__webpack_require__(409);
	module.exports = __webpack_require__(286).Symbol;


/***/ }),
/* 400 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global = __webpack_require__(285);
	var has = __webpack_require__(302);
	var DESCRIPTORS = __webpack_require__(294);
	var $export = __webpack_require__(284);
	var redefine = __webpack_require__(326);
	var META = __webpack_require__(401).KEY;
	var $fails = __webpack_require__(295);
	var shared = __webpack_require__(312);
	var setToStringTag = __webpack_require__(332);
	var uid = __webpack_require__(313);
	var wks = __webpack_require__(333);
	var wksExt = __webpack_require__(397);
	var wksDefine = __webpack_require__(402);
	var enumKeys = __webpack_require__(403);
	var isArray = __webpack_require__(404);
	var anObject = __webpack_require__(291);
	var toIObject = __webpack_require__(303);
	var toPrimitive = __webpack_require__(297);
	var createDesc = __webpack_require__(298);
	var _create = __webpack_require__(329);
	var gOPNExt = __webpack_require__(405);
	var $GOPD = __webpack_require__(407);
	var $DP = __webpack_require__(290);
	var $keys = __webpack_require__(300);
	var gOPD = $GOPD.f;
	var dP = $DP.f;
	var gOPN = gOPNExt.f;
	var $Symbol = global.Symbol;
	var $JSON = global.JSON;
	var _stringify = $JSON && $JSON.stringify;
	var PROTOTYPE = 'prototype';
	var HIDDEN = wks('_hidden');
	var TO_PRIMITIVE = wks('toPrimitive');
	var isEnum = {}.propertyIsEnumerable;
	var SymbolRegistry = shared('symbol-registry');
	var AllSymbols = shared('symbols');
	var OPSymbols = shared('op-symbols');
	var ObjectProto = Object[PROTOTYPE];
	var USE_NATIVE = typeof $Symbol == 'function';
	var QObject = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
	
	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function () {
	  return _create(dP({}, 'a', {
	    get: function () { return dP(this, 'a', { value: 7 }).a; }
	  })).a != 7;
	}) ? function (it, key, D) {
	  var protoDesc = gOPD(ObjectProto, key);
	  if (protoDesc) delete ObjectProto[key];
	  dP(it, key, D);
	  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
	} : dP;
	
	var wrap = function (tag) {
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};
	
	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
	  return typeof it == 'symbol';
	} : function (it) {
	  return it instanceof $Symbol;
	};
	
	var $defineProperty = function defineProperty(it, key, D) {
	  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if (has(AllSymbols, key)) {
	    if (!D.enumerable) {
	      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
	      D = _create(D, { enumerable: createDesc(0, false) });
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P) {
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P));
	  var i = 0;
	  var l = keys.length;
	  var key;
	  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P) {
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key) {
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
	  it = toIObject(it);
	  key = toPrimitive(key, true);
	  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
	  var D = gOPD(it, key);
	  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it) {
	  var names = gOPN(toIObject(it));
	  var result = [];
	  var i = 0;
	  var key;
	  while (names.length > i) {
	    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
	  var IS_OP = it === ObjectProto;
	  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
	  var result = [];
	  var i = 0;
	  var key;
	  while (names.length > i) {
	    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
	  } return result;
	};
	
	// 19.4.1.1 Symbol([description])
	if (!USE_NATIVE) {
	  $Symbol = function Symbol() {
	    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function (value) {
	      if (this === ObjectProto) $set.call(OPSymbols, value);
	      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
	    return this._k;
	  });
	
	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f = $defineProperty;
	  __webpack_require__(406).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(316).f = $propertyIsEnumerable;
	  __webpack_require__(315).f = $getOwnPropertySymbols;
	
	  if (DESCRIPTORS && !__webpack_require__(325)) {
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	
	  wksExt.f = function (name) {
	    return wrap(wks(name));
	  };
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });
	
	for (var es6Symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);
	
	for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);
	
	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function (key) {
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(sym) {
	    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
	    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
	  },
	  useSetter: function () { setter = true; },
	  useSimple: function () { setter = false; }
	});
	
	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});
	
	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it) {
	    if (it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
	    var args = [it];
	    var i = 1;
	    var replacer, $replacer;
	    while (arguments.length > i) args.push(arguments[i++]);
	    replacer = args[1];
	    if (typeof replacer == 'function') $replacer = replacer;
	    if ($replacer || !isArray(replacer)) replacer = function (key, value) {
	      if ($replacer) value = $replacer.call(this, key, value);
	      if (!isSymbol(value)) return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});
	
	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(289)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);


/***/ }),
/* 401 */
/***/ (function(module, exports, __webpack_require__) {

	var META = __webpack_require__(313)('meta');
	var isObject = __webpack_require__(292);
	var has = __webpack_require__(302);
	var setDesc = __webpack_require__(290).f;
	var id = 0;
	var isExtensible = Object.isExtensible || function () {
	  return true;
	};
	var FREEZE = !__webpack_require__(295)(function () {
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function (it) {
	  setDesc(it, META, { value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  } });
	};
	var fastKey = function (it, create) {
	  // return primitive with prefix
	  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if (!has(it, META)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) return 'F';
	    // not necessary to add metadata
	    if (!create) return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function (it, create) {
	  if (!has(it, META)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) return true;
	    // not necessary to add metadata
	    if (!create) return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function (it) {
	  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY: META,
	  NEED: false,
	  fastKey: fastKey,
	  getWeak: getWeak,
	  onFreeze: onFreeze
	};


/***/ }),
/* 402 */
/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(285);
	var core = __webpack_require__(286);
	var LIBRARY = __webpack_require__(325);
	var wksExt = __webpack_require__(397);
	var defineProperty = __webpack_require__(290).f;
	module.exports = function (name) {
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
	};


/***/ }),
/* 403 */
/***/ (function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(300);
	var gOPS = __webpack_require__(315);
	var pIE = __webpack_require__(316);
	module.exports = function (it) {
	  var result = getKeys(it);
	  var getSymbols = gOPS.f;
	  if (getSymbols) {
	    var symbols = getSymbols(it);
	    var isEnum = pIE.f;
	    var i = 0;
	    var key;
	    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
	  } return result;
	};


/***/ }),
/* 404 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(305);
	module.exports = Array.isArray || function isArray(arg) {
	  return cof(arg) == 'Array';
	};


/***/ }),
/* 405 */
/***/ (function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(303);
	var gOPN = __webpack_require__(406).f;
	var toString = {}.toString;
	
	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];
	
	var getWindowNames = function (it) {
	  try {
	    return gOPN(it);
	  } catch (e) {
	    return windowNames.slice();
	  }
	};
	
	module.exports.f = function getOwnPropertyNames(it) {
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ }),
/* 406 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys = __webpack_require__(301);
	var hiddenKeys = __webpack_require__(314).concat('length', 'prototype');
	
	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
	  return $keys(O, hiddenKeys);
	};


/***/ }),
/* 407 */
/***/ (function(module, exports, __webpack_require__) {

	var pIE = __webpack_require__(316);
	var createDesc = __webpack_require__(298);
	var toIObject = __webpack_require__(303);
	var toPrimitive = __webpack_require__(297);
	var has = __webpack_require__(302);
	var IE8_DOM_DEFINE = __webpack_require__(293);
	var gOPD = Object.getOwnPropertyDescriptor;
	
	exports.f = __webpack_require__(294) ? gOPD : function getOwnPropertyDescriptor(O, P) {
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if (IE8_DOM_DEFINE) try {
	    return gOPD(O, P);
	  } catch (e) { /* empty */ }
	  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
	};


/***/ }),
/* 408 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(402)('asyncIterator');


/***/ }),
/* 409 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(402)('observable');


/***/ }),
/* 410 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _setPrototypeOf = __webpack_require__(411);
	
	var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);
	
	var _create = __webpack_require__(415);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _typeof2 = __webpack_require__(394);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
	  }
	
	  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
	};

/***/ }),
/* 411 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(412), __esModule: true };

/***/ }),
/* 412 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(413);
	module.exports = __webpack_require__(286).Object.setPrototypeOf;


/***/ }),
/* 413 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(284);
	$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(414).set });


/***/ }),
/* 414 */
/***/ (function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(292);
	var anObject = __webpack_require__(291);
	var check = function (O, proto) {
	  anObject(O);
	  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function (test, buggy, set) {
	      try {
	        set = __webpack_require__(287)(Function.call, __webpack_require__(407).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch (e) { buggy = true; }
	      return function setPrototypeOf(O, proto) {
	        check(O, proto);
	        if (buggy) O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};


/***/ }),
/* 415 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(416), __esModule: true };

/***/ }),
/* 416 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(417);
	var $Object = __webpack_require__(286).Object;
	module.exports = function create(P, D) {
	  return $Object.create(P, D);
	};


/***/ }),
/* 417 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(284);
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', { create: __webpack_require__(329) });


/***/ }),
/* 418 */,
/* 419 */,
/* 420 */,
/* 421 */,
/* 422 */,
/* 423 */,
/* 424 */,
/* 425 */,
/* 426 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.createRoutes = undefined;
	
	var _CoreLayout = __webpack_require__(427);
	
	var _CoreLayout2 = _interopRequireDefault(_CoreLayout);
	
	var _Dashboard = __webpack_require__(442);
	
	var _Dashboard2 = _interopRequireDefault(_Dashboard);
	
	var _Team = __webpack_require__(526);
	
	var _Team2 = _interopRequireDefault(_Team);
	
	var _Player = __webpack_require__(569);
	
	var _Player2 = _interopRequireDefault(_Player);
	
	var _Ground = __webpack_require__(575);
	
	var _Ground2 = _interopRequireDefault(_Ground);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*  Note: Instead of using JSX, we recommend using react-router
	    PlainRoute objects to build route definitions.   */
	
	var createRoutes = exports.createRoutes = function createRoutes(store) {
	  return {
	    path: '/',
	    component: _CoreLayout2.default,
	    indexRoute: _Dashboard2.default,
	    childRoutes: [_Team2.default, _Player2.default, _Ground2.default]
	  };
	}; // We only need to import the modules necessary for initial render
	exports.default = createRoutes;

/***/ }),
/* 427 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.CoreLayout = undefined;
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Header = __webpack_require__(428);
	
	var _Header2 = _interopRequireDefault(_Header);
	
	var _Loader = __webpack_require__(435);
	
	var _Loader2 = _interopRequireDefault(_Loader);
	
	var _CoreLayout = __webpack_require__(438);
	
	var _CoreLayout2 = _interopRequireDefault(_CoreLayout);
	
	__webpack_require__(440);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var CoreLayout = exports.CoreLayout = function CoreLayout(_ref) {
	  var children = _ref.children;
	  return _react2.default.createElement(
	    'div',
	    { className: _CoreLayout2.default.wrapper + ' full-size' },
	    _react2.default.createElement(_Header2.default, null),
	    _react2.default.createElement(_Loader2.default, null),
	    _react2.default.createElement(
	      'div',
	      { className: 'mainContainer full-size' },
	      children
	    )
	  );
	};
	
	CoreLayout.propTypes = {
	  children: _react2.default.PropTypes.element.isRequired
	};
	
	exports.default = CoreLayout;

/***/ }),
/* 428 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Header = __webpack_require__(429);
	
	var _Header2 = _interopRequireDefault(_Header);
	
	var _iplLogo = __webpack_require__(433);
	
	var _iplLogo2 = _interopRequireDefault(_iplLogo);
	
	var _appLogo = __webpack_require__(434);
	
	var _appLogo2 = _interopRequireDefault(_appLogo);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Header = function Header(props, context) {
	  var navigate = function navigate(link) {
	    return function () {
	      context.router.push(link);
	    };
	  };
	  return _react2.default.createElement(
	    'div',
	    { className: _Header2.default.container + ' full-width' },
	    _react2.default.createElement('img', { onClick: navigate('/'), className: _Header2.default.logo, src: _iplLogo2.default, alt: 'Home' }),
	    _react2.default.createElement('img', { className: _Header2.default.appLogo, src: _appLogo2.default })
	  );
	};
	
	Header.contextTypes = {
	  router: _react2.default.PropTypes.object.isRequired
	};
	
	exports.default = Header;

/***/ }),
/* 429 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(430);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(432)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(true) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept(430, function() {
				var newContent = __webpack_require__(430);
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 430 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(431)();
	// imports
	
	
	// module
	exports.push([module.id, ".Header__container___izfMl{height:50px;z-index:2;box-shadow:0 0 5px 0 rgba(0,0,0,.25);display:-ms-flexbox;display:flex;-ms-flex-pack:justify;justify-content:space-between;-ms-flex-align:center;align-items:center;padding:20px;position:fixed;top:0;left:0;background-color:#fff}.Header__container___izfMl .Header__headerText___3k_wl{color:#172376;font-size:18px}.Header__container___izfMl .Header__logo___1AtfL{width:60px;cursor:pointer}.Header__container___izfMl .Header__appLogo___3vaD9{width:350px}@media screen and (max-width:768px){.Header__container___izfMl .Header__appLogo___3vaD9{width:270px}}", "", {"version":3,"sources":["/./src/components/Header/src/components/Header/Header.scss","/./src/components/Header/src/styles/variables.scss"],"names":[],"mappings":"AAEA,2BACE,YAAa,UACF,qCACe,oBAC1B,aAAc,sBACd,8BAA+B,sBAC/B,mBAAoB,aACN,eACE,MACT,OACC,qBCRW,CDFrB,uDAaI,cACA,cCMa,CDpBjB,iDAiBI,WAAY,cACI,CAlBpB,oDAqBI,WAAa,CACd,oCAID,oDAEI,WAAa,CACd,CAAA","file":"Header.scss","sourcesContent":["@import '../../styles/variables';\n\n.container {\n  height: 50px;\n  z-index: 2;\n  box-shadow: 0 0 5px 0 rgba(0, 0, 0, .25);\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 20px;\n  position: fixed;\n  top: 0;\n  left: 0;\n  background-color: $theme_white;\n  .headerText {\n    color: $theme_blue;\n    font-size: $font-large\n  }\n  .logo {\n    width: 60px;\n    cursor: pointer;\n  }\n  .appLogo {\n    width: 350px;\n  }\n}\n\n@media screen and (max-width: $mobile_breakpoint) {\n  .container {\n    .appLogo {\n      width: 270px;\n    }\n  }\n}\n","// Color variables\n$theme_dark_red: #ca0716;\n$theme_grey_light: #e8e8e8;\n$theme_background_grey: #f8f8f8;\n$theme_white: #ffffff;\n$theme_text_grey: #606060;\n$theme_yellow:#fbff5b;\n$theme_green:#3ec654;\n$theme_black: #000000;\n$theme_red: #980411;\n$theme_orange:#F18625;\n$theme_purple:#7824EF;\n$theme_grey:#7F7F7F;\n$theme_blue:#172376;\n$theme_pink: #f9e2e3;\n$theme_light_green: #def3e2;\n\n\n//Font Size Variables\n$font-xs: 10px;\n$font-small: 12px;\n$font-medium: 15px;\n$font-large: 18px;\n\n//mobile breakpoint for css\n$mobile-breakpoint: 768px;"],"sourceRoot":"webpack://"}]);
	
	// exports
	exports.locals = {
		"container": "Header__container___izfMl",
		"headerText": "Header__headerText___3k_wl",
		"logo": "Header__logo___1AtfL",
		"appLogo": "Header__appLogo___3vaD9"
	};

/***/ }),
/* 431 */
/***/ (function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ }),
/* 432 */
/***/ (function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(self.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ }),
/* 433 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "65cc3e20cc637985a530f5bb3647afce.png";

/***/ }),
/* 434 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAw0AAAAzCAIAAABaG3P3AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAA7USURBVHhe7ZxLlty2DobvLryA67Vk7J145m1klonnWUTO6V14msyzCkclSiQo4ilCZXX1/x1O3E2RIPADRD3a//sJAAAAAAA40CcBAAAAAPCgTwIAAAAA4EGfBAAAAADAgz4JAAAAAIAHfRIAAAAAAA/6JAAAAAAAHvRJAAAAAAA86JMAAAAAAHjQJwEAAAAA8KBPuic/vn7+9un/376+bf+eYFvq0+c//9p+AsB7JDEp7srbn0jVu4MYfTzQJ92Mf95+K23NOuavhL++tdU+ffux/RSAd0R2UtyQv7//Xg+IO/ieIEYfFrZP2t+BOD1wH5+gvEzpB/ok8JHpbqZ9vFaf9O8fX44HxB18MxCjONx11sbn3//4Z5t4pt/oHqeoS02E7Jo+CRpiWaSjeOaaPqlFE0EB741r+yQ9H58E7uD788FilJIXl/ZJ+/jt+7/bGhtP7ZN26Nvd5lsRvV9e8r3xSR5F3xMq4na4EYCVVgGzksKbj0+jltAXvoPfOa1xf90YJecF7SKMZUmXo8w8dGBf3v7efkGhS0lvPgXQv59E+mjfRzbtUx58xDPwcI5Hf+iTADiS3yd58/FpoE+6PR+hT8rOi0AX0foHw4D+HT5u2bYU30jFSO6TFjYlIdWPrIXe4xb0SQAcSe+T3Pn4NNAn3Z4P0Cel58UVfdJCKwjLGGvC3fuk+hTueEqgfUSfBMCR5D7pji/n0Cfdnpfvky7Ii4v6JBILbuX790l7wmfY9yKEKiD6JACOpPZJ9+xI0Cfdnhfvky5R4FV9UrN2GUOzcas+aS1ejB3rg6HW6nXp2l5P+NEnAXAkrU8K5+PTQJ90e164T7osL9AniX0ShSxyGN0X0YVpor9a3WzD1ZltG3V/Ukhak4dVb+Sfw+jLtGT242gtVMoYvSf3SZ2U2WdZyoLG1/5Xfw5zjkeI5M/R2nV0J6onDR2kX7AOf1wYuJWHPzrdYM8lHIE3Q1o5SH7IJtKqMPc4LXxlNK+2lU/3SSfzsRIRyRnUPkk3nvPJBfIIeEBIwGXsHubzaBnEZn5OTNIHpMrgWrPZQ+ePbrnKq5cUn9m8MCBmfNA+qQTYsENOmC6H3fLlVNUNMRjdFrtcuMquDv99fFJ/5IB1L7Gm6JWaKmmomDvEA2aFKsOSu/bsMtaYdnNE23rU0J/sk8a7+TCGw15RqoLkh2wirVYmH9ej8PDtL+2T4iI5Q92FuyR043ufXCCPsAeEBFzG7mHRHtPmUBdSMY+wDKsQNXtWGwxF8TWBENcV75C54nM+L1wQMyyZNUscIaZma4c6b3ljqk/aTHHZ0bUj2j1RCy4n2U4lh31ppT5Yy8nxYYMk023rXmd6jOvu7LS6kSfDyUHW8te5jh3jzcFIf/TnePxtjr2jEsFu684bdun0kRaXztTeBuVXDSo58wjE25r+da4J2cm02sl8/KhS5lyn+6RGJB9nReLHYxX15zjtCRkd8gC1lg+cM5d3+8ci5qPT2LgL9Zu6RbeOML/ziRzKWV1dUXwieeHG6CIo7eC2AUTSXMjaUqZzHJzvk8J2kLiq98R2fiapSLCFWtkM7iaM5WOx4cum+GZMtbAdlgRDj3HZQopuSH/EUV+/S07r68sQgi7TyhjFNLplmUM+c+ydbOxYoHWEjVGbMJWKCXExTe0qkbBLJAuaA1X9q1wQMrom7wcprQp5j0tOPlxOwi4R6qaWCFNE4sW2ymoXqDPLuD6jDQ/Y8mi5LOfFZurJxCEWiiv44thJUYrCAg0E59ibFh93XkQgMrMSpJ3IMKCXLrdsuD9RcfdJynDb4TF9ExAzwZNORF68o/sTOdTQBK1OLkcTDQvpj2bIOoT6Qs7iyVhlzpkd2YN42heyiJU2CrNxiZdF1idtQlapcnJByE6lVdrjugNb6RBPGsGZj0ki8aJbVX/rqbdZ8kjwgJ3vdhIVM/RgKXhqYOh6eixlGKMpNklXtt8avuLjzIsYtgAqzWmKAdXIMoQ1PdH089Q+qelD1Ou24ygLt0Bb5eW0RU7kNdtxE5hpHNIfzSJ1PvFJXp80s6Md3wfuUOpMxYUkpGaqeZHnlyonSSFzx4JPq7zH9Sh052XvjBi+fMwSiRfZqmqJVzlJ8kjxgCmSNkEIbjFjImt289R7mhxW9Jhb8AvEJ/2+WbpqxmQVn9A95YXcuf4+yTeUs7SlZlJyZ+L7SdWnATssl5U1mSCRB92Dc2IgZhVTjtsEZcGQ/vxXQltWzjfPnKwdPXsthLwhMxEXsYSN6EUtv1Q5yQnZZFrlPW57r4XsWX1Smki88FY1LwUOniOPLA/osetVJGXrjGN9kCOIqmj57qhdwoJpusovPkmVuYfE139ea5i50JaynWMz9T3uLU4hO9RIlLMxgaQvj/yDsTkQM4Ke5440Dunv/fZJdR3VG6Fao3I2LvUUjpalWcvtkl+qnKSEbDKtEh+3k1GPdZDmE1mBeSLxMlrVEiqYKSnyyPOAdmmtu9RvizInLWZk3HYj1Ow2ZG+3+Y6IkMnEt3lebb/NKj5NDEG9aZzqk6YNuFGftBWvmB1ywEpusw4iaW9qSyUQM4qZ58ZqIf2l1LiKZ07ajh73ngwBy8m41FOY510gk0ft5ZcqJykhm0yrycdVxw78yj5pUiReDlaRNZcRO3WKPBI9UO0Zdnmk8OOHLTsOe5Ucjx1fofcqP2RVnOyTqP15XkWfpKBdDXGe3yeJ0d1+bl1s58vQg0DMOsQ83xY0FB/SX0qNq3jmJO5oLUUKjWyPn1Nx4euXhKq9/FLlJCVk6tFs8h63o/D0PilRJF6IVV9rlScjcPAMeaR6QBJ/u0GEVFonZFzb7eKkg5zac0k3Iz0mEZ9UByZ6VfAYi6/4EAXOO3ynbY0+aUTRN1vyynzh7iRpf74MPQjE7EDzO32wGGZGIqS/lCuw4pmTuyNZrXdyi/sy7Brh40xc6iluWKqcpISMLHLGpMnHVccOsEXjLM0ncj7micQLWeQxNttI1ihJdyBFHqkeYDOl/HBbvNpMLSnLBmv1QFd5pFRN75PI5OFE65j0an7xqdt57ikv76ZPKo+wQZnsk0S2EApPMXebng8k7aOW9Jw/EauhchC7Mob0l1LjKp45uTvS+LJDfTbMibjURxyxa8WIc05+qXKSErLJtMp73OGQX9knTYrEC9mx92e8VUqRR7IHxgiuGTGk7TL27cqEyXJBar66VKtasiraMR2VnF8wz6v5xaeJwT6dG+J/q0p4QuCkLeXsk0rKCPte1CdtKSGmaE3jTbjbRnJKU63PePD0iRbas7vU1mN67AnpL6XGVTxzEnfcl1rXIfVdf2qKE3Ehhs2lbqRujnZOkBOyybSafJxEwa5lbbJxXg+ufEwTiRfFKhJu1xY58kj2QJtTVitb05WrMUUP5RTOe07C7QrPEc7le3+EGxcfV15EIX54Th6ttKV8+tnmCxZe0idtW6pHrcd4hM2RD3pnPbBokb2ST55oo5fRZpJnnZD+cmrcjmdO1o7lt8pGF9G71xMXd0IaRY2UKuPUVMC36ZNm02rycRIFUzMtEI6NLHrBSGSJxItuVf3tMszSnySPZA9Uq9bVHosfN93XWX9e1DWZLCRD9SO4DktWsxRLQnA4QpZX/cbQPEWfNFL9IyVLfp/U7NMfISEpX1q0yh8RjeHE3WzGgLk+idjw9W1dysyWglqMjmR1LQXPnJwdd986fZJJPC5yFaOYlYgWIFFRZK8y7tMnTafV3OPUM2o+Uj9bhcKBMx+TROKlWcV7shObXv2z5JHsgV0DD6tW5QynaEt9e1sTefa+JLZpS3W+lWfSaWoWt5MyqyV5tbM5pfg48yIGcYWa4wu/pk+y8m4ht08i8w0ZLXSTPU1fO482fyvcwu6krLtOdKSTpn8RYvlQtn58PSySVeMKnjk5O/YBnRZ6iBNxITkpeIbqTVrwUIYO08gKiyC9LyE8JIqEHvNEWs093nwi5myvK3FaBGKzno85IvFh3osL1F1azcyTR64HDnnKhFJPqBOQBQXlkEuhDNn/B/sl39IwsXNyvJpefMgjel5ECHQRxC1P6pNopBTz1D6JhkHdLCS1CtWct/ZR9QyxrGeWVnOqXKU7qXsF8hRRwGZPH57OSE1Y/f3Bz+zmuNyiBdrasY/OOLxRPsOJuGjHcebPQjdTGMWeNtORHTppISvMpdXc472F3Vnar7a3H5g55/DnY45IHHQCllfr7RGElCqPXA/wnid027kLrAY1shMhveAW46mMhbNUxzZBHk7R9y5yxcvxajdTGJHi488LN9QhRt3rUmAu9GQpXv+9/5eh2sb2SZ25J4erlglSMzDMY/yr39+x3UkNitTrrnLRUXfXjSQa1XOjZKZnTu6OO4P+pBF0u8m5uJiFRq50FfXIxBhmr4ipDy4JWSGeVh1Tj2vWbjrh1o96j2DnIyFDJBJGvrSVPUXsMnkkeqAtJd279RQT8e1RnUwizh6TSneTzfaIETvzps/wanLxCeWFhiFX2pRMVh6KsZQ2VLFd1Sc506YEz59jBMZIcR1PifGzN8hxs3ubD/um1jjPnF9YVdswXmFEOB8X3uBIfh5fRz7GcA0wu0RvgstCthNJK4aZx4dnO+cwK4e9d0TNx4EEkTC8jz6pkOOBPVPkB7e4RITnwJGhDwYfUju3NqJ7kIlgyCcJXk0uPrG84DHkers+SReb/v0kwLIG45x6Xp+tagiy42+FWFEQQVwAAAAkgz4pDPeSAhS2dt71QpC+Bpp9Y+AB4gIAACAd9ElR1ndEEj8teh3294oCTc/+NmnCm0CICwAAgHzQJwUpH7viTYuR/QPpyLcK9tZqvk9CXAAAAFwA+qQQeNNCpP2hhL9ZqR+9zX7uhrgAAAC4BPRJHNJfZOBNCwXyBw6+72W3v03wfo8bcQEAAPBc0CcxdP+HxH77bj/M+Mbxq9L96an87k7n3sgfuyEuAAAAngz6JI7xv6MoA39zbnHogYwRbW4QFwAAAM8FfZJE+1SoDP/bHmD0Xjem3vtBXAAAADwP9EkAAAAAADzokwAAAAAAeNAnAQAAAABw/Pz5H2gp5DozdM29AAAAAElFTkSuQmCC"

/***/ }),
/* 435 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Loader = __webpack_require__(436);
	
	var _Loader2 = _interopRequireDefault(_Loader);
	
	var _reactRedux = __webpack_require__(418);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Loader = function Loader(_ref) {
	  var _ref$loaderVisibility = _ref.loaderVisibility,
	      loaderVisibility = _ref$loaderVisibility === undefined ? false : _ref$loaderVisibility;
	  return _react2.default.createElement(
	    'div',
	    { className: _Loader2.default.container + ' full-size ' + (loaderVisibility ? _Loader2.default.show : '') },
	    _react2.default.createElement('div', { className: 'loader' })
	  );
	};
	
	Loader.propTypes = {
	  loaderVisibility: _react2.default.PropTypes.bool
	};
	
	var mapStateToProps = function mapStateToProps(state) {
	  return { loaderVisibility: state.commonData.loaderVisibility };
	};
	
	exports.default = (0, _reactRedux.connect)(mapStateToProps)(Loader);

/***/ }),
/* 436 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(437);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(432)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(true) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept(437, function() {
				var newContent = __webpack_require__(437);
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 437 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(431)();
	// imports
	
	
	// module
	exports.push([module.id, ".Loader__container___R8y1m{display:none;position:fixed;top:50px;left:0;background-color:#fff;opacity:.8;z-index:99}.Loader__container___R8y1m .loader{position:fixed;left:calc(50% - 25px);top:calc(50% - 25px);z-index:99;width:50px;height:50px;border-radius:50%;background:transparent;border-top:5px solid transparent;border-right:5px solid transparent;border-bottom:5px solid #ca0716;border-left:5px solid #ca0716;animation:loading 1s infinite linear}.Loader__container___R8y1m.Loader__show___3vMRg{display:block}", "", {"version":3,"sources":["/./src/components/Loader/src/components/Loader/Loader.scss"],"names":[],"mappings":"AAEA,2BACE,aAAc,eACE,SACN,OACF,sBAER,WAAa,UACD,CAPd,mCAWM,eAAgB,sBACN,qBACD,WACG,WACA,YACC,kBACM,uBACK,iCACU,mCACE,gCAEpC,8BACA,oCAAsC,CAvB5C,gDA4BI,aAAe,CAChB","file":"Loader.scss","sourcesContent":["@import '../../styles/variables';\n\n.container {\n  display: none;\n  position: fixed;\n  top: 50px;\n  left: 0;\n  background-color: $theme_white;\n  opacity: 0.8;\n  z-index: 99;\n\n  :global {\n    .loader {\n      position: fixed;\n      left: calc(50% - 25px);\n      top: calc(50% - 25px);\n      z-index: 99;\n      width: 50px;\n      height: 50px;\n      border-radius: 50%;\n      background: transparent;\n      border-top: 5px solid transparent;\n      border-right: 5px solid transparent;\n      border-bottom: 5px solid $theme_dark_red;\n      border-left: 5px solid $theme_dark_red;\n      animation: loading 1s infinite linear;\n    }\n  }\n\n  &.show {\n    display: block;\n  }\n}\n"],"sourceRoot":"webpack://"}]);
	
	// exports
	exports.locals = {
		"container": "Loader__container___R8y1m",
		"show": "Loader__show___3vMRg"
	};

/***/ }),
/* 438 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(439);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(432)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(true) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept(439, function() {
				var newContent = __webpack_require__(439);
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 439 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(431)();
	// imports
	
	
	// module
	exports.push([module.id, ".CoreLayout__wrapper___1miNC .mainContainer{padding-top:50px}", "", {"version":3,"sources":["/./src/layouts/CoreLayout/src/layouts/CoreLayout/CoreLayout.scss"],"names":[],"mappings":"AAAA,4CAGM,gBAAkB,CACnB","file":"CoreLayout.scss","sourcesContent":[".wrapper {\n  :global {\n    .mainContainer {\n      padding-top: 50px;\n    }\n  }\n}\n"],"sourceRoot":"webpack://"}]);
	
	// exports
	exports.locals = {
		"wrapper": "CoreLayout__wrapper___1miNC"
	};

/***/ }),
/* 440 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(441);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(432)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(true) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept(441, function() {
				var newContent = __webpack_require__(441);
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 441 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(431)();
	// imports
	
	
	// module
	exports.push([module.id, "html{font-family:sans-serif;line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress{vertical-align:baseline}[hidden],template{display:none}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{box-sizing:border-box}body,html{margin:0;padding:0;height:100%}*,:after,:before{box-sizing:inherit}.full-width{width:100%}.full-size{width:100%;height:100%}.flex-center-xy{display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center;-ms-flex-align:center;align-items:center}.no-margin{margin:0}.yellow{background-color:#fbff5b}.red{background-color:#980411}.green{background-color:#3ec654}.black{background-color:#000}.darkRed{background-color:#980411}.orange{background-color:#f18625}.purple{background-color:#7824ef}.grey{background-color:#7f7f7f}.blue{background-color:#172376}.white{background-color:#fff}.black-font{color:#000}.white-font{color:#fff}.theme{background-color:#ca0716}select{-webkit-appearance:none;-moz-appearance:none;border:none}.title-block{background-color:#f9e2e3;height:180px;-ms-flex-align:center;align-items:center;text-align:center;color:#606060;font-size:12px;width:30%;-ms-flex-pack:center;justify-content:center}.scroll{overflow:auto}.no-display{display:none}.full-height{height:100%}", "", {"version":3,"sources":["/./src/styles/src/styles/core.scss","/./src/styles/node_modules/normalize.css/normalize.css","/./src/styles/src/styles/variables.scss"],"names":[],"mappings":"AAAA,KCSE,uBAAwB,iBACN,0BACS,6BACI,CDZjC,KCoBE,QAAU,CDpBZ,oFC4CE,aAAe,CD5CjB,4BCuDE,oBAAsB,CDvDxB,sBC+DE,aAAc,QACJ,CDhEZ,SCwEE,uBAAyB,CDxE3B,kBCkFE,YAAc,CDlFhB,EC8FE,6BAA8B,oCACQ,CD/FxC,iBCyGE,eAAiB,CDzGnB,YCqHE,mBAAoB,0BACO,gCACO,CDvHpC,SCgIE,oBAAqB,kBASD,CDzItB,ICiJE,iBAAmB,CDjJrB,GC0JE,cAAe,cACE,CD3JnB,KCmKE,sBAAuB,UACX,CDpKd,MC4KE,aAAe,CD5KjB,QCsLE,cAAe,cACA,kBACI,uBACM,CDzL3B,IC6LE,aAAgB,CD7LlB,ICiME,SAAY,CDjMd,IC4ME,iBAAmB,CD5MrB,eCoNE,eAAiB,CDpNnB,kBCmOE,gCAAkC,aACnB,CDpOjB,OC4OE,eAAiB,CD5OnB,GCqPE,uBAAwB,SACd,gBACQ,CDvPpB,sCCuQE,aAAc,QACJ,CDxQZ,SCgRE,eAAkB,CDhRpB,aC0RE,gBAAkB,CD1RpB,cCoSE,mBAAqB,CDpSvB,qDCiTE,yBAA2B,CDjT7B,wHC4TE,kBAAmB,SACR,CD7Tb,4GCwUE,6BAA+B,CDxUjC,SCgVE,wBAA0B,aACZ,0BACiB,CDlVjC,OC6VE,sBAAuB,cACR,cACA,eACC,UACL,kBACS,CDlWtB,SC0WE,aAAe,CD1WjB,6BCoXE,sBAAuB,SACZ,CDrXb,kFC8XE,WAAa,CD9Xf,cCuYE,6BAA8B,mBACT,CDxYvB,qFCiZE,uBAAyB,CDjZ3B,4BCyZE,cAAe,WACD,CD1ZhB,6BCmaE,0BAA2B,YACb,CDpahB,KAMI,qBAAuB,CAN3B,UAWI,SAAU,UACC,WACE,CAbjB,iBAmBI,kBAAoB,CAnBxB,YAsBI,UAAY,CAtBhB,WA4BI,WAAY,WACC,CA7BjB,gBAgCI,oBAAA,aAAc,qBACd,uBAAwB,sBACxB,kBAAoB,CAlCxB,WAqCI,QAAY,CArChB,QAwCI,wBElCiB,CFNrB,KA2CI,wBElCe,CFTnB,OA8CI,wBEvCgB,CFPpB,OAiDI,qBEzCiB,CFRrB,SAoDI,wBE3Ce,CFTnB,QAuDI,wBE7CiB,CFVrB,QA0DI,wBE/CiB,CFXrB,MA6DI,wBEjDe,CFZnB,MAgEI,wBEnDe,CFbnB,OAmEI,qBE/DiB,CFJrB,YAsEI,UE9DiB,CFRrB,YAyEI,UErEiB,CFJrB,OA4EI,wBE3EoB,CFDxB,OA+EI,wBAAyB,qBACH,WACT,CAjFjB,aAoFE,yBACA,aAAc,sBACd,mBAAoB,kBACD,cAEnB,eACA,UAAW,qBACX,sBAAwB,CA3F1B,QA8FI,aAAe,CA9FnB,YAiGI,YAAc,CAjGlB,aAoGI,WAAa,CACd","file":"core.scss","sourcesContent":[":global {\n  @import 'base';\n  @import '~normalize.css/normalize';\n  // Some best-practice CSS that's useful for most apps\n  // Just remove them if they're not what you want\n  html {\n    box-sizing: border-box;\n  }\n\n  html,\n  body {\n    margin: 0;\n    padding: 0;\n    height: 100%;\n  }\n\n  *,\n  *:before,\n  *:after {\n    box-sizing: inherit;\n  }\n  .full-width {\n    width: 100%;\n  }\n  .full-height {\n    height: 100%;\n  }\n  .full-size {\n    width: 100%;\n    height: 100%;\n  }\n  .flex-center-xy {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n  }\n  .no-margin {\n    margin: 0px;\n  }\n  .yellow {\n    background-color:$theme_yellow;\n  }\n  .red {\n    background-color: $theme_red;\n  }\n  .green {\n    background-color: $theme_green;\n  }\n  .black {\n    background-color: $theme_black;\n  }\n  .darkRed {\n    background-color: $theme_red;\n  }\n  .orange {\n    background-color: $theme_orange;\n  }\n  .purple {\n    background-color: $theme_purple;\n  }\n  .grey {\n    background-color: $theme_grey;\n  }\n  .blue {\n    background-color: $theme_blue;\n  }\n  .white {\n    background-color: $theme_white;\n  }\n  .black-font {\n    color: $theme_black;\n  }\n  .white-font {\n    color: $theme_white;\n  }\n  .theme {\n    background-color: $theme_dark_red;\n  }\n  select {\n    -webkit-appearance: none;\n    -moz-appearance: none;\n    border: none;\n  }\n  .title-block {\n  background-color: $theme_pink;\n  height: 180px;\n  align-items: center;\n  text-align: center;\n  color: $theme_text_grey;\n  font-size: $font-small;\n  width: 30%;\n  justify-content: center;\n  }\n  .scroll {\n    overflow: auto;\n  }\n  .no-display {\n    display: none;\n  }\n  .full-height {\n    height: 100%;\n  }\n}\n","/*! normalize.css v4.1.1 | MIT License | github.com/necolas/normalize.css */\n\n/**\n * 1. Change the default font family in all browsers (opinionated).\n * 2. Correct the line height in all browsers.\n * 3. Prevent adjustments of font size after orientation changes in IE and iOS.\n */\n\nhtml {\n  font-family: sans-serif; /* 1 */\n  line-height: 1.15; /* 2 */\n  -ms-text-size-adjust: 100%; /* 3 */\n  -webkit-text-size-adjust: 100%; /* 3 */\n}\n\n/**\n * Remove the margin in all browsers (opinionated).\n */\n\nbody {\n  margin: 0;\n}\n\n/* HTML5 display definitions\n   ========================================================================== */\n\n/**\n * Add the correct display in IE 9-.\n * 1. Add the correct display in Edge, IE, and Firefox.\n * 2. Add the correct display in IE.\n */\n\narticle,\naside,\ndetails, /* 1 */\nfigcaption,\nfigure,\nfooter,\nheader,\nmain, /* 2 */\nmenu,\nnav,\nsection,\nsummary { /* 1 */\n  display: block;\n}\n\n/**\n * Add the correct display in IE 9-.\n */\n\naudio,\ncanvas,\nprogress,\nvideo {\n  display: inline-block;\n}\n\n/**\n * Add the correct display in iOS 4-7.\n */\n\naudio:not([controls]) {\n  display: none;\n  height: 0;\n}\n\n/**\n * Add the correct vertical alignment in Chrome, Firefox, and Opera.\n */\n\nprogress {\n  vertical-align: baseline;\n}\n\n/**\n * Add the correct display in IE 10-.\n * 1. Add the correct display in IE.\n */\n\ntemplate, /* 1 */\n[hidden] {\n  display: none;\n}\n\n/* Links\n   ========================================================================== */\n\n/**\n * 1. Remove the gray background on active links in IE 10.\n * 2. Remove gaps in links underline in iOS 8+ and Safari 8+.\n */\n\na {\n  background-color: transparent; /* 1 */\n  -webkit-text-decoration-skip: objects; /* 2 */\n}\n\n/**\n * Remove the outline on focused links when they are also active or hovered\n * in all browsers (opinionated).\n */\n\na:active,\na:hover {\n  outline-width: 0;\n}\n\n/* Text-level semantics\n   ========================================================================== */\n\n/**\n * 1. Remove the bottom border in Firefox 39-.\n * 2. Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari.\n */\n\nabbr[title] {\n  border-bottom: none; /* 1 */\n  text-decoration: underline; /* 2 */\n  text-decoration: underline dotted; /* 2 */\n}\n\n/**\n * Prevent the duplicate application of `bolder` by the next rule in Safari 6.\n */\n\nb,\nstrong {\n  font-weight: inherit;\n}\n\n/**\n * Add the correct font weight in Chrome, Edge, and Safari.\n */\n\nb,\nstrong {\n  font-weight: bolder;\n}\n\n/**\n * Add the correct font style in Android 4.3-.\n */\n\ndfn {\n  font-style: italic;\n}\n\n/**\n * Correct the font size and margin on `h1` elements within `section` and\n * `article` contexts in Chrome, Firefox, and Safari.\n */\n\nh1 {\n  font-size: 2em;\n  margin: 0.67em 0;\n}\n\n/**\n * Add the correct background and color in IE 9-.\n */\n\nmark {\n  background-color: #ff0;\n  color: #000;\n}\n\n/**\n * Add the correct font size in all browsers.\n */\n\nsmall {\n  font-size: 80%;\n}\n\n/**\n * Prevent `sub` and `sup` elements from affecting the line height in\n * all browsers.\n */\n\nsub,\nsup {\n  font-size: 75%;\n  line-height: 0;\n  position: relative;\n  vertical-align: baseline;\n}\n\nsub {\n  bottom: -0.25em;\n}\n\nsup {\n  top: -0.5em;\n}\n\n/* Embedded content\n   ========================================================================== */\n\n/**\n * Remove the border on images inside links in IE 10-.\n */\n\nimg {\n  border-style: none;\n}\n\n/**\n * Hide the overflow in IE.\n */\n\nsvg:not(:root) {\n  overflow: hidden;\n}\n\n/* Grouping content\n   ========================================================================== */\n\n/**\n * 1. Correct the inheritance and scaling of font size in all browsers.\n * 2. Correct the odd `em` font sizing in all browsers.\n */\n\ncode,\nkbd,\npre,\nsamp {\n  font-family: monospace, monospace; /* 1 */\n  font-size: 1em; /* 2 */\n}\n\n/**\n * Add the correct margin in IE 8.\n */\n\nfigure {\n  margin: 1em 40px;\n}\n\n/**\n * 1. Add the correct box sizing in Firefox.\n * 2. Show the overflow in Edge and IE.\n */\n\nhr {\n  box-sizing: content-box; /* 1 */\n  height: 0; /* 1 */\n  overflow: visible; /* 2 */\n}\n\n/* Forms\n   ========================================================================== */\n\n/**\n * 1. Change font properties to `inherit` in all browsers (opinionated).\n * 2. Remove the margin in Firefox and Safari.\n */\n\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n  font: inherit; /* 1 */\n  margin: 0; /* 2 */\n}\n\n/**\n * Restore the font weight unset by the previous rule.\n */\n\noptgroup {\n  font-weight: bold;\n}\n\n/**\n * Show the overflow in IE.\n * 1. Show the overflow in Edge.\n */\n\nbutton,\ninput { /* 1 */\n  overflow: visible;\n}\n\n/**\n * Remove the inheritance of text transform in Edge, Firefox, and IE.\n * 1. Remove the inheritance of text transform in Firefox.\n */\n\nbutton,\nselect { /* 1 */\n  text-transform: none;\n}\n\n/**\n * 1. Prevent a WebKit bug where (2) destroys native `audio` and `video`\n *    controls in Android 4.\n * 2. Correct the inability to style clickable types in iOS and Safari.\n */\n\nbutton,\nhtml [type=\"button\"], /* 1 */\n[type=\"reset\"],\n[type=\"submit\"] {\n  -webkit-appearance: button; /* 2 */\n}\n\n/**\n * Remove the inner border and padding in Firefox.\n */\n\nbutton::-moz-focus-inner,\n[type=\"button\"]::-moz-focus-inner,\n[type=\"reset\"]::-moz-focus-inner,\n[type=\"submit\"]::-moz-focus-inner {\n  border-style: none;\n  padding: 0;\n}\n\n/**\n * Restore the focus styles unset by the previous rule.\n */\n\nbutton:-moz-focusring,\n[type=\"button\"]:-moz-focusring,\n[type=\"reset\"]:-moz-focusring,\n[type=\"submit\"]:-moz-focusring {\n  outline: 1px dotted ButtonText;\n}\n\n/**\n * Change the border, margin, and padding in all browsers (opinionated).\n */\n\nfieldset {\n  border: 1px solid #c0c0c0;\n  margin: 0 2px;\n  padding: 0.35em 0.625em 0.75em;\n}\n\n/**\n * 1. Correct the text wrapping in Edge and IE.\n * 2. Correct the color inheritance from `fieldset` elements in IE.\n * 3. Remove the padding so developers are not caught out when they zero out\n *    `fieldset` elements in all browsers.\n */\n\nlegend {\n  box-sizing: border-box; /* 1 */\n  color: inherit; /* 2 */\n  display: table; /* 1 */\n  max-width: 100%; /* 1 */\n  padding: 0; /* 3 */\n  white-space: normal; /* 1 */\n}\n\n/**\n * Remove the default vertical scrollbar in IE.\n */\n\ntextarea {\n  overflow: auto;\n}\n\n/**\n * 1. Add the correct box sizing in IE 10-.\n * 2. Remove the padding in IE 10-.\n */\n\n[type=\"checkbox\"],\n[type=\"radio\"] {\n  box-sizing: border-box; /* 1 */\n  padding: 0; /* 2 */\n}\n\n/**\n * Correct the cursor style of increment and decrement buttons in Chrome.\n */\n\n[type=\"number\"]::-webkit-inner-spin-button,\n[type=\"number\"]::-webkit-outer-spin-button {\n  height: auto;\n}\n\n/**\n * 1. Correct the odd appearance in Chrome and Safari.\n * 2. Correct the outline style in Safari.\n */\n\n[type=\"search\"] {\n  -webkit-appearance: textfield; /* 1 */\n  outline-offset: -2px; /* 2 */\n}\n\n/**\n * Remove the inner padding and cancel buttons in Chrome and Safari on OS X.\n */\n\n[type=\"search\"]::-webkit-search-cancel-button,\n[type=\"search\"]::-webkit-search-decoration {\n  -webkit-appearance: none;\n}\n\n/**\n * Correct the text style of placeholders in Chrome, Edge, and Safari.\n */\n\n::-webkit-input-placeholder {\n  color: inherit;\n  opacity: 0.54;\n}\n\n/**\n * 1. Correct the inability to style clickable types in iOS and Safari.\n * 2. Change font properties to `inherit` in Safari.\n */\n\n::-webkit-file-upload-button {\n  -webkit-appearance: button; /* 1 */\n  font: inherit; /* 2 */\n}\n","// Color variables\n$theme_dark_red: #ca0716;\n$theme_grey_light: #e8e8e8;\n$theme_background_grey: #f8f8f8;\n$theme_white: #ffffff;\n$theme_text_grey: #606060;\n$theme_yellow:#fbff5b;\n$theme_green:#3ec654;\n$theme_black: #000000;\n$theme_red: #980411;\n$theme_orange:#F18625;\n$theme_purple:#7824EF;\n$theme_grey:#7F7F7F;\n$theme_blue:#172376;\n$theme_pink: #f9e2e3;\n$theme_light_green: #def3e2;\n\n\n//Font Size Variables\n$font-xs: 10px;\n$font-small: 12px;\n$font-medium: 15px;\n$font-large: 18px;\n\n//mobile breakpoint for css\n$mobile-breakpoint: 768px;"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ }),
/* 442 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _Dashboard = __webpack_require__(443);
	
	var _Dashboard2 = _interopRequireDefault(_Dashboard);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// Sync route definition
	exports.default = {
	  component: _Dashboard2.default
	};

/***/ }),
/* 443 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _Dashboard = __webpack_require__(444);
	
	var _Dashboard2 = _interopRequireDefault(_Dashboard);
	
	var _reactRedux = __webpack_require__(418);
	
	var _redux = __webpack_require__(254);
	
	var _reduxActions = __webpack_require__(465);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// Actions
	var getData = (0, _reduxActions.createAction)('GET_METADATA');
	
	var mapDispatchToProps = function mapDispatchToProps(dispatch) {
	  return {
	    getData: (0, _redux.bindActionCreators)(getData, dispatch)
	  };
	};
	
	exports.default = (0, _reactRedux.connect)(null, mapDispatchToProps)(_Dashboard2.default);

/***/ }),
/* 444 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(384);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(388);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(389);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(393);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(410);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Dashboard = __webpack_require__(445);
	
	var _Dashboard2 = _interopRequireDefault(_Dashboard);
	
	var _Card = __webpack_require__(447);
	
	var _Card2 = _interopRequireDefault(_Card);
	
	var _Carousel = __webpack_require__(453);
	
	var _Carousel2 = _interopRequireDefault(_Carousel);
	
	var _reactRedux = __webpack_require__(418);
	
	var _redux = __webpack_require__(254);
	
	var _reduxActions = __webpack_require__(465);
	
	var _common = __webpack_require__(318);
	
	var commonActions = _interopRequireWildcard(_common);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Dashboard = function (_React$Component) {
	  (0, _inherits3.default)(Dashboard, _React$Component);
	
	  function Dashboard(props) {
	    (0, _classCallCheck3.default)(this, Dashboard);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (Dashboard.__proto__ || (0, _getPrototypeOf2.default)(Dashboard)).call(this, props));
	
	    _this.navigate = _this.navigate.bind(_this);
	    return _this;
	  }
	
	  (0, _createClass3.default)(Dashboard, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      this.props.actions.getMatches();
	    }
	  }, {
	    key: 'navigate',
	    value: function navigate(link) {
	      this.context.router.push(link);
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this2 = this;
	
	      return _react2.default.createElement(
	        'div',
	        { className: _Dashboard2.default.container + ' full-size px1 py2' },
	        _react2.default.createElement(
	          _Card2.default,
	          { cardType: 'carousal' },
	          _react2.default.createElement(_Carousel2.default, null)
	        ),
	        _react2.default.createElement(
	          'div',
	          { className: _Dashboard2.default.bottomCardContainer },
	          _react2.default.createElement(
	            'div',
	            { onClick: function onClick() {
	                return _this2.navigate('/team');
	              } },
	            _react2.default.createElement(_Card2.default, { cardType: 'tile', cardDetails: 'team', cardTitle: 'Know your favourite team better' })
	          ),
	          _react2.default.createElement(
	            'div',
	            { onClick: function onClick() {
	                return _this2.navigate('/player');
	              } },
	            _react2.default.createElement(_Card2.default, { cardType: 'tile', cardDetails: 'player', cardTitle: 'Player performances through the last 9 seasons' })
	          ),
	          _react2.default.createElement(
	            'div',
	            { onClick: function onClick() {
	                return _this2.navigate('/ground');
	              } },
	            _react2.default.createElement(_Card2.default, { cardType: 'tile', cardDetails: 'ground', cardTitle: 'Fun facts about cricket stadiums' })
	          )
	        )
	      );
	    }
	  }]);
	  return Dashboard;
	}(_react2.default.Component);
	
	function mapDispatchToProps(dispatch) {
	  return {
	    actions: (0, _redux.bindActionCreators)(commonActions, dispatch)
	  };
	}
	
	Dashboard.contextTypes = {
	  router: _react2.default.PropTypes.object.isRequired
	};
	exports.default = (0, _reactRedux.connect)(null, mapDispatchToProps)(Dashboard);

/***/ }),
/* 445 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(446);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(432)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(true) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept(446, function() {
				var newContent = __webpack_require__(446);
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 446 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(431)();
	// imports
	
	
	// module
	exports.push([module.id, ".Dashboard__container___1pttV{background-color:#def3e2;overflow-y:auto}.Dashboard__bottomCardContainer___1wCrh{display:-ms-flexbox;display:flex;-ms-flex-pack:distribute;justify-content:space-around;-ms-flex-align:center;align-items:center}@media screen and (max-width:768px){.Dashboard__bottomCardContainer___1wCrh{display:block}}", "", {"version":3,"sources":["/./src/components/Dashboard/src/components/Dashboard/Dashboard.scss"],"names":[],"mappings":"AAEA,8BACE,yBACA,eAAiB,CAClB,wCAEC,oBAAA,aAAc,yBACd,6BAA8B,sBAC9B,kBAAoB,CACrB,oCAEC,wCACE,aAAe,CAChB,CAAA","file":"Dashboard.scss","sourcesContent":["@import '../../styles/variables';\n\n.container {\n  background-color: $theme_light_green;\n  overflow-y: auto;\n}\n.bottomCardContainer{\n  display: flex;\n  justify-content: space-around;\n  align-items: center;\n}\n@media screen and (max-width: $mobile_breakpoint) {\n  .bottomCardContainer{\n    display: block;\n  }\n}"],"sourceRoot":"webpack://"}]);
	
	// exports
	exports.locals = {
		"container": "Dashboard__container___1pttV",
		"bottomCardContainer": "Dashboard__bottomCardContainer___1wCrh"
	};

/***/ }),
/* 447 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Card = __webpack_require__(448);
	
	var _Card2 = _interopRequireDefault(_Card);
	
	var _ground = __webpack_require__(450);
	
	var _ground2 = _interopRequireDefault(_ground);
	
	var _team = __webpack_require__(451);
	
	var _team2 = _interopRequireDefault(_team);
	
	var _playerSquad = __webpack_require__(452);
	
	var _playerSquad2 = _interopRequireDefault(_playerSquad);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var image = {
	  team: _team2.default,
	  player: _playerSquad2.default,
	  ground: _ground2.default
	};
	var Card = function Card(_ref) {
	  var cardTitle = _ref.cardTitle,
	      children = _ref.children,
	      cardType = _ref.cardType,
	      cardDetails = _ref.cardDetails;
	  return _react2.default.createElement(
	    'div',
	    null,
	    cardType === 'carousal' && _react2.default.createElement(
	      'div',
	      { className: _Card2.default.container + ' full-width ' },
	      _react2.default.createElement(
	        'div',
	        null,
	        children
	      )
	    ),
	    cardType === 'selector' && _react2.default.createElement(
	      'div',
	      { className: _Card2.default.selectorCardContainer + ' full-width ' },
	      _react2.default.createElement(
	        'div',
	        null,
	        children
	      )
	    ),
	    cardType === 'tile' && _react2.default.createElement(
	      'div',
	      { className: _Card2.default.tileContainer },
	      _react2.default.createElement(
	        'div',
	        { className: _Card2.default.tile },
	        _react2.default.createElement('img', { className: _Card2.default.tileImages, src: image[cardDetails] }),
	        _react2.default.createElement(
	          'div',
	          { className: _Card2.default.cardText },
	          cardTitle
	        )
	      )
	    )
	  );
	};
	
	Card.propTypes = {
	  cardType: _react2.default.PropTypes.string,
	  cardTitle: _react2.default.PropTypes.string,
	  cardDetails: _react2.default.PropTypes.string,
	  children: _react2.default.PropTypes.element
	};
	exports.default = Card;

/***/ }),
/* 448 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(449);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(432)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(true) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept(449, function() {
				var newContent = __webpack_require__(449);
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 449 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(431)();
	// imports
	
	
	// module
	exports.push([module.id, ".Card__container___3Sqon{height:40vh;margin:0 auto 15px;border-radius:5px;border:1px solid #e8e8e8;background-color:#172376}.Card__container___3Sqon .card-title{border-bottom:1px solid #e8e8e8;height:40px;font-size:15px;color:#ca0716}.Card__selectorCardContainer___1L1yp{height:200px;border:1px solid #e8e8e8}.Card__carousal___36YhQ,.Card__selectorCardContainer___1L1yp{background-color:#172376}.Card__tile___1DjA3{background-color:#fff;box-shadow:0 0 5px 0 rgba(0,0,0,.25);margin:20px;padding:20px 20px 0;height:45vh;width:25vw;overflow:hidden;cursor:pointer}.Card__tile___1DjA3:hover{transition:opacity 2s cubic-bezier(.165,.84,.44,1);box-shadow:0 10px 20px 0 rgba(0,0,0,.2),0 10px 22px 0 rgba(0,0,0,.15)}.Card__tileImages___22oey{height:250px;width:100%}.Card__cardText___2eo5c{color:#172376;font-size:16px;padding:8px;text-align:center}@media screen and (max-width:768px){.Card__tileImages___22oey{width:100%;height:30vh}.Card__tile___1DjA3{width:89%;height:300px;height:40vh;box-shadow:0 10px 20px 0 rgba(0,0,0,.2),0 10px 22px 0 rgba(0,0,0,.15)}.Card__container___3Sqon{height:250px}}", "", {"version":3,"sources":["/./src/components/Card/src/components/Card/Card.scss","/./src/components/Card/src/styles/variables.scss"],"names":[],"mappings":"AAEA,yBACE,YAAa,mBACO,kBACD,yBAEnB,wBCMiB,CDXnB,qCASM,gCACA,YAAa,eAEb,aCbkB,CDcnB,qCAKH,aAAc,wBClBU,CDqBzB,6DAFC,wBCRiB,CDalB,oBAGC,sBACA,qCAA0B,YACb,oBACa,YACb,WACD,gBACK,cACD,CACjB,0BAEC,mDAAmC,qEAC4B,CAChE,0BAEC,aAAc,UAEf,CAAC,wBAGA,cACA,eAAgB,YACH,iBACM,CACpB,oCAEC,0BACE,WAAY,WACC,CACd,oBAEC,UAAW,aACG,YACD,qEACkD,CAChE,yBAEC,YAAc,CACf,CAAA","file":"Card.scss","sourcesContent":["@import '../../styles/variables';\n\n.container {\n  height: 40vh;\n  margin: 0 auto 15px;\n  border-radius: 5px;\n  border: 1px solid $theme_grey_light;\n  background-color: $theme_blue;\n\n   :global {\n    .card-title {\n      border-bottom: 1px solid $theme_grey_light;\n      height: 40px;\n      font-size: $font-medium;\n      color: $theme_dark_red;\n    }\n  }\n}\n\n.selectorCardContainer{\n  height: 200px;\n  background-color: $theme_blue;\n  border: 1px solid $theme_grey_light;\n}\n.carousal {\n  background-color: $theme_blue;\n}\n\n.tile {\n  background-color: $theme_white;\n  box-shadow: 0 0 5px 0 rgba(0,0,0,.25);\n  margin: 20px;\n  padding: 20px 20px 0 20px;\n  height: 45vh;\n  width: 25vw;\n  overflow: hidden;\n  cursor: pointer;\n}\n.tile:hover {\n  transition: opacity 2s cubic-bezier(.165, .84, .44, 1);\n  box-shadow: 0 10px 20px 0 rgba(0, 0, 0, .2), 0 10px 22px 0 rgba(0, 0, 0, .15);\n}\n.tileImages {\n  height: 250px;\n  width: 100%\n}\n\n.cardText{\n  color: $theme_blue;\n  font-size: 16px;\n  padding: 8px;\n  text-align: center;\n}\n@media screen and (max-width: $mobile_breakpoint) {\n  .tileImages {\n    width: 100%;\n    height: 30vh;\n  }\n  .tile{\n    width: 89%;\n    height: 300px;\n    height: 40vh;\n    box-shadow: 0 10px 20px 0 rgba(0, 0, 0, .2), 0 10px 22px 0 rgba(0, 0, 0, .15);\n  }\n  .container{ \n    height: 250px;\n  }\n}\n","// Color variables\n$theme_dark_red: #ca0716;\n$theme_grey_light: #e8e8e8;\n$theme_background_grey: #f8f8f8;\n$theme_white: #ffffff;\n$theme_text_grey: #606060;\n$theme_yellow:#fbff5b;\n$theme_green:#3ec654;\n$theme_black: #000000;\n$theme_red: #980411;\n$theme_orange:#F18625;\n$theme_purple:#7824EF;\n$theme_grey:#7F7F7F;\n$theme_blue:#172376;\n$theme_pink: #f9e2e3;\n$theme_light_green: #def3e2;\n\n\n//Font Size Variables\n$font-xs: 10px;\n$font-small: 12px;\n$font-medium: 15px;\n$font-large: 18px;\n\n//mobile breakpoint for css\n$mobile-breakpoint: 768px;"],"sourceRoot":"webpack://"}]);
	
	// exports
	exports.locals = {
		"container": "Card__container___3Sqon",
		"selectorCardContainer": "Card__selectorCardContainer___1L1yp",
		"carousal": "Card__carousal___36YhQ",
		"tile": "Card__tile___1DjA3",
		"tileImages": "Card__tileImages___22oey",
		"cardText": "Card__cardText___2eo5c"
	};

/***/ }),
/* 450 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "ae0d08f87ac851816086ab6d9855f648.jpeg";

/***/ }),
/* 451 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "a3708d1bee021f65b01a3f8e97b57915.jpeg";

/***/ }),
/* 452 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "e57f0ae694dac9ee3a157932fdf33dd1.jpg";

/***/ }),
/* 453 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Carousel = __webpack_require__(454);
	
	var _Carousel2 = _interopRequireDefault(_Carousel);
	
	var _nukaCarousel = __webpack_require__(456);
	
	var _nukaCarousel2 = _interopRequireDefault(_nukaCarousel);
	
	var _Highlights = __webpack_require__(462);
	
	var _trophy = __webpack_require__(463);
	
	var _trophy2 = _interopRequireDefault(_trophy);
	
	var _best = __webpack_require__(464);
	
	var _best2 = _interopRequireDefault(_best);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Carousel = function Carousel() {
	  var HighlightList = _Highlights.Highlights.map(function (data, index) {
	    return _react2.default.createElement(
	      'div',
	      { key: data.text },
	      _react2.default.createElement('img', { className: _Carousel2.default.best, src: _best2.default }),
	      _react2.default.createElement(
	        'div',
	        { className: _Carousel2.default.factContainer },
	        _react2.default.createElement(
	          'div',
	          { className: _Carousel2.default.factText },
	          data.text
	        ),
	        _react2.default.createElement('img', { src: _trophy2.default, className: _Carousel2.default.trophy })
	      )
	    );
	  });
	  return _react2.default.createElement(
	    'div',
	    { className: _Carousel2.default.container + ' p1' },
	    _react2.default.createElement(
	      _nukaCarousel2.default,
	      { autoplay: true, wrapAround: true },
	      HighlightList
	    )
	  );
	};
	
	exports.default = Carousel;

/***/ }),
/* 454 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(455);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(432)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(true) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept(455, function() {
				var newContent = __webpack_require__(455);
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 455 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(431)();
	// imports
	
	
	// module
	exports.push([module.id, ".Carousel__container___4N826 .slider,.Carousel__container___4N826 slider-frame{min-height:200px}.Carousel__container___4N826 .slider-decorator-0,.Carousel__container___4N826 .slider-decorator-1{display:none}.Carousel__container___4N826 .slider-decorator-2 ul{top:40px!important}.Carousel__container___4N826 .slider-decorator-2 ul li button{color:#fff!important;font-size:40px}.Carousel__factContainer___3A7kB{display:-ms-flexbox;display:flex;-ms-flex-pack:justify;justify-content:space-between}.Carousel__trophy___3u76Z{height:260px;padding:20px}.Carousel__factText___2C1O8{color:#fff;font-size:24px;padding:140px 0 0 70px}.Carousel__best___2pXbk{width:250px;position:absolute;left:72px;top:60px}@media screen and (max-width:768px){.Carousel__factText___2C1O8{color:#fff;font-size:20px;padding:40px}.Carousel__best___2pXbk,.Carousel__trophy___3u76Z{display:none}}", "", {"version":3,"sources":["/./src/components/Carousel/src/components/Carousel/Carousel.scss"],"names":[],"mappings":"AAEA,+EAIM,gBAAkB,CAJxB,kGAQM,YAAc,CARpB,oDAWM,kBAAmB,CAXzB,8DAcM,qBAA6B,cACb,CACjB,iCAKH,oBAAA,aAAc,sBACd,6BAA+B,CAChC,0BAGC,aAAc,YACA,CACf,4BAGC,WAAa,eACG,sBACU,CAC3B,wBAGC,YAAa,kBACM,UACR,QACD,CACX,oCAGC,4BACE,WAAa,eACG,YACF,CACf,kDAKC,YAAc,CACf,CAAA","file":"Carousel.scss","sourcesContent":["@import '../../styles/variables';\n\n.container {\n   :global {\n    .slider,\n    slider-frame {\n      min-height: 200px;\n    }\n    .slider-decorator-0,\n    .slider-decorator-1 {\n      display: none;\n    }\n    .slider-decorator-2 ul {\n      top: 40px!important;\n    }\n    .slider-decorator-2 ul li button {\n      color: $theme_white!important;\n      font-size: 40px;\n    }\n  }\n}\n\n.factContainer {\n  display: flex;\n  justify-content: space-between;\n}\n\n.trophy {\n  height: 260px;\n  padding: 20px;\n}\n\n.factText {\n  color: white;\n  font-size: 24px;\n  padding: 140px 0px 0 70px;\n}\n\n.best {\n  width: 250px;\n  position: absolute;\n  left: 72px;\n  top: 60px;\n}\n\n@media screen and (max-width: $mobile_breakpoint) {\n  .factText {\n    color: white;\n    font-size: 20px;\n    padding: 40px;\n  }\n  .trophy {\n    display: none;\n  }\n  .best {\n    display: none;\n  }\n}\n"],"sourceRoot":"webpack://"}]);
	
	// exports
	exports.locals = {
		"container": "Carousel__container___4N826",
		"factContainer": "Carousel__factContainer___3A7kB",
		"trophy": "Carousel__trophy___3u76Z",
		"factText": "Carousel__factText___2C1O8",
		"best": "Carousel__best___2pXbk"
	};

/***/ }),
/* 456 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var Carousel = __webpack_require__(457);
	
	module.exports = Carousel;


/***/ }),
/* 457 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(38);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _propTypes = __webpack_require__(420);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _kwReactTweenState = __webpack_require__(458);
	
	var _kwReactTweenState2 = _interopRequireDefault(_kwReactTweenState);
	
	var _decorators = __webpack_require__(459);
	
	var _decorators2 = _interopRequireDefault(_decorators);
	
	var _objectAssign = __webpack_require__(4);
	
	var _objectAssign2 = _interopRequireDefault(_objectAssign);
	
	var _exenv = __webpack_require__(461);
	
	var _exenv2 = _interopRequireDefault(_exenv);
	
	var _createReactClass = __webpack_require__(460);
	
	var _createReactClass2 = _interopRequireDefault(_createReactClass);
	
	var addEvent = function addEvent(elem, type, eventHandle) {
	  if (elem === null || typeof elem === 'undefined') {
	    return;
	  }
	  if (elem.addEventListener) {
	    elem.addEventListener(type, eventHandle, false);
	  } else if (elem.attachEvent) {
	    elem.attachEvent('on' + type, eventHandle);
	  } else {
	    elem['on' + type] = eventHandle;
	  }
	};
	
	var removeEvent = function removeEvent(elem, type, eventHandle) {
	  if (elem === null || typeof elem === 'undefined') {
	    return;
	  }
	  if (elem.removeEventListener) {
	    elem.removeEventListener(type, eventHandle, false);
	  } else if (elem.detachEvent) {
	    elem.detachEvent('on' + type, eventHandle);
	  } else {
	    elem['on' + type] = null;
	  }
	};
	
	var Carousel = (0, _createReactClass2['default'])({
	  displayName: 'Carousel',
	
	  mixins: [_kwReactTweenState2['default'].Mixin],
	
	  propTypes: {
	    afterSlide: _propTypes2['default'].func,
	    autoplay: _propTypes2['default'].bool,
	    autoplayInterval: _propTypes2['default'].number,
	    beforeSlide: _propTypes2['default'].func,
	    cellAlign: _propTypes2['default'].oneOf(['left', 'center', 'right']),
	    cellSpacing: _propTypes2['default'].number,
	    data: _propTypes2['default'].func,
	    decorators: _propTypes2['default'].arrayOf(_propTypes2['default'].shape({
	      component: _propTypes2['default'].func,
	      position: _propTypes2['default'].oneOf(['TopLeft', 'TopCenter', 'TopRight', 'CenterLeft', 'CenterCenter', 'CenterRight', 'BottomLeft', 'BottomCenter', 'BottomRight']),
	      style: _propTypes2['default'].object
	    })),
	    dragging: _propTypes2['default'].bool,
	    easing: _propTypes2['default'].string,
	    edgeEasing: _propTypes2['default'].string,
	    framePadding: _propTypes2['default'].string,
	    frameOverflow: _propTypes2['default'].string,
	    initialSlideHeight: _propTypes2['default'].number,
	    initialSlideWidth: _propTypes2['default'].number,
	    slideIndex: _propTypes2['default'].number,
	    slidesToShow: _propTypes2['default'].number,
	    slidesToScroll: _propTypes2['default'].oneOfType([_propTypes2['default'].number, _propTypes2['default'].oneOf(['auto'])]),
	    slideWidth: _propTypes2['default'].oneOfType([_propTypes2['default'].string, _propTypes2['default'].number]),
	    speed: _propTypes2['default'].number,
	    swiping: _propTypes2['default'].bool,
	    vertical: _propTypes2['default'].bool,
	    width: _propTypes2['default'].string,
	    wrapAround: _propTypes2['default'].bool
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      afterSlide: function afterSlide() {},
	      autoplay: false,
	      autoplayInterval: 3000,
	      beforeSlide: function beforeSlide() {},
	      cellAlign: 'left',
	      cellSpacing: 0,
	      data: function data() {},
	      decorators: _decorators2['default'],
	      dragging: true,
	      easing: 'easeOutCirc',
	      edgeEasing: 'easeOutElastic',
	      framePadding: '0px',
	      frameOverflow: 'hidden',
	      slideIndex: 0,
	      slidesToScroll: 1,
	      slidesToShow: 1,
	      slideWidth: 1,
	      speed: 500,
	      swiping: true,
	      vertical: false,
	      width: '100%',
	      wrapAround: false
	    };
	  },
	
	  getInitialState: function getInitialState() {
	    return {
	      currentSlide: this.props.slideIndex,
	      dragging: false,
	      frameWidth: 0,
	      left: 0,
	      slideCount: 0,
	      slidesToScroll: this.props.slidesToScroll,
	      slideWidth: 0,
	      top: 0
	    };
	  },
	
	  componentWillMount: function componentWillMount() {
	    this.setInitialDimensions();
	  },
	
	  componentDidMount: function componentDidMount() {
	    this.setDimensions();
	    this.bindEvents();
	    this.setExternalData();
	    if (this.props.autoplay) {
	      this.startAutoplay();
	    }
	  },
	
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    this.setState({
	      slideCount: nextProps.children.length
	    });
	    this.setDimensions(nextProps);
	    if (this.props.slideIndex !== nextProps.slideIndex && nextProps.slideIndex !== this.state.currentSlide) {
	      this.goToSlide(nextProps.slideIndex);
	    }
	    if (this.props.autoplay !== nextProps.autoplay) {
	      if (nextProps.autoplay) {
	        this.startAutoplay();
	      } else {
	        this.stopAutoplay();
	      }
	    }
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    this.unbindEvents();
	    this.stopAutoplay();
	  },
	
	  render: function render() {
	    var self = this;
	    var children = _react2['default'].Children.count(this.props.children) > 1 ? this.formatChildren(this.props.children) : this.props.children;
	    return _react2['default'].createElement(
	      'div',
	      {
	        className: ['slider', this.props.className || ''].join(' '),
	        ref: 'slider',
	        style: (0, _objectAssign2['default'])(this.getSliderStyles(), this.props.style || {})
	      },
	      _react2['default'].createElement(
	        'div',
	        _extends({
	          className: 'slider-frame',
	          ref: 'frame',
	          style: this.getFrameStyles()
	        }, this.getTouchEvents(), this.getMouseEvents(), {
	          onClick: this.handleClick
	        }),
	        _react2['default'].createElement(
	          'ul',
	          { className: 'slider-list', ref: 'list', style: this.getListStyles() },
	          children
	        )
	      ),
	      this.props.decorators ? this.props.decorators.map(function (Decorator, index) {
	        return _react2['default'].createElement(
	          'div',
	          {
	            style: (0, _objectAssign2['default'])(self.getDecoratorStyles(Decorator.position), Decorator.style || {}),
	            className: 'slider-decorator-' + index,
	            key: index
	          },
	          _react2['default'].createElement(Decorator.component, {
	            currentSlide: self.state.currentSlide,
	            slideCount: self.state.slideCount,
	            frameWidth: self.state.frameWidth,
	            slideWidth: self.state.slideWidth,
	            slidesToScroll: self.state.slidesToScroll,
	            cellSpacing: self.props.cellSpacing,
	            slidesToShow: self.props.slidesToShow,
	            wrapAround: self.props.wrapAround,
	            nextSlide: self.nextSlide,
	            previousSlide: self.previousSlide,
	            goToSlide: self.goToSlide
	          })
	        );
	      }) : null,
	      _react2['default'].createElement('style', {
	        type: 'text/css',
	        dangerouslySetInnerHTML: { __html: self.getStyleTagStyles() }
	      })
	    );
	  },
	
	  // Touch Events
	
	  touchObject: {},
	
	  getTouchEvents: function getTouchEvents() {
	    var self = this;
	
	    if (self.props.swiping === false) {
	      return null;
	    }
	
	    return {
	      onTouchStart: function onTouchStart(e) {
	        self.touchObject = {
	          startX: e.touches[0].pageX,
	          startY: e.touches[0].pageY
	        };
	        self.handleMouseOver();
	      },
	      onTouchMove: function onTouchMove(e) {
	        var direction = self.swipeDirection(self.touchObject.startX, e.touches[0].pageX, self.touchObject.startY, e.touches[0].pageY);
	
	        if (direction !== 0) {
	          e.preventDefault();
	        }
	
	        var length = self.props.vertical ? Math.round(Math.sqrt(Math.pow(e.touches[0].pageY - self.touchObject.startY, 2))) : Math.round(Math.sqrt(Math.pow(e.touches[0].pageX - self.touchObject.startX, 2)));
	
	        self.touchObject = {
	          startX: self.touchObject.startX,
	          startY: self.touchObject.startY,
	          endX: e.touches[0].pageX,
	          endY: e.touches[0].pageY,
	          length: length,
	          direction: direction
	        };
	
	        self.setState({
	          left: self.props.vertical ? 0 : self.getTargetLeft(self.touchObject.length * self.touchObject.direction),
	          top: self.props.vertical ? self.getTargetLeft(self.touchObject.length * self.touchObject.direction) : 0
	        });
	      },
	      onTouchEnd: function onTouchEnd(e) {
	        self.handleSwipe(e);
	        self.handleMouseOut();
	      },
	      onTouchCancel: function onTouchCancel(e) {
	        self.handleSwipe(e);
	      }
	    };
	  },
	
	  clickSafe: true,
	
	  getMouseEvents: function getMouseEvents() {
	    var self = this;
	
	    if (this.props.dragging === false) {
	      return null;
	    }
	
	    return {
	      onMouseOver: function onMouseOver() {
	        self.handleMouseOver();
	      },
	      onMouseOut: function onMouseOut() {
	        self.handleMouseOut();
	      },
	      onMouseDown: function onMouseDown(e) {
	        self.touchObject = {
	          startX: e.clientX,
	          startY: e.clientY
	        };
	
	        self.setState({
	          dragging: true
	        });
	      },
	      onMouseMove: function onMouseMove(e) {
	        if (!self.state.dragging) {
	          return;
	        }
	
	        var direction = self.swipeDirection(self.touchObject.startX, e.clientX, self.touchObject.startY, e.clientY);
	
	        if (direction !== 0) {
	          e.preventDefault();
	        }
	
	        var length = self.props.vertical ? Math.round(Math.sqrt(Math.pow(e.clientY - self.touchObject.startY, 2))) : Math.round(Math.sqrt(Math.pow(e.clientX - self.touchObject.startX, 2)));
	
	        self.touchObject = {
	          startX: self.touchObject.startX,
	          startY: self.touchObject.startY,
	          endX: e.clientX,
	          endY: e.clientY,
	          length: length,
	          direction: direction
	        };
	
	        self.setState({
	          left: self.props.vertical ? 0 : self.getTargetLeft(self.touchObject.length * self.touchObject.direction),
	          top: self.props.vertical ? self.getTargetLeft(self.touchObject.length * self.touchObject.direction) : 0
	        });
	      },
	      onMouseUp: function onMouseUp(e) {
	        if (!self.state.dragging) {
	          return;
	        }
	
	        self.handleSwipe(e);
	      },
	      onMouseLeave: function onMouseLeave(e) {
	        if (!self.state.dragging) {
	          return;
	        }
	
	        self.handleSwipe(e);
	      }
	    };
	  },
	
	  handleMouseOver: function handleMouseOver() {
	    if (this.props.autoplay) {
	      this.autoplayPaused = true;
	      this.stopAutoplay();
	    }
	  },
	
	  handleMouseOut: function handleMouseOut() {
	    if (this.props.autoplay && this.autoplayPaused) {
	      this.startAutoplay();
	      this.autoplayPaused = null;
	    }
	  },
	
	  handleClick: function handleClick(e) {
	    if (this.clickSafe === true) {
	      e.preventDefault();
	      e.stopPropagation();
	
	      if (e.nativeEvent) {
	        e.nativeEvent.stopPropagation();
	      }
	    }
	  },
	
	  handleSwipe: function handleSwipe(e) {
	    if (typeof this.touchObject.length !== 'undefined' && this.touchObject.length > 44) {
	      this.clickSafe = true;
	    } else {
	      this.clickSafe = false;
	    }
	
	    var slidesToShow = this.props.slidesToShow;
	    if (this.props.slidesToScroll === 'auto') {
	      slidesToShow = this.state.slidesToScroll;
	    }
	
	    if (this.touchObject.length > this.state.slideWidth / slidesToShow / 5) {
	      if (this.touchObject.direction === 1) {
	        if (this.state.currentSlide >= _react2['default'].Children.count(this.props.children) - slidesToShow && !this.props.wrapAround) {
	          this.animateSlide(_kwReactTweenState2['default'].easingTypes[this.props.edgeEasing]);
	        } else {
	          this.nextSlide();
	        }
	      } else if (this.touchObject.direction === -1) {
	        if (this.state.currentSlide <= 0 && !this.props.wrapAround) {
	          this.animateSlide(_kwReactTweenState2['default'].easingTypes[this.props.edgeEasing]);
	        } else {
	          this.previousSlide();
	        }
	      }
	    } else {
	      this.goToSlide(this.state.currentSlide);
	    }
	
	    this.touchObject = {};
	
	    this.setState({
	      dragging: false
	    });
	  },
	
	  swipeDirection: function swipeDirection(x1, x2, y1, y2) {
	    var xDist, yDist, r, swipeAngle;
	
	    xDist = x1 - x2;
	    yDist = y1 - y2;
	    r = Math.atan2(yDist, xDist);
	
	    swipeAngle = Math.round(r * 180 / Math.PI);
	    if (swipeAngle < 0) {
	      swipeAngle = 360 - Math.abs(swipeAngle);
	    }
	    if (swipeAngle <= 45 && swipeAngle >= 0) {
	      return 1;
	    }
	    if (swipeAngle <= 360 && swipeAngle >= 315) {
	      return 1;
	    }
	    if (swipeAngle >= 135 && swipeAngle <= 225) {
	      return -1;
	    }
	    if (this.props.vertical === true) {
	      if (swipeAngle >= 35 && swipeAngle <= 135) {
	        return 1;
	      } else {
	        return -1;
	      }
	    }
	    return 0;
	  },
	
	  autoplayIterator: function autoplayIterator() {
	    if (this.props.wrapAround) {
	      return this.nextSlide();
	    }
	    if (this.state.currentSlide !== this.state.slideCount - this.state.slidesToShow) {
	      this.nextSlide();
	    } else {
	      this.stopAutoplay();
	    }
	  },
	
	  startAutoplay: function startAutoplay() {
	    this.autoplayID = setInterval(this.autoplayIterator, this.props.autoplayInterval);
	  },
	
	  resetAutoplay: function resetAutoplay() {
	    if (this.props.autoplay && !this.autoplayPaused) {
	      this.stopAutoplay();
	      this.startAutoplay();
	    }
	  },
	
	  stopAutoplay: function stopAutoplay() {
	    this.autoplayID && clearInterval(this.autoplayID);
	  },
	
	  // Action Methods
	
	  goToSlide: function goToSlide(index) {
	    var self = this;
	    if (index >= _react2['default'].Children.count(this.props.children) || index < 0) {
	      if (!this.props.wrapAround) {
	        return;
	      }
	      if (index >= _react2['default'].Children.count(this.props.children)) {
	        this.props.beforeSlide(this.state.currentSlide, 0);
	        return this.setState({
	          currentSlide: 0
	        }, function () {
	          self.animateSlide(null, null, self.getTargetLeft(null, index), function () {
	            self.animateSlide(null, 0.01);
	            self.props.afterSlide(0);
	            self.resetAutoplay();
	            self.setExternalData();
	          });
	        });
	      } else {
	        var endSlide = _react2['default'].Children.count(this.props.children) - this.state.slidesToScroll;
	        this.props.beforeSlide(this.state.currentSlide, endSlide);
	        return this.setState({
	          currentSlide: endSlide
	        }, function () {
	          self.animateSlide(null, null, self.getTargetLeft(null, index), function () {
	            self.animateSlide(null, 0.01);
	            self.props.afterSlide(endSlide);
	            self.resetAutoplay();
	            self.setExternalData();
	          });
	        });
	      }
	    }
	
	    this.props.beforeSlide(this.state.currentSlide, index);
	
	    if (index !== this.state.currentSlide) {
	      this.props.afterSlide(index);
	    }
	    this.setState({
	      currentSlide: index
	    }, function () {
	      self.animateSlide();
	      self.resetAutoplay();
	      self.setExternalData();
	    });
	  },
	
	  nextSlide: function nextSlide() {
	    var childrenCount = _react2['default'].Children.count(this.props.children);
	    var slidesToShow = this.props.slidesToShow;
	    if (this.props.slidesToScroll === 'auto') {
	      slidesToShow = this.state.slidesToScroll;
	    }
	    if (this.state.currentSlide >= childrenCount - slidesToShow && !this.props.wrapAround) {
	      return;
	    }
	
	    if (this.props.wrapAround) {
	      this.goToSlide(this.state.currentSlide + this.state.slidesToScroll);
	    } else {
	      if (this.props.slideWidth !== 1) {
	        return this.goToSlide(this.state.currentSlide + this.state.slidesToScroll);
	      }
	      this.goToSlide(Math.min(this.state.currentSlide + this.state.slidesToScroll, childrenCount - slidesToShow));
	    }
	  },
	
	  previousSlide: function previousSlide() {
	    if (this.state.currentSlide <= 0 && !this.props.wrapAround) {
	      return;
	    }
	
	    if (this.props.wrapAround) {
	      this.goToSlide(this.state.currentSlide - this.state.slidesToScroll);
	    } else {
	      this.goToSlide(Math.max(0, this.state.currentSlide - this.state.slidesToScroll));
	    }
	  },
	
	  // Animation
	
	  animateSlide: function animateSlide(easing, duration, endValue, callback) {
	    this.tweenState(this.props.vertical ? 'top' : 'left', {
	      easing: easing || _kwReactTweenState2['default'].easingTypes[this.props.easing],
	      duration: duration || this.props.speed,
	      endValue: endValue || this.getTargetLeft(),
	      onEnd: callback || null
	    });
	  },
	
	  getTargetLeft: function getTargetLeft(touchOffset, slide) {
	    var offset;
	    var target = slide || this.state.currentSlide;
	    switch (this.props.cellAlign) {
	      case 'left':
	        {
	          offset = 0;
	          offset -= this.props.cellSpacing * target;
	          break;
	        }
	      case 'center':
	        {
	          offset = (this.state.frameWidth - this.state.slideWidth) / 2;
	          offset -= this.props.cellSpacing * target;
	          break;
	        }
	      case 'right':
	        {
	          offset = this.state.frameWidth - this.state.slideWidth;
	          offset -= this.props.cellSpacing * target;
	          break;
	        }
	    }
	
	    var left = this.state.slideWidth * target;
	
	    var lastSlide = this.state.currentSlide > 0 && target + this.state.slidesToScroll >= this.state.slideCount;
	
	    if (lastSlide && this.props.slideWidth !== 1 && !this.props.wrapAround && this.props.slidesToScroll === 'auto') {
	      left = this.state.slideWidth * this.state.slideCount - this.state.frameWidth;
	      offset = 0;
	      offset -= this.props.cellSpacing * (this.state.slideCount - 1);
	    }
	
	    offset -= touchOffset || 0;
	
	    return (left - offset) * -1;
	  },
	
	  // Bootstrapping
	
	  bindEvents: function bindEvents() {
	    var self = this;
	    if (_exenv2['default'].canUseDOM) {
	      addEvent(window, 'resize', self.onResize);
	      addEvent(document, 'readystatechange', self.onReadyStateChange);
	    }
	  },
	
	  onResize: function onResize() {
	    this.setDimensions();
	  },
	
	  onReadyStateChange: function onReadyStateChange() {
	    this.setDimensions();
	  },
	
	  unbindEvents: function unbindEvents() {
	    var self = this;
	    if (_exenv2['default'].canUseDOM) {
	      removeEvent(window, 'resize', self.onResize);
	      removeEvent(document, 'readystatechange', self.onReadyStateChange);
	    }
	  },
	
	  formatChildren: function formatChildren(children) {
	    var self = this;
	    var positionValue = this.props.vertical ? this.getTweeningValue('top') : this.getTweeningValue('left');
	    return _react2['default'].Children.map(children, function (child, index) {
	      return _react2['default'].createElement(
	        'li',
	        {
	          className: 'slider-slide',
	          style: self.getSlideStyles(index, positionValue),
	          key: index
	        },
	        child
	      );
	    });
	  },
	
	  setInitialDimensions: function setInitialDimensions() {
	    var self = this,
	        slideWidth,
	        frameHeight,
	        slideHeight;
	
	    slideWidth = this.props.vertical ? this.props.initialSlideHeight || 0 : this.props.initialSlideWidth || 0;
	    slideHeight = this.props.initialSlideHeight ? this.props.initialSlideHeight * this.props.slidesToShow : 0;
	
	    frameHeight = slideHeight + this.props.cellSpacing * (this.props.slidesToShow - 1);
	
	    this.setState({
	      slideHeight: slideHeight,
	      frameWidth: this.props.vertical ? frameHeight : '100%',
	      slideCount: _react2['default'].Children.count(this.props.children),
	      slideWidth: slideWidth
	    }, function () {
	      self.setLeft();
	      self.setExternalData();
	    });
	  },
	
	  setDimensions: function setDimensions(props) {
	    props = props || this.props;
	
	    var self = this,
	        slideWidth,
	        slidesToScroll,
	        firstSlide,
	        frame,
	        frameWidth,
	        frameHeight,
	        slideHeight;
	
	    slidesToScroll = props.slidesToScroll;
	    frame = this.refs.frame;
	    firstSlide = frame.childNodes[0].childNodes[0];
	    if (firstSlide) {
	      firstSlide.style.height = 'auto';
	      slideHeight = this.props.vertical ? firstSlide.offsetHeight * props.slidesToShow : firstSlide.offsetHeight;
	    } else {
	      slideHeight = 100;
	    }
	
	    if (typeof props.slideWidth !== 'number') {
	      slideWidth = parseInt(props.slideWidth);
	    } else {
	      if (props.vertical) {
	        slideWidth = slideHeight / props.slidesToShow * props.slideWidth;
	      } else {
	        slideWidth = frame.offsetWidth / props.slidesToShow * props.slideWidth;
	      }
	    }
	
	    if (!props.vertical) {
	      slideWidth -= props.cellSpacing * ((100 - 100 / props.slidesToShow) / 100);
	    }
	
	    frameHeight = slideHeight + props.cellSpacing * (props.slidesToShow - 1);
	    frameWidth = props.vertical ? frameHeight : frame.offsetWidth;
	
	    if (props.slidesToScroll === 'auto') {
	      slidesToScroll = Math.floor(frameWidth / (slideWidth + props.cellSpacing));
	    }
	
	    this.setState({
	      slideHeight: slideHeight,
	      frameWidth: frameWidth,
	      slideWidth: slideWidth,
	      slidesToScroll: slidesToScroll,
	      left: props.vertical ? 0 : this.getTargetLeft(),
	      top: props.vertical ? this.getTargetLeft() : 0
	    }, function () {
	      self.setLeft();
	    });
	  },
	
	  setLeft: function setLeft() {
	    this.setState({
	      left: this.props.vertical ? 0 : this.getTargetLeft(),
	      top: this.props.vertical ? this.getTargetLeft() : 0
	    });
	  },
	
	  // Data
	
	  setExternalData: function setExternalData() {
	    if (this.props.data) {
	      this.props.data();
	    }
	  },
	
	  // Styles
	
	  getListStyles: function getListStyles() {
	    var listWidth = this.state.slideWidth * _react2['default'].Children.count(this.props.children);
	    var spacingOffset = this.props.cellSpacing * _react2['default'].Children.count(this.props.children);
	    var transform = 'translate3d(' + this.getTweeningValue('left') + 'px, ' + this.getTweeningValue('top') + 'px, 0)';
	    return {
	      transform: transform,
	      WebkitTransform: transform,
	      msTransform: 'translate(' + this.getTweeningValue('left') + 'px, ' + this.getTweeningValue('top') + 'px)',
	      position: 'relative',
	      display: 'block',
	      margin: this.props.vertical ? this.props.cellSpacing / 2 * -1 + 'px 0px' : '0px ' + this.props.cellSpacing / 2 * -1 + 'px',
	      padding: 0,
	      height: this.props.vertical ? listWidth + spacingOffset : this.state.slideHeight,
	      width: this.props.vertical ? 'auto' : listWidth + spacingOffset,
	      cursor: this.state.dragging === true ? 'pointer' : 'inherit',
	      boxSizing: 'border-box',
	      MozBoxSizing: 'border-box'
	    };
	  },
	
	  getFrameStyles: function getFrameStyles() {
	    return {
	      position: 'relative',
	      display: 'block',
	      overflow: this.props.frameOverflow,
	      height: this.props.vertical ? this.state.frameWidth || 'initial' : 'auto',
	      margin: this.props.framePadding,
	      padding: 0,
	      transform: 'translate3d(0, 0, 0)',
	      WebkitTransform: 'translate3d(0, 0, 0)',
	      msTransform: 'translate(0, 0)',
	      boxSizing: 'border-box',
	      MozBoxSizing: 'border-box'
	    };
	  },
	
	  getSlideStyles: function getSlideStyles(index, positionValue) {
	    var targetPosition = this.getSlideTargetPosition(index, positionValue);
	    return {
	      position: 'absolute',
	      left: this.props.vertical ? 0 : targetPosition,
	      top: this.props.vertical ? targetPosition : 0,
	      display: this.props.vertical ? 'block' : 'inline-block',
	      listStyleType: 'none',
	      verticalAlign: 'top',
	      width: this.props.vertical ? '100%' : this.state.slideWidth,
	      height: 'auto',
	      boxSizing: 'border-box',
	      MozBoxSizing: 'border-box',
	      marginLeft: this.props.vertical ? 'auto' : this.props.cellSpacing / 2,
	      marginRight: this.props.vertical ? 'auto' : this.props.cellSpacing / 2,
	      marginTop: this.props.vertical ? this.props.cellSpacing / 2 : 'auto',
	      marginBottom: this.props.vertical ? this.props.cellSpacing / 2 : 'auto'
	    };
	  },
	
	  getSlideTargetPosition: function getSlideTargetPosition(index, positionValue) {
	    var slidesToShow = this.state.frameWidth / this.state.slideWidth;
	    var targetPosition = (this.state.slideWidth + this.props.cellSpacing) * index;
	    var end = (this.state.slideWidth + this.props.cellSpacing) * slidesToShow * -1;
	
	    if (this.props.wrapAround) {
	      var slidesBefore = Math.ceil(positionValue / this.state.slideWidth);
	      if (this.state.slideCount - slidesBefore <= index) {
	        return (this.state.slideWidth + this.props.cellSpacing) * (this.state.slideCount - index) * -1;
	      }
	
	      var slidesAfter = Math.ceil((Math.abs(positionValue) - Math.abs(end)) / this.state.slideWidth);
	
	      if (this.state.slideWidth !== 1) {
	        slidesAfter = Math.ceil((Math.abs(positionValue) - this.state.slideWidth) / this.state.slideWidth);
	      }
	
	      if (index <= slidesAfter - 1) {
	        return (this.state.slideWidth + this.props.cellSpacing) * (this.state.slideCount + index);
	      }
	    }
	
	    return targetPosition;
	  },
	
	  getSliderStyles: function getSliderStyles() {
	    return {
	      position: 'relative',
	      display: 'block',
	      width: this.props.width,
	      height: 'auto',
	      boxSizing: 'border-box',
	      MozBoxSizing: 'border-box',
	      visibility: this.state.slideWidth ? 'visible' : 'hidden'
	    };
	  },
	
	  getStyleTagStyles: function getStyleTagStyles() {
	    return '.slider-slide > img {width: 100%; display: block;}';
	  },
	
	  getDecoratorStyles: function getDecoratorStyles(position) {
	    switch (position) {
	      case 'TopLeft':
	        {
	          return {
	            position: 'absolute',
	            top: 0,
	            left: 0
	          };
	        }
	      case 'TopCenter':
	        {
	          return {
	            position: 'absolute',
	            top: 0,
	            left: '50%',
	            transform: 'translateX(-50%)',
	            WebkitTransform: 'translateX(-50%)',
	            msTransform: 'translateX(-50%)'
	          };
	        }
	      case 'TopRight':
	        {
	          return {
	            position: 'absolute',
	            top: 0,
	            right: 0
	          };
	        }
	      case 'CenterLeft':
	        {
	          return {
	            position: 'absolute',
	            top: '50%',
	            left: 0,
	            transform: 'translateY(-50%)',
	            WebkitTransform: 'translateY(-50%)',
	            msTransform: 'translateY(-50%)'
	          };
	        }
	      case 'CenterCenter':
	        {
	          return {
	            position: 'absolute',
	            top: '50%',
	            left: '50%',
	            transform: 'translate(-50%,-50%)',
	            WebkitTransform: 'translate(-50%, -50%)',
	            msTransform: 'translate(-50%, -50%)'
	          };
	        }
	      case 'CenterRight':
	        {
	          return {
	            position: 'absolute',
	            top: '50%',
	            right: 0,
	            transform: 'translateY(-50%)',
	            WebkitTransform: 'translateY(-50%)',
	            msTransform: 'translateY(-50%)'
	          };
	        }
	      case 'BottomLeft':
	        {
	          return {
	            position: 'absolute',
	            bottom: 0,
	            left: 0
	          };
	        }
	      case 'BottomCenter':
	        {
	          return {
	            position: 'absolute',
	            bottom: 0,
	            left: '50%',
	            transform: 'translateX(-50%)',
	            WebkitTransform: 'translateX(-50%)',
	            msTransform: 'translateX(-50%)'
	          };
	        }
	      case 'BottomRight':
	        {
	          return {
	            position: 'absolute',
	            bottom: 0,
	            right: 0
	          };
	        }
	      default:
	        {
	          return {
	            position: 'absolute',
	            top: 0,
	            left: 0
	          };
	        }
	    }
	  }
	});
	
	Carousel.ControllerMixin = {
	  getInitialState: function getInitialState() {
	    return {
	      carousels: {}
	    };
	  },
	  setCarouselData: function setCarouselData(carousel) {
	    var data = this.state.carousels;
	    data[carousel] = this.refs[carousel];
	    this.setState({
	      carousels: data
	    });
	  }
	};
	
	exports['default'] = Carousel;
	module.exports = exports['default'];

/***/ }),
/* 458 */
/***/ (function(module, exports, __webpack_require__) {

	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory();
		else if(typeof define === 'function' && define.amd)
			define([], factory);
		else if(typeof exports === 'object')
			exports["tweenState"] = factory();
		else
			root["tweenState"] = factory();
	})(this, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	/******/
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	/******/
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	/******/
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	/******/
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	/******/
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	/******/
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ({
	
	/***/ 0:
	/*!*****************!*\
	  !*** multi lib ***!
	  \*****************/
	/***/ function(module, exports, __webpack_require__) {
	
		module.exports = __webpack_require__(/*! ./index.js */169);
	
	
	/***/ },
	
	/***/ 5:
	/*!******************************!*\
	  !*** ./~/process/browser.js ***!
	  \******************************/
	/***/ function(module, exports) {
	
		// shim for using process in browser
		
		var process = module.exports = {};
		var queue = [];
		var draining = false;
		var currentQueue;
		var queueIndex = -1;
		
		function cleanUpNextTick() {
		    draining = false;
		    if (currentQueue.length) {
		        queue = currentQueue.concat(queue);
		    } else {
		        queueIndex = -1;
		    }
		    if (queue.length) {
		        drainQueue();
		    }
		}
		
		function drainQueue() {
		    if (draining) {
		        return;
		    }
		    var timeout = setTimeout(cleanUpNextTick);
		    draining = true;
		
		    var len = queue.length;
		    while(len) {
		        currentQueue = queue;
		        queue = [];
		        while (++queueIndex < len) {
		            if (currentQueue) {
		                currentQueue[queueIndex].run();
		            }
		        }
		        queueIndex = -1;
		        len = queue.length;
		    }
		    currentQueue = null;
		    draining = false;
		    clearTimeout(timeout);
		}
		
		process.nextTick = function (fun) {
		    var args = new Array(arguments.length - 1);
		    if (arguments.length > 1) {
		        for (var i = 1; i < arguments.length; i++) {
		            args[i - 1] = arguments[i];
		        }
		    }
		    queue.push(new Item(fun, args));
		    if (queue.length === 1 && !draining) {
		        setTimeout(drainQueue, 0);
		    }
		};
		
		// v8 likes predictible objects
		function Item(fun, array) {
		    this.fun = fun;
		    this.array = array;
		}
		Item.prototype.run = function () {
		    this.fun.apply(null, this.array);
		};
		process.title = 'browser';
		process.browser = true;
		process.env = {};
		process.argv = [];
		process.version = ''; // empty string to avoid regexp issues
		process.versions = {};
		
		function noop() {}
		
		process.on = noop;
		process.addListener = noop;
		process.once = noop;
		process.off = noop;
		process.removeListener = noop;
		process.removeAllListeners = noop;
		process.emit = noop;
		
		process.binding = function (name) {
		    throw new Error('process.binding is not supported');
		};
		
		process.cwd = function () { return '/' };
		process.chdir = function (dir) {
		    throw new Error('process.chdir is not supported');
		};
		process.umask = function() { return 0; };
	
	
	/***/ },
	
	/***/ 169:
	/*!******************!*\
	  !*** ./index.js ***!
	  \******************/
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		Object.defineProperty(exports, '__esModule', {
		  value: true
		});
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
		
		var _tweenFunctions = __webpack_require__(/*! tween-functions */ 170);
		
		var _tweenFunctions2 = _interopRequireDefault(_tweenFunctions);
		
		var _raf = __webpack_require__(/*! raf */ 171);
		
		var _raf2 = _interopRequireDefault(_raf);
		
		// additive is the new iOS 8 default. In most cases it simulates a physics-
		// looking overshoot behavior (especially with easeInOut. You can test that in
		// the example
		var DEFAULT_STACK_BEHAVIOR = 'ADDITIVE';
		var DEFAULT_EASING = _tweenFunctions.easeInOutQuad;
		var DEFAULT_DURATION = 300;
		var DEFAULT_DELAY = 0;
		
		var stackBehavior = {
		  ADDITIVE: 'ADDITIVE',
		  DESTRUCTIVE: 'DESTRUCTIVE'
		};
		
		var Mixin = {
		  _rafID: null,
		
		  getInitialState: function getInitialState() {
		    return {
		      tweenQueue: []
		    };
		  },
		
		  componentWillUnmount: function componentWillUnmount() {
		    _raf2['default'].cancel(this._rafID);
		    this._rafID = -1;
		  },
		
		  tweenState: function tweenState(path, _ref) {
		    var _this = this;
		
		    var easing = _ref.easing;
		    var duration = _ref.duration;
		    var delay = _ref.delay;
		    var beginValue = _ref.beginValue;
		    var endValue = _ref.endValue;
		    var onEnd = _ref.onEnd;
		    var configSB = _ref.stackBehavior;
		
		    this.setState(function (state) {
		      var cursor = state;
		      var stateName = undefined;
		      // see comment below on pash hash
		      var pathHash = undefined;
		      if (typeof path === 'string') {
		        stateName = path;
		        pathHash = path;
		      } else {
		        for (var i = 0; i < path.length - 1; i++) {
		          cursor = cursor[path[i]];
		        }
		        stateName = path[path.length - 1];
		        pathHash = path.join('|');
		      }
		      // see the reasoning for these defaults at the top of file
		      var newConfig = {
		        easing: easing || DEFAULT_EASING,
		        duration: duration == null ? DEFAULT_DURATION : duration,
		        delay: delay == null ? DEFAULT_DELAY : delay,
		        beginValue: beginValue == null ? cursor[stateName] : beginValue,
		        endValue: endValue,
		        onEnd: onEnd,
		        stackBehavior: configSB || DEFAULT_STACK_BEHAVIOR
		      };
		
		      var newTweenQueue = state.tweenQueue;
		      if (newConfig.stackBehavior === stackBehavior.DESTRUCTIVE) {
		        newTweenQueue = state.tweenQueue.filter(function (item) {
		          return item.pathHash !== pathHash;
		        });
		      }
		
		      // we store path hash, so that during value retrieval we can use hash
		      // comparison to find the path. See the kind of shitty thing you have to
		      // do when you don't have value comparison for collections?
		      newTweenQueue.push({
		        pathHash: pathHash,
		        config: newConfig,
		        initTime: Date.now() + newConfig.delay
		      });
		
		      // sorry for mutating. For perf reasons we don't want to deep clone.
		      // guys, can we please all start using persistent collections so that
		      // we can stop worrying about nonesense like this
		      cursor[stateName] = newConfig.endValue;
		      if (newTweenQueue.length === 1) {
		        _this._rafID = (0, _raf2['default'])(_this._rafCb);
		      }
		
		      // this will also include the above mutated update
		      return { tweenQueue: newTweenQueue };
		    });
		  },
		
		  getTweeningValue: function getTweeningValue(path) {
		    var state = this.state;
		
		    var tweeningValue = undefined;
		    var pathHash = undefined;
		    if (typeof path === 'string') {
		      tweeningValue = state[path];
		      pathHash = path;
		    } else {
		      tweeningValue = state;
		      for (var i = 0; i < path.length; i++) {
		        tweeningValue = tweeningValue[path[i]];
		      }
		      pathHash = path.join('|');
		    }
		    var now = Date.now();
		
		    for (var i = 0; i < state.tweenQueue.length; i++) {
		      var _state$tweenQueue$i = state.tweenQueue[i];
		      var itemPathHash = _state$tweenQueue$i.pathHash;
		      var initTime = _state$tweenQueue$i.initTime;
		      var config = _state$tweenQueue$i.config;
		
		      if (itemPathHash !== pathHash) {
		        continue;
		      }
		
		      var progressTime = now - initTime > config.duration ? config.duration : Math.max(0, now - initTime);
		      // `now - initTime` can be negative if initTime is scheduled in the
		      // future by a delay. In this case we take 0
		
		      // if duration is 0, consider that as jumping to endValue directly. This
		      // is needed because the easing functino might have undefined behavior for
		      // duration = 0
		      var easeValue = config.duration === 0 ? config.endValue : config.easing(progressTime, config.beginValue, config.endValue, config.duration);
		
		      // TODO: some funcs accept a 5th param
		      var contrib = easeValue - config.endValue;
		      tweeningValue += contrib;
		    }
		
		    return tweeningValue;
		  },
		
		  _rafCb: function _rafCb() {
		    var state = this.state;
		    if (state.tweenQueue.length === 0) {
		      return;
		    }
		
		    var now = Date.now();
		    var newTweenQueue = [];
		
		    for (var i = 0; i < state.tweenQueue.length; i++) {
		      var item = state.tweenQueue[i];
		      var initTime = item.initTime;
		      var config = item.config;
		
		      if (now - initTime < config.duration) {
		        newTweenQueue.push(item);
		      } else {
		        config.onEnd && config.onEnd();
		      }
		    }
		
		    // onEnd might trigger a parent callback that removes this component
		    // -1 means we've canceled it in componentWillUnmount
		    if (this._rafID === -1) {
		      return;
		    }
		
		    this.setState({
		      tweenQueue: newTweenQueue
		    });
		
		    this._rafID = (0, _raf2['default'])(this._rafCb);
		  }
		};
		
		exports['default'] = {
		  Mixin: Mixin,
		  easingTypes: _tweenFunctions2['default'],
		  stackBehavior: stackBehavior
		};
		module.exports = exports['default'];
	
	/***/ },
	
	/***/ 170:
	/*!************************************!*\
	  !*** ./~/tween-functions/index.js ***!
	  \************************************/
	/***/ function(module, exports) {
	
		'use strict';
		
		// t: current time, b: beginning value, _c: final value, d: total duration
		var tweenFunctions = {
		  linear: function(t, b, _c, d) {
		    var c = _c - b;
		    return c * t / d + b;
		  },
		  easeInQuad: function(t, b, _c, d) {
		    var c = _c - b;
		    return c * (t /= d) * t + b;
		  },
		  easeOutQuad: function(t, b, _c, d) {
		    var c = _c - b;
		    return -c * (t /= d) * (t - 2) + b;
		  },
		  easeInOutQuad: function(t, b, _c, d) {
		    var c = _c - b;
		    if ((t /= d / 2) < 1) {
		      return c / 2 * t * t + b;
		    } else {
		      return -c / 2 * ((--t) * (t - 2) - 1) + b;
		    }
		  },
		  easeInCubic: function(t, b, _c, d) {
		    var c = _c - b;
		    return c * (t /= d) * t * t + b;
		  },
		  easeOutCubic: function(t, b, _c, d) {
		    var c = _c - b;
		    return c * ((t = t / d - 1) * t * t + 1) + b;
		  },
		  easeInOutCubic: function(t, b, _c, d) {
		    var c = _c - b;
		    if ((t /= d / 2) < 1) {
		      return c / 2 * t * t * t + b;
		    } else {
		      return c / 2 * ((t -= 2) * t * t + 2) + b;
		    }
		  },
		  easeInQuart: function(t, b, _c, d) {
		    var c = _c - b;
		    return c * (t /= d) * t * t * t + b;
		  },
		  easeOutQuart: function(t, b, _c, d) {
		    var c = _c - b;
		    return -c * ((t = t / d - 1) * t * t * t - 1) + b;
		  },
		  easeInOutQuart: function(t, b, _c, d) {
		    var c = _c - b;
		    if ((t /= d / 2) < 1) {
		      return c / 2 * t * t * t * t + b;
		    } else {
		      return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
		    }
		  },
		  easeInQuint: function(t, b, _c, d) {
		    var c = _c - b;
		    return c * (t /= d) * t * t * t * t + b;
		  },
		  easeOutQuint: function(t, b, _c, d) {
		    var c = _c - b;
		    return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
		  },
		  easeInOutQuint: function(t, b, _c, d) {
		    var c = _c - b;
		    if ((t /= d / 2) < 1) {
		      return c / 2 * t * t * t * t * t + b;
		    } else {
		      return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
		    }
		  },
		  easeInSine: function(t, b, _c, d) {
		    var c = _c - b;
		    return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
		  },
		  easeOutSine: function(t, b, _c, d) {
		    var c = _c - b;
		    return c * Math.sin(t / d * (Math.PI / 2)) + b;
		  },
		  easeInOutSine: function(t, b, _c, d) {
		    var c = _c - b;
		    return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
		  },
		  easeInExpo: function(t, b, _c, d) {
		    var c = _c - b;
		    return (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;
		  },
		  easeOutExpo: function(t, b, _c, d) {
		    var c = _c - b;
		    return (t==d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b;
		  },
		  easeInOutExpo: function(t, b, _c, d) {
		    var c = _c - b;
		    if (t === 0) {
		      return b;
		    }
		    if (t === d) {
		      return b + c;
		    }
		    if ((t /= d / 2) < 1) {
		      return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
		    } else {
		      return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
		    }
		  },
		  easeInCirc: function(t, b, _c, d) {
		    var c = _c - b;
		    return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
		  },
		  easeOutCirc: function(t, b, _c, d) {
		    var c = _c - b;
		    return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
		  },
		  easeInOutCirc: function(t, b, _c, d) {
		    var c = _c - b;
		    if ((t /= d / 2) < 1) {
		      return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
		    } else {
		      return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
		    }
		  },
		  easeInElastic: function(t, b, _c, d) {
		    var c = _c - b;
		    var a, p, s;
		    s = 1.70158;
		    p = 0;
		    a = c;
		    if (t === 0) {
		      return b;
		    } else if ((t /= d) === 1) {
		      return b + c;
		    }
		    if (!p) {
		      p = d * 0.3;
		    }
		    if (a < Math.abs(c)) {
		      a = c;
		      s = p / 4;
		    } else {
		      s = p / (2 * Math.PI) * Math.asin(c / a);
		    }
		    return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
		  },
		  easeOutElastic: function(t, b, _c, d) {
		    var c = _c - b;
		    var a, p, s;
		    s = 1.70158;
		    p = 0;
		    a = c;
		    if (t === 0) {
		      return b;
		    } else if ((t /= d) === 1) {
		      return b + c;
		    }
		    if (!p) {
		      p = d * 0.3;
		    }
		    if (a < Math.abs(c)) {
		      a = c;
		      s = p / 4;
		    } else {
		      s = p / (2 * Math.PI) * Math.asin(c / a);
		    }
		    return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;
		  },
		  easeInOutElastic: function(t, b, _c, d) {
		    var c = _c - b;
		    var a, p, s;
		    s = 1.70158;
		    p = 0;
		    a = c;
		    if (t === 0) {
		      return b;
		    } else if ((t /= d / 2) === 2) {
		      return b + c;
		    }
		    if (!p) {
		      p = d * (0.3 * 1.5);
		    }
		    if (a < Math.abs(c)) {
		      a = c;
		      s = p / 4;
		    } else {
		      s = p / (2 * Math.PI) * Math.asin(c / a);
		    }
		    if (t < 1) {
		      return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
		    } else {
		      return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b;
		    }
		  },
		  easeInBack: function(t, b, _c, d, s) {
		    var c = _c - b;
		    if (s === void 0) {
		      s = 1.70158;
		    }
		    return c * (t /= d) * t * ((s + 1) * t - s) + b;
		  },
		  easeOutBack: function(t, b, _c, d, s) {
		    var c = _c - b;
		    if (s === void 0) {
		      s = 1.70158;
		    }
		    return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
		  },
		  easeInOutBack: function(t, b, _c, d, s) {
		    var c = _c - b;
		    if (s === void 0) {
		      s = 1.70158;
		    }
		    if ((t /= d / 2) < 1) {
		      return c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;
		    } else {
		      return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
		    }
		  },
		  easeInBounce: function(t, b, _c, d) {
		    var c = _c - b;
		    var v;
		    v = tweenFunctions.easeOutBounce(d - t, 0, c, d);
		    return c - v + b;
		  },
		  easeOutBounce: function(t, b, _c, d) {
		    var c = _c - b;
		    if ((t /= d) < 1 / 2.75) {
		      return c * (7.5625 * t * t) + b;
		    } else if (t < 2 / 2.75) {
		      return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;
		    } else if (t < 2.5 / 2.75) {
		      return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;
		    } else {
		      return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;
		    }
		  },
		  easeInOutBounce: function(t, b, _c, d) {
		    var c = _c - b;
		    var v;
		    if (t < d / 2) {
		      v = tweenFunctions.easeInBounce(t * 2, 0, c, d);
		      return v * 0.5 + b;
		    } else {
		      v = tweenFunctions.easeOutBounce(t * 2 - d, 0, c, d);
		      return v * 0.5 + c * 0.5 + b;
		    }
		  }
		};
		
		module.exports = tweenFunctions;
	
	
	/***/ },
	
	/***/ 171:
	/*!************************!*\
	  !*** ./~/raf/index.js ***!
	  \************************/
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(global) {var now = __webpack_require__(/*! performance-now */ 172)
		  , root = typeof window === 'undefined' ? global : window
		  , vendors = ['moz', 'webkit']
		  , suffix = 'AnimationFrame'
		  , raf = root['request' + suffix]
		  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]
		
		for(var i = 0; !raf && i < vendors.length; i++) {
		  raf = root[vendors[i] + 'Request' + suffix]
		  caf = root[vendors[i] + 'Cancel' + suffix]
		      || root[vendors[i] + 'CancelRequest' + suffix]
		}
		
		// Some versions of FF have rAF but not cAF
		if(!raf || !caf) {
		  var last = 0
		    , id = 0
		    , queue = []
		    , frameDuration = 1000 / 60
		
		  raf = function(callback) {
		    if(queue.length === 0) {
		      var _now = now()
		        , next = Math.max(0, frameDuration - (_now - last))
		      last = next + _now
		      setTimeout(function() {
		        var cp = queue.slice(0)
		        // Clear queue here to prevent
		        // callbacks from appending listeners
		        // to the current frame's queue
		        queue.length = 0
		        for(var i = 0; i < cp.length; i++) {
		          if(!cp[i].cancelled) {
		            try{
		              cp[i].callback(last)
		            } catch(e) {
		              setTimeout(function() { throw e }, 0)
		            }
		          }
		        }
		      }, Math.round(next))
		    }
		    queue.push({
		      handle: ++id,
		      callback: callback,
		      cancelled: false
		    })
		    return id
		  }
		
		  caf = function(handle) {
		    for(var i = 0; i < queue.length; i++) {
		      if(queue[i].handle === handle) {
		        queue[i].cancelled = true
		      }
		    }
		  }
		}
		
		module.exports = function(fn) {
		  // Wrap in a new function to prevent
		  // `cancel` potentially being assigned
		  // to the native rAF function
		  return raf.call(root, fn)
		}
		module.exports.cancel = function() {
		  caf.apply(root, arguments)
		}
		module.exports.polyfill = function() {
		  root.requestAnimationFrame = raf
		  root.cancelAnimationFrame = caf
		}
		
		/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))
	
	/***/ },
	
	/***/ 172:
	/*!**************************************************!*\
	  !*** ./~/performance-now/lib/performance-now.js ***!
	  \**************************************************/
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {// Generated by CoffeeScript 1.7.1
		(function() {
		  var getNanoSeconds, hrtime, loadTime;
		
		  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
		    module.exports = function() {
		      return performance.now();
		    };
		  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
		    module.exports = function() {
		      return (getNanoSeconds() - loadTime) / 1e6;
		    };
		    hrtime = process.hrtime;
		    getNanoSeconds = function() {
		      var hr;
		      hr = hrtime();
		      return hr[0] * 1e9 + hr[1];
		    };
		    loadTime = getNanoSeconds();
		  } else if (Date.now) {
		    module.exports = function() {
		      return Date.now() - loadTime;
		    };
		    loadTime = Date.now();
		  } else {
		    module.exports = function() {
		      return new Date().getTime() - loadTime;
		    };
		    loadTime = new Date().getTime();
		  }
		
		}).call(this);
		
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/process/browser.js */ 5)))
	
	/***/ }
	
	/******/ })
	});
	;
	//# sourceMappingURL=index.js.map

/***/ }),
/* 459 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _createReactClass = __webpack_require__(460);
	
	var _createReactClass2 = _interopRequireDefault(_createReactClass);
	
	var DefaultDecorators = [{
	  component: (0, _createReactClass2['default'])({
	    render: function render() {
	      return _react2['default'].createElement(
	        'button',
	        {
	          style: this.getButtonStyles(this.props.currentSlide === 0 && !this.props.wrapAround),
	          onClick: this.handleClick },
	        'PREV'
	      );
	    },
	    handleClick: function handleClick(e) {
	      e.preventDefault();
	      this.props.previousSlide();
	    },
	    getButtonStyles: function getButtonStyles(disabled) {
	      return {
	        border: 0,
	        background: 'rgba(0,0,0,0.4)',
	        color: 'white',
	        padding: 10,
	        outline: 0,
	        opacity: disabled ? 0.3 : 1,
	        cursor: 'pointer'
	      };
	    }
	  }),
	  position: 'CenterLeft'
	}, {
	  component: (0, _createReactClass2['default'])({
	    render: function render() {
	      return _react2['default'].createElement(
	        'button',
	        {
	          style: this.getButtonStyles(this.props.currentSlide + this.props.slidesToScroll >= this.props.slideCount && !this.props.wrapAround),
	          onClick: this.handleClick },
	        'NEXT'
	      );
	    },
	    handleClick: function handleClick(e) {
	      e.preventDefault();
	      this.props.nextSlide();
	    },
	    getButtonStyles: function getButtonStyles(disabled) {
	      return {
	        border: 0,
	        background: 'rgba(0,0,0,0.4)',
	        color: 'white',
	        padding: 10,
	        outline: 0,
	        opacity: disabled ? 0.3 : 1,
	        cursor: 'pointer'
	      };
	    }
	  }),
	  position: 'CenterRight'
	}, {
	  component: (0, _createReactClass2['default'])({
	    render: function render() {
	      var self = this;
	      var indexes = this.getIndexes(self.props.slideCount, self.props.slidesToScroll);
	      return _react2['default'].createElement(
	        'ul',
	        { style: self.getListStyles() },
	        indexes.map(function (index) {
	          return _react2['default'].createElement(
	            'li',
	            { style: self.getListItemStyles(), key: index },
	            _react2['default'].createElement(
	              'button',
	              {
	                style: self.getButtonStyles(self.props.currentSlide === index),
	                onClick: self.props.goToSlide.bind(null, index) },
	              '•'
	            )
	          );
	        })
	      );
	    },
	    getIndexes: function getIndexes(count, inc) {
	      var arr = [];
	      for (var i = 0; i < count; i += inc) {
	        arr.push(i);
	      }
	      return arr;
	    },
	    getListStyles: function getListStyles() {
	      return {
	        position: 'relative',
	        margin: 0,
	        top: -10,
	        padding: 0
	      };
	    },
	    getListItemStyles: function getListItemStyles() {
	      return {
	        listStyleType: 'none',
	        display: 'inline-block'
	      };
	    },
	    getButtonStyles: function getButtonStyles(active) {
	      return {
	        border: 0,
	        background: 'transparent',
	        color: 'black',
	        cursor: 'pointer',
	        padding: 10,
	        outline: 0,
	        fontSize: 24,
	        opacity: active ? 1 : 0.5
	      };
	    }
	  }),
	  position: 'BottomCenter'
	}];
	
	exports['default'] = DefaultDecorators;
	module.exports = exports['default'];

/***/ }),
/* 460 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	
	'use strict';
	
	var React = __webpack_require__(2);
	var factory = __webpack_require__(36);
	
	if (typeof React === 'undefined') {
	  throw Error(
	    'create-react-class could not find the React object. If you are using script tags, ' +
	      'make sure that React is being loaded before create-react-class.'
	  );
	}
	
	// Hack to grab NoopUpdateQueue from isomorphic React
	var ReactNoopUpdateQueue = new React.Component().updater;
	
	module.exports = factory(
	  React.Component,
	  React.isValidElement,
	  ReactNoopUpdateQueue
	);


/***/ }),
/* 461 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*!
	  Copyright (c) 2015 Jed Watson.
	  Based on code that is Copyright 2013-2015, Facebook, Inc.
	  All rights reserved.
	*/
	/* global define */
	
	(function () {
		'use strict';
	
		var canUseDOM = !!(
			typeof window !== 'undefined' &&
			window.document &&
			window.document.createElement
		);
	
		var ExecutionEnvironment = {
	
			canUseDOM: canUseDOM,
	
			canUseWorkers: typeof Worker !== 'undefined',
	
			canUseEventListeners:
				canUseDOM && !!(window.addEventListener || window.attachEvent),
	
			canUseViewport: canUseDOM && !!window.screen
	
		};
	
		if (true) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return ExecutionEnvironment;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (typeof module !== 'undefined' && module.exports) {
			module.exports = ExecutionEnvironment;
		} else {
			window.ExecutionEnvironment = ExecutionEnvironment;
		}
	
	}());


/***/ }),
/* 462 */
/***/ (function(module, exports) {

	module.exports = {"Highlights":[{"text":"Chris Gayle has won the most number of man of the match awards throughout IPL (17). His batting strike rate is a staggering 152.4","img":"Chris"},{"text":"Virat Kohli holds the record for most runs scored by a batsman in IPL history (4115)"},{"text":"M Chinnaswamy Stadium in Bangalore has hosted the most number of IPL matches (58)"},{"text":"Lasith Malinga has take the most of wickets in IPL history (159)"},{"text":"Suresh Raina holds the records for most number of catches in IPL history (79)"}]}

/***/ }),
/* 463 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "d78c3b0b832b2c78f099dae92c14a5b5.png";

/***/ }),
/* 464 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "570ae796d8e28555e82d16eee079e8ce.png";

/***/ }),
/* 465 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.combineActions = exports.handleActions = exports.handleAction = exports.createActions = exports.createAction = undefined;
	
	var _createAction = __webpack_require__(466);
	
	var _createAction2 = _interopRequireDefault(_createAction);
	
	var _handleAction = __webpack_require__(472);
	
	var _handleAction2 = _interopRequireDefault(_handleAction);
	
	var _handleActions = __webpack_require__(521);
	
	var _handleActions2 = _interopRequireDefault(_handleActions);
	
	var _combineActions = __webpack_require__(505);
	
	var _combineActions2 = _interopRequireDefault(_combineActions);
	
	var _createActions = __webpack_require__(524);
	
	var _createActions2 = _interopRequireDefault(_createActions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.createAction = _createAction2.default;
	exports.createActions = _createActions2.default;
	exports.handleAction = _handleAction2.default;
	exports.handleActions = _handleActions2.default;
	exports.combineActions = _combineActions2.default;

/***/ }),
/* 466 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = createAction;
	
	var _identity = __webpack_require__(467);
	
	var _identity2 = _interopRequireDefault(_identity);
	
	var _isFunction = __webpack_require__(468);
	
	var _isFunction2 = _interopRequireDefault(_isFunction);
	
	var _isUndefined = __webpack_require__(470);
	
	var _isUndefined2 = _interopRequireDefault(_isUndefined);
	
	var _isNull = __webpack_require__(471);
	
	var _isNull2 = _interopRequireDefault(_isNull);
	
	var _invariant = __webpack_require__(187);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function createAction(type) {
	  var payloadCreator = arguments.length <= 1 || arguments[1] === undefined ? _identity2.default : arguments[1];
	  var metaCreator = arguments[2];
	
	  (0, _invariant2.default)((0, _isFunction2.default)(payloadCreator) || (0, _isNull2.default)(payloadCreator), 'Expected payloadCreator to be a function, undefined or null');
	
	  var finalPayloadCreator = (0, _isNull2.default)(payloadCreator) ? _identity2.default : payloadCreator;
	
	  var actionCreator = function actionCreator() {
	    var hasError = (arguments.length <= 0 ? undefined : arguments[0]) instanceof Error;
	
	    var action = {
	      type: type
	    };
	
	    var payload = hasError ? arguments.length <= 0 ? undefined : arguments[0] : finalPayloadCreator.apply(undefined, arguments);
	    if (!(0, _isUndefined2.default)(payload)) {
	      action.payload = payload;
	    }
	
	    if (hasError || payload instanceof Error) {
	      // Handle FSA errors where the payload is an Error object. Set error.
	      action.error = true;
	    }
	
	    if ((0, _isFunction2.default)(metaCreator)) {
	      action.meta = metaCreator.apply(undefined, arguments);
	    }
	
	    return action;
	  };
	
	  actionCreator.toString = function () {
	    return type.toString();
	  };
	
	  return actionCreator;
	}

/***/ }),
/* 467 */
/***/ (function(module, exports) {

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}
	
	module.exports = identity;


/***/ }),
/* 468 */
/***/ (function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(257),
	    isObject = __webpack_require__(469);
	
	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';
	
	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}
	
	module.exports = isFunction;


/***/ }),
/* 469 */
/***/ (function(module, exports) {

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}
	
	module.exports = isObject;


/***/ }),
/* 470 */
/***/ (function(module, exports) {

	/**
	 * Checks if `value` is `undefined`.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
	 * @example
	 *
	 * _.isUndefined(void 0);
	 * // => true
	 *
	 * _.isUndefined(null);
	 * // => false
	 */
	function isUndefined(value) {
	  return value === undefined;
	}
	
	module.exports = isUndefined;


/***/ }),
/* 471 */
/***/ (function(module, exports) {

	/**
	 * Checks if `value` is `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
	 * @example
	 *
	 * _.isNull(null);
	 * // => true
	 *
	 * _.isNull(void 0);
	 * // => false
	 */
	function isNull(value) {
	  return value === null;
	}
	
	module.exports = isNull;


/***/ }),
/* 472 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	exports.default = handleAction;
	
	var _isFunction = __webpack_require__(468);
	
	var _isFunction2 = _interopRequireDefault(_isFunction);
	
	var _isPlainObject = __webpack_require__(256);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _identity = __webpack_require__(467);
	
	var _identity2 = _interopRequireDefault(_identity);
	
	var _isNil = __webpack_require__(473);
	
	var _isNil2 = _interopRequireDefault(_isNil);
	
	var _isUndefined = __webpack_require__(470);
	
	var _isUndefined2 = _interopRequireDefault(_isUndefined);
	
	var _includes = __webpack_require__(474);
	
	var _includes2 = _interopRequireDefault(_includes);
	
	var _invariant = __webpack_require__(187);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _combineActions = __webpack_require__(505);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function handleAction(actionType) {
	  var reducer = arguments.length <= 1 || arguments[1] === undefined ? _identity2.default : arguments[1];
	  var defaultState = arguments[2];
	
	  var actionTypes = actionType.toString().split(_combineActions.ACTION_TYPE_DELIMITER);
	  (0, _invariant2.default)(!(0, _isUndefined2.default)(defaultState), 'defaultState for reducer handling ' + actionTypes.join(', ') + ' should be defined');
	  (0, _invariant2.default)((0, _isFunction2.default)(reducer) || (0, _isPlainObject2.default)(reducer), 'Expected reducer to be a function or object with next and throw reducers');
	
	  var _ref = (0, _isFunction2.default)(reducer) ? [reducer, reducer] : [reducer.next, reducer.throw].map(function (aReducer) {
	    return (0, _isNil2.default)(aReducer) ? _identity2.default : aReducer;
	  });
	
	  var _ref2 = _slicedToArray(_ref, 2);
	
	  var nextReducer = _ref2[0];
	  var throwReducer = _ref2[1];
	
	
	  return function () {
	    var state = arguments.length <= 0 || arguments[0] === undefined ? defaultState : arguments[0];
	    var action = arguments[1];
	    var type = action.type;
	
	    if (!type || !(0, _includes2.default)(actionTypes, type.toString())) {
	      return state;
	    }
	
	    return (action.error === true ? throwReducer : nextReducer)(state, action);
	  };
	}

/***/ }),
/* 473 */
/***/ (function(module, exports) {

	/**
	 * Checks if `value` is `null` or `undefined`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
	 * @example
	 *
	 * _.isNil(null);
	 * // => true
	 *
	 * _.isNil(void 0);
	 * // => true
	 *
	 * _.isNil(NaN);
	 * // => false
	 */
	function isNil(value) {
	  return value == null;
	}
	
	module.exports = isNil;


/***/ }),
/* 474 */
/***/ (function(module, exports, __webpack_require__) {

	var baseIndexOf = __webpack_require__(475),
	    isArrayLike = __webpack_require__(479),
	    isString = __webpack_require__(481),
	    toInteger = __webpack_require__(483),
	    values = __webpack_require__(487);
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;
	
	/**
	 * Checks if `value` is in `collection`. If `collection` is a string, it's
	 * checked for a substring of `value`, otherwise
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * is used for equality comparisons. If `fromIndex` is negative, it's used as
	 * the offset from the end of `collection`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object|string} collection The collection to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} [fromIndex=0] The index to search from.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
	 * @returns {boolean} Returns `true` if `value` is found, else `false`.
	 * @example
	 *
	 * _.includes([1, 2, 3], 1);
	 * // => true
	 *
	 * _.includes([1, 2, 3], 1, 2);
	 * // => false
	 *
	 * _.includes({ 'a': 1, 'b': 2 }, 1);
	 * // => true
	 *
	 * _.includes('abcd', 'bc');
	 * // => true
	 */
	function includes(collection, value, fromIndex, guard) {
	  collection = isArrayLike(collection) ? collection : values(collection);
	  fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;
	
	  var length = collection.length;
	  if (fromIndex < 0) {
	    fromIndex = nativeMax(length + fromIndex, 0);
	  }
	  return isString(collection)
	    ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
	    : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
	}
	
	module.exports = includes;


/***/ }),
/* 475 */
/***/ (function(module, exports, __webpack_require__) {

	var baseFindIndex = __webpack_require__(476),
	    baseIsNaN = __webpack_require__(477),
	    strictIndexOf = __webpack_require__(478);
	
	/**
	 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseIndexOf(array, value, fromIndex) {
	  return value === value
	    ? strictIndexOf(array, value, fromIndex)
	    : baseFindIndex(array, baseIsNaN, fromIndex);
	}
	
	module.exports = baseIndexOf;


/***/ }),
/* 476 */
/***/ (function(module, exports) {

	/**
	 * The base implementation of `_.findIndex` and `_.findLastIndex` without
	 * support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} predicate The function invoked per iteration.
	 * @param {number} fromIndex The index to search from.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseFindIndex(array, predicate, fromIndex, fromRight) {
	  var length = array.length,
	      index = fromIndex + (fromRight ? 1 : -1);
	
	  while ((fromRight ? index-- : ++index < length)) {
	    if (predicate(array[index], index, array)) {
	      return index;
	    }
	  }
	  return -1;
	}
	
	module.exports = baseFindIndex;


/***/ }),
/* 477 */
/***/ (function(module, exports) {

	/**
	 * The base implementation of `_.isNaN` without support for number objects.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	 */
	function baseIsNaN(value) {
	  return value !== value;
	}
	
	module.exports = baseIsNaN;


/***/ }),
/* 478 */
/***/ (function(module, exports) {

	/**
	 * A specialized version of `_.indexOf` which performs strict equality
	 * comparisons of values, i.e. `===`.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function strictIndexOf(array, value, fromIndex) {
	  var index = fromIndex - 1,
	      length = array.length;
	
	  while (++index < length) {
	    if (array[index] === value) {
	      return index;
	    }
	  }
	  return -1;
	}
	
	module.exports = strictIndexOf;


/***/ }),
/* 479 */
/***/ (function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(468),
	    isLength = __webpack_require__(480);
	
	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}
	
	module.exports = isArrayLike;


/***/ }),
/* 480 */
/***/ (function(module, exports) {

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;
	
	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}
	
	module.exports = isLength;


/***/ }),
/* 481 */
/***/ (function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(257),
	    isArray = __webpack_require__(482),
	    isObjectLike = __webpack_require__(265);
	
	/** `Object#toString` result references. */
	var stringTag = '[object String]';
	
	/**
	 * Checks if `value` is classified as a `String` primitive or object.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
	 * @example
	 *
	 * _.isString('abc');
	 * // => true
	 *
	 * _.isString(1);
	 * // => false
	 */
	function isString(value) {
	  return typeof value == 'string' ||
	    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
	}
	
	module.exports = isString;


/***/ }),
/* 482 */
/***/ (function(module, exports) {

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;
	
	module.exports = isArray;


/***/ }),
/* 483 */
/***/ (function(module, exports, __webpack_require__) {

	var toFinite = __webpack_require__(484);
	
	/**
	 * Converts `value` to an integer.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted integer.
	 * @example
	 *
	 * _.toInteger(3.2);
	 * // => 3
	 *
	 * _.toInteger(Number.MIN_VALUE);
	 * // => 0
	 *
	 * _.toInteger(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toInteger('3.2');
	 * // => 3
	 */
	function toInteger(value) {
	  var result = toFinite(value),
	      remainder = result % 1;
	
	  return result === result ? (remainder ? result - remainder : result) : 0;
	}
	
	module.exports = toInteger;


/***/ }),
/* 484 */
/***/ (function(module, exports, __webpack_require__) {

	var toNumber = __webpack_require__(485);
	
	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0,
	    MAX_INTEGER = 1.7976931348623157e+308;
	
	/**
	 * Converts `value` to a finite number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.12.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted number.
	 * @example
	 *
	 * _.toFinite(3.2);
	 * // => 3.2
	 *
	 * _.toFinite(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toFinite(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toFinite('3.2');
	 * // => 3.2
	 */
	function toFinite(value) {
	  if (!value) {
	    return value === 0 ? value : 0;
	  }
	  value = toNumber(value);
	  if (value === INFINITY || value === -INFINITY) {
	    var sign = (value < 0 ? -1 : 1);
	    return sign * MAX_INTEGER;
	  }
	  return value === value ? value : 0;
	}
	
	module.exports = toFinite;


/***/ }),
/* 485 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(469),
	    isSymbol = __webpack_require__(486);
	
	/** Used as references for various `Number` constants. */
	var NAN = 0 / 0;
	
	/** Used to match leading and trailing whitespace. */
	var reTrim = /^\s+|\s+$/g;
	
	/** Used to detect bad signed hexadecimal string values. */
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
	
	/** Used to detect binary string values. */
	var reIsBinary = /^0b[01]+$/i;
	
	/** Used to detect octal string values. */
	var reIsOctal = /^0o[0-7]+$/i;
	
	/** Built-in method references without a dependency on `root`. */
	var freeParseInt = parseInt;
	
	/**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */
	function toNumber(value) {
	  if (typeof value == 'number') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return NAN;
	  }
	  if (isObject(value)) {
	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	    value = isObject(other) ? (other + '') : other;
	  }
	  if (typeof value != 'string') {
	    return value === 0 ? value : +value;
	  }
	  value = value.replace(reTrim, '');
	  var isBinary = reIsBinary.test(value);
	  return (isBinary || reIsOctal.test(value))
	    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	    : (reIsBadHex.test(value) ? NAN : +value);
	}
	
	module.exports = toNumber;


/***/ }),
/* 486 */
/***/ (function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(257),
	    isObjectLike = __webpack_require__(265);
	
	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';
	
	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && baseGetTag(value) == symbolTag);
	}
	
	module.exports = isSymbol;


/***/ }),
/* 487 */
/***/ (function(module, exports, __webpack_require__) {

	var baseValues = __webpack_require__(488),
	    keys = __webpack_require__(490);
	
	/**
	 * Creates an array of the own enumerable string keyed property values of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property values.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.values(new Foo);
	 * // => [1, 2] (iteration order is not guaranteed)
	 *
	 * _.values('hi');
	 * // => ['h', 'i']
	 */
	function values(object) {
	  return object == null ? [] : baseValues(object, keys(object));
	}
	
	module.exports = values;


/***/ }),
/* 488 */
/***/ (function(module, exports, __webpack_require__) {

	var arrayMap = __webpack_require__(489);
	
	/**
	 * The base implementation of `_.values` and `_.valuesIn` which creates an
	 * array of `object` property values corresponding to the property names
	 * of `props`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array} props The property names to get values for.
	 * @returns {Object} Returns the array of property values.
	 */
	function baseValues(object, props) {
	  return arrayMap(props, function(key) {
	    return object[key];
	  });
	}
	
	module.exports = baseValues;


/***/ }),
/* 489 */
/***/ (function(module, exports) {

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      result = Array(length);
	
	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}
	
	module.exports = arrayMap;


/***/ }),
/* 490 */
/***/ (function(module, exports, __webpack_require__) {

	var arrayLikeKeys = __webpack_require__(491),
	    baseKeys = __webpack_require__(502),
	    isArrayLike = __webpack_require__(479);
	
	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}
	
	module.exports = keys;


/***/ }),
/* 491 */
/***/ (function(module, exports, __webpack_require__) {

	var baseTimes = __webpack_require__(492),
	    isArguments = __webpack_require__(493),
	    isArray = __webpack_require__(482),
	    isBuffer = __webpack_require__(495),
	    isIndex = __webpack_require__(497),
	    isTypedArray = __webpack_require__(498);
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray(value),
	      isArg = !isArr && isArguments(value),
	      isBuff = !isArr && !isArg && isBuffer(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;
	
	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	module.exports = arrayLikeKeys;


/***/ }),
/* 492 */
/***/ (function(module, exports) {

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);
	
	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}
	
	module.exports = baseTimes;


/***/ }),
/* 493 */
/***/ (function(module, exports, __webpack_require__) {

	var baseIsArguments = __webpack_require__(494),
	    isObjectLike = __webpack_require__(265);
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;
	
	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};
	
	module.exports = isArguments;


/***/ }),
/* 494 */
/***/ (function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(257),
	    isObjectLike = __webpack_require__(265);
	
	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]';
	
	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike(value) && baseGetTag(value) == argsTag;
	}
	
	module.exports = baseIsArguments;


/***/ }),
/* 495 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(259),
	    stubFalse = __webpack_require__(496);
	
	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
	
	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
	
	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;
	
	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined;
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
	
	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse;
	
	module.exports = isBuffer;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(268)(module)))

/***/ }),
/* 496 */
/***/ (function(module, exports) {

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}
	
	module.exports = stubFalse;


/***/ }),
/* 497 */
/***/ (function(module, exports) {

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;
	
	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;
	
	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return !!length &&
	    (typeof value == 'number' || reIsUint.test(value)) &&
	    (value > -1 && value % 1 == 0 && value < length);
	}
	
	module.exports = isIndex;


/***/ }),
/* 498 */
/***/ (function(module, exports, __webpack_require__) {

	var baseIsTypedArray = __webpack_require__(499),
	    baseUnary = __webpack_require__(500),
	    nodeUtil = __webpack_require__(501);
	
	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
	
	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
	
	module.exports = isTypedArray;


/***/ }),
/* 499 */
/***/ (function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(257),
	    isLength = __webpack_require__(480),
	    isObjectLike = __webpack_require__(265);
	
	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    weakMapTag = '[object WeakMap]';
	
	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';
	
	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;
	
	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	}
	
	module.exports = baseIsTypedArray;


/***/ }),
/* 500 */
/***/ (function(module, exports) {

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}
	
	module.exports = baseUnary;


/***/ }),
/* 501 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(260);
	
	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
	
	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
	
	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;
	
	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && freeGlobal.process;
	
	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
	  } catch (e) {}
	}());
	
	module.exports = nodeUtil;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(268)(module)))

/***/ }),
/* 502 */
/***/ (function(module, exports, __webpack_require__) {

	var isPrototype = __webpack_require__(503),
	    nativeKeys = __webpack_require__(504);
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	module.exports = baseKeys;


/***/ }),
/* 503 */
/***/ (function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
	
	  return value === proto;
	}
	
	module.exports = isPrototype;


/***/ }),
/* 504 */
/***/ (function(module, exports, __webpack_require__) {

	var overArg = __webpack_require__(264);
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = overArg(Object.keys, Object);
	
	module.exports = nativeKeys;


/***/ }),
/* 505 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ACTION_TYPE_DELIMITER = undefined;
	exports.default = combineActions;
	
	var _isString = __webpack_require__(481);
	
	var _isString2 = _interopRequireDefault(_isString);
	
	var _isFunction = __webpack_require__(468);
	
	var _isFunction2 = _interopRequireDefault(_isFunction);
	
	var _isEmpty = __webpack_require__(506);
	
	var _isEmpty2 = _interopRequireDefault(_isEmpty);
	
	var _toString = __webpack_require__(519);
	
	var _toString2 = _interopRequireDefault(_toString);
	
	var _isSymbol = __webpack_require__(486);
	
	var _isSymbol2 = _interopRequireDefault(_isSymbol);
	
	var _invariant = __webpack_require__(187);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ACTION_TYPE_DELIMITER = exports.ACTION_TYPE_DELIMITER = '||';
	
	function isValidActionType(actionType) {
	  return (0, _isString2.default)(actionType) || (0, _isFunction2.default)(actionType) || (0, _isSymbol2.default)(actionType);
	}
	
	function isValidActionTypes(actionTypes) {
	  if ((0, _isEmpty2.default)(actionTypes)) {
	    return false;
	  }
	  return actionTypes.every(isValidActionType);
	}
	
	function combineActions() {
	  for (var _len = arguments.length, actionsTypes = Array(_len), _key = 0; _key < _len; _key++) {
	    actionsTypes[_key] = arguments[_key];
	  }
	
	  (0, _invariant2.default)(isValidActionTypes(actionsTypes), 'Expected action types to be strings, symbols, or action creators');
	  var combinedActionType = actionsTypes.map(_toString2.default).join(ACTION_TYPE_DELIMITER);
	  return { toString: function toString() {
	      return combinedActionType;
	    } };
	}

/***/ }),
/* 506 */
/***/ (function(module, exports, __webpack_require__) {

	var baseKeys = __webpack_require__(502),
	    getTag = __webpack_require__(507),
	    isArguments = __webpack_require__(493),
	    isArray = __webpack_require__(482),
	    isArrayLike = __webpack_require__(479),
	    isBuffer = __webpack_require__(495),
	    isPrototype = __webpack_require__(503),
	    isTypedArray = __webpack_require__(498);
	
	/** `Object#toString` result references. */
	var mapTag = '[object Map]',
	    setTag = '[object Set]';
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Checks if `value` is an empty object, collection, map, or set.
	 *
	 * Objects are considered empty if they have no own enumerable string keyed
	 * properties.
	 *
	 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
	 * jQuery-like collections are considered empty if they have a `length` of `0`.
	 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
	 * @example
	 *
	 * _.isEmpty(null);
	 * // => true
	 *
	 * _.isEmpty(true);
	 * // => true
	 *
	 * _.isEmpty(1);
	 * // => true
	 *
	 * _.isEmpty([1, 2, 3]);
	 * // => false
	 *
	 * _.isEmpty({ 'a': 1 });
	 * // => false
	 */
	function isEmpty(value) {
	  if (value == null) {
	    return true;
	  }
	  if (isArrayLike(value) &&
	      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
	        isBuffer(value) || isTypedArray(value) || isArguments(value))) {
	    return !value.length;
	  }
	  var tag = getTag(value);
	  if (tag == mapTag || tag == setTag) {
	    return !value.size;
	  }
	  if (isPrototype(value)) {
	    return !baseKeys(value).length;
	  }
	  for (var key in value) {
	    if (hasOwnProperty.call(value, key)) {
	      return false;
	    }
	  }
	  return true;
	}
	
	module.exports = isEmpty;


/***/ }),
/* 507 */
/***/ (function(module, exports, __webpack_require__) {

	var DataView = __webpack_require__(508),
	    Map = __webpack_require__(515),
	    Promise = __webpack_require__(516),
	    Set = __webpack_require__(517),
	    WeakMap = __webpack_require__(518),
	    baseGetTag = __webpack_require__(257),
	    toSource = __webpack_require__(513);
	
	/** `Object#toString` result references. */
	var mapTag = '[object Map]',
	    objectTag = '[object Object]',
	    promiseTag = '[object Promise]',
	    setTag = '[object Set]',
	    weakMapTag = '[object WeakMap]';
	
	var dataViewTag = '[object DataView]';
	
	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map),
	    promiseCtorString = toSource(Promise),
	    setCtorString = toSource(Set),
	    weakMapCtorString = toSource(WeakMap);
	
	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = baseGetTag;
	
	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	    (Map && getTag(new Map) != mapTag) ||
	    (Promise && getTag(Promise.resolve()) != promiseTag) ||
	    (Set && getTag(new Set) != setTag) ||
	    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	  getTag = function(value) {
	    var result = baseGetTag(value),
	        Ctor = result == objectTag ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : '';
	
	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag;
	        case mapCtorString: return mapTag;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag;
	        case weakMapCtorString: return weakMapTag;
	      }
	    }
	    return result;
	  };
	}
	
	module.exports = getTag;


/***/ }),
/* 508 */
/***/ (function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(509),
	    root = __webpack_require__(259);
	
	/* Built-in method references that are verified to be native. */
	var DataView = getNative(root, 'DataView');
	
	module.exports = DataView;


/***/ }),
/* 509 */
/***/ (function(module, exports, __webpack_require__) {

	var baseIsNative = __webpack_require__(510),
	    getValue = __webpack_require__(514);
	
	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}
	
	module.exports = getNative;


/***/ }),
/* 510 */
/***/ (function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(468),
	    isMasked = __webpack_require__(511),
	    isObject = __webpack_require__(469),
	    toSource = __webpack_require__(513);
	
	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
	
	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;
	
	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);
	
	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}
	
	module.exports = baseIsNative;


/***/ }),
/* 511 */
/***/ (function(module, exports, __webpack_require__) {

	var coreJsData = __webpack_require__(512);
	
	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());
	
	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}
	
	module.exports = isMasked;


/***/ }),
/* 512 */
/***/ (function(module, exports, __webpack_require__) {

	var root = __webpack_require__(259);
	
	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];
	
	module.exports = coreJsData;


/***/ }),
/* 513 */
/***/ (function(module, exports) {

	/** Used for built-in method references. */
	var funcProto = Function.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;
	
	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}
	
	module.exports = toSource;


/***/ }),
/* 514 */
/***/ (function(module, exports) {

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}
	
	module.exports = getValue;


/***/ }),
/* 515 */
/***/ (function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(509),
	    root = __webpack_require__(259);
	
	/* Built-in method references that are verified to be native. */
	var Map = getNative(root, 'Map');
	
	module.exports = Map;


/***/ }),
/* 516 */
/***/ (function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(509),
	    root = __webpack_require__(259);
	
	/* Built-in method references that are verified to be native. */
	var Promise = getNative(root, 'Promise');
	
	module.exports = Promise;


/***/ }),
/* 517 */
/***/ (function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(509),
	    root = __webpack_require__(259);
	
	/* Built-in method references that are verified to be native. */
	var Set = getNative(root, 'Set');
	
	module.exports = Set;


/***/ }),
/* 518 */
/***/ (function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(509),
	    root = __webpack_require__(259);
	
	/* Built-in method references that are verified to be native. */
	var WeakMap = getNative(root, 'WeakMap');
	
	module.exports = WeakMap;


/***/ }),
/* 519 */
/***/ (function(module, exports, __webpack_require__) {

	var baseToString = __webpack_require__(520);
	
	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : baseToString(value);
	}
	
	module.exports = toString;


/***/ }),
/* 520 */
/***/ (function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(258),
	    arrayMap = __webpack_require__(489),
	    isArray = __webpack_require__(482),
	    isSymbol = __webpack_require__(486);
	
	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;
	
	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;
	
	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isArray(value)) {
	    // Recursively convert values (susceptible to call stack limits).
	    return arrayMap(value, baseToString) + '';
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}
	
	module.exports = baseToString;


/***/ }),
/* 521 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = handleActions;
	
	var _handleAction = __webpack_require__(472);
	
	var _handleAction2 = _interopRequireDefault(_handleAction);
	
	var _ownKeys = __webpack_require__(522);
	
	var _ownKeys2 = _interopRequireDefault(_ownKeys);
	
	var _reduceReducers = __webpack_require__(523);
	
	var _reduceReducers2 = _interopRequireDefault(_reduceReducers);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function handleActions(handlers, defaultState) {
	  var reducers = (0, _ownKeys2.default)(handlers).map(function (type) {
	    return (0, _handleAction2.default)(type, handlers[type], defaultState);
	  });
	  var reducer = _reduceReducers2.default.apply(undefined, _toConsumableArray(reducers));
	  return function (state, action) {
	    return reducer(state, action);
	  };
	}

/***/ }),
/* 522 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = ownKeys;
	function ownKeys(object) {
	  if (typeof Reflect !== 'undefined' && typeof Reflect.ownKeys === 'function') {
	    return Reflect.ownKeys(object);
	  }
	
	  var keys = Object.getOwnPropertyNames(object);
	
	  if (typeof Object.getOwnPropertySymbols === 'function') {
	    keys = keys.concat(Object.getOwnPropertySymbols(object));
	  }
	
	  return keys;
	}

/***/ }),
/* 523 */
/***/ (function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = reduceReducers;
	
	function reduceReducers() {
	  for (var _len = arguments.length, reducers = Array(_len), _key = 0; _key < _len; _key++) {
	    reducers[_key] = arguments[_key];
	  }
	
	  return function (previous, current) {
	    return reducers.reduce(function (p, r) {
	      return r(p, current);
	    }, previous);
	  };
	}
	
	module.exports = exports["default"];

/***/ }),
/* 524 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.default = createActions;
	
	var _identity = __webpack_require__(467);
	
	var _identity2 = _interopRequireDefault(_identity);
	
	var _camelCase = __webpack_require__(525);
	
	var _camelCase2 = _interopRequireDefault(_camelCase);
	
	var _isPlainObject = __webpack_require__(256);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _isArray = __webpack_require__(482);
	
	var _isArray2 = _interopRequireDefault(_isArray);
	
	var _isString = __webpack_require__(481);
	
	var _isString2 = _interopRequireDefault(_isString);
	
	var _isFunction = __webpack_require__(468);
	
	var _isFunction2 = _interopRequireDefault(_isFunction);
	
	var _createAction = __webpack_require__(466);
	
	var _createAction2 = _interopRequireDefault(_createAction);
	
	var _invariant = __webpack_require__(187);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function createActions(actionsMap) {
	  for (var _len = arguments.length, identityActions = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    identityActions[_key - 1] = arguments[_key];
	  }
	
	  (0, _invariant2.default)(identityActions.every(_isString2.default) && ((0, _isString2.default)(actionsMap) || (0, _isPlainObject2.default)(actionsMap)), 'Expected optional object followed by string action types');
	  if ((0, _isString2.default)(actionsMap)) {
	    return fromIdentityActions([actionsMap].concat(identityActions));
	  }
	  return _extends({}, fromActionsMap(actionsMap), fromIdentityActions(identityActions));
	}
	
	function isValidActionsMapValue(actionsMapValue) {
	  if ((0, _isFunction2.default)(actionsMapValue)) {
	    return true;
	  } else if ((0, _isArray2.default)(actionsMapValue)) {
	    var _actionsMapValue = _slicedToArray(actionsMapValue, 2);
	
	    var _actionsMapValue$ = _actionsMapValue[0];
	    var payload = _actionsMapValue$ === undefined ? _identity2.default : _actionsMapValue$;
	    var meta = _actionsMapValue[1];
	
	
	    return (0, _isFunction2.default)(payload) && (0, _isFunction2.default)(meta);
	  }
	  return false;
	}
	
	function fromActionsMap(actionsMap) {
	  return Object.keys(actionsMap).reduce(function (actionCreatorsMap, type) {
	    var actionsMapValue = actionsMap[type];
	    (0, _invariant2.default)(isValidActionsMapValue(actionsMapValue), 'Expected function, undefined, or array with payload and meta ' + ('functions for ' + type));
	    var actionCreator = (0, _isArray2.default)(actionsMapValue) ? _createAction2.default.apply(undefined, [type].concat(_toConsumableArray(actionsMapValue))) : (0, _createAction2.default)(type, actionsMapValue);
	    return _extends({}, actionCreatorsMap, _defineProperty({}, (0, _camelCase2.default)(type), actionCreator));
	  }, {});
	}
	
	function fromIdentityActions(identityActions) {
	  return fromActionsMap(identityActions.reduce(function (actionsMap, actionType) {
	    return _extends({}, actionsMap, _defineProperty({}, actionType, _identity2.default));
	  }, {}));
	}

/***/ }),
/* 525 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	// based on https://github.com/lodash/lodash/blob/4.17.2/lodash.js#L14100
	// eslint-disable-next-line max-len
	var wordPattern = /[A-Z\xc0-\xd6\xd8-\xde]?[a-z\xdf-\xf6\xf8-\xff]+(?:['’](?:d|ll|m|re|s|t|ve))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde]|$)|(?:[A-Z\xc0-\xd6\xd8-\xde]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['’](?:D|LL|M|RE|S|T|VE))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde](?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])|$)|[A-Z\xc0-\xd6\xd8-\xde]?(?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['’](?:d|ll|m|re|s|t|ve))?|[A-Z\xc0-\xd6\xd8-\xde]+(?:['’](?:D|LL|M|RE|S|T|VE))?|\d*(?:(?:1ST|2ND|3RD|(?![123])\dTH)\b)|\d*(?:(?:1st|2nd|3rd|(?![123])\dth)\b)|\d+|(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?(?:\u200d(?:[^\ud800-\udfff]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?)*/g;
	var namespacer = '/';
	
	function camelCase(string) {
	  return string.match(wordPattern).reduce(function (camelCased, word, index) {
	    return camelCased + (index === 0 ? word.toLowerCase() : word.charAt(0).toUpperCase() + word.substring(1).toLowerCase());
	  }, '');
	}
	
	exports.default = function (actionType) {
	  return actionType.split(namespacer).map(camelCase).join(namespacer);
	};

/***/ }),
/* 526 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _TeamDashboard = __webpack_require__(527);
	
	var _TeamDashboard2 = _interopRequireDefault(_TeamDashboard);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	  path: 'team',
	  component: _TeamDashboard2.default
	};

/***/ }),
/* 527 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _TeamPerformanceTrend = __webpack_require__(528);
	
	var _TeamPerformanceTrend2 = _interopRequireDefault(_TeamPerformanceTrend);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _TeamPerformanceTrend2.default;

/***/ }),
/* 528 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(384);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(388);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(389);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(393);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(410);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _LineChart = __webpack_require__(529);
	
	var _LineChart2 = _interopRequireDefault(_LineChart);
	
	var _ColumnChart = __webpack_require__(531);
	
	var _ColumnChart2 = _interopRequireDefault(_ColumnChart);
	
	var _TeamPerformanceTrend = __webpack_require__(532);
	
	var _TeamPerformanceTrend2 = _interopRequireDefault(_TeamPerformanceTrend);
	
	var _Dropdown = __webpack_require__(534);
	
	var _Dropdown2 = _interopRequireDefault(_Dropdown);
	
	var _lodash = __webpack_require__(275);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _HomeGround = __webpack_require__(538);
	
	var _HomeGround2 = _interopRequireDefault(_HomeGround);
	
	var _HeatMap = __webpack_require__(539);
	
	var _HeatMap2 = _interopRequireDefault(_HeatMap);
	
	var _Card = __webpack_require__(447);
	
	var _Card2 = _interopRequireDefault(_Card);
	
	var _whiteIplLogo = __webpack_require__(541);
	
	var _whiteIplLogo2 = _interopRequireDefault(_whiteIplLogo);
	
	var _KKRLogo = __webpack_require__(542);
	
	var _KKRLogo2 = _interopRequireDefault(_KKRLogo);
	
	var _CSKLogo = __webpack_require__(543);
	
	var _CSKLogo2 = _interopRequireDefault(_CSKLogo);
	
	var _RRLogo = __webpack_require__(544);
	
	var _RRLogo2 = _interopRequireDefault(_RRLogo);
	
	var _MILogo = __webpack_require__(545);
	
	var _MILogo2 = _interopRequireDefault(_MILogo);
	
	var _DCLogo = __webpack_require__(546);
	
	var _DCLogo2 = _interopRequireDefault(_DCLogo);
	
	var _KXIPLogo = __webpack_require__(547);
	
	var _KXIPLogo2 = _interopRequireDefault(_KXIPLogo);
	
	var _RBCLogo = __webpack_require__(548);
	
	var _RBCLogo2 = _interopRequireDefault(_RBCLogo);
	
	var _DDLogo = __webpack_require__(549);
	
	var _DDLogo2 = _interopRequireDefault(_DDLogo);
	
	var _KTKLogo = __webpack_require__(550);
	
	var _KTKLogo2 = _interopRequireDefault(_KTKLogo);
	
	var _PWILogo = __webpack_require__(551);
	
	var _PWILogo2 = _interopRequireDefault(_PWILogo);
	
	var _SHLogo = __webpack_require__(552);
	
	var _SHLogo2 = _interopRequireDefault(_SHLogo);
	
	var _RPSLogo = __webpack_require__(553);
	
	var _RPSLogo2 = _interopRequireDefault(_RPSLogo);
	
	var _GLLogo = __webpack_require__(554);
	
	var _GLLogo2 = _interopRequireDefault(_GLLogo);
	
	var _reactTabs = __webpack_require__(555);
	
	__webpack_require__(567);
	
	var _reactRedux = __webpack_require__(418);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var imageMapping = {
	  'All Teams': _whiteIplLogo2.default,
	  'Kolkata Knight Riders': _KKRLogo2.default,
	  'Chennai Super Kings': _CSKLogo2.default,
	  'Rajasthan Royals': _RRLogo2.default,
	  'Mumbai Indians': _MILogo2.default,
	  'Deccan Chargers': _DCLogo2.default,
	  'Kings XI Punjab': _KXIPLogo2.default,
	  'Royal Challengers Bangalore': _RBCLogo2.default,
	  'Delhi Daredevils': _DDLogo2.default,
	  'Kochi Tuskers Kerala': _KTKLogo2.default,
	  'Pune Warriors': _PWILogo2.default,
	  'Sunrisers Hyderabad': _SHLogo2.default,
	  'Rising Pune Supergiants': _RPSLogo2.default,
	  'Gujarat Lions': _GLLogo2.default
	};
	
	var TeamPerformanceTrend = function (_React$Component) {
	  (0, _inherits3.default)(TeamPerformanceTrend, _React$Component);
	
	  function TeamPerformanceTrend(props) {
	    (0, _classCallCheck3.default)(this, TeamPerformanceTrend);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (TeamPerformanceTrend.__proto__ || (0, _getPrototypeOf2.default)(TeamPerformanceTrend)).call(this, props));
	
	    _this.getSelectedTeam = _this.getSelectedTeam.bind(_this);
	    _this.state = {
	      selectedTeam: 'All Teams',
	      series: [],
	      teams: [{ 'label': 'All Teams', value: 'All Teams' }],
	      options: _lodash2.default.uniq(_lodash2.default.map(_this.props.matches, 'team1')),
	      seasons: _lodash2.default.uniq(_lodash2.default.map(_this.props.matches, 'season')),
	      teamTrajectoryData: [],
	      columnChartData: {
	        title: '% of Matches won batting first',
	        name: 'Bat First'
	      },
	      columnChartSeriesBatFirst: [],
	      columnChartSeriesHomeGround: [],
	      newcolumnChartSeriesHomeGround: [],
	      newcolumnChartSeriesBatFirst: [],
	      columnChartDataHomeGround: {
	        title: '% of Matches won on home ground',
	        name: 'Home ground wins'
	      },
	      heatMapData: {
	        name: 'Average runs per season',
	        title: 'Average runs per season'
	      },
	      heatMapSeries: [],
	      xAxisCategories: []
	    };
	    _this.mapping = {
	      2008: _this.props['2008'],
	      2009: _this.props['2009'],
	      2010: _this.props['2010'],
	      2011: _this.props['2011'],
	      2012: _this.props['2012'],
	      2013: _this.props['2013'],
	      2014: _this.props['2014'],
	      2015: _this.props['2015'],
	      2016: _this.props['2016']
	    };
	    return _this;
	  }
	
	  (0, _createClass3.default)(TeamPerformanceTrend, [{
	    key: 'componentWillMount',
	    value: function componentWillMount() {
	      console.log(this.props);
	      this.state.options.map(function (team) {
	        this.state.seasons.map(function (year) {
	          var dataArray = [];
	          var averageArray = [];
	          dataArray.push(this.state.options.indexOf(team));
	          dataArray.push(this.state.seasons.indexOf(year));
	          var groupByMatch = _lodash2.default.groupBy(_lodash2.default.filter(this.mapping[year], function (match) {
	            return match['batting_team'] === team;
	          }), 'match_id');
	          _lodash2.default.map(groupByMatch, function (match) {
	            var runsInOneMatch = match.reduce(function (n, match) {
	              return n + parseInt(match.total_runs);
	            }, 0);
	            averageArray.push(runsInOneMatch);
	          });
	          var average = _lodash2.default.reduce(averageArray, function (memo, num) {
	            return memo + num;
	          }, 0) / (averageArray.length === 0 ? 1 : averageArray.length);
	          dataArray.push(Math.round(average));
	          this.state.heatMapSeries.push(dataArray);
	        }, this);
	      }, this);
	
	      var newOption = {};
	      newOption.name = 'Teams';
	      newOption.data = [];
	      this.state.options.map(function (item) {
	        var totalMatchesWon = this.props.matches.reduce(function (n, match) {
	          return n + (match.winner === item);
	        }, 0);
	        var matchesWonBatFirst = this.props.matches.reduce(function (n, match) {
	          return n + (match.winner === item && match['toss_winner'] === item && match['toss_decision'] === 'bat' || match.winner === item && match['toss_winner'] !== item && match['toss_decision'] === 'field');
	        }, 0);
	        var percentage = matchesWonBatFirst / totalMatchesWon * 100;
	        newOption.data.push(parseInt(percentage));
	      }, this);
	      this.state.columnChartSeriesBatFirst.push(newOption);
	      this.state.xAxisCategories = this.state.options;
	
	      var newOptionHomeGround = {};
	      newOptionHomeGround.name = 'Teams';
	      newOptionHomeGround.data = [];
	      this.state.options.map(function (item) {
	        var totalMatchesWon = this.props.matches.reduce(function (n, match) {
	          return n + (match.winner === item);
	        }, 0);
	        var matchesWonHomeGround = this.props.matches.reduce(function (n, match) {
	          return n + (match.winner === item && match.city === _HomeGround2.default[item]);
	        }, 0);
	        var percentage = matchesWonHomeGround / totalMatchesWon * 100;
	        newOptionHomeGround.data.push(parseInt(percentage));
	      }, this);
	      this.state.columnChartSeriesHomeGround.push(newOptionHomeGround);
	
	      this.state.options.map(function (item) {
	        var newOption = {};
	        newOption.label = item;
	        newOption.value = item;
	        this.state.teams.push(newOption);
	      }, this);
	
	      this.state.options.map(function (item) {
	        var newOption = {};
	        newOption.name = item;
	        newOption.data = [];
	        this.state.seasons.forEach(function (season) {
	          var numberOfMatchesWon = 0;
	          _lodash2.default.forEach(this.props.matches, function (data) {
	            if (data.season === season && data.winner === item) {
	              numberOfMatchesWon = numberOfMatchesWon + 1;
	            }
	          });
	          newOption.data.push(numberOfMatchesWon);
	        }, this);
	        this.state.teamTrajectoryData.push(newOption);
	      }, this);
	
	      this.data = {
	        height: 200,
	        title: 'Team Trajectory',
	        subtitle: '',
	        yAxisTitle: 'No of matches won'
	      };
	    }
	  }, {
	    key: 'getSelectedTeam',
	    value: function getSelectedTeam(item) {
	      this.setState({ selectedTeam: item.target.value });
	      if (item.target.value !== 'All Teams') {
	        var oneTeamData = [];
	        oneTeamData.push(_lodash2.default.find(this.state.teamTrajectoryData, { name: item.target.value }));
	
	        var newcolumnChartSeriesHomeGround = [];
	        var newOption = {};
	        newOption.name = 'Season';
	        newOption.data = [];
	        this.state.seasons.map(function (year) {
	          var totalMatchesWon = this.props.matches.reduce(function (n, match) {
	            return n + (match.winner === item.target.value && match.season === year);
	          }, 0);
	          var matchesWonHomeGround = this.props.matches.reduce(function (n, match) {
	            return n + (match.winner === item.target.value && match.season === year && match.city === _HomeGround2.default[item.target.value]);
	          }, 0);
	          var percentage = matchesWonHomeGround / totalMatchesWon * 100;
	          newOption.data.push(parseInt(percentage));
	        }, this);
	        newcolumnChartSeriesHomeGround.push(newOption);
	
	        var newcolumnChartSeriesBatFirst = [];
	        var newOptionHomeGround = {};
	        newOptionHomeGround.name = 'Season';
	        newOptionHomeGround.data = [];
	        this.state.seasons.map(function (year) {
	          var totalMatchesWon = this.props.matches.reduce(function (n, match) {
	            return n + (match.winner === item.target.value && match.season === year);
	          }, 0);
	          var matchesWonBatFirst = this.props.matches.reduce(function (n, match) {
	            return n + (match.winner === item.target.value && match['toss_winner'] === item.target.value && match['toss_decision'] === 'bat' && match.season === year || match.winner === item.target.value && match['toss_winner'] !== item.target.value && match['toss_decision'] === 'field' && match.season === year);
	          }, 0);
	          var percentage = matchesWonBatFirst / totalMatchesWon * 100;
	          newOptionHomeGround.data.push(parseInt(percentage));
	        }, this);
	        newcolumnChartSeriesBatFirst.push(newOptionHomeGround);
	
	        this.setState({ series: _lodash2.default.map(oneTeamData, _lodash2.default.partial(_lodash2.default.pick, _lodash2.default, ['name', 'data'])),
	          newcolumnChartSeriesHomeGround: newcolumnChartSeriesHomeGround,
	          newcolumnChartSeriesBatFirst: newcolumnChartSeriesBatFirst, xAxisCategories: this.state.seasons });
	      } else {
	        this.setState({ series: this.state.teamTrajectoryData });
	      }
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      return _react2.default.createElement(
	        'div',
	        { className: _TeamPerformanceTrend2.default.container + ' full-size' },
	        _react2.default.createElement(
	          _Card2.default,
	          { cardType: 'selector' },
	          _react2.default.createElement(
	            'div',
	            { className: _TeamPerformanceTrend2.default.teamSelectorContainer },
	            _react2.default.createElement('img', { className: _TeamPerformanceTrend2.default.whiteLogo, src: imageMapping[this.state.selectedTeam] }),
	            _react2.default.createElement(
	              'div',
	              { className: _TeamPerformanceTrend2.default.dropDownContainer },
	              _react2.default.createElement(
	                'div',
	                { className: _TeamPerformanceTrend2.default.selectText },
	                'Select a team'
	              ),
	              _react2.default.createElement(_Dropdown2.default, { optionList: this.state.teams, onChange: this.getSelectedTeam })
	            )
	          )
	        ),
	        _react2.default.createElement(
	          _reactTabs.Tabs,
	          null,
	          _react2.default.createElement(
	            _reactTabs.TabList,
	            null,
	            _react2.default.createElement(
	              _reactTabs.Tab,
	              null,
	              'Team Trajectory'
	            ),
	            _react2.default.createElement(
	              _reactTabs.Tab,
	              null,
	              'Bat First Wins'
	            ),
	            _react2.default.createElement(
	              _reactTabs.Tab,
	              null,
	              'Home Ground Wins'
	            ),
	            _react2.default.createElement(
	              _reactTabs.Tab,
	              null,
	              'Average Runs'
	            )
	          ),
	          _react2.default.createElement(
	            _reactTabs.TabPanel,
	            null,
	            _react2.default.createElement(
	              'div',
	              { className: 'flex performace-chart pl1' },
	              _react2.default.createElement(_LineChart2.default, { data: this.data,
	                series: this.state.series.length > 0 ? this.state.series : this.state.teamTrajectoryData })
	            )
	          ),
	          _react2.default.createElement(
	            _reactTabs.TabPanel,
	            null,
	            _react2.default.createElement(
	              'div',
	              { className: 'flex performace-chart pl1' },
	              _react2.default.createElement(_ColumnChart2.default, { data: this.state.columnChartData,
	                xAxisCategories: this.state.xAxisCategories,
	                series: this.state.selectedTeam === 'All Teams' ? this.state.columnChartSeriesBatFirst : this.state.newcolumnChartSeriesBatFirst,
	                container: 'containercolumn' })
	            )
	          ),
	          _react2.default.createElement(
	            _reactTabs.TabPanel,
	            null,
	            _react2.default.createElement(
	              'div',
	              { className: 'flex performace-chart pl1' },
	              _react2.default.createElement(_ColumnChart2.default, { xAxisCategories: this.state.xAxisCategories,
	                data: this.state.columnChartDataHomeGround,
	                series: this.state.selectedTeam === 'All Teams' ? this.state.columnChartSeriesHomeGround : this.state.newcolumnChartSeriesHomeGround,
	                container: 'containercolumn2' })
	            )
	          ),
	          _react2.default.createElement(
	            _reactTabs.TabPanel,
	            null,
	            _react2.default.createElement(_HeatMap2.default, { data: this.state.heatMapData, container: 'heat-map-runs',
	              xAxis: this.state.options, yAxis: this.state.seasons, series: this.state.heatMapSeries })
	          )
	        )
	      );
	    }
	  }]);
	  return TeamPerformanceTrend;
	}(_react2.default.Component);
	
	TeamPerformanceTrend.propTypes = {
	  params: _react2.default.PropTypes.object.isRequired
	};
	
	var mapStateToProps = function mapStateToProps(state) {
	  return {
	    matches: state.commonData.matches.data,
	    '2008': state.commonData['2008'].data,
	    '2009': state.commonData['2009'].data,
	    '2010': state.commonData['2010'].data,
	    '2011': state.commonData['2011'].data,
	    '2012': state.commonData['2012'].data,
	    '2013': state.commonData['2013'].data,
	    '2014': state.commonData['2014'].data,
	    '2015': state.commonData['2015'].data,
	    '2016': state.commonData['2016'].data
	  };
	};
	
	exports.default = (0, _reactRedux.connect)(mapStateToProps)(TeamPerformanceTrend);

/***/ }),
/* 529 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(384);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(388);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(389);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(393);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(410);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _highcharts = __webpack_require__(530);
	
	var _highcharts2 = _interopRequireDefault(_highcharts);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var LineChart = function (_React$Component) {
	  (0, _inherits3.default)(LineChart, _React$Component);
	
	  function LineChart() {
	    var _ref;
	
	    var _temp, _this, _ret;
	
	    (0, _classCallCheck3.default)(this, LineChart);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = LineChart.__proto__ || (0, _getPrototypeOf2.default)(LineChart)).call.apply(_ref, [this].concat(args))), _this), _this.initializeChart = function (data, series) {
	      _highcharts2.default.chart('container', {
	        chart: {
	          type: 'line',
	          backgroundColor: null
	        },
	        title: {
	          text: data.title
	        },
	        credits: {
	          enabled: false
	        },
	        subtitle: {
	          text: data.subTitle
	        },
	        yAxis: {
	          title: {
	            text: data.yAxisTitle
	          }
	        },
	        plotOptions: {
	          series: {
	            pointStart: 2008
	          }
	        },
	        series: series
	      });
	    }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
	  }
	
	  (0, _createClass3.default)(LineChart, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      var _props = this.props,
	          data = _props.data,
	          series = _props.series;
	
	      this.initializeChart(data, series);
	    }
	  }, {
	    key: 'componentDidUpdate',
	    value: function componentDidUpdate() {
	      var _props2 = this.props,
	          data = _props2.data,
	          series = _props2.series;
	
	      this.initializeChart(data, series);
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      return _react2.default.createElement('div', { id: 'container',
	        className: 'scroll' });
	    }
	  }]);
	  return LineChart;
	}(_react2.default.Component);
	
	LineChart.propTypes = {
	  data: _react2.default.PropTypes.object.isRequired,
	  series: _react2.default.PropTypes.array.isRequired
	};
	exports.default = LineChart;

/***/ }),
/* 530 */
/***/ (function(module, exports) {

	/*
	 Highcharts JS v5.0.14 (2017-07-28)
	
	 (c) 2009-2016 Torstein Honsi
	
	 License: www.highcharts.com/license
	*/
	(function(M,S){"object"===typeof module&&module.exports?module.exports=M.document?S(M):S:M.Highcharts=S(M)})("undefined"!==typeof window?window:this,function(M){M=function(){var a=window,C=a.document,A=a.navigator&&a.navigator.userAgent||"",F=C&&C.createElementNS&&!!C.createElementNS("http://www.w3.org/2000/svg","svg").createSVGRect,E=/(edge|msie|trident)/i.test(A)&&!window.opera,m=!F,f=/Firefox/.test(A),l=f&&4>parseInt(A.split("Firefox/")[1],10);return a.Highcharts?a.Highcharts.error(16,!0):{product:"Highcharts",
	version:"5.0.14",deg2rad:2*Math.PI/360,doc:C,hasBidiBug:l,hasTouch:C&&void 0!==C.documentElement.ontouchstart,isMS:E,isWebKit:/AppleWebKit/.test(A),isFirefox:f,isTouchDevice:/(Mobile|Android|Windows Phone)/.test(A),SVG_NS:"http://www.w3.org/2000/svg",chartCount:0,seriesTypes:{},symbolSizes:{},svg:F,vml:m,win:a,marginNames:["plotTop","marginRight","marginBottom","plotLeft"],noop:function(){},charts:[]}}();(function(a){var C=[],A=a.charts,F=a.doc,E=a.win;a.error=function(m,f){m=a.isNumber(m)?"Highcharts error #"+
	m+": www.highcharts.com/errors/"+m:m;if(f)throw Error(m);E.console&&console.log(m)};a.Fx=function(a,f,l){this.options=f;this.elem=a;this.prop=l};a.Fx.prototype={dSetter:function(){var a=this.paths[0],f=this.paths[1],l=[],r=this.now,u=a.length,t;if(1===r)l=this.toD;else if(u===f.length&&1>r)for(;u--;)t=parseFloat(a[u]),l[u]=isNaN(t)?a[u]:r*parseFloat(f[u]-t)+t;else l=f;this.elem.attr("d",l,null,!0)},update:function(){var a=this.elem,f=this.prop,l=this.now,r=this.options.step;if(this[f+"Setter"])this[f+
	"Setter"]();else a.attr?a.element&&a.attr(f,l,null,!0):a.style[f]=l+this.unit;r&&r.call(a,l,this)},run:function(a,f,l){var r=this,m=function(a){return m.stopped?!1:r.step(a)},t;this.startTime=+new Date;this.start=a;this.end=f;this.unit=l;this.now=this.start;this.pos=0;m.elem=this.elem;m.prop=this.prop;m()&&1===C.push(m)&&(m.timerId=setInterval(function(){for(t=0;t<C.length;t++)C[t]()||C.splice(t--,1);C.length||clearInterval(m.timerId)},13))},step:function(m){var f=+new Date,l,r=this.options,u=this.elem,
	t=r.complete,g=r.duration,d=r.curAnim;u.attr&&!u.element?m=!1:m||f>=g+this.startTime?(this.now=this.end,this.pos=1,this.update(),l=d[this.prop]=!0,a.objectEach(d,function(a){!0!==a&&(l=!1)}),l&&t&&t.call(u),m=!1):(this.pos=r.easing((f-this.startTime)/g),this.now=this.start+(this.end-this.start)*this.pos,this.update(),m=!0);return m},initPath:function(m,f,l){function r(a){var c,e;for(n=a.length;n--;)c="M"===a[n]||"L"===a[n],e=/[a-zA-Z]/.test(a[n+3]),c&&e&&a.splice(n+1,0,a[n+1],a[n+2],a[n+1],a[n+2])}
	function u(a,c){for(;a.length<v;){a[0]=c[v-a.length];var b=a.slice(0,e);[].splice.apply(a,[0,0].concat(b));D&&(b=a.slice(a.length-e),[].splice.apply(a,[a.length,0].concat(b)),n--)}a[0]="M"}function t(a,c){for(var q=(v-a.length)/e;0<q&&q--;)y=a.slice().splice(a.length/J-e,e*J),y[0]=c[v-e-q*e],b&&(y[e-6]=y[e-2],y[e-5]=y[e-1]),[].splice.apply(a,[a.length/J,0].concat(y)),D&&q--}f=f||"";var g,d=m.startX,k=m.endX,b=-1<f.indexOf("C"),e=b?7:3,v,y,n;f=f.split(" ");l=l.slice();var D=m.isArea,J=D?2:1,c;b&&(r(f),
	r(l));if(d&&k){for(n=0;n<d.length;n++)if(d[n]===k[0]){g=n;break}else if(d[0]===k[k.length-d.length+n]){g=n;c=!0;break}void 0===g&&(f=[])}f.length&&a.isNumber(g)&&(v=l.length+g*J*e,c?(u(f,l),t(l,f)):(u(l,f),t(f,l)));return[f,l]}};a.Fx.prototype.fillSetter=a.Fx.prototype.strokeSetter=function(){this.elem.attr(this.prop,a.color(this.start).tweenTo(a.color(this.end),this.pos),null,!0)};a.extend=function(a,f){var m;a||(a={});for(m in f)a[m]=f[m];return a};a.merge=function(){var m,f=arguments,l,r={},u=
	function(f,g){"object"!==typeof f&&(f={});a.objectEach(g,function(d,k){!a.isObject(d,!0)||a.isClass(d)||a.isDOMElement(d)?f[k]=g[k]:f[k]=u(f[k]||{},d)});return f};!0===f[0]&&(r=f[1],f=Array.prototype.slice.call(f,2));l=f.length;for(m=0;m<l;m++)r=u(r,f[m]);return r};a.pInt=function(a,f){return parseInt(a,f||10)};a.isString=function(a){return"string"===typeof a};a.isArray=function(a){a=Object.prototype.toString.call(a);return"[object Array]"===a||"[object Array Iterator]"===a};a.isObject=function(m,
	f){return!!m&&"object"===typeof m&&(!f||!a.isArray(m))};a.isDOMElement=function(m){return a.isObject(m)&&"number"===typeof m.nodeType};a.isClass=function(m){var f=m&&m.constructor;return!(!a.isObject(m,!0)||a.isDOMElement(m)||!f||!f.name||"Object"===f.name)};a.isNumber=function(a){return"number"===typeof a&&!isNaN(a)};a.erase=function(a,f){for(var m=a.length;m--;)if(a[m]===f){a.splice(m,1);break}};a.defined=function(a){return void 0!==a&&null!==a};a.attr=function(m,f,l){var r;a.isString(f)?a.defined(l)?
	m.setAttribute(f,l):m&&m.getAttribute&&(r=m.getAttribute(f)):a.defined(f)&&a.isObject(f)&&a.objectEach(f,function(a,f){m.setAttribute(f,a)});return r};a.splat=function(m){return a.isArray(m)?m:[m]};a.syncTimeout=function(a,f,l){if(f)return setTimeout(a,f,l);a.call(0,l)};a.pick=function(){var a=arguments,f,l,r=a.length;for(f=0;f<r;f++)if(l=a[f],void 0!==l&&null!==l)return l};a.css=function(m,f){a.isMS&&!a.svg&&f&&void 0!==f.opacity&&(f.filter="alpha(opacity\x3d"+100*f.opacity+")");a.extend(m.style,
	f)};a.createElement=function(m,f,l,r,u){m=F.createElement(m);var t=a.css;f&&a.extend(m,f);u&&t(m,{padding:0,border:"none",margin:0});l&&t(m,l);r&&r.appendChild(m);return m};a.extendClass=function(m,f){var l=function(){};l.prototype=new m;a.extend(l.prototype,f);return l};a.pad=function(a,f,l){return Array((f||2)+1-String(a).length).join(l||0)+a};a.relativeLength=function(a,f,l){return/%$/.test(a)?f*parseFloat(a)/100+(l||0):parseFloat(a)};a.wrap=function(a,f,l){var r=a[f];a[f]=function(){var a=Array.prototype.slice.call(arguments),
	f=arguments,g=this;g.proceed=function(){r.apply(g,arguments.length?arguments:f)};a.unshift(r);a=l.apply(this,a);g.proceed=null;return a}};a.getTZOffset=function(m){var f=a.Date;return 6E4*(f.hcGetTimezoneOffset&&f.hcGetTimezoneOffset(m)||f.hcTimezoneOffset||0)};a.dateFormat=function(m,f,l){if(!a.defined(f)||isNaN(f))return a.defaultOptions.lang.invalidDate||"";m=a.pick(m,"%Y-%m-%d %H:%M:%S");var r=a.Date,u=new r(f-a.getTZOffset(f)),t=u[r.hcGetHours](),g=u[r.hcGetDay](),d=u[r.hcGetDate](),k=u[r.hcGetMonth](),
	b=u[r.hcGetFullYear](),e=a.defaultOptions.lang,v=e.weekdays,y=e.shortWeekdays,n=a.pad,r=a.extend({a:y?y[g]:v[g].substr(0,3),A:v[g],d:n(d),e:n(d,2," "),w:g,b:e.shortMonths[k],B:e.months[k],m:n(k+1),y:b.toString().substr(2,2),Y:b,H:n(t),k:t,I:n(t%12||12),l:t%12||12,M:n(u[r.hcGetMinutes]()),p:12>t?"AM":"PM",P:12>t?"am":"pm",S:n(u.getSeconds()),L:n(Math.round(f%1E3),3)},a.dateFormats);a.objectEach(r,function(a,e){for(;-1!==m.indexOf("%"+e);)m=m.replace("%"+e,"function"===typeof a?a(f):a)});return l?m.substr(0,
	1).toUpperCase()+m.substr(1):m};a.formatSingle=function(m,f){var l=/\.([0-9])/,r=a.defaultOptions.lang;/f$/.test(m)?(l=(l=m.match(l))?l[1]:-1,null!==f&&(f=a.numberFormat(f,l,r.decimalPoint,-1<m.indexOf(",")?r.thousandsSep:""))):f=a.dateFormat(m,f);return f};a.format=function(m,f){for(var l="{",r=!1,u,t,g,d,k=[],b;m;){l=m.indexOf(l);if(-1===l)break;u=m.slice(0,l);if(r){u=u.split(":");t=u.shift().split(".");d=t.length;b=f;for(g=0;g<d;g++)b=b[t[g]];u.length&&(b=a.formatSingle(u.join(":"),b));k.push(b)}else k.push(u);
	m=m.slice(l+1);l=(r=!r)?"}":"{"}k.push(m);return k.join("")};a.getMagnitude=function(a){return Math.pow(10,Math.floor(Math.log(a)/Math.LN10))};a.normalizeTickInterval=function(m,f,l,r,u){var t,g=m;l=a.pick(l,1);t=m/l;f||(f=u?[1,1.2,1.5,2,2.5,3,4,5,6,8,10]:[1,2,2.5,5,10],!1===r&&(1===l?f=a.grep(f,function(a){return 0===a%1}):.1>=l&&(f=[1/l])));for(r=0;r<f.length&&!(g=f[r],u&&g*l>=m||!u&&t<=(f[r]+(f[r+1]||f[r]))/2);r++);return g=a.correctFloat(g*l,-Math.round(Math.log(.001)/Math.LN10))};a.stableSort=
	function(a,f){var l=a.length,r,m;for(m=0;m<l;m++)a[m].safeI=m;a.sort(function(a,g){r=f(a,g);return 0===r?a.safeI-g.safeI:r});for(m=0;m<l;m++)delete a[m].safeI};a.arrayMin=function(a){for(var f=a.length,l=a[0];f--;)a[f]<l&&(l=a[f]);return l};a.arrayMax=function(a){for(var f=a.length,l=a[0];f--;)a[f]>l&&(l=a[f]);return l};a.destroyObjectProperties=function(m,f){a.objectEach(m,function(a,r){a&&a!==f&&a.destroy&&a.destroy();delete m[r]})};a.discardElement=function(m){var f=a.garbageBin;f||(f=a.createElement("div"));
	m&&f.appendChild(m);f.innerHTML=""};a.correctFloat=function(a,f){return parseFloat(a.toPrecision(f||14))};a.setAnimation=function(m,f){f.renderer.globalAnimation=a.pick(m,f.options.chart.animation,!0)};a.animObject=function(m){return a.isObject(m)?a.merge(m):{duration:m?500:0}};a.timeUnits={millisecond:1,second:1E3,minute:6E4,hour:36E5,day:864E5,week:6048E5,month:24192E5,year:314496E5};a.numberFormat=function(m,f,l,r){m=+m||0;f=+f;var u=a.defaultOptions.lang,t=(m.toString().split(".")[1]||"").split("e")[0].length,
	g,d,k=m.toString().split("e");-1===f?f=Math.min(t,20):a.isNumber(f)||(f=2);d=(Math.abs(k[1]?k[0]:m)+Math.pow(10,-Math.max(f,t)-1)).toFixed(f);t=String(a.pInt(d));g=3<t.length?t.length%3:0;l=a.pick(l,u.decimalPoint);r=a.pick(r,u.thousandsSep);m=(0>m?"-":"")+(g?t.substr(0,g)+r:"");m+=t.substr(g).replace(/(\d{3})(?=\d)/g,"$1"+r);f&&(m+=l+d.slice(-f));k[1]&&(m+="e"+k[1]);return m};Math.easeInOutSine=function(a){return-.5*(Math.cos(Math.PI*a)-1)};a.getStyle=function(m,f,l){if("width"===f)return Math.min(m.offsetWidth,
	m.scrollWidth)-a.getStyle(m,"padding-left")-a.getStyle(m,"padding-right");if("height"===f)return Math.min(m.offsetHeight,m.scrollHeight)-a.getStyle(m,"padding-top")-a.getStyle(m,"padding-bottom");if(m=E.getComputedStyle(m,void 0))m=m.getPropertyValue(f),a.pick(l,!0)&&(m=a.pInt(m));return m};a.inArray=function(a,f){return f.indexOf?f.indexOf(a):[].indexOf.call(f,a)};a.grep=function(a,f){return[].filter.call(a,f)};a.find=function(a,f){return[].find.call(a,f)};a.map=function(a,f){for(var l=[],r=0,m=
	a.length;r<m;r++)l[r]=f.call(a[r],a[r],r,a);return l};a.offset=function(a){var f=F.documentElement;a=a.getBoundingClientRect();return{top:a.top+(E.pageYOffset||f.scrollTop)-(f.clientTop||0),left:a.left+(E.pageXOffset||f.scrollLeft)-(f.clientLeft||0)}};a.stop=function(a,f){for(var l=C.length;l--;)C[l].elem!==a||f&&f!==C[l].prop||(C[l].stopped=!0)};a.each=function(a,f,l){return Array.prototype.forEach.call(a,f,l)};a.objectEach=function(a,f,l){for(var r in a)a.hasOwnProperty(r)&&f.call(l,a[r],r,a)};
	a.addEvent=function(m,f,l){function r(a){a.target=a.srcElement||E;l.call(m,a)}var u=m.hcEvents=m.hcEvents||{};m.addEventListener?m.addEventListener(f,l,!1):m.attachEvent&&(m.hcEventsIE||(m.hcEventsIE={}),l.hcGetKey||(l.hcGetKey=a.uniqueKey()),m.hcEventsIE[l.hcGetKey]=r,m.attachEvent("on"+f,r));u[f]||(u[f]=[]);u[f].push(l);return function(){a.removeEvent(m,f,l)}};a.removeEvent=function(m,f,l){function r(a,b){m.removeEventListener?m.removeEventListener(a,b,!1):m.attachEvent&&(b=m.hcEventsIE[b.hcGetKey],
	m.detachEvent("on"+a,b))}function u(){var d,b;m.nodeName&&(f?(d={},d[f]=!0):d=g,a.objectEach(d,function(a,d){if(g[d])for(b=g[d].length;b--;)r(d,g[d][b])}))}var t,g=m.hcEvents,d;g&&(f?(t=g[f]||[],l?(d=a.inArray(l,t),-1<d&&(t.splice(d,1),g[f]=t),r(f,l)):(u(),g[f]=[])):(u(),m.hcEvents={}))};a.fireEvent=function(m,f,l,r){var u;u=m.hcEvents;var t,g;l=l||{};if(F.createEvent&&(m.dispatchEvent||m.fireEvent))u=F.createEvent("Events"),u.initEvent(f,!0,!0),a.extend(u,l),m.dispatchEvent?m.dispatchEvent(u):m.fireEvent(f,
	u);else if(u)for(u=u[f]||[],t=u.length,l.target||a.extend(l,{preventDefault:function(){l.defaultPrevented=!0},target:m,type:f}),f=0;f<t;f++)(g=u[f])&&!1===g.call(m,l)&&l.preventDefault();r&&!l.defaultPrevented&&r(l)};a.animate=function(m,f,l){var r,u="",t,g,d;a.isObject(l)||(d=arguments,l={duration:d[2],easing:d[3],complete:d[4]});a.isNumber(l.duration)||(l.duration=400);l.easing="function"===typeof l.easing?l.easing:Math[l.easing]||Math.easeInOutSine;l.curAnim=a.merge(f);a.objectEach(f,function(d,
	b){a.stop(m,b);g=new a.Fx(m,l,b);t=null;"d"===b?(g.paths=g.initPath(m,m.d,f.d),g.toD=f.d,r=0,t=1):m.attr?r=m.attr(b):(r=parseFloat(a.getStyle(m,b))||0,"opacity"!==b&&(u="px"));t||(t=d);t&&t.match&&t.match("px")&&(t=t.replace(/px/g,""));g.run(r,t,u)})};a.seriesType=function(m,f,l,r,u){var t=a.getOptions(),g=a.seriesTypes;t.plotOptions[m]=a.merge(t.plotOptions[f],l);g[m]=a.extendClass(g[f]||function(){},r);g[m].prototype.type=m;u&&(g[m].prototype.pointClass=a.extendClass(a.Point,u));return g[m]};a.uniqueKey=
	function(){var a=Math.random().toString(36).substring(2,9),f=0;return function(){return"highcharts-"+a+"-"+f++}}();E.jQuery&&(E.jQuery.fn.highcharts=function(){var m=[].slice.call(arguments);if(this[0])return m[0]?(new (a[a.isString(m[0])?m.shift():"Chart"])(this[0],m[0],m[1]),this):A[a.attr(this[0],"data-highcharts-chart")]});F&&!F.defaultView&&(a.getStyle=function(m,f){var l={width:"clientWidth",height:"clientHeight"}[f];if(m.style[f])return a.pInt(m.style[f]);"opacity"===f&&(f="filter");if(l)return m.style.zoom=
	1,Math.max(m[l]-2*a.getStyle(m,"padding"),0);m=m.currentStyle[f.replace(/\-(\w)/g,function(a,f){return f.toUpperCase()})];"filter"===f&&(m=m.replace(/alpha\(opacity=([0-9]+)\)/,function(a,f){return f/100}));return""===m?1:a.pInt(m)});Array.prototype.forEach||(a.each=function(a,f,l){for(var r=0,m=a.length;r<m;r++)if(!1===f.call(l,a[r],r,a))return r});Array.prototype.indexOf||(a.inArray=function(a,f){var l,r=0;if(f)for(l=f.length;r<l;r++)if(f[r]===a)return r;return-1});Array.prototype.filter||(a.grep=
	function(a,f){for(var l=[],r=0,m=a.length;r<m;r++)f(a[r],r)&&l.push(a[r]);return l});Array.prototype.find||(a.find=function(a,f){var l,r=a.length;for(l=0;l<r;l++)if(f(a[l],l))return a[l]})})(M);(function(a){var C=a.each,A=a.isNumber,F=a.map,E=a.merge,m=a.pInt;a.Color=function(f){if(!(this instanceof a.Color))return new a.Color(f);this.init(f)};a.Color.prototype={parsers:[{regex:/rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,parse:function(a){return[m(a[1]),
	m(a[2]),m(a[3]),parseFloat(a[4],10)]}},{regex:/rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,parse:function(a){return[m(a[1]),m(a[2]),m(a[3]),1]}}],names:{none:"rgba(255,255,255,0)",white:"#ffffff",black:"#000000"},init:function(f){var l,r,m,t;if((this.input=f=this.names[f&&f.toLowerCase?f.toLowerCase():""]||f)&&f.stops)this.stops=F(f.stops,function(g){return new a.Color(g[1])});else if(f&&"#"===f.charAt()&&(l=f.length,f=parseInt(f.substr(1),16),7===l?r=[(f&16711680)>>16,(f&65280)>>
	8,f&255,1]:4===l&&(r=[(f&3840)>>4|(f&3840)>>8,(f&240)>>4|f&240,(f&15)<<4|f&15,1])),!r)for(m=this.parsers.length;m--&&!r;)t=this.parsers[m],(l=t.regex.exec(f))&&(r=t.parse(l));this.rgba=r||[]},get:function(a){var f=this.input,r=this.rgba,m;this.stops?(m=E(f),m.stops=[].concat(m.stops),C(this.stops,function(f,g){m.stops[g]=[m.stops[g][0],f.get(a)]})):m=r&&A(r[0])?"rgb"===a||!a&&1===r[3]?"rgb("+r[0]+","+r[1]+","+r[2]+")":"a"===a?r[3]:"rgba("+r.join(",")+")":f;return m},brighten:function(a){var f,r=this.rgba;
	if(this.stops)C(this.stops,function(f){f.brighten(a)});else if(A(a)&&0!==a)for(f=0;3>f;f++)r[f]+=m(255*a),0>r[f]&&(r[f]=0),255<r[f]&&(r[f]=255);return this},setOpacity:function(a){this.rgba[3]=a;return this},tweenTo:function(a,l){var f,m;a.rgba.length?(f=this.rgba,a=a.rgba,m=1!==a[3]||1!==f[3],a=(m?"rgba(":"rgb(")+Math.round(a[0]+(f[0]-a[0])*(1-l))+","+Math.round(a[1]+(f[1]-a[1])*(1-l))+","+Math.round(a[2]+(f[2]-a[2])*(1-l))+(m?","+(a[3]+(f[3]-a[3])*(1-l)):"")+")"):a=a.input||"none";return a}};a.color=
	function(f){return new a.Color(f)}})(M);(function(a){var C,A,F=a.addEvent,E=a.animate,m=a.attr,f=a.charts,l=a.color,r=a.css,u=a.createElement,t=a.defined,g=a.deg2rad,d=a.destroyObjectProperties,k=a.doc,b=a.each,e=a.extend,v=a.erase,y=a.grep,n=a.hasTouch,D=a.inArray,J=a.isArray,c=a.isFirefox,G=a.isMS,q=a.isObject,B=a.isString,K=a.isWebKit,p=a.merge,z=a.noop,I=a.objectEach,L=a.pick,h=a.pInt,w=a.removeEvent,P=a.stop,H=a.svg,O=a.SVG_NS,Q=a.symbolSizes,R=a.win;C=a.SVGElement=function(){return this};e(C.prototype,
	{opacity:1,SVG_NS:O,textProps:"direction fontSize fontWeight fontFamily fontStyle color lineHeight width textAlign textDecoration textOverflow textOutline".split(" "),init:function(a,h){this.element="span"===h?u(h):k.createElementNS(this.SVG_NS,h);this.renderer=a},animate:function(x,h,c){h=a.animObject(L(h,this.renderer.globalAnimation,!0));0!==h.duration?(c&&(h.complete=c),E(this,x,h)):(this.attr(x,null,c),h.step&&h.step.call(this));return this},colorGradient:function(x,h,c){var w=this.renderer,
	e,q,N,d,n,g,k,H,G,v,z=[],f;x.radialGradient?q="radialGradient":x.linearGradient&&(q="linearGradient");q&&(N=x[q],n=w.gradients,k=x.stops,v=c.radialReference,J(N)&&(x[q]=N={x1:N[0],y1:N[1],x2:N[2],y2:N[3],gradientUnits:"userSpaceOnUse"}),"radialGradient"===q&&v&&!t(N.gradientUnits)&&(d=N,N=p(N,w.getRadialAttr(v,d),{gradientUnits:"userSpaceOnUse"})),I(N,function(a,x){"id"!==x&&z.push(x,a)}),I(k,function(a){z.push(a)}),z=z.join(","),n[z]?v=n[z].attr("id"):(N.id=v=a.uniqueKey(),n[z]=g=w.createElement(q).attr(N).add(w.defs),
	g.radAttr=d,g.stops=[],b(k,function(x){0===x[1].indexOf("rgba")?(e=a.color(x[1]),H=e.get("rgb"),G=e.get("a")):(H=x[1],G=1);x=w.createElement("stop").attr({offset:x[0],"stop-color":H,"stop-opacity":G}).add(g);g.stops.push(x)})),f="url("+w.url+"#"+v+")",c.setAttribute(h,f),c.gradient=z,x.toString=function(){return f})},applyTextOutline:function(x){var h=this.element,c,w,p,e,q;-1!==x.indexOf("contrast")&&(x=x.replace(/contrast/g,this.renderer.getContrast(h.style.fill)));x=x.split(" ");w=x[x.length-1];
	if((p=x[0])&&"none"!==p&&a.svg){this.fakeTS=!0;x=[].slice.call(h.getElementsByTagName("tspan"));this.ySetter=this.xSetter;p=p.replace(/(^[\d\.]+)(.*?)$/g,function(a,x,h){return 2*x+h});for(q=x.length;q--;)c=x[q],"highcharts-text-outline"===c.getAttribute("class")&&v(x,h.removeChild(c));e=h.firstChild;b(x,function(a,x){0===x&&(a.setAttribute("x",h.getAttribute("x")),x=h.getAttribute("y"),a.setAttribute("y",x||0),null===x&&h.setAttribute("y",0));a=a.cloneNode(1);m(a,{"class":"highcharts-text-outline",
	fill:w,stroke:w,"stroke-width":p,"stroke-linejoin":"round"});h.insertBefore(a,e)})}},attr:function(a,h,c,w){var x,p=this.element,e,q=this,b,N;"string"===typeof a&&void 0!==h&&(x=a,a={},a[x]=h);"string"===typeof a?q=(this[a+"Getter"]||this._defaultGetter).call(this,a,p):(I(a,function(x,h){b=!1;w||P(this,h);this.symbolName&&/^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)$/.test(h)&&(e||(this.symbolAttr(a),e=!0),b=!0);!this.rotation||"x"!==h&&"y"!==h||(this.doTransform=!0);b||(N=this[h+"Setter"]||
	this._defaultSetter,N.call(this,x,h,p),this.shadows&&/^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(h)&&this.updateShadows(h,x,N))},this),this.afterSetters());c&&c();return q},afterSetters:function(){this.doTransform&&(this.updateTransform(),this.doTransform=!1)},updateShadows:function(a,h,c){for(var x=this.shadows,w=x.length;w--;)c.call(x[w],"height"===a?Math.max(h-(x[w].cutHeight||0),0):"d"===a?this.d:h,a,x[w])},addClass:function(a,h){var x=this.attr("class")||"";-1===x.indexOf(a)&&
	(h||(a=(x+(x?" ":"")+a).replace("  "," ")),this.attr("class",a));return this},hasClass:function(a){return-1!==D(a,(this.attr("class")||"").split(" "))},removeClass:function(a){return this.attr("class",(this.attr("class")||"").replace(a,""))},symbolAttr:function(a){var x=this;b("x y r start end width height innerR anchorX anchorY".split(" "),function(h){x[h]=L(a[h],x[h])});x.attr({d:x.renderer.symbols[x.symbolName](x.x,x.y,x.width,x.height,x)})},clip:function(a){return this.attr("clip-path",a?"url("+
	this.renderer.url+"#"+a.id+")":"none")},crisp:function(a,h){var x=this,c={},w;h=h||a.strokeWidth||0;w=Math.round(h)%2/2;a.x=Math.floor(a.x||x.x||0)+w;a.y=Math.floor(a.y||x.y||0)+w;a.width=Math.floor((a.width||x.width||0)-2*w);a.height=Math.floor((a.height||x.height||0)-2*w);t(a.strokeWidth)&&(a.strokeWidth=h);I(a,function(a,h){x[h]!==a&&(x[h]=c[h]=a)});return c},css:function(a){var x=this.styles,c={},w=this.element,p,q="",b,d=!x,n=["textOutline","textOverflow","width"];a&&a.color&&(a.fill=a.color);
	x&&I(a,function(a,h){a!==x[h]&&(c[h]=a,d=!0)});d&&(x&&(a=e(x,c)),p=this.textWidth=a&&a.width&&"auto"!==a.width&&"text"===w.nodeName.toLowerCase()&&h(a.width),this.styles=a,p&&!H&&this.renderer.forExport&&delete a.width,G&&!H?r(this.element,a):(b=function(a,x){return"-"+x.toLowerCase()},I(a,function(a,x){-1===D(x,n)&&(q+=x.replace(/([A-Z])/g,b)+":"+a+";")}),q&&m(w,"style",q)),this.added&&("text"===this.element.nodeName&&this.renderer.buildText(this),a&&a.textOutline&&this.applyTextOutline(a.textOutline)));
	return this},strokeWidth:function(){return this["stroke-width"]||0},on:function(a,h){var x=this,c=x.element;n&&"click"===a?(c.ontouchstart=function(a){x.touchEventFired=Date.now();a.preventDefault();h.call(c,a)},c.onclick=function(a){(-1===R.navigator.userAgent.indexOf("Android")||1100<Date.now()-(x.touchEventFired||0))&&h.call(c,a)}):c["on"+a]=h;return this},setRadialReference:function(a){var x=this.renderer.gradients[this.element.gradient];this.element.radialReference=a;x&&x.radAttr&&x.animate(this.renderer.getRadialAttr(a,
	x.radAttr));return this},translate:function(a,h){return this.attr({translateX:a,translateY:h})},invert:function(a){this.inverted=a;this.updateTransform();return this},updateTransform:function(){var a=this.translateX||0,h=this.translateY||0,c=this.scaleX,w=this.scaleY,p=this.inverted,e=this.rotation,q=this.element;p&&(a+=this.width,h+=this.height);a=["translate("+a+","+h+")"];p?a.push("rotate(90) scale(-1,1)"):e&&a.push("rotate("+e+" "+(q.getAttribute("x")||0)+" "+(q.getAttribute("y")||0)+")");(t(c)||
	t(w))&&a.push("scale("+L(c,1)+" "+L(w,1)+")");a.length&&q.setAttribute("transform",a.join(" "))},toFront:function(){var a=this.element;a.parentNode.appendChild(a);return this},align:function(a,h,c){var x,w,p,e,q={};w=this.renderer;p=w.alignedObjects;var b,d;if(a){if(this.alignOptions=a,this.alignByTranslate=h,!c||B(c))this.alignTo=x=c||"renderer",v(p,this),p.push(this),c=null}else a=this.alignOptions,h=this.alignByTranslate,x=this.alignTo;c=L(c,w[x],w);x=a.align;w=a.verticalAlign;p=(c.x||0)+(a.x||
	0);e=(c.y||0)+(a.y||0);"right"===x?b=1:"center"===x&&(b=2);b&&(p+=(c.width-(a.width||0))/b);q[h?"translateX":"x"]=Math.round(p);"bottom"===w?d=1:"middle"===w&&(d=2);d&&(e+=(c.height-(a.height||0))/d);q[h?"translateY":"y"]=Math.round(e);this[this.placed?"animate":"attr"](q);this.placed=!0;this.alignAttr=q;return this},getBBox:function(a,h){var x,c=this.renderer,w,p=this.element,q=this.styles,d,n=this.textStr,k,N=c.cache,H=c.cacheKeys,G;h=L(h,this.rotation);w=h*g;d=q&&q.fontSize;void 0!==n&&(G=n.toString(),
	-1===G.indexOf("\x3c")&&(G=G.replace(/[0-9]/g,"0")),G+=["",h||0,d,q&&q.width,q&&q.textOverflow].join());G&&!a&&(x=N[G]);if(!x){if(p.namespaceURI===this.SVG_NS||c.forExport){try{(k=this.fakeTS&&function(a){b(p.querySelectorAll(".highcharts-text-outline"),function(x){x.style.display=a})})&&k("none"),x=p.getBBox?e({},p.getBBox()):{width:p.offsetWidth,height:p.offsetHeight},k&&k("")}catch(W){}if(!x||0>x.width)x={width:0,height:0}}else x=this.htmlGetBBox();c.isSVG&&(a=x.width,c=x.height,q&&"11px"===q.fontSize&&
	17===Math.round(c)&&(x.height=c=14),h&&(x.width=Math.abs(c*Math.sin(w))+Math.abs(a*Math.cos(w)),x.height=Math.abs(c*Math.cos(w))+Math.abs(a*Math.sin(w))));if(G&&0<x.height){for(;250<H.length;)delete N[H.shift()];N[G]||H.push(G);N[G]=x}}return x},show:function(a){return this.attr({visibility:a?"inherit":"visible"})},hide:function(){return this.attr({visibility:"hidden"})},fadeOut:function(a){var x=this;x.animate({opacity:0},{duration:a||150,complete:function(){x.attr({y:-9999})}})},add:function(a){var x=
	this.renderer,h=this.element,c;a&&(this.parentGroup=a);this.parentInverted=a&&a.inverted;void 0!==this.textStr&&x.buildText(this);this.added=!0;if(!a||a.handleZ||this.zIndex)c=this.zIndexSetter();c||(a?a.element:x.box).appendChild(h);if(this.onAdd)this.onAdd();return this},safeRemoveChild:function(a){var x=a.parentNode;x&&x.removeChild(a)},destroy:function(){var a=this,h=a.element||{},c=a.renderer.isSVG&&"SPAN"===h.nodeName&&a.parentGroup,w=h.ownerSVGElement;h.onclick=h.onmouseout=h.onmouseover=h.onmousemove=
	h.point=null;P(a);a.clipPath&&w&&(b(w.querySelectorAll("[clip-path]"),function(x){-1<x.getAttribute("clip-path").indexOf(a.clipPath.element.id+")")&&x.removeAttribute("clip-path")}),a.clipPath=a.clipPath.destroy());if(a.stops){for(w=0;w<a.stops.length;w++)a.stops[w]=a.stops[w].destroy();a.stops=null}a.safeRemoveChild(h);for(a.destroyShadows();c&&c.div&&0===c.div.childNodes.length;)h=c.parentGroup,a.safeRemoveChild(c.div),delete c.div,c=h;a.alignTo&&v(a.renderer.alignedObjects,a);I(a,function(x,h){delete a[h]});
	return null},shadow:function(a,h,c){var x=[],w,p,q=this.element,e,b,d,n;if(!a)this.destroyShadows();else if(!this.shadows){b=L(a.width,3);d=(a.opacity||.15)/b;n=this.parentInverted?"(-1,-1)":"("+L(a.offsetX,1)+", "+L(a.offsetY,1)+")";for(w=1;w<=b;w++)p=q.cloneNode(0),e=2*b+1-2*w,m(p,{isShadow:"true",stroke:a.color||"#000000","stroke-opacity":d*w,"stroke-width":e,transform:"translate"+n,fill:"none"}),c&&(m(p,"height",Math.max(m(p,"height")-e,0)),p.cutHeight=e),h?h.element.appendChild(p):q.parentNode.insertBefore(p,
	q),x.push(p);this.shadows=x}return this},destroyShadows:function(){b(this.shadows||[],function(a){this.safeRemoveChild(a)},this);this.shadows=void 0},xGetter:function(a){"circle"===this.element.nodeName&&("x"===a?a="cx":"y"===a&&(a="cy"));return this._defaultGetter(a)},_defaultGetter:function(a){a=L(this[a],this.element?this.element.getAttribute(a):null,0);/^[\-0-9\.]+$/.test(a)&&(a=parseFloat(a));return a},dSetter:function(a,h,c){a&&a.join&&(a=a.join(" "));/(NaN| {2}|^$)/.test(a)&&(a="M 0 0");this[h]!==
	a&&(c.setAttribute(h,a),this[h]=a)},dashstyleSetter:function(a){var x,c=this["stroke-width"];"inherit"===c&&(c=1);if(a=a&&a.toLowerCase()){a=a.replace("shortdashdotdot","3,1,1,1,1,1,").replace("shortdashdot","3,1,1,1").replace("shortdot","1,1,").replace("shortdash","3,1,").replace("longdash","8,3,").replace(/dot/g,"1,3,").replace("dash","4,3,").replace(/,$/,"").split(",");for(x=a.length;x--;)a[x]=h(a[x])*c;a=a.join(",").replace(/NaN/g,"none");this.element.setAttribute("stroke-dasharray",a)}},alignSetter:function(a){this.element.setAttribute("text-anchor",
	{left:"start",center:"middle",right:"end"}[a])},opacitySetter:function(a,h,c){this[h]=a;c.setAttribute(h,a)},titleSetter:function(a){var h=this.element.getElementsByTagName("title")[0];h||(h=k.createElementNS(this.SVG_NS,"title"),this.element.appendChild(h));h.firstChild&&h.removeChild(h.firstChild);h.appendChild(k.createTextNode(String(L(a),"").replace(/<[^>]*>/g,"")))},textSetter:function(a){a!==this.textStr&&(delete this.bBox,this.textStr=a,this.added&&this.renderer.buildText(this))},fillSetter:function(a,
	h,c){"string"===typeof a?c.setAttribute(h,a):a&&this.colorGradient(a,h,c)},visibilitySetter:function(a,h,c){"inherit"===a?c.removeAttribute(h):this[h]!==a&&c.setAttribute(h,a);this[h]=a},zIndexSetter:function(a,c){var x=this.renderer,w=this.parentGroup,p=(w||x).element||x.box,q,e=this.element,b;q=this.added;var d;t(a)&&(e.zIndex=a,a=+a,this[c]===a&&(q=!1),this[c]=a);if(q){(a=this.zIndex)&&w&&(w.handleZ=!0);c=p.childNodes;for(d=0;d<c.length&&!b;d++)w=c[d],q=w.zIndex,w!==e&&(h(q)>a||!t(a)&&t(q)||0>
	a&&!t(q)&&p!==x.box)&&(p.insertBefore(e,w),b=!0);b||p.appendChild(e)}return b},_defaultSetter:function(a,h,c){c.setAttribute(h,a)}});C.prototype.yGetter=C.prototype.xGetter;C.prototype.translateXSetter=C.prototype.translateYSetter=C.prototype.rotationSetter=C.prototype.verticalAlignSetter=C.prototype.scaleXSetter=C.prototype.scaleYSetter=function(a,h){this[h]=a;this.doTransform=!0};C.prototype["stroke-widthSetter"]=C.prototype.strokeSetter=function(a,h,c){this[h]=a;this.stroke&&this["stroke-width"]?
	(C.prototype.fillSetter.call(this,this.stroke,"stroke",c),c.setAttribute("stroke-width",this["stroke-width"]),this.hasStroke=!0):"stroke-width"===h&&0===a&&this.hasStroke&&(c.removeAttribute("stroke"),this.hasStroke=!1)};A=a.SVGRenderer=function(){this.init.apply(this,arguments)};e(A.prototype,{Element:C,SVG_NS:O,init:function(a,h,w,p,q,e){var x;p=this.createElement("svg").attr({version:"1.1","class":"highcharts-root"}).css(this.getStyle(p));x=p.element;a.appendChild(x);-1===a.innerHTML.indexOf("xmlns")&&
	m(x,"xmlns",this.SVG_NS);this.isSVG=!0;this.box=x;this.boxWrapper=p;this.alignedObjects=[];this.url=(c||K)&&k.getElementsByTagName("base").length?R.location.href.replace(/#.*?$/,"").replace(/<[^>]*>/g,"").replace(/([\('\)])/g,"\\$1").replace(/ /g,"%20"):"";this.createElement("desc").add().element.appendChild(k.createTextNode("Created with Highcharts 5.0.14"));this.defs=this.createElement("defs").add();this.allowHTML=e;this.forExport=q;this.gradients={};this.cache={};this.cacheKeys=[];this.imgCount=
	0;this.setSize(h,w,!1);var b;c&&a.getBoundingClientRect&&(h=function(){r(a,{left:0,top:0});b=a.getBoundingClientRect();r(a,{left:Math.ceil(b.left)-b.left+"px",top:Math.ceil(b.top)-b.top+"px"})},h(),this.unSubPixelFix=F(R,"resize",h))},getStyle:function(a){return this.style=e({fontFamily:'"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',fontSize:"12px"},a)},setStyle:function(a){this.boxWrapper.css(this.getStyle(a))},isHidden:function(){return!this.boxWrapper.getBBox().width},destroy:function(){var a=
	this.defs;this.box=null;this.boxWrapper=this.boxWrapper.destroy();d(this.gradients||{});this.gradients=null;a&&(this.defs=a.destroy());this.unSubPixelFix&&this.unSubPixelFix();return this.alignedObjects=null},createElement:function(a){var h=new this.Element;h.init(this,a);return h},draw:z,getRadialAttr:function(a,h){return{cx:a[0]-a[2]/2+h.cx*a[2],cy:a[1]-a[2]/2+h.cy*a[2],r:h.r*a[2]}},getSpanWidth:function(a,h){var c=a.getBBox(!0).width;!H&&this.forExport&&(c=this.measureSpanWidth(h.firstChild.data,
	a.styles));return c},applyEllipsis:function(a,h,c,w){var x=a.rotation,p=c,q,e=0,b=c.length,d=function(a){h.removeChild(h.firstChild);a&&h.appendChild(k.createTextNode(a))},n;a.rotation=0;p=this.getSpanWidth(a,h);if(n=p>w){for(;e<=b;)q=Math.ceil((e+b)/2),p=c.substring(0,q)+"\u2026",d(p),p=this.getSpanWidth(a,h),e===b?e=b+1:p>w?b=q-1:e=q;0===b&&d("")}a.rotation=x;return n},buildText:function(a){var c=a.element,w=this,x=w.forExport,p=L(a.textStr,"").toString(),q=-1!==p.indexOf("\x3c"),e=c.childNodes,
	d,n,g,G,v=m(c,"x"),z=a.styles,f=a.textWidth,I=z&&z.lineHeight,B=z&&z.textOutline,D=z&&"ellipsis"===z.textOverflow,l=z&&"nowrap"===z.whiteSpace,P=z&&z.fontSize,t,J,u=e.length,z=f&&!a.added&&this.box,K=function(a){var x;x=/(px|em)$/.test(a&&a.style.fontSize)?a.style.fontSize:P||w.style.fontSize||12;return I?h(I):w.fontMetrics(x,a.getAttribute("style")?a:c).h};t=[p,D,l,I,B,P,f].join();if(t!==a.textCache){for(a.textCache=t;u--;)c.removeChild(e[u]);q||B||D||f||-1!==p.indexOf(" ")?(d=/<.*class="([^"]+)".*>/,
	n=/<.*style="([^"]+)".*>/,g=/<.*href="([^"]+)".*>/,z&&z.appendChild(c),p=q?p.replace(/<(b|strong)>/g,'\x3cspan style\x3d"font-weight:bold"\x3e').replace(/<(i|em)>/g,'\x3cspan style\x3d"font-style:italic"\x3e').replace(/<a/g,"\x3cspan").replace(/<\/(b|strong|i|em|a)>/g,"\x3c/span\x3e").split(/<br.*?>/g):[p],p=y(p,function(a){return""!==a}),b(p,function(h,p){var q,e=0;h=h.replace(/^\s+|\s+$/g,"").replace(/<span/g,"|||\x3cspan").replace(/<\/span>/g,"\x3c/span\x3e|||");q=h.split("|||");b(q,function(h){if(""!==
	h||1===q.length){var b={},z=k.createElementNS(w.SVG_NS,"tspan"),y,I;d.test(h)&&(y=h.match(d)[1],m(z,"class",y));n.test(h)&&(I=h.match(n)[1].replace(/(;| |^)color([ :])/,"$1fill$2"),m(z,"style",I));g.test(h)&&!x&&(m(z,"onclick",'location.href\x3d"'+h.match(g)[1]+'"'),r(z,{cursor:"pointer"}));h=(h.replace(/<(.|\n)*?>/g,"")||" ").replace(/&lt;/g,"\x3c").replace(/&gt;/g,"\x3e");if(" "!==h){z.appendChild(k.createTextNode(h));e?b.dx=0:p&&null!==v&&(b.x=v);m(z,b);c.appendChild(z);!e&&J&&(!H&&x&&r(z,{display:"block"}),
	m(z,"dy",K(z)));if(f){b=h.replace(/([^\^])-/g,"$1- ").split(" ");y=1<q.length||p||1<b.length&&!l;var B=[],N,P=K(z),t=a.rotation;for(D&&(G=w.applyEllipsis(a,z,h,f));!D&&y&&(b.length||B.length);)a.rotation=0,N=w.getSpanWidth(a,z),h=N>f,void 0===G&&(G=h),h&&1!==b.length?(z.removeChild(z.firstChild),B.unshift(b.pop())):(b=B,B=[],b.length&&!l&&(z=k.createElementNS(O,"tspan"),m(z,{dy:P,x:v}),I&&m(z,"style",I),c.appendChild(z)),N>f&&(f=N)),b.length&&z.appendChild(k.createTextNode(b.join(" ").replace(/- /g,
	"-")));a.rotation=t}e++}}});J=J||c.childNodes.length}),G&&a.attr("title",a.textStr),z&&z.removeChild(c),B&&a.applyTextOutline&&a.applyTextOutline(B)):c.appendChild(k.createTextNode(p.replace(/&lt;/g,"\x3c").replace(/&gt;/g,"\x3e")))}},getContrast:function(a){a=l(a).rgba;return 510<a[0]+a[1]+a[2]?"#000000":"#FFFFFF"},button:function(a,h,c,w,q,b,d,n,g){var x=this.label(a,h,c,g,null,null,null,null,"button"),k=0;x.attr(p({padding:8,r:2},q));var z,H,v,f;q=p({fill:"#f7f7f7",stroke:"#cccccc","stroke-width":1,
	style:{color:"#333333",cursor:"pointer",fontWeight:"normal"}},q);z=q.style;delete q.style;b=p(q,{fill:"#e6e6e6"},b);H=b.style;delete b.style;d=p(q,{fill:"#e6ebf5",style:{color:"#000000",fontWeight:"bold"}},d);v=d.style;delete d.style;n=p(q,{style:{color:"#cccccc"}},n);f=n.style;delete n.style;F(x.element,G?"mouseover":"mouseenter",function(){3!==k&&x.setState(1)});F(x.element,G?"mouseout":"mouseleave",function(){3!==k&&x.setState(k)});x.setState=function(a){1!==a&&(x.state=k=a);x.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-"+
	["normal","hover","pressed","disabled"][a||0]);x.attr([q,b,d,n][a||0]).css([z,H,v,f][a||0])};x.attr(q).css(e({cursor:"default"},z));return x.on("click",function(a){3!==k&&w.call(x,a)})},crispLine:function(a,h){a[1]===a[4]&&(a[1]=a[4]=Math.round(a[1])-h%2/2);a[2]===a[5]&&(a[2]=a[5]=Math.round(a[2])+h%2/2);return a},path:function(a){var h={fill:"none"};J(a)?h.d=a:q(a)&&e(h,a);return this.createElement("path").attr(h)},circle:function(a,h,c){a=q(a)?a:{x:a,y:h,r:c};h=this.createElement("circle");h.xSetter=
	h.ySetter=function(a,h,c){c.setAttribute("c"+h,a)};return h.attr(a)},arc:function(a,h,c,w,p,b){q(a)?(w=a,h=w.y,c=w.r,a=w.x):w={innerR:w,start:p,end:b};a=this.symbol("arc",a,h,c,c,w);a.r=c;return a},rect:function(a,h,c,w,p,b){p=q(a)?a.r:p;var x=this.createElement("rect");a=q(a)?a:void 0===a?{}:{x:a,y:h,width:Math.max(c,0),height:Math.max(w,0)};void 0!==b&&(a.strokeWidth=b,a=x.crisp(a));a.fill="none";p&&(a.r=p);x.rSetter=function(a,h,c){m(c,{rx:a,ry:a})};return x.attr(a)},setSize:function(a,h,c){var w=
	this.alignedObjects,p=w.length;this.width=a;this.height=h;for(this.boxWrapper.animate({width:a,height:h},{step:function(){this.attr({viewBox:"0 0 "+this.attr("width")+" "+this.attr("height")})},duration:L(c,!0)?void 0:0});p--;)w[p].align()},g:function(a){var h=this.createElement("g");return a?h.attr({"class":"highcharts-"+a}):h},image:function(a,h,c,w,p){var x={preserveAspectRatio:"none"};1<arguments.length&&e(x,{x:h,y:c,width:w,height:p});x=this.createElement("image").attr(x);x.element.setAttributeNS?
	x.element.setAttributeNS("http://www.w3.org/1999/xlink","href",a):x.element.setAttribute("hc-svg-href",a);return x},symbol:function(a,h,c,w,p,q){var x=this,d,n=/^url\((.*?)\)$/,g=n.test(a),z=!g&&(this.symbols[a]?a:"circle"),G=z&&this.symbols[z],H=t(h)&&G&&G.call(this.symbols,Math.round(h),Math.round(c),w,p,q),v,y;G?(d=this.path(H),d.attr("fill","none"),e(d,{symbolName:z,x:h,y:c,width:w,height:p}),q&&e(d,q)):g&&(v=a.match(n)[1],d=this.image(v),d.imgwidth=L(Q[v]&&Q[v].width,q&&q.width),d.imgheight=
	L(Q[v]&&Q[v].height,q&&q.height),y=function(){d.attr({width:d.width,height:d.height})},b(["width","height"],function(a){d[a+"Setter"]=function(a,h){var c={},w=this["img"+h],p="width"===h?"translateX":"translateY";this[h]=a;t(w)&&(this.element&&this.element.setAttribute(h,w),this.alignByTranslate||(c[p]=((this[h]||0)-w)/2,this.attr(c)))}}),t(h)&&d.attr({x:h,y:c}),d.isImg=!0,t(d.imgwidth)&&t(d.imgheight)?y():(d.attr({width:0,height:0}),u("img",{onload:function(){var a=f[x.chartIndex];0===this.width&&
	(r(this,{position:"absolute",top:"-999em"}),k.body.appendChild(this));Q[v]={width:this.width,height:this.height};d.imgwidth=this.width;d.imgheight=this.height;d.element&&y();this.parentNode&&this.parentNode.removeChild(this);x.imgCount--;if(!x.imgCount&&a&&a.onload)a.onload()},src:v}),this.imgCount++));return d},symbols:{circle:function(a,h,c,w){return this.arc(a+c/2,h+w/2,c/2,w/2,{start:0,end:2*Math.PI,open:!1})},square:function(a,h,c,w){return["M",a,h,"L",a+c,h,a+c,h+w,a,h+w,"Z"]},triangle:function(a,
	h,c,w){return["M",a+c/2,h,"L",a+c,h+w,a,h+w,"Z"]},"triangle-down":function(a,h,c,w){return["M",a,h,"L",a+c,h,a+c/2,h+w,"Z"]},diamond:function(a,h,c,w){return["M",a+c/2,h,"L",a+c,h+w/2,a+c/2,h+w,a,h+w/2,"Z"]},arc:function(a,h,c,w,p){var q=p.start,b=p.r||c,x=p.r||w||c,e=p.end-.001;c=p.innerR;w=L(p.open,.001>Math.abs(p.end-p.start-2*Math.PI));var d=Math.cos(q),n=Math.sin(q),g=Math.cos(e),e=Math.sin(e);p=.001>p.end-q-Math.PI?0:1;b=["M",a+b*d,h+x*n,"A",b,x,0,p,1,a+b*g,h+x*e];t(c)&&b.push(w?"M":"L",a+c*
	g,h+c*e,"A",c,c,0,p,0,a+c*d,h+c*n);b.push(w?"":"Z");return b},callout:function(a,h,c,w,p){var q=Math.min(p&&p.r||0,c,w),b=q+6,e=p&&p.anchorX;p=p&&p.anchorY;var d;d=["M",a+q,h,"L",a+c-q,h,"C",a+c,h,a+c,h,a+c,h+q,"L",a+c,h+w-q,"C",a+c,h+w,a+c,h+w,a+c-q,h+w,"L",a+q,h+w,"C",a,h+w,a,h+w,a,h+w-q,"L",a,h+q,"C",a,h,a,h,a+q,h];e&&e>c?p>h+b&&p<h+w-b?d.splice(13,3,"L",a+c,p-6,a+c+6,p,a+c,p+6,a+c,h+w-q):d.splice(13,3,"L",a+c,w/2,e,p,a+c,w/2,a+c,h+w-q):e&&0>e?p>h+b&&p<h+w-b?d.splice(33,3,"L",a,p+6,a-6,p,a,p-6,
	a,h+q):d.splice(33,3,"L",a,w/2,e,p,a,w/2,a,h+q):p&&p>w&&e>a+b&&e<a+c-b?d.splice(23,3,"L",e+6,h+w,e,h+w+6,e-6,h+w,a+q,h+w):p&&0>p&&e>a+b&&e<a+c-b&&d.splice(3,3,"L",e-6,h,e,h-6,e+6,h,c-q,h);return d}},clipRect:function(h,c,w,p){var q=a.uniqueKey(),b=this.createElement("clipPath").attr({id:q}).add(this.defs);h=this.rect(h,c,w,p,0).add(b);h.id=q;h.clipPath=b;h.count=0;return h},text:function(a,h,c,w){var p=!H&&this.forExport,q={};if(w&&(this.allowHTML||!this.forExport))return this.html(a,h,c);q.x=Math.round(h||
	0);c&&(q.y=Math.round(c));if(a||0===a)q.text=a;a=this.createElement("text").attr(q);p&&a.css({position:"absolute"});w||(a.xSetter=function(a,h,c){var w=c.getElementsByTagName("tspan"),p,q=c.getAttribute(h),b;for(b=0;b<w.length;b++)p=w[b],p.getAttribute(h)===q&&p.setAttribute(h,a);c.setAttribute(h,a)});return a},fontMetrics:function(a,c){a=a||c&&c.style&&c.style.fontSize||this.style&&this.style.fontSize;a=/px/.test(a)?h(a):/em/.test(a)?parseFloat(a)*(c?this.fontMetrics(null,c.parentNode).f:16):12;
	c=24>a?a+3:Math.round(1.2*a);return{h:c,b:Math.round(.8*c),f:a}},rotCorr:function(a,h,c){var w=a;h&&c&&(w=Math.max(w*Math.cos(h*g),4));return{x:-a/3*Math.sin(h*g),y:w}},label:function(h,c,q,d,n,g,k,z,G){var x=this,H=x.g("button"!==G&&"label"),v=H.text=x.text("",0,0,k).attr({zIndex:1}),f,y,I=0,B=3,D=0,r,l,P,m,J,O={},L,u,N=/^url\((.*?)\)$/.test(d),K=N,U,T,Q,R;G&&H.addClass("highcharts-"+G);K=N;U=function(){return(L||0)%2/2};T=function(){var a=v.element.style,h={};y=(void 0===r||void 0===l||J)&&t(v.textStr)&&
	v.getBBox();H.width=(r||y.width||0)+2*B+D;H.height=(l||y.height||0)+2*B;u=B+x.fontMetrics(a&&a.fontSize,v).b;K&&(f||(H.box=f=x.symbols[d]||N?x.symbol(d):x.rect(),f.addClass(("button"===G?"":"highcharts-label-box")+(G?" highcharts-"+G+"-box":"")),f.add(H),a=U(),h.x=a,h.y=(z?-u:0)+a),h.width=Math.round(H.width),h.height=Math.round(H.height),f.attr(e(h,O)),O={})};Q=function(){var a=D+B,h;h=z?0:u;t(r)&&y&&("center"===J||"right"===J)&&(a+={center:.5,right:1}[J]*(r-y.width));if(a!==v.x||h!==v.y)v.attr("x",
	a),void 0!==h&&v.attr("y",h);v.x=a;v.y=h};R=function(a,h){f?f.attr(a,h):O[a]=h};H.onAdd=function(){v.add(H);H.attr({text:h||0===h?h:"",x:c,y:q});f&&t(n)&&H.attr({anchorX:n,anchorY:g})};H.widthSetter=function(h){r=a.isNumber(h)?h:null};H.heightSetter=function(a){l=a};H["text-alignSetter"]=function(a){J=a};H.paddingSetter=function(a){t(a)&&a!==B&&(B=H.padding=a,Q())};H.paddingLeftSetter=function(a){t(a)&&a!==D&&(D=a,Q())};H.alignSetter=function(a){a={left:0,center:.5,right:1}[a];a!==I&&(I=a,y&&H.attr({x:P}))};
	H.textSetter=function(a){void 0!==a&&v.textSetter(a);T();Q()};H["stroke-widthSetter"]=function(a,h){a&&(K=!0);L=this["stroke-width"]=a;R(h,a)};H.strokeSetter=H.fillSetter=H.rSetter=function(a,h){"r"!==h&&("fill"===h&&a&&(K=!0),H[h]=a);R(h,a)};H.anchorXSetter=function(a,h){n=H.anchorX=a;R(h,Math.round(a)-U()-P)};H.anchorYSetter=function(a,h){g=H.anchorY=a;R(h,a-m)};H.xSetter=function(a){H.x=a;I&&(a-=I*((r||y.width)+2*B));P=Math.round(a);H.attr("translateX",P)};H.ySetter=function(a){m=H.y=Math.round(a);
	H.attr("translateY",m)};var V=H.css;return e(H,{css:function(a){if(a){var h={};a=p(a);b(H.textProps,function(c){void 0!==a[c]&&(h[c]=a[c],delete a[c])});v.css(h)}return V.call(H,a)},getBBox:function(){return{width:y.width+2*B,height:y.height+2*B,x:y.x-B,y:y.y-B}},shadow:function(a){a&&(T(),f&&f.shadow(a));return H},destroy:function(){w(H.element,"mouseenter");w(H.element,"mouseleave");v&&(v=v.destroy());f&&(f=f.destroy());C.prototype.destroy.call(H);H=x=T=Q=R=null}})}});a.Renderer=A})(M);(function(a){var C=
	a.attr,A=a.createElement,F=a.css,E=a.defined,m=a.each,f=a.extend,l=a.isFirefox,r=a.isMS,u=a.isWebKit,t=a.pInt,g=a.SVGRenderer,d=a.win,k=a.wrap;f(a.SVGElement.prototype,{htmlCss:function(a){var b=this.element;if(b=a&&"SPAN"===b.tagName&&a.width)delete a.width,this.textWidth=b,this.updateTransform();a&&"ellipsis"===a.textOverflow&&(a.whiteSpace="nowrap",a.overflow="hidden");this.styles=f(this.styles,a);F(this.element,a);return this},htmlGetBBox:function(){var a=this.element;"text"===a.nodeName&&(a.style.position=
	"absolute");return{x:a.offsetLeft,y:a.offsetTop,width:a.offsetWidth,height:a.offsetHeight}},htmlUpdateTransform:function(){if(this.added){var a=this.renderer,e=this.element,d=this.translateX||0,g=this.translateY||0,n=this.x||0,k=this.y||0,f=this.textAlign||"left",c={left:0,center:.5,right:1}[f],G=this.styles;F(e,{marginLeft:d,marginTop:g});this.shadows&&m(this.shadows,function(a){F(a,{marginLeft:d+1,marginTop:g+1})});this.inverted&&m(e.childNodes,function(c){a.invertChild(c,e)});if("SPAN"===e.tagName){var q=
	this.rotation,B=t(this.textWidth),r=G&&G.whiteSpace,p=[q,f,e.innerHTML,this.textWidth,this.textAlign].join();p!==this.cTT&&(G=a.fontMetrics(e.style.fontSize).b,E(q)&&this.setSpanRotation(q,c,G),F(e,{width:"",whiteSpace:r||"nowrap"}),e.offsetWidth>B&&/[ \-]/.test(e.textContent||e.innerText)&&F(e,{width:B+"px",display:"block",whiteSpace:r||"normal"}),this.getSpanCorrection(e.offsetWidth,G,c,q,f));F(e,{left:n+(this.xCorr||0)+"px",top:k+(this.yCorr||0)+"px"});u&&(G=e.offsetHeight);this.cTT=p}}else this.alignOnAdd=
	!0},setSpanRotation:function(a,e,g){var b={},n=r?"-ms-transform":u?"-webkit-transform":l?"MozTransform":d.opera?"-o-transform":"";b[n]=b.transform="rotate("+a+"deg)";b[n+(l?"Origin":"-origin")]=b.transformOrigin=100*e+"% "+g+"px";F(this.element,b)},getSpanCorrection:function(a,e,d){this.xCorr=-a*d;this.yCorr=-e}});f(g.prototype,{html:function(a,e,d){var b=this.createElement("span"),n=b.element,g=b.renderer,v=g.isSVG,c=function(a,c){m(["opacity","visibility"],function(q){k(a,q+"Setter",function(a,
	p,q,b){a.call(this,p,q,b);c[q]=p})})};b.textSetter=function(a){a!==n.innerHTML&&delete this.bBox;n.innerHTML=this.textStr=a;b.htmlUpdateTransform()};v&&c(b,b.element.style);b.xSetter=b.ySetter=b.alignSetter=b.rotationSetter=function(a,c){"align"===c&&(c="textAlign");b[c]=a;b.htmlUpdateTransform()};b.attr({text:a,x:Math.round(e),y:Math.round(d)}).css({fontFamily:this.style.fontFamily,fontSize:this.style.fontSize,position:"absolute"});n.style.whiteSpace="nowrap";b.css=b.htmlCss;v&&(b.add=function(a){var q,
	e=g.box.parentNode,d=[];if(this.parentGroup=a){if(q=a.div,!q){for(;a;)d.push(a),a=a.parentGroup;m(d.reverse(),function(a){var p,n=C(a.element,"class");n&&(n={className:n});q=a.div=a.div||A("div",n,{position:"absolute",left:(a.translateX||0)+"px",top:(a.translateY||0)+"px",display:a.display,opacity:a.opacity,pointerEvents:a.styles&&a.styles.pointerEvents},q||e);p=q.style;f(a,{classSetter:function(a){this.element.setAttribute("class",a);q.className=a},on:function(){d[0].div&&b.on.apply({element:d[0].div},
	arguments);return a},translateXSetter:function(c,h){p.left=c+"px";a[h]=c;a.doTransform=!0},translateYSetter:function(c,h){p.top=c+"px";a[h]=c;a.doTransform=!0}});c(a,p)})}}else q=e;q.appendChild(n);b.added=!0;b.alignOnAdd&&b.htmlUpdateTransform();return b});return b}})})(M);(function(a){var C,A,F=a.createElement,E=a.css,m=a.defined,f=a.deg2rad,l=a.discardElement,r=a.doc,u=a.each,t=a.erase,g=a.extend;C=a.extendClass;var d=a.isArray,k=a.isNumber,b=a.isObject,e=a.merge;A=a.noop;var v=a.pick,y=a.pInt,
	n=a.SVGElement,D=a.SVGRenderer,J=a.win;a.svg||(A={docMode8:r&&8===r.documentMode,init:function(a,b){var c=["\x3c",b,' filled\x3d"f" stroked\x3d"f"'],e=["position: ","absolute",";"],d="div"===b;("shape"===b||d)&&e.push("left:0;top:0;width:1px;height:1px;");e.push("visibility: ",d?"hidden":"visible");c.push(' style\x3d"',e.join(""),'"/\x3e');b&&(c=d||"span"===b||"img"===b?c.join(""):a.prepVML(c),this.element=F(c));this.renderer=a},add:function(a){var c=this.renderer,b=this.element,e=c.box,d=a&&a.inverted,
	e=a?a.element||a:e;a&&(this.parentGroup=a);d&&c.invertChild(b,e);e.appendChild(b);this.added=!0;this.alignOnAdd&&!this.deferUpdateTransform&&this.updateTransform();if(this.onAdd)this.onAdd();this.className&&this.attr("class",this.className);return this},updateTransform:n.prototype.htmlUpdateTransform,setSpanRotation:function(){var a=this.rotation,b=Math.cos(a*f),q=Math.sin(a*f);E(this.element,{filter:a?["progid:DXImageTransform.Microsoft.Matrix(M11\x3d",b,", M12\x3d",-q,", M21\x3d",q,", M22\x3d",
	b,", sizingMethod\x3d'auto expand')"].join(""):"none"})},getSpanCorrection:function(a,b,q,e,d){var c=e?Math.cos(e*f):1,n=e?Math.sin(e*f):0,g=v(this.elemHeight,this.element.offsetHeight),k;this.xCorr=0>c&&-a;this.yCorr=0>n&&-g;k=0>c*n;this.xCorr+=n*b*(k?1-q:q);this.yCorr-=c*b*(e?k?q:1-q:1);d&&"left"!==d&&(this.xCorr-=a*q*(0>c?-1:1),e&&(this.yCorr-=g*q*(0>n?-1:1)),E(this.element,{textAlign:d}))},pathToVML:function(a){for(var c=a.length,b=[];c--;)k(a[c])?b[c]=Math.round(10*a[c])-5:"Z"===a[c]?b[c]="x":
	(b[c]=a[c],!a.isArc||"wa"!==a[c]&&"at"!==a[c]||(b[c+5]===b[c+7]&&(b[c+7]+=a[c+7]>a[c+5]?1:-1),b[c+6]===b[c+8]&&(b[c+8]+=a[c+8]>a[c+6]?1:-1)));return b.join(" ")||"x"},clip:function(a){var c=this,b;a?(b=a.members,t(b,c),b.push(c),c.destroyClip=function(){t(b,c)},a=a.getCSS(c)):(c.destroyClip&&c.destroyClip(),a={clip:c.docMode8?"inherit":"rect(auto)"});return c.css(a)},css:n.prototype.htmlCss,safeRemoveChild:function(a){a.parentNode&&l(a)},destroy:function(){this.destroyClip&&this.destroyClip();return n.prototype.destroy.apply(this)},
	on:function(a,b){this.element["on"+a]=function(){var a=J.event;a.target=a.srcElement;b(a)};return this},cutOffPath:function(a,b){var c;a=a.split(/[ ,]/);c=a.length;if(9===c||11===c)a[c-4]=a[c-2]=y(a[c-2])-10*b;return a.join(" ")},shadow:function(a,b,e){var c=[],q,p=this.element,d=this.renderer,n,g=p.style,h,w=p.path,k,H,f,D;w&&"string"!==typeof w.value&&(w="x");H=w;if(a){f=v(a.width,3);D=(a.opacity||.15)/f;for(q=1;3>=q;q++)k=2*f+1-2*q,e&&(H=this.cutOffPath(w.value,k+.5)),h=['\x3cshape isShadow\x3d"true" strokeweight\x3d"',
	k,'" filled\x3d"false" path\x3d"',H,'" coordsize\x3d"10 10" style\x3d"',p.style.cssText,'" /\x3e'],n=F(d.prepVML(h),null,{left:y(g.left)+v(a.offsetX,1),top:y(g.top)+v(a.offsetY,1)}),e&&(n.cutOff=k+1),h=['\x3cstroke color\x3d"',a.color||"#000000",'" opacity\x3d"',D*q,'"/\x3e'],F(d.prepVML(h),null,null,n),b?b.element.appendChild(n):p.parentNode.insertBefore(n,p),c.push(n);this.shadows=c}return this},updateShadows:A,setAttr:function(a,b){this.docMode8?this.element[a]=b:this.element.setAttribute(a,b)},
	classSetter:function(a){(this.added?this.element:this).className=a},dashstyleSetter:function(a,b,e){(e.getElementsByTagName("stroke")[0]||F(this.renderer.prepVML(["\x3cstroke/\x3e"]),null,null,e))[b]=a||"solid";this[b]=a},dSetter:function(a,b,e){var c=this.shadows;a=a||[];this.d=a.join&&a.join(" ");e.path=a=this.pathToVML(a);if(c)for(e=c.length;e--;)c[e].path=c[e].cutOff?this.cutOffPath(a,c[e].cutOff):a;this.setAttr(b,a)},fillSetter:function(a,b,e){var c=e.nodeName;"SPAN"===c?e.style.color=a:"IMG"!==
	c&&(e.filled="none"!==a,this.setAttr("fillcolor",this.renderer.color(a,e,b,this)))},"fill-opacitySetter":function(a,b,e){F(this.renderer.prepVML(["\x3c",b.split("-")[0],' opacity\x3d"',a,'"/\x3e']),null,null,e)},opacitySetter:A,rotationSetter:function(a,b,e){e=e.style;this[b]=e[b]=a;e.left=-Math.round(Math.sin(a*f)+1)+"px";e.top=Math.round(Math.cos(a*f))+"px"},strokeSetter:function(a,b,e){this.setAttr("strokecolor",this.renderer.color(a,e,b,this))},"stroke-widthSetter":function(a,b,e){e.stroked=!!a;
	this[b]=a;k(a)&&(a+="px");this.setAttr("strokeweight",a)},titleSetter:function(a,b){this.setAttr(b,a)},visibilitySetter:function(a,b,e){"inherit"===a&&(a="visible");this.shadows&&u(this.shadows,function(c){c.style[b]=a});"DIV"===e.nodeName&&(a="hidden"===a?"-999em":0,this.docMode8||(e.style[b]=a?"visible":"hidden"),b="top");e.style[b]=a},xSetter:function(a,b,e){this[b]=a;"x"===b?b="left":"y"===b&&(b="top");this.updateClipping?(this[b]=a,this.updateClipping()):e.style[b]=a},zIndexSetter:function(a,
	b,e){e.style[b]=a}},A["stroke-opacitySetter"]=A["fill-opacitySetter"],a.VMLElement=A=C(n,A),A.prototype.ySetter=A.prototype.widthSetter=A.prototype.heightSetter=A.prototype.xSetter,A={Element:A,isIE8:-1<J.navigator.userAgent.indexOf("MSIE 8.0"),init:function(a,b,e){var c,d;this.alignedObjects=[];c=this.createElement("div").css({position:"relative"});d=c.element;a.appendChild(c.element);this.isVML=!0;this.box=d;this.boxWrapper=c;this.gradients={};this.cache={};this.cacheKeys=[];this.imgCount=0;this.setSize(b,
	e,!1);if(!r.namespaces.hcv){r.namespaces.add("hcv","urn:schemas-microsoft-com:vml");try{r.createStyleSheet().cssText="hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke{ behavior:url(#default#VML); display: inline-block; } "}catch(p){r.styleSheets[0].cssText+="hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke{ behavior:url(#default#VML); display: inline-block; } "}}},isHidden:function(){return!this.box.offsetWidth},clipRect:function(a,e,d,n){var c=this.createElement(),p=b(a);return g(c,{members:[],
	count:0,left:(p?a.x:a)+1,top:(p?a.y:e)+1,width:(p?a.width:d)-1,height:(p?a.height:n)-1,getCSS:function(a){var c=a.element,b=c.nodeName,h=a.inverted,w=this.top-("shape"===b?c.offsetTop:0),p=this.left,c=p+this.width,e=w+this.height,w={clip:"rect("+Math.round(h?p:w)+"px,"+Math.round(h?e:c)+"px,"+Math.round(h?c:e)+"px,"+Math.round(h?w:p)+"px)"};!h&&a.docMode8&&"DIV"===b&&g(w,{width:c+"px",height:e+"px"});return w},updateClipping:function(){u(c.members,function(a){a.element&&a.css(c.getCSS(a))})}})},color:function(c,
	b,e,d){var q=this,p,n=/^rgba/,g,k,h="none";c&&c.linearGradient?k="gradient":c&&c.radialGradient&&(k="pattern");if(k){var w,v,H=c.linearGradient||c.radialGradient,f,D,y,x,r,B="";c=c.stops;var l,G=[],m=function(){g=['\x3cfill colors\x3d"'+G.join(",")+'" opacity\x3d"',y,'" o:opacity2\x3d"',D,'" type\x3d"',k,'" ',B,'focus\x3d"100%" method\x3d"any" /\x3e'];F(q.prepVML(g),null,null,b)};f=c[0];l=c[c.length-1];0<f[0]&&c.unshift([0,f[1]]);1>l[0]&&c.push([1,l[1]]);u(c,function(h,c){n.test(h[1])?(p=a.color(h[1]),
	w=p.get("rgb"),v=p.get("a")):(w=h[1],v=1);G.push(100*h[0]+"% "+w);c?(y=v,x=w):(D=v,r=w)});if("fill"===e)if("gradient"===k)e=H.x1||H[0]||0,c=H.y1||H[1]||0,f=H.x2||H[2]||0,H=H.y2||H[3]||0,B='angle\x3d"'+(90-180*Math.atan((H-c)/(f-e))/Math.PI)+'"',m();else{var h=H.r,t=2*h,J=2*h,A=H.cx,C=H.cy,E=b.radialReference,M,h=function(){E&&(M=d.getBBox(),A+=(E[0]-M.x)/M.width-.5,C+=(E[1]-M.y)/M.height-.5,t*=E[2]/M.width,J*=E[2]/M.height);B='src\x3d"'+a.getOptions().global.VMLRadialGradientURL+'" size\x3d"'+t+","+
	J+'" origin\x3d"0.5,0.5" position\x3d"'+A+","+C+'" color2\x3d"'+r+'" ';m()};d.added?h():d.onAdd=h;h=x}else h=w}else n.test(c)&&"IMG"!==b.tagName?(p=a.color(c),d[e+"-opacitySetter"](p.get("a"),e,b),h=p.get("rgb")):(h=b.getElementsByTagName(e),h.length&&(h[0].opacity=1,h[0].type="solid"),h=c);return h},prepVML:function(a){var c=this.isIE8;a=a.join("");c?(a=a.replace("/\x3e",' xmlns\x3d"urn:schemas-microsoft-com:vml" /\x3e'),a=-1===a.indexOf('style\x3d"')?a.replace("/\x3e",' style\x3d"display:inline-block;behavior:url(#default#VML);" /\x3e'):
	a.replace('style\x3d"','style\x3d"display:inline-block;behavior:url(#default#VML);')):a=a.replace("\x3c","\x3chcv:");return a},text:D.prototype.html,path:function(a){var c={coordsize:"10 10"};d(a)?c.d=a:b(a)&&g(c,a);return this.createElement("shape").attr(c)},circle:function(a,e,d){var c=this.symbol("circle");b(a)&&(d=a.r,e=a.y,a=a.x);c.isCircle=!0;c.r=d;return c.attr({x:a,y:e})},g:function(a){var c;a&&(c={className:"highcharts-"+a,"class":"highcharts-"+a});return this.createElement("div").attr(c)},
	image:function(a,b,e,d,n){var c=this.createElement("img").attr({src:a});1<arguments.length&&c.attr({x:b,y:e,width:d,height:n});return c},createElement:function(a){return"rect"===a?this.symbol(a):D.prototype.createElement.call(this,a)},invertChild:function(a,b){var c=this;b=b.style;var e="IMG"===a.tagName&&a.style;E(a,{flip:"x",left:y(b.width)-(e?y(e.top):1),top:y(b.height)-(e?y(e.left):1),rotation:-90});u(a.childNodes,function(b){c.invertChild(b,a)})},symbols:{arc:function(a,b,e,d,n){var c=n.start,
	q=n.end,g=n.r||e||d;e=n.innerR;d=Math.cos(c);var k=Math.sin(c),h=Math.cos(q),w=Math.sin(q);if(0===q-c)return["x"];c=["wa",a-g,b-g,a+g,b+g,a+g*d,b+g*k,a+g*h,b+g*w];n.open&&!e&&c.push("e","M",a,b);c.push("at",a-e,b-e,a+e,b+e,a+e*h,b+e*w,a+e*d,b+e*k,"x","e");c.isArc=!0;return c},circle:function(a,b,e,d,n){n&&m(n.r)&&(e=d=2*n.r);n&&n.isCircle&&(a-=e/2,b-=d/2);return["wa",a,b,a+e,b+d,a+e,b+d/2,a+e,b+d/2,"e"]},rect:function(a,b,e,d,n){return D.prototype.symbols[m(n)&&n.r?"callout":"square"].call(0,a,b,
	e,d,n)}}},a.VMLRenderer=C=function(){this.init.apply(this,arguments)},C.prototype=e(D.prototype,A),a.Renderer=C);D.prototype.measureSpanWidth=function(a,b){var c=r.createElement("span");a=r.createTextNode(a);c.appendChild(a);E(c,b);this.box.appendChild(c);b=c.offsetWidth;l(c);return b}})(M);(function(a){function C(){var f=a.defaultOptions.global,l=r.moment;if(f.timezone){if(l)return function(a){return-l.tz(a,f.timezone).utcOffset()};a.error(25)}return f.useUTC&&f.getTimezoneOffset}function A(){var f=
	a.defaultOptions.global,t,g=f.useUTC,d=g?"getUTC":"get",k=g?"setUTC":"set";a.Date=t=f.Date||r.Date;t.hcTimezoneOffset=g&&f.timezoneOffset;t.hcGetTimezoneOffset=C();t.hcMakeTime=function(a,e,d,k,n,f){var b;g?(b=t.UTC.apply(0,arguments),b+=m(b)):b=(new t(a,e,l(d,1),l(k,0),l(n,0),l(f,0))).getTime();return b};E("Minutes Hours Day Date Month FullYear".split(" "),function(a){t["hcGet"+a]=d+a});E("Milliseconds Seconds Minutes Hours Date Month FullYear".split(" "),function(a){t["hcSet"+a]=k+a})}var F=a.color,
	E=a.each,m=a.getTZOffset,f=a.merge,l=a.pick,r=a.win;a.defaultOptions={colors:"#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1".split(" "),symbols:["circle","diamond","square","triangle","triangle-down"],lang:{loading:"Loading...",months:"January February March April May June July August September October November December".split(" "),shortMonths:"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),weekdays:"Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
	decimalPoint:".",numericSymbols:"kMGTPE".split(""),resetZoom:"Reset zoom",resetZoomTitle:"Reset zoom level 1:1",thousandsSep:" "},global:{useUTC:!0,VMLRadialGradientURL:"http://code.highcharts.com/5.0.14/gfx/vml-radial-gradient.png"},chart:{borderRadius:0,defaultSeriesType:"line",ignoreHiddenSeries:!0,spacing:[10,10,15,10],resetZoomButton:{theme:{zIndex:20},position:{align:"right",x:-10,y:10}},width:null,height:null,borderColor:"#335cad",backgroundColor:"#ffffff",plotBorderColor:"#cccccc"},title:{text:"Chart title",
	align:"center",margin:15,widthAdjust:-44},subtitle:{text:"",align:"center",widthAdjust:-44},plotOptions:{},labels:{style:{position:"absolute",color:"#333333"}},legend:{enabled:!0,align:"center",layout:"horizontal",labelFormatter:function(){return this.name},borderColor:"#999999",borderRadius:0,navigation:{activeColor:"#003399",inactiveColor:"#cccccc"},itemStyle:{color:"#333333",fontSize:"12px",fontWeight:"bold",textOverflow:"ellipsis"},itemHoverStyle:{color:"#000000"},itemHiddenStyle:{color:"#cccccc"},
	shadow:!1,itemCheckboxStyle:{position:"absolute",width:"13px",height:"13px"},squareSymbol:!0,symbolPadding:5,verticalAlign:"bottom",x:0,y:0,title:{style:{fontWeight:"bold"}}},loading:{labelStyle:{fontWeight:"bold",position:"relative",top:"45%"},style:{position:"absolute",backgroundColor:"#ffffff",opacity:.5,textAlign:"center"}},tooltip:{enabled:!0,animation:a.svg,borderRadius:3,dateTimeLabelFormats:{millisecond:"%A, %b %e, %H:%M:%S.%L",second:"%A, %b %e, %H:%M:%S",minute:"%A, %b %e, %H:%M",hour:"%A, %b %e, %H:%M",
	day:"%A, %b %e, %Y",week:"Week from %A, %b %e, %Y",month:"%B %Y",year:"%Y"},footerFormat:"",padding:8,snap:a.isTouchDevice?25:10,backgroundColor:F("#f7f7f7").setOpacity(.85).get(),borderWidth:1,headerFormat:'\x3cspan style\x3d"font-size: 10px"\x3e{point.key}\x3c/span\x3e\x3cbr/\x3e',pointFormat:'\x3cspan style\x3d"color:{point.color}"\x3e\u25cf\x3c/span\x3e {series.name}: \x3cb\x3e{point.y}\x3c/b\x3e\x3cbr/\x3e',shadow:!0,style:{color:"#333333",cursor:"default",fontSize:"12px",pointerEvents:"none",
	whiteSpace:"nowrap"}},credits:{enabled:!0,href:"http://www.highcharts.com",position:{align:"right",x:-10,verticalAlign:"bottom",y:-5},style:{cursor:"pointer",color:"#999999",fontSize:"9px"},text:"Highcharts.com"}};a.setOptions=function(r){a.defaultOptions=f(!0,a.defaultOptions,r);A();return a.defaultOptions};a.getOptions=function(){return a.defaultOptions};a.defaultPlotOptions=a.defaultOptions.plotOptions;A()})(M);(function(a){var C=a.correctFloat,A=a.defined,F=a.destroyObjectProperties,E=a.isNumber,
	m=a.merge,f=a.pick,l=a.deg2rad;a.Tick=function(a,f,l,g){this.axis=a;this.pos=f;this.type=l||"";this.isNewLabel=this.isNew=!0;l||g||this.addLabel()};a.Tick.prototype={addLabel:function(){var a=this.axis,l=a.options,t=a.chart,g=a.categories,d=a.names,k=this.pos,b=l.labels,e=a.tickPositions,v=k===e[0],y=k===e[e.length-1],d=g?f(g[k],d[k],k):k,g=this.label,e=e.info,n;a.isDatetimeAxis&&e&&(n=l.dateTimeLabelFormats[e.higherRanks[k]||e.unitName]);this.isFirst=v;this.isLast=y;l=a.labelFormatter.call({axis:a,
	chart:t,isFirst:v,isLast:y,dateTimeLabelFormat:n,value:a.isLog?C(a.lin2log(d)):d,pos:k});A(g)?g&&g.attr({text:l}):(this.labelLength=(this.label=g=A(l)&&b.enabled?t.renderer.text(l,0,0,b.useHTML).css(m(b.style)).add(a.labelGroup):null)&&g.getBBox().width,this.rotation=0)},getLabelSize:function(){return this.label?this.label.getBBox()[this.axis.horiz?"height":"width"]:0},handleOverflow:function(a){var r=this.axis,m=a.x,g=r.chart.chartWidth,d=r.chart.spacing,k=f(r.labelLeft,Math.min(r.pos,d[3])),d=f(r.labelRight,
	Math.max(r.pos+r.len,g-d[1])),b=this.label,e=this.rotation,v={left:0,center:.5,right:1}[r.labelAlign],y=b.getBBox().width,n=r.getSlotWidth(),D=n,J=1,c,G={};if(e)0>e&&m-v*y<k?c=Math.round(m/Math.cos(e*l)-k):0<e&&m+v*y>d&&(c=Math.round((g-m)/Math.cos(e*l)));else if(g=m+(1-v)*y,m-v*y<k?D=a.x+D*(1-v)-k:g>d&&(D=d-a.x+D*v,J=-1),D=Math.min(n,D),D<n&&"center"===r.labelAlign&&(a.x+=J*(n-D-v*(n-Math.min(y,D)))),y>D||r.autoRotation&&(b.styles||{}).width)c=D;c&&(G.width=c,(r.options.labels.style||{}).textOverflow||
	(G.textOverflow="ellipsis"),b.css(G))},getPosition:function(a,f,l,g){var d=this.axis,k=d.chart,b=g&&k.oldChartHeight||k.chartHeight;return{x:a?d.translate(f+l,null,null,g)+d.transB:d.left+d.offset+(d.opposite?(g&&k.oldChartWidth||k.chartWidth)-d.right-d.left:0),y:a?b-d.bottom+d.offset-(d.opposite?d.height:0):b-d.translate(f+l,null,null,g)-d.transB}},getLabelPosition:function(a,f,m,g,d,k,b,e){var v=this.axis,y=v.transA,n=v.reversed,D=v.staggerLines,r=v.tickRotCorr||{x:0,y:0},c=d.y;A(c)||(c=0===v.side?
	m.rotation?-8:-m.getBBox().height:2===v.side?r.y+8:Math.cos(m.rotation*l)*(r.y-m.getBBox(!1,0).height/2));a=a+d.x+r.x-(k&&g?k*y*(n?-1:1):0);f=f+c-(k&&!g?k*y*(n?1:-1):0);D&&(m=b/(e||1)%D,v.opposite&&(m=D-m-1),f+=v.labelOffset/D*m);return{x:a,y:Math.round(f)}},getMarkPath:function(a,f,l,g,d,k){return k.crispLine(["M",a,f,"L",a+(d?0:-l),f+(d?l:0)],g)},renderGridLine:function(a,f,l){var g=this.axis,d=g.options,k=this.gridLine,b={},e=this.pos,v=this.type,y=g.tickmarkOffset,n=g.chart.renderer,D=v?v+"Grid":
	"grid",r=d[D+"LineWidth"],c=d[D+"LineColor"],d=d[D+"LineDashStyle"];k||(b.stroke=c,b["stroke-width"]=r,d&&(b.dashstyle=d),v||(b.zIndex=1),a&&(b.opacity=0),this.gridLine=k=n.path().attr(b).addClass("highcharts-"+(v?v+"-":"")+"grid-line").add(g.gridGroup));if(!a&&k&&(a=g.getPlotLinePath(e+y,k.strokeWidth()*l,a,!0)))k[this.isNew?"attr":"animate"]({d:a,opacity:f})},renderMark:function(a,l,m){var g=this.axis,d=g.options,k=g.chart.renderer,b=this.type,e=b?b+"Tick":"tick",v=g.tickSize(e),y=this.mark,n=!y,
	D=a.x;a=a.y;var r=f(d[e+"Width"],!b&&g.isXAxis?1:0),d=d[e+"Color"];v&&(g.opposite&&(v[0]=-v[0]),n&&(this.mark=y=k.path().addClass("highcharts-"+(b?b+"-":"")+"tick").add(g.axisGroup),y.attr({stroke:d,"stroke-width":r})),y[n?"attr":"animate"]({d:this.getMarkPath(D,a,v[0],y.strokeWidth()*m,g.horiz,k),opacity:l}))},renderLabel:function(a,l,m,g){var d=this.axis,k=d.horiz,b=d.options,e=this.label,v=b.labels,y=v.step,n=d.tickmarkOffset,D=!0,r=a.x;a=a.y;e&&E(r)&&(e.xy=a=this.getLabelPosition(r,a,e,k,v,n,
	g,y),this.isFirst&&!this.isLast&&!f(b.showFirstLabel,1)||this.isLast&&!this.isFirst&&!f(b.showLastLabel,1)?D=!1:!k||d.isRadial||v.step||v.rotation||l||0===m||this.handleOverflow(a),y&&g%y&&(D=!1),D&&E(a.y)?(a.opacity=m,e[this.isNewLabel?"attr":"animate"](a),this.isNewLabel=!1):(e.attr("y",-9999),this.isNewLabel=!0),this.isNew=!1)},render:function(a,l,m){var g=this.axis,d=g.horiz,k=this.getPosition(d,this.pos,g.tickmarkOffset,l),b=k.x,e=k.y,g=d&&b===g.pos+g.len||!d&&e===g.pos?-1:1;m=f(m,1);this.isActive=
	!0;this.renderGridLine(l,m,g);this.renderMark(k,m,g);this.renderLabel(k,l,m,a)},destroy:function(){F(this,this.axis)}}})(M);var S=function(a){var C=a.addEvent,A=a.animObject,F=a.arrayMax,E=a.arrayMin,m=a.color,f=a.correctFloat,l=a.defaultOptions,r=a.defined,u=a.deg2rad,t=a.destroyObjectProperties,g=a.each,d=a.extend,k=a.fireEvent,b=a.format,e=a.getMagnitude,v=a.grep,y=a.inArray,n=a.isArray,D=a.isNumber,J=a.isString,c=a.merge,G=a.normalizeTickInterval,q=a.objectEach,B=a.pick,K=a.removeEvent,p=a.splat,
	z=a.syncTimeout,I=a.Tick,L=function(){this.init.apply(this,arguments)};a.extend(L.prototype,{defaultOptions:{dateTimeLabelFormats:{millisecond:"%H:%M:%S.%L",second:"%H:%M:%S",minute:"%H:%M",hour:"%H:%M",day:"%e. %b",week:"%e. %b",month:"%b '%y",year:"%Y"},endOnTick:!1,labels:{enabled:!0,style:{color:"#666666",cursor:"default",fontSize:"11px"},x:0},minPadding:.01,maxPadding:.01,minorTickLength:2,minorTickPosition:"outside",startOfWeek:1,startOnTick:!1,tickLength:10,tickmarkPlacement:"between",tickPixelInterval:100,
	tickPosition:"outside",title:{align:"middle",style:{color:"#666666"}},type:"linear",minorGridLineColor:"#f2f2f2",minorGridLineWidth:1,minorTickColor:"#999999",lineColor:"#ccd6eb",lineWidth:1,gridLineColor:"#e6e6e6",tickColor:"#ccd6eb"},defaultYAxisOptions:{endOnTick:!0,tickPixelInterval:72,showLastLabel:!0,labels:{x:-8},maxPadding:.05,minPadding:.05,startOnTick:!0,title:{rotation:270,text:"Values"},stackLabels:{allowOverlap:!1,enabled:!1,formatter:function(){return a.numberFormat(this.total,-1)},
	style:{fontSize:"11px",fontWeight:"bold",color:"#000000",textOutline:"1px contrast"}},gridLineWidth:1,lineWidth:0},defaultLeftAxisOptions:{labels:{x:-15},title:{rotation:270}},defaultRightAxisOptions:{labels:{x:15},title:{rotation:90}},defaultBottomAxisOptions:{labels:{autoRotation:[-45],x:0},title:{rotation:0}},defaultTopAxisOptions:{labels:{autoRotation:[-45],x:0},title:{rotation:0}},init:function(a,c){var h=c.isX,b=this;b.chart=a;b.horiz=a.inverted&&!b.isZAxis?!h:h;b.isXAxis=h;b.coll=b.coll||(h?
	"xAxis":"yAxis");b.opposite=c.opposite;b.side=c.side||(b.horiz?b.opposite?0:2:b.opposite?1:3);b.setOptions(c);var w=this.options,e=w.type;b.labelFormatter=w.labels.formatter||b.defaultLabelFormatter;b.userOptions=c;b.minPixelPadding=0;b.reversed=w.reversed;b.visible=!1!==w.visible;b.zoomEnabled=!1!==w.zoomEnabled;b.hasNames="category"===e||!0===w.categories;b.categories=w.categories||b.hasNames;b.names=b.names||[];b.plotLinesAndBandsGroups={};b.isLog="logarithmic"===e;b.isDatetimeAxis="datetime"===
	e;b.positiveValuesOnly=b.isLog&&!b.allowNegativeLog;b.isLinked=r(w.linkedTo);b.ticks={};b.labelEdge=[];b.minorTicks={};b.plotLinesAndBands=[];b.alternateBands={};b.len=0;b.minRange=b.userMinRange=w.minRange||w.maxZoom;b.range=w.range;b.offset=w.offset||0;b.stacks={};b.oldStacks={};b.stacksTouched=0;b.max=null;b.min=null;b.crosshair=B(w.crosshair,p(a.options.tooltip.crosshairs)[h?0:1],!1);c=b.options.events;-1===y(b,a.axes)&&(h?a.axes.splice(a.xAxis.length,0,b):a.axes.push(b),a[b.coll].push(b));b.series=
	b.series||[];a.inverted&&!b.isZAxis&&h&&void 0===b.reversed&&(b.reversed=!0);q(c,function(a,h){C(b,h,a)});b.lin2log=w.linearToLogConverter||b.lin2log;b.isLog&&(b.val2lin=b.log2lin,b.lin2val=b.lin2log)},setOptions:function(a){this.options=c(this.defaultOptions,"yAxis"===this.coll&&this.defaultYAxisOptions,[this.defaultTopAxisOptions,this.defaultRightAxisOptions,this.defaultBottomAxisOptions,this.defaultLeftAxisOptions][this.side],c(l[this.coll],a))},defaultLabelFormatter:function(){var h=this.axis,
	c=this.value,e=h.categories,p=this.dateTimeLabelFormat,d=l.lang,n=d.numericSymbols,d=d.numericSymbolMagnitude||1E3,q=n&&n.length,x,g=h.options.labels.format,h=h.isLog?Math.abs(c):h.tickInterval;if(g)x=b(g,this);else if(e)x=c;else if(p)x=a.dateFormat(p,c);else if(q&&1E3<=h)for(;q--&&void 0===x;)e=Math.pow(d,q+1),h>=e&&0===10*c%e&&null!==n[q]&&0!==c&&(x=a.numberFormat(c/e,-1)+n[q]);void 0===x&&(x=1E4<=Math.abs(c)?a.numberFormat(c,-1):a.numberFormat(c,-1,void 0,""));return x},getSeriesExtremes:function(){var a=
	this,b=a.chart;a.hasVisibleSeries=!1;a.dataMin=a.dataMax=a.threshold=null;a.softThreshold=!a.isXAxis;a.buildStacks&&a.buildStacks();g(a.series,function(h){if(h.visible||!b.options.chart.ignoreHiddenSeries){var c=h.options,w=c.threshold,e;a.hasVisibleSeries=!0;a.positiveValuesOnly&&0>=w&&(w=null);if(a.isXAxis)c=h.xData,c.length&&(h=E(c),D(h)||h instanceof Date||(c=v(c,function(a){return D(a)}),h=E(c)),a.dataMin=Math.min(B(a.dataMin,c[0]),h),a.dataMax=Math.max(B(a.dataMax,c[0]),F(c)));else if(h.getExtremes(),
	e=h.dataMax,h=h.dataMin,r(h)&&r(e)&&(a.dataMin=Math.min(B(a.dataMin,h),h),a.dataMax=Math.max(B(a.dataMax,e),e)),r(w)&&(a.threshold=w),!c.softThreshold||a.positiveValuesOnly)a.softThreshold=!1}})},translate:function(a,b,c,e,p,d){var h=this.linkedParent||this,w=1,n=0,q=e?h.oldTransA:h.transA;e=e?h.oldMin:h.min;var g=h.minPixelPadding;p=(h.isOrdinal||h.isBroken||h.isLog&&p)&&h.lin2val;q||(q=h.transA);c&&(w*=-1,n=h.len);h.reversed&&(w*=-1,n-=w*(h.sector||h.len));b?(a=(a*w+n-g)/q+e,p&&(a=h.lin2val(a))):
	(p&&(a=h.val2lin(a)),a=w*(a-e)*q+n+w*g+(D(d)?q*d:0));return a},toPixels:function(a,b){return this.translate(a,!1,!this.horiz,null,!0)+(b?0:this.pos)},toValue:function(a,b){return this.translate(a-(b?0:this.pos),!0,!this.horiz,null,!0)},getPlotLinePath:function(a,b,c,e,p){var h=this.chart,w=this.left,d=this.top,n,q,g=c&&h.oldChartHeight||h.chartHeight,k=c&&h.oldChartWidth||h.chartWidth,f;n=this.transB;var v=function(a,h,b){if(a<h||a>b)e?a=Math.min(Math.max(h,a),b):f=!0;return a};p=B(p,this.translate(a,
	null,null,c));a=c=Math.round(p+n);n=q=Math.round(g-p-n);D(p)?this.horiz?(n=d,q=g-this.bottom,a=c=v(a,w,w+this.width)):(a=w,c=k-this.right,n=q=v(n,d,d+this.height)):f=!0;return f&&!e?null:h.renderer.crispLine(["M",a,n,"L",c,q],b||1)},getLinearTickPositions:function(a,b,c){var h,w=f(Math.floor(b/a)*a);c=f(Math.ceil(c/a)*a);var e=[];if(this.single)return[b];for(b=w;b<=c;){e.push(b);b=f(b+a);if(b===h)break;h=b}return e},getMinorTickPositions:function(){var a=this,b=a.options,c=a.tickPositions,e=a.minorTickInterval,
	p=[],d=a.pointRangePadding||0,n=a.min-d,d=a.max+d,q=d-n;if(q&&q/e<a.len/3)if(a.isLog)g(this.paddedTicks,function(h,b,c){b&&p.push.apply(p,a.getLogTickPositions(e,c[b-1],c[b],!0))});else if(a.isDatetimeAxis&&"auto"===b.minorTickInterval)p=p.concat(a.getTimeTicks(a.normalizeTimeTickInterval(e),n,d,b.startOfWeek));else for(b=n+(c[0]-n)%e;b<=d&&b!==p[0];b+=e)p.push(b);0!==p.length&&a.trimTicks(p);return p},adjustForMinRange:function(){var a=this.options,b=this.min,c=this.max,e,p,d,n,q,k,f,v;this.isXAxis&&
	void 0===this.minRange&&!this.isLog&&(r(a.min)||r(a.max)?this.minRange=null:(g(this.series,function(a){k=a.xData;for(n=f=a.xIncrement?1:k.length-1;0<n;n--)if(q=k[n]-k[n-1],void 0===d||q<d)d=q}),this.minRange=Math.min(5*d,this.dataMax-this.dataMin)));c-b<this.minRange&&(p=this.dataMax-this.dataMin>=this.minRange,v=this.minRange,e=(v-c+b)/2,e=[b-e,B(a.min,b-e)],p&&(e[2]=this.isLog?this.log2lin(this.dataMin):this.dataMin),b=F(e),c=[b+v,B(a.max,b+v)],p&&(c[2]=this.isLog?this.log2lin(this.dataMax):this.dataMax),
	c=E(c),c-b<v&&(e[0]=c-v,e[1]=B(a.min,c-v),b=F(e)));this.min=b;this.max=c},getClosest:function(){var a;this.categories?a=1:g(this.series,function(h){var b=h.closestPointRange,c=h.visible||!h.chart.options.chart.ignoreHiddenSeries;!h.noSharedTooltip&&r(b)&&c&&(a=r(a)?Math.min(a,b):b)});return a},nameToX:function(a){var h=n(this.categories),b=h?this.categories:this.names,c=a.options.x,e;a.series.requireSorting=!1;r(c)||(c=!1===this.options.uniqueNames?a.series.autoIncrement():y(a.name,b));-1===c?h||
	(e=b.length):e=c;void 0!==e&&(this.names[e]=a.name);return e},updateNames:function(){var a=this;0<this.names.length&&(this.names.length=0,this.minRange=this.userMinRange,g(this.series||[],function(h){h.xIncrement=null;if(!h.points||h.isDirtyData)h.processData(),h.generatePoints();g(h.points,function(b,c){var e;b.options&&(e=a.nameToX(b),void 0!==e&&e!==b.x&&(b.x=e,h.xData[c]=e))})}))},setAxisTranslation:function(a){var h=this,b=h.max-h.min,c=h.axisPointRange||0,e,p=0,d=0,n=h.linkedParent,q=!!h.categories,
	k=h.transA,f=h.isXAxis;if(f||q||c)e=h.getClosest(),n?(p=n.minPointOffset,d=n.pointRangePadding):g(h.series,function(a){var b=q?1:f?B(a.options.pointRange,e,0):h.axisPointRange||0;a=a.options.pointPlacement;c=Math.max(c,b);h.single||(p=Math.max(p,J(a)?0:b/2),d=Math.max(d,"on"===a?0:b))}),n=h.ordinalSlope&&e?h.ordinalSlope/e:1,h.minPointOffset=p*=n,h.pointRangePadding=d*=n,h.pointRange=Math.min(c,b),f&&(h.closestPointRange=e);a&&(h.oldTransA=k);h.translationSlope=h.transA=k=h.options.staticScale||h.len/
	(b+d||1);h.transB=h.horiz?h.left:h.bottom;h.minPixelPadding=k*p},minFromRange:function(){return this.max-this.range},setTickInterval:function(h){var b=this,c=b.chart,p=b.options,d=b.isLog,n=b.log2lin,q=b.isDatetimeAxis,x=b.isXAxis,v=b.isLinked,z=p.maxPadding,y=p.minPadding,l=p.tickInterval,I=p.tickPixelInterval,m=b.categories,J=b.threshold,t=b.softThreshold,L,u,K,A;q||m||v||this.getTickAmount();K=B(b.userMin,p.min);A=B(b.userMax,p.max);v?(b.linkedParent=c[b.coll][p.linkedTo],c=b.linkedParent.getExtremes(),
	b.min=B(c.min,c.dataMin),b.max=B(c.max,c.dataMax),p.type!==b.linkedParent.options.type&&a.error(11,1)):(!t&&r(J)&&(b.dataMin>=J?(L=J,y=0):b.dataMax<=J&&(u=J,z=0)),b.min=B(K,L,b.dataMin),b.max=B(A,u,b.dataMax));d&&(b.positiveValuesOnly&&!h&&0>=Math.min(b.min,B(b.dataMin,b.min))&&a.error(10,1),b.min=f(n(b.min),15),b.max=f(n(b.max),15));b.range&&r(b.max)&&(b.userMin=b.min=K=Math.max(b.dataMin,b.minFromRange()),b.userMax=A=b.max,b.range=null);k(b,"foundExtremes");b.beforePadding&&b.beforePadding();b.adjustForMinRange();
	!(m||b.axisPointRange||b.usePercentage||v)&&r(b.min)&&r(b.max)&&(n=b.max-b.min)&&(!r(K)&&y&&(b.min-=n*y),!r(A)&&z&&(b.max+=n*z));D(p.softMin)&&(b.min=Math.min(b.min,p.softMin));D(p.softMax)&&(b.max=Math.max(b.max,p.softMax));D(p.floor)&&(b.min=Math.max(b.min,p.floor));D(p.ceiling)&&(b.max=Math.min(b.max,p.ceiling));t&&r(b.dataMin)&&(J=J||0,!r(K)&&b.min<J&&b.dataMin>=J?b.min=J:!r(A)&&b.max>J&&b.dataMax<=J&&(b.max=J));b.tickInterval=b.min===b.max||void 0===b.min||void 0===b.max?1:v&&!l&&I===b.linkedParent.options.tickPixelInterval?
	l=b.linkedParent.tickInterval:B(l,this.tickAmount?(b.max-b.min)/Math.max(this.tickAmount-1,1):void 0,m?1:(b.max-b.min)*I/Math.max(b.len,I));x&&!h&&g(b.series,function(a){a.processData(b.min!==b.oldMin||b.max!==b.oldMax)});b.setAxisTranslation(!0);b.beforeSetTickPositions&&b.beforeSetTickPositions();b.postProcessTickInterval&&(b.tickInterval=b.postProcessTickInterval(b.tickInterval));b.pointRange&&!l&&(b.tickInterval=Math.max(b.pointRange,b.tickInterval));h=B(p.minTickInterval,b.isDatetimeAxis&&b.closestPointRange);
	!l&&b.tickInterval<h&&(b.tickInterval=h);q||d||l||(b.tickInterval=G(b.tickInterval,null,e(b.tickInterval),B(p.allowDecimals,!(.5<b.tickInterval&&5>b.tickInterval&&1E3<b.max&&9999>b.max)),!!this.tickAmount));this.tickAmount||(b.tickInterval=b.unsquish());this.setTickPositions()},setTickPositions:function(){var a=this.options,b,c=a.tickPositions,e=a.tickPositioner,p=a.startOnTick,d=a.endOnTick;this.tickmarkOffset=this.categories&&"between"===a.tickmarkPlacement&&1===this.tickInterval?.5:0;this.minorTickInterval=
	"auto"===a.minorTickInterval&&this.tickInterval?this.tickInterval/5:a.minorTickInterval;this.single=this.min===this.max&&r(this.min)&&!this.tickAmount&&(parseInt(this.min,10)===this.min||!1!==a.allowDecimals);this.tickPositions=b=c&&c.slice();!b&&(b=this.isDatetimeAxis?this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval,a.units),this.min,this.max,a.startOfWeek,this.ordinalPositions,this.closestPointRange,!0):this.isLog?this.getLogTickPositions(this.tickInterval,this.min,this.max):this.getLinearTickPositions(this.tickInterval,
	this.min,this.max),b.length>this.len&&(b=[b[0],b.pop()]),this.tickPositions=b,e&&(e=e.apply(this,[this.min,this.max])))&&(this.tickPositions=b=e);this.paddedTicks=b.slice(0);this.trimTicks(b,p,d);this.isLinked||(this.single&&2>b.length&&(this.min-=.5,this.max+=.5),c||e||this.adjustTickAmount())},trimTicks:function(a,b,c){var h=a[0],e=a[a.length-1],p=this.minPointOffset||0;if(!this.isLinked){if(b&&-Infinity!==h)this.min=h;else for(;this.min-p>a[0];)a.shift();if(c)this.max=e;else for(;this.max+p<a[a.length-
	1];)a.pop();0===a.length&&r(h)&&a.push((e+h)/2)}},alignToOthers:function(){var a={},b,c=this.options;!1===this.chart.options.chart.alignTicks||!1===c.alignTicks||this.isLog||g(this.chart[this.coll],function(h){var c=h.options,c=[h.horiz?c.left:c.top,c.width,c.height,c.pane].join();h.series.length&&(a[c]?b=!0:a[c]=1)});return b},getTickAmount:function(){var a=this.options,b=a.tickAmount,c=a.tickPixelInterval;!r(a.tickInterval)&&this.len<c&&!this.isRadial&&!this.isLog&&a.startOnTick&&a.endOnTick&&(b=
	2);!b&&this.alignToOthers()&&(b=Math.ceil(this.len/c)+1);4>b&&(this.finalTickAmt=b,b=5);this.tickAmount=b},adjustTickAmount:function(){var a=this.tickInterval,b=this.tickPositions,c=this.tickAmount,e=this.finalTickAmt,p=b&&b.length;if(p<c){for(;b.length<c;)b.push(f(b[b.length-1]+a));this.transA*=(p-1)/(c-1);this.max=b[b.length-1]}else p>c&&(this.tickInterval*=2,this.setTickPositions());if(r(e)){for(a=c=b.length;a--;)(3===e&&1===a%2||2>=e&&0<a&&a<c-1)&&b.splice(a,1);this.finalTickAmt=void 0}},setScale:function(){var a,
	b;this.oldMin=this.min;this.oldMax=this.max;this.oldAxisLength=this.len;this.setAxisSize();b=this.len!==this.oldAxisLength;g(this.series,function(b){if(b.isDirtyData||b.isDirty||b.xAxis.isDirty)a=!0});b||a||this.isLinked||this.forceRedraw||this.userMin!==this.oldUserMin||this.userMax!==this.oldUserMax||this.alignToOthers()?(this.resetStacks&&this.resetStacks(),this.forceRedraw=!1,this.getSeriesExtremes(),this.setTickInterval(),this.oldUserMin=this.userMin,this.oldUserMax=this.userMax,this.isDirty||
	(this.isDirty=b||this.min!==this.oldMin||this.max!==this.oldMax)):this.cleanStacks&&this.cleanStacks()},setExtremes:function(a,b,c,e,p){var h=this,n=h.chart;c=B(c,!0);g(h.series,function(a){delete a.kdTree});p=d(p,{min:a,max:b});k(h,"setExtremes",p,function(){h.userMin=a;h.userMax=b;h.eventArgs=p;c&&n.redraw(e)})},zoom:function(a,b){var h=this.dataMin,c=this.dataMax,e=this.options,p=Math.min(h,B(e.min,h)),e=Math.max(c,B(e.max,c));if(a!==this.min||b!==this.max)this.allowZoomOutside||(r(h)&&(a<p&&(a=
	p),a>e&&(a=e)),r(c)&&(b<p&&(b=p),b>e&&(b=e))),this.displayBtn=void 0!==a||void 0!==b,this.setExtremes(a,b,!1,void 0,{trigger:"zoom"});return!0},setAxisSize:function(){var b=this.chart,c=this.options,e=c.offsets||[0,0,0,0],p=this.horiz,d=this.width=Math.round(a.relativeLength(B(c.width,b.plotWidth-e[3]+e[1]),b.plotWidth)),n=this.height=Math.round(a.relativeLength(B(c.height,b.plotHeight-e[0]+e[2]),b.plotHeight)),q=this.top=Math.round(a.relativeLength(B(c.top,b.plotTop+e[0]),b.plotHeight,b.plotTop)),
	c=this.left=Math.round(a.relativeLength(B(c.left,b.plotLeft+e[3]),b.plotWidth,b.plotLeft));this.bottom=b.chartHeight-n-q;this.right=b.chartWidth-d-c;this.len=Math.max(p?d:n,0);this.pos=p?c:q},getExtremes:function(){var a=this.isLog,b=this.lin2log;return{min:a?f(b(this.min)):this.min,max:a?f(b(this.max)):this.max,dataMin:this.dataMin,dataMax:this.dataMax,userMin:this.userMin,userMax:this.userMax}},getThreshold:function(a){var b=this.isLog,h=this.lin2log,c=b?h(this.min):this.min,b=b?h(this.max):this.max;
	null===a?a=c:c>a?a=c:b<a&&(a=b);return this.translate(a,0,1,0,1)},autoLabelAlign:function(a){a=(B(a,0)-90*this.side+720)%360;return 15<a&&165>a?"right":195<a&&345>a?"left":"center"},tickSize:function(a){var b=this.options,h=b[a+"Length"],c=B(b[a+"Width"],"tick"===a&&this.isXAxis?1:0);if(c&&h)return"inside"===b[a+"Position"]&&(h=-h),[h,c]},labelMetrics:function(){var a=this.tickPositions&&this.tickPositions[0]||0;return this.chart.renderer.fontMetrics(this.options.labels.style&&this.options.labels.style.fontSize,
	this.ticks[a]&&this.ticks[a].label)},unsquish:function(){var a=this.options.labels,b=this.horiz,c=this.tickInterval,e=c,p=this.len/(((this.categories?1:0)+this.max-this.min)/c),d,n=a.rotation,q=this.labelMetrics(),k,f=Number.MAX_VALUE,v,z=function(a){a/=p||1;a=1<a?Math.ceil(a):1;return a*c};b?(v=!a.staggerLines&&!a.step&&(r(n)?[n]:p<B(a.autoRotationLimit,80)&&a.autoRotation))&&g(v,function(a){var b;if(a===n||a&&-90<=a&&90>=a)k=z(Math.abs(q.h/Math.sin(u*a))),b=k+Math.abs(a/360),b<f&&(f=b,d=a,e=k)}):
	a.step||(e=z(q.h));this.autoRotation=v;this.labelRotation=B(d,n);return e},getSlotWidth:function(){var a=this.chart,b=this.horiz,c=this.options.labels,e=Math.max(this.tickPositions.length-(this.categories?0:1),1),p=a.margin[3];return b&&2>(c.step||0)&&!c.rotation&&(this.staggerLines||1)*this.len/e||!b&&(p&&p-a.spacing[3]||.33*a.chartWidth)},renderUnsquish:function(){var a=this.chart,b=a.renderer,e=this.tickPositions,p=this.ticks,d=this.options.labels,n=this.horiz,q=this.getSlotWidth(),k=Math.max(1,
	Math.round(q-2*(d.padding||5))),f={},v=this.labelMetrics(),z=d.style&&d.style.textOverflow,D,y=0,l,I;J(d.rotation)||(f.rotation=d.rotation||0);g(e,function(a){(a=p[a])&&a.labelLength>y&&(y=a.labelLength)});this.maxLabelLength=y;if(this.autoRotation)y>k&&y>v.h?f.rotation=this.labelRotation:this.labelRotation=0;else if(q&&(D={width:k+"px"},!z))for(D.textOverflow="clip",l=e.length;!n&&l--;)if(I=e[l],k=p[I].label)k.styles&&"ellipsis"===k.styles.textOverflow?k.css({textOverflow:"clip"}):p[I].labelLength>
	q&&k.css({width:q+"px"}),k.getBBox().height>this.len/e.length-(v.h-v.f)&&(k.specCss={textOverflow:"ellipsis"});f.rotation&&(D={width:(y>.5*a.chartHeight?.33*a.chartHeight:a.chartHeight)+"px"},z||(D.textOverflow="ellipsis"));if(this.labelAlign=d.align||this.autoLabelAlign(this.labelRotation))f.align=this.labelAlign;g(e,function(a){var b=(a=p[a])&&a.label;b&&(b.attr(f),D&&b.css(c(D,b.specCss)),delete b.specCss,a.rotation=f.rotation)});this.tickRotCorr=b.rotCorr(v.b,this.labelRotation||0,0!==this.side)},
	hasData:function(){return this.hasVisibleSeries||r(this.min)&&r(this.max)&&!!this.tickPositions},addTitle:function(a){var b=this.chart.renderer,c=this.horiz,h=this.opposite,e=this.options.title,p;this.axisTitle||((p=e.textAlign)||(p=(c?{low:"left",middle:"center",high:"right"}:{low:h?"right":"left",middle:"center",high:h?"left":"right"})[e.align]),this.axisTitle=b.text(e.text,0,0,e.useHTML).attr({zIndex:7,rotation:e.rotation||0,align:p}).addClass("highcharts-axis-title").css(e.style).add(this.axisGroup),
	this.axisTitle.isNew=!0);e.style.width||this.isRadial||this.axisTitle.css({width:this.len});this.axisTitle[a?"show":"hide"](!0)},generateTick:function(a){var b=this.ticks;b[a]?b[a].addLabel():b[a]=new I(this,a)},getOffset:function(){var a=this,b=a.chart,c=b.renderer,e=a.options,p=a.tickPositions,d=a.ticks,n=a.horiz,k=a.side,f=b.inverted&&!a.isZAxis?[1,0,3,2][k]:k,v,z,D=0,y,l=0,I=e.title,m=e.labels,G=0,J=b.axisOffset,b=b.clipOffset,t=[-1,1,1,-1][k],L=e.className,u=a.axisParent,K=this.tickSize("tick");
	v=a.hasData();a.showAxis=z=v||B(e.showEmpty,!0);a.staggerLines=a.horiz&&m.staggerLines;a.axisGroup||(a.gridGroup=c.g("grid").attr({zIndex:e.gridZIndex||1}).addClass("highcharts-"+this.coll.toLowerCase()+"-grid "+(L||"")).add(u),a.axisGroup=c.g("axis").attr({zIndex:e.zIndex||2}).addClass("highcharts-"+this.coll.toLowerCase()+" "+(L||"")).add(u),a.labelGroup=c.g("axis-labels").attr({zIndex:m.zIndex||7}).addClass("highcharts-"+a.coll.toLowerCase()+"-labels "+(L||"")).add(u));v||a.isLinked?(g(p,function(b,
	c){a.generateTick(b,c)}),a.renderUnsquish(),!1===m.reserveSpace||0!==k&&2!==k&&{1:"left",3:"right"}[k]!==a.labelAlign&&"center"!==a.labelAlign||g(p,function(a){G=Math.max(d[a].getLabelSize(),G)}),a.staggerLines&&(G*=a.staggerLines,a.labelOffset=G*(a.opposite?-1:1))):q(d,function(a,b){a.destroy();delete d[b]});I&&I.text&&!1!==I.enabled&&(a.addTitle(z),z&&!1!==I.reserveSpace&&(a.titleOffset=D=a.axisTitle.getBBox()[n?"height":"width"],y=I.offset,l=r(y)?0:B(I.margin,n?5:10)));a.renderLine();a.offset=
	t*B(e.offset,J[k]);a.tickRotCorr=a.tickRotCorr||{x:0,y:0};c=0===k?-a.labelMetrics().h:2===k?a.tickRotCorr.y:0;l=Math.abs(G)+l;G&&(l=l-c+t*(n?B(m.y,a.tickRotCorr.y+8*t):m.x));a.axisTitleMargin=B(y,l);J[k]=Math.max(J[k],a.axisTitleMargin+D+t*a.offset,l,v&&p.length&&K?K[0]+t*a.offset:0);p=2*Math.floor(a.axisLine.strokeWidth()/2);0<e.offset&&(p-=2*e.offset);b[f]=Math.max(b[f]||p,p)},getLinePath:function(a){var b=this.chart,c=this.opposite,h=this.offset,e=this.horiz,p=this.left+(c?this.width:0)+h,h=b.chartHeight-
	this.bottom-(c?this.height:0)+h;c&&(a*=-1);return b.renderer.crispLine(["M",e?this.left:p,e?h:this.top,"L",e?b.chartWidth-this.right:p,e?h:b.chartHeight-this.bottom],a)},renderLine:function(){this.axisLine||(this.axisLine=this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup),this.axisLine.attr({stroke:this.options.lineColor,"stroke-width":this.options.lineWidth,zIndex:7}))},getTitlePosition:function(){var a=this.horiz,b=this.left,c=this.top,e=this.len,p=this.options.title,
	d=a?b:c,n=this.opposite,q=this.offset,k=p.x||0,g=p.y||0,f=this.axisTitle,v=this.chart.renderer.fontMetrics(p.style&&p.style.fontSize,f),f=Math.max(f.getBBox(null,0).height-v.h-1,0),e={low:d+(a?0:e),middle:d+e/2,high:d+(a?e:0)}[p.align],b=(a?c+this.height:b)+(a?1:-1)*(n?-1:1)*this.axisTitleMargin+[-f,f,v.f,-f][this.side];return{x:a?e+k:b+(n?this.width:0)+q+k,y:a?b+g-(n?this.height:0)+q:e+g}},renderMinorTick:function(a){var b=this.chart.hasRendered&&D(this.oldMin),c=this.minorTicks;c[a]||(c[a]=new I(this,
	a,"minor"));b&&c[a].isNew&&c[a].render(null,!0);c[a].render(null,!1,1)},renderTick:function(a,b){var c=this.isLinked,e=this.ticks,h=this.chart.hasRendered&&D(this.oldMin);if(!c||a>=this.min&&a<=this.max)e[a]||(e[a]=new I(this,a)),h&&e[a].isNew&&e[a].render(b,!0,.1),e[a].render(b)},render:function(){var b=this,c=b.chart,e=b.options,p=b.isLog,d=b.lin2log,n=b.isLinked,k=b.tickPositions,f=b.axisTitle,v=b.ticks,y=b.minorTicks,l=b.alternateBands,m=e.stackLabels,r=e.alternateGridColor,B=b.tickmarkOffset,
	G=b.axisLine,J=b.showAxis,t=A(c.renderer.globalAnimation),L,u;b.labelEdge.length=0;b.overlap=!1;g([v,y,l],function(a){q(a,function(a){a.isActive=!1})});if(b.hasData()||n)b.minorTickInterval&&!b.categories&&g(b.getMinorTickPositions(),function(a){b.renderMinorTick(a)}),k.length&&(g(k,function(a,c){b.renderTick(a,c)}),B&&(0===b.min||b.single)&&(v[-1]||(v[-1]=new I(b,-1,null,!0)),v[-1].render(-1))),r&&g(k,function(e,h){u=void 0!==k[h+1]?k[h+1]+B:b.max-B;0===h%2&&e<b.max&&u<=b.max+(c.polar?-B:B)&&(l[e]||
	(l[e]=new a.PlotLineOrBand(b)),L=e+B,l[e].options={from:p?d(L):L,to:p?d(u):u,color:r},l[e].render(),l[e].isActive=!0)}),b._addedPlotLB||(g((e.plotLines||[]).concat(e.plotBands||[]),function(a){b.addPlotBandOrLine(a)}),b._addedPlotLB=!0);g([v,y,l],function(a){var b,e=[],h=t.duration;q(a,function(a,b){a.isActive||(a.render(b,!1,0),a.isActive=!1,e.push(b))});z(function(){for(b=e.length;b--;)a[e[b]]&&!a[e[b]].isActive&&(a[e[b]].destroy(),delete a[e[b]])},a!==l&&c.hasRendered&&h?h:0)});G&&(G[G.isPlaced?
	"animate":"attr"]({d:this.getLinePath(G.strokeWidth())}),G.isPlaced=!0,G[J?"show":"hide"](!0));f&&J&&(e=b.getTitlePosition(),D(e.y)?(f[f.isNew?"attr":"animate"](e),f.isNew=!1):(f.attr("y",-9999),f.isNew=!0));m&&m.enabled&&b.renderStackTotals();b.isDirty=!1},redraw:function(){this.visible&&(this.render(),g(this.plotLinesAndBands,function(a){a.render()}));g(this.series,function(a){a.isDirty=!0})},keepProps:"extKey hcEvents names series userMax userMin".split(" "),destroy:function(a){var b=this,c=b.stacks,
	e=b.plotLinesAndBands,h;a||K(b);q(c,function(a,b){t(a);c[b]=null});g([b.ticks,b.minorTicks,b.alternateBands],function(a){t(a)});if(e)for(a=e.length;a--;)e[a].destroy();g("stackTotalGroup axisLine axisTitle axisGroup gridGroup labelGroup cross".split(" "),function(a){b[a]&&(b[a]=b[a].destroy())});for(h in b.plotLinesAndBandsGroups)b.plotLinesAndBandsGroups[h]=b.plotLinesAndBandsGroups[h].destroy();q(b,function(a,c){-1===y(c,b.keepProps)&&delete b[c]})},drawCrosshair:function(a,b){var c,e=this.crosshair,
	h=B(e.snap,!0),p,d=this.cross;a||(a=this.cross&&this.cross.e);this.crosshair&&!1!==(r(b)||!h)?(h?r(b)&&(p=this.isXAxis?b.plotX:this.len-b.plotY):p=a&&(this.horiz?a.chartX-this.pos:this.len-a.chartY+this.pos),r(p)&&(c=this.getPlotLinePath(b&&(this.isXAxis?b.x:B(b.stackY,b.y)),null,null,null,p)||null),r(c)?(b=this.categories&&!this.isRadial,d||(this.cross=d=this.chart.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-"+(b?"category ":"thin ")+e.className).attr({zIndex:B(e.zIndex,2)}).add(),
	d.attr({stroke:e.color||(b?m("#ccd6eb").setOpacity(.25).get():"#cccccc"),"stroke-width":B(e.width,1)}),e.dashStyle&&d.attr({dashstyle:e.dashStyle})),d.show().attr({d:c}),b&&!e.width&&d.attr({"stroke-width":this.transA}),this.cross.e=a):this.hideCrosshair()):this.hideCrosshair()},hideCrosshair:function(){this.cross&&this.cross.hide()}});return a.Axis=L}(M);(function(a){var C=a.Axis,A=a.Date,F=a.dateFormat,E=a.defaultOptions,m=a.defined,f=a.each,l=a.extend,r=a.getMagnitude,u=a.getTZOffset,t=a.normalizeTickInterval,
	g=a.pick,d=a.timeUnits;C.prototype.getTimeTicks=function(a,b,e,v){var k=[],n={},D=E.global.useUTC,r,c=new A(b-Math.max(u(b),u(e))),G=A.hcMakeTime,q=a.unitRange,B=a.count,t,p;if(m(b)){c[A.hcSetMilliseconds](q>=d.second?0:B*Math.floor(c.getMilliseconds()/B));if(q>=d.second)c[A.hcSetSeconds](q>=d.minute?0:B*Math.floor(c.getSeconds()/B));if(q>=d.minute)c[A.hcSetMinutes](q>=d.hour?0:B*Math.floor(c[A.hcGetMinutes]()/B));if(q>=d.hour)c[A.hcSetHours](q>=d.day?0:B*Math.floor(c[A.hcGetHours]()/B));if(q>=d.day)c[A.hcSetDate](q>=
	d.month?1:B*Math.floor(c[A.hcGetDate]()/B));q>=d.month&&(c[A.hcSetMonth](q>=d.year?0:B*Math.floor(c[A.hcGetMonth]()/B)),r=c[A.hcGetFullYear]());if(q>=d.year)c[A.hcSetFullYear](r-r%B);if(q===d.week)c[A.hcSetDate](c[A.hcGetDate]()-c[A.hcGetDay]()+g(v,1));r=c[A.hcGetFullYear]();v=c[A.hcGetMonth]();var z=c[A.hcGetDate](),I=c[A.hcGetHours]();if(A.hcTimezoneOffset||A.hcGetTimezoneOffset)p=(!D||!!A.hcGetTimezoneOffset)&&(e-b>4*d.month||u(b)!==u(e)),c=c.getTime(),t=u(c),c=new A(c+t);D=c.getTime();for(b=1;D<
	e;)k.push(D),D=q===d.year?G(r+b*B,0):q===d.month?G(r,v+b*B):!p||q!==d.day&&q!==d.week?p&&q===d.hour?G(r,v,z,I+b*B,0,0,t)-t:D+q*B:G(r,v,z+b*B*(q===d.day?1:7)),b++;k.push(D);q<=d.hour&&1E4>k.length&&f(k,function(a){0===a%18E5&&"000000000"===F("%H%M%S%L",a)&&(n[a]="day")})}k.info=l(a,{higherRanks:n,totalRange:q*B});return k};C.prototype.normalizeTimeTickInterval=function(a,b){var e=b||[["millisecond",[1,2,5,10,20,25,50,100,200,500]],["second",[1,2,5,10,15,30]],["minute",[1,2,5,10,15,30]],["hour",[1,
	2,3,4,6,8,12]],["day",[1,2]],["week",[1,2]],["month",[1,2,3,4,6]],["year",null]];b=e[e.length-1];var k=d[b[0]],g=b[1],n;for(n=0;n<e.length&&!(b=e[n],k=d[b[0]],g=b[1],e[n+1]&&a<=(k*g[g.length-1]+d[e[n+1][0]])/2);n++);k===d.year&&a<5*k&&(g=[1,2,5]);a=t(a/k,g,"year"===b[0]?Math.max(r(a/k),1):1);return{unitRange:k,count:a,unitName:b[0]}}})(M);(function(a){var C=a.Axis,A=a.getMagnitude,F=a.map,E=a.normalizeTickInterval,m=a.pick;C.prototype.getLogTickPositions=function(a,l,r,u){var f=this.options,g=this.len,
	d=this.lin2log,k=this.log2lin,b=[];u||(this._minorAutoInterval=null);if(.5<=a)a=Math.round(a),b=this.getLinearTickPositions(a,l,r);else if(.08<=a)for(var g=Math.floor(l),e,v,y,n,D,f=.3<a?[1,2,4]:.15<a?[1,2,4,6,8]:[1,2,3,4,5,6,7,8,9];g<r+1&&!D;g++)for(v=f.length,e=0;e<v&&!D;e++)y=k(d(g)*f[e]),y>l&&(!u||n<=r)&&void 0!==n&&b.push(n),n>r&&(D=!0),n=y;else l=d(l),r=d(r),a=f[u?"minorTickInterval":"tickInterval"],a=m("auto"===a?null:a,this._minorAutoInterval,f.tickPixelInterval/(u?5:1)*(r-l)/((u?g/this.tickPositions.length:
	g)||1)),a=E(a,null,A(a)),b=F(this.getLinearTickPositions(a,l,r),k),u||(this._minorAutoInterval=a/5);u||(this.tickInterval=a);return b};C.prototype.log2lin=function(a){return Math.log(a)/Math.LN10};C.prototype.lin2log=function(a){return Math.pow(10,a)}})(M);(function(a,C){var A=a.arrayMax,F=a.arrayMin,E=a.defined,m=a.destroyObjectProperties,f=a.each,l=a.erase,r=a.merge,u=a.pick;a.PlotLineOrBand=function(a,g){this.axis=a;g&&(this.options=g,this.id=g.id)};a.PlotLineOrBand.prototype={render:function(){var f=
	this,g=f.axis,d=g.horiz,k=f.options,b=k.label,e=f.label,v=k.to,l=k.from,n=k.value,D=E(l)&&E(v),m=E(n),c=f.svgElem,G=!c,q=[],B=k.color,K=u(k.zIndex,0),p=k.events,q={"class":"highcharts-plot-"+(D?"band ":"line ")+(k.className||"")},z={},I=g.chart.renderer,L=D?"bands":"lines",h=g.log2lin;g.isLog&&(l=h(l),v=h(v),n=h(n));m?(q={stroke:B,"stroke-width":k.width},k.dashStyle&&(q.dashstyle=k.dashStyle)):D&&(B&&(q.fill=B),k.borderWidth&&(q.stroke=k.borderColor,q["stroke-width"]=k.borderWidth));z.zIndex=K;L+=
	"-"+K;(B=g.plotLinesAndBandsGroups[L])||(g.plotLinesAndBandsGroups[L]=B=I.g("plot-"+L).attr(z).add());G&&(f.svgElem=c=I.path().attr(q).add(B));if(m)q=g.getPlotLinePath(n,c.strokeWidth());else if(D)q=g.getPlotBandPath(l,v,k);else return;G&&q&&q.length?(c.attr({d:q}),p&&a.objectEach(p,function(a,b){c.on(b,function(a){p[b].apply(f,[a])})})):c&&(q?(c.show(),c.animate({d:q})):(c.hide(),e&&(f.label=e=e.destroy())));b&&E(b.text)&&q&&q.length&&0<g.width&&0<g.height&&!q.flat?(b=r({align:d&&D&&"center",x:d?
	!D&&4:10,verticalAlign:!d&&D&&"middle",y:d?D?16:10:D?6:-4,rotation:d&&!D&&90},b),this.renderLabel(b,q,D,K)):e&&e.hide();return f},renderLabel:function(a,g,d,k){var b=this.label,e=this.axis.chart.renderer;b||(b={align:a.textAlign||a.align,rotation:a.rotation,"class":"highcharts-plot-"+(d?"band":"line")+"-label "+(a.className||"")},b.zIndex=k,this.label=b=e.text(a.text,0,0,a.useHTML).attr(b).add(),b.css(a.style));k=[g[1],g[4],d?g[6]:g[1]];g=[g[2],g[5],d?g[7]:g[2]];d=F(k);e=F(g);b.align(a,!1,{x:d,y:e,
	width:A(k)-d,height:A(g)-e});b.show()},destroy:function(){l(this.axis.plotLinesAndBands,this);delete this.axis;m(this)}};a.extend(C.prototype,{getPlotBandPath:function(a,g){var d=this.getPlotLinePath(g,null,null,!0),k=this.getPlotLinePath(a,null,null,!0),b=this.horiz,e=1;a=a<this.min&&g<this.min||a>this.max&&g>this.max;k&&d?(a&&(k.flat=k.toString()===d.toString(),e=0),k.push(b&&d[4]===k[4]?d[4]+e:d[4],b||d[5]!==k[5]?d[5]:d[5]+e,b&&d[1]===k[1]?d[1]+e:d[1],b||d[2]!==k[2]?d[2]:d[2]+e)):k=null;return k},
	addPlotBand:function(a){return this.addPlotBandOrLine(a,"plotBands")},addPlotLine:function(a){return this.addPlotBandOrLine(a,"plotLines")},addPlotBandOrLine:function(f,g){var d=(new a.PlotLineOrBand(this,f)).render(),k=this.userOptions;d&&(g&&(k[g]=k[g]||[],k[g].push(f)),this.plotLinesAndBands.push(d));return d},removePlotBandOrLine:function(a){for(var g=this.plotLinesAndBands,d=this.options,k=this.userOptions,b=g.length;b--;)g[b].id===a&&g[b].destroy();f([d.plotLines||[],k.plotLines||[],d.plotBands||
	[],k.plotBands||[]],function(e){for(b=e.length;b--;)e[b].id===a&&l(e,e[b])})},removePlotBand:function(a){this.removePlotBandOrLine(a)},removePlotLine:function(a){this.removePlotBandOrLine(a)}})})(M,S);(function(a){var C=a.dateFormat,A=a.each,F=a.extend,E=a.format,m=a.isNumber,f=a.map,l=a.merge,r=a.pick,u=a.splat,t=a.syncTimeout,g=a.timeUnits;a.Tooltip=function(){this.init.apply(this,arguments)};a.Tooltip.prototype={init:function(a,k){this.chart=a;this.options=k;this.crosshairs=[];this.now={x:0,y:0};
	this.isHidden=!0;this.split=k.split&&!a.inverted;this.shared=k.shared||this.split},cleanSplit:function(a){A(this.chart.series,function(d){var b=d&&d.tt;b&&(!b.isActive||a?d.tt=b.destroy():b.isActive=!1)})},getLabel:function(){var a=this.chart.renderer,k=this.options;this.label||(this.split?this.label=a.g("tooltip"):(this.label=a.label("",0,0,k.shape||"callout",null,null,k.useHTML,null,"tooltip").attr({padding:k.padding,r:k.borderRadius}),this.label.attr({fill:k.backgroundColor,"stroke-width":k.borderWidth}).css(k.style).shadow(k.shadow)),
	this.label.attr({zIndex:8}).add());return this.label},update:function(a){this.destroy();l(!0,this.chart.options.tooltip.userOptions,a);this.init(this.chart,l(!0,this.options,a))},destroy:function(){this.label&&(this.label=this.label.destroy());this.split&&this.tt&&(this.cleanSplit(this.chart,!0),this.tt=this.tt.destroy());clearTimeout(this.hideTimer);clearTimeout(this.tooltipTimeout)},move:function(a,k,b,e){var d=this,g=d.now,n=!1!==d.options.animation&&!d.isHidden&&(1<Math.abs(a-g.x)||1<Math.abs(k-
	g.y)),f=d.followPointer||1<d.len;F(g,{x:n?(2*g.x+a)/3:a,y:n?(g.y+k)/2:k,anchorX:f?void 0:n?(2*g.anchorX+b)/3:b,anchorY:f?void 0:n?(g.anchorY+e)/2:e});d.getLabel().attr(g);n&&(clearTimeout(this.tooltipTimeout),this.tooltipTimeout=setTimeout(function(){d&&d.move(a,k,b,e)},32))},hide:function(a){var d=this;clearTimeout(this.hideTimer);a=r(a,this.options.hideDelay,500);this.isHidden||(this.hideTimer=t(function(){d.getLabel()[a?"fadeOut":"hide"]();d.isHidden=!0},a))},getAnchor:function(a,k){var b,e=this.chart,
	d=e.inverted,g=e.plotTop,n=e.plotLeft,l=0,m=0,c,r;a=u(a);b=a[0].tooltipPos;this.followPointer&&k&&(void 0===k.chartX&&(k=e.pointer.normalize(k)),b=[k.chartX-e.plotLeft,k.chartY-g]);b||(A(a,function(a){c=a.series.yAxis;r=a.series.xAxis;l+=a.plotX+(!d&&r?r.left-n:0);m+=(a.plotLow?(a.plotLow+a.plotHigh)/2:a.plotY)+(!d&&c?c.top-g:0)}),l/=a.length,m/=a.length,b=[d?e.plotWidth-m:l,this.shared&&!d&&1<a.length&&k?k.chartY-g:d?e.plotHeight-l:m]);return f(b,Math.round)},getPosition:function(a,g,b){var e=this.chart,
	d=this.distance,k={},n=b.h||0,f,l=["y",e.chartHeight,g,b.plotY+e.plotTop,e.plotTop,e.plotTop+e.plotHeight],c=["x",e.chartWidth,a,b.plotX+e.plotLeft,e.plotLeft,e.plotLeft+e.plotWidth],m=!this.followPointer&&r(b.ttBelow,!e.inverted===!!b.negative),q=function(a,b,c,e,p,q){var h=c<e-d,g=e+d+c<b,f=e-d-c;e+=d;if(m&&g)k[a]=e;else if(!m&&h)k[a]=f;else if(h)k[a]=Math.min(q-c,0>f-n?f:f-n);else if(g)k[a]=Math.max(p,e+n+c>b?e:e+n);else return!1},B=function(a,b,c,e){var h;e<d||e>b-d?h=!1:k[a]=e<c/2?1:e>b-c/2?
	b-c-2:e-c/2;return h},t=function(a){var b=l;l=c;c=b;f=a},p=function(){!1!==q.apply(0,l)?!1!==B.apply(0,c)||f||(t(!0),p()):f?k.x=k.y=0:(t(!0),p())};(e.inverted||1<this.len)&&t();p();return k},defaultFormatter:function(a){var d=this.points||u(this),b;b=[a.tooltipFooterHeaderFormatter(d[0])];b=b.concat(a.bodyFormatter(d));b.push(a.tooltipFooterHeaderFormatter(d[0],!0));return b},refresh:function(a,g){var b,e=this.options,d,k=a,n,f={},l=[];b=e.formatter||this.defaultFormatter;var f=this.shared,c;e.enabled&&
	(clearTimeout(this.hideTimer),this.followPointer=u(k)[0].series.tooltipOptions.followPointer,n=this.getAnchor(k,g),g=n[0],d=n[1],!f||k.series&&k.series.noSharedTooltip?f=k.getLabelConfig():(A(k,function(a){a.setState("hover");l.push(a.getLabelConfig())}),f={x:k[0].category,y:k[0].y},f.points=l,k=k[0]),this.len=l.length,f=b.call(f,this),c=k.series,this.distance=r(c.tooltipOptions.distance,16),!1===f?this.hide():(b=this.getLabel(),this.isHidden&&b.attr({opacity:1}).show(),this.split?this.renderSplit(f,
	a):(e.style.width||b.css({width:this.chart.spacingBox.width}),b.attr({text:f&&f.join?f.join(""):f}),b.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-"+r(k.colorIndex,c.colorIndex)),b.attr({stroke:e.borderColor||k.color||c.color||"#666666"}),this.updatePosition({plotX:g,plotY:d,negative:k.negative,ttBelow:k.ttBelow,h:n[2]||0})),this.isHidden=!1))},renderSplit:function(d,k){var b=this,e=[],g=this.chart,f=g.renderer,n=!0,l=this.options,m=0,c=this.getLabel();A(d.slice(0,k.length+1),
	function(a,d){if(!1!==a){d=k[d-1]||{isHeader:!0,plotX:k[0].plotX};var q=d.series||b,v=q.tt,p=d.series||{},z="highcharts-color-"+r(d.colorIndex,p.colorIndex,"none");v||(q.tt=v=f.label(null,null,null,"callout").addClass("highcharts-tooltip-box "+z).attr({padding:l.padding,r:l.borderRadius,fill:l.backgroundColor,stroke:l.borderColor||d.color||p.color||"#333333","stroke-width":l.borderWidth}).add(c));v.isActive=!0;v.attr({text:a});v.css(l.style).shadow(l.shadow);a=v.getBBox();p=a.width+v.strokeWidth();
	d.isHeader?(m=a.height,p=Math.max(0,Math.min(d.plotX+g.plotLeft-p/2,g.chartWidth-p))):p=d.plotX+g.plotLeft-r(l.distance,16)-p;0>p&&(n=!1);a=(d.series&&d.series.yAxis&&d.series.yAxis.pos)+(d.plotY||0);a-=g.plotTop;e.push({target:d.isHeader?g.plotHeight+m:a,rank:d.isHeader?1:0,size:q.tt.getBBox().height+1,point:d,x:p,tt:v})}});this.cleanSplit();a.distribute(e,g.plotHeight+m);A(e,function(a){var b=a.point,c=b.series;a.tt.attr({visibility:void 0===a.pos?"hidden":"inherit",x:n||b.isHeader?a.x:b.plotX+
	g.plotLeft+r(l.distance,16),y:a.pos+g.plotTop,anchorX:b.isHeader?b.plotX+g.plotLeft:b.plotX+c.xAxis.pos,anchorY:b.isHeader?a.pos+g.plotTop-15:b.plotY+c.yAxis.pos})})},updatePosition:function(a){var d=this.chart,b=this.getLabel(),b=(this.options.positioner||this.getPosition).call(this,b.width,b.height,a);this.move(Math.round(b.x),Math.round(b.y||0),a.plotX+d.plotLeft,a.plotY+d.plotTop)},getDateFormat:function(a,k,b,e){var d=C("%m-%d %H:%M:%S.%L",k),f,n,l={millisecond:15,second:12,minute:9,hour:6,day:3},
	m="millisecond";for(n in g){if(a===g.week&&+C("%w",k)===b&&"00:00:00.000"===d.substr(6)){n="week";break}if(g[n]>a){n=m;break}if(l[n]&&d.substr(l[n])!=="01-01 00:00:00.000".substr(l[n]))break;"week"!==n&&(m=n)}n&&(f=e[n]);return f},getXDateFormat:function(a,g,b){g=g.dateTimeLabelFormats;var e=b&&b.closestPointRange;return(e?this.getDateFormat(e,a.x,b.options.startOfWeek,g):g.day)||g.year},tooltipFooterHeaderFormatter:function(a,g){var b=g?"footer":"header";g=a.series;var e=g.tooltipOptions,d=e.xDateFormat,
	k=g.xAxis,n=k&&"datetime"===k.options.type&&m(a.key),b=e[b+"Format"];n&&!d&&(d=this.getXDateFormat(a,e,k));n&&d&&(b=b.replace("{point.key}","{point.key:"+d+"}"));return E(b,{point:a,series:g})},bodyFormatter:function(a){return f(a,function(a){var b=a.series.tooltipOptions;return(b.pointFormatter||a.point.tooltipFormatter).call(a.point,b.pointFormat)})}}})(M);(function(a){var C=a.addEvent,A=a.attr,F=a.charts,E=a.color,m=a.css,f=a.defined,l=a.each,r=a.extend,u=a.find,t=a.fireEvent,g=a.isObject,d=a.offset,
	k=a.pick,b=a.removeEvent,e=a.splat,v=a.Tooltip,y=a.win;a.Pointer=function(a,b){this.init(a,b)};a.Pointer.prototype={init:function(a,b){this.options=b;this.chart=a;this.runChartClick=b.chart.events&&!!b.chart.events.click;this.pinchDown=[];this.lastValidTouch={};v&&(a.tooltip=new v(a,b.tooltip),this.followTouchMove=k(b.tooltip.followTouchMove,!0));this.setDOMEvents()},zoomOption:function(a){var b=this.chart,e=b.options.chart,c=e.zoomType||"",b=b.inverted;/touch/.test(a.type)&&(c=k(e.pinchType,c));
	this.zoomX=a=/x/.test(c);this.zoomY=c=/y/.test(c);this.zoomHor=a&&!b||c&&b;this.zoomVert=c&&!b||a&&b;this.hasZoom=a||c},normalize:function(a,b){var e,c;a=a||y.event;a.target||(a.target=a.srcElement);c=a.touches?a.touches.length?a.touches.item(0):a.changedTouches[0]:a;b||(this.chartPosition=b=d(this.chart.container));void 0===c.pageX?(e=Math.max(a.x,a.clientX-b.left),b=a.y):(e=c.pageX-b.left,b=c.pageY-b.top);return r(a,{chartX:Math.round(e),chartY:Math.round(b)})},getCoordinates:function(a){var b=
	{xAxis:[],yAxis:[]};l(this.chart.axes,function(e){b[e.isXAxis?"xAxis":"yAxis"].push({axis:e,value:e.toValue(a[e.horiz?"chartX":"chartY"])})});return b},findNearestKDPoint:function(a,b,e){var c;l(a,function(a){var d=!(a.noSharedTooltip&&b)&&0>a.options.findNearestPointBy.indexOf("y");a=a.searchPoint(e,d);if((d=g(a,!0))&&!(d=!g(c,!0)))var d=c.distX-a.distX,n=c.dist-a.dist,k=(a.series.group&&a.series.group.zIndex)-(c.series.group&&c.series.group.zIndex),d=0<(0!==d&&b?d:0!==n?n:0!==k?k:c.series.index>
	a.series.index?-1:1);d&&(c=a)});return c},getPointFromEvent:function(a){a=a.target;for(var b;a&&!b;)b=a.point,a=a.parentNode;return b},getChartCoordinatesFromPoint:function(a,b){var e=a.series,c=e.xAxis,e=e.yAxis;if(c&&e)return b?{chartX:c.len+c.pos-a.clientX,chartY:e.len+e.pos-a.plotY}:{chartX:a.clientX+c.pos,chartY:a.plotY+e.pos}},getHoverData:function(b,e,d,c,f,q){var n,v=[];c=!(!c||!b);var p=e&&!e.stickyTracking?[e]:a.grep(d,function(a){return a.visible&&!(!f&&a.directTouch)&&k(a.options.enableMouseTracking,
	!0)&&a.stickyTracking});e=(n=c?b:this.findNearestKDPoint(p,f,q))&&n.series;n&&(f&&!e.noSharedTooltip?(p=a.grep(d,function(a){return a.visible&&!(!f&&a.directTouch)&&k(a.options.enableMouseTracking,!0)&&!a.noSharedTooltip}),l(p,function(a){a=u(a.points,function(a){return a.x===n.x});g(a)&&!a.isNull&&v.push(a)})):v.push(n));return{hoverPoint:n,hoverSeries:e,hoverPoints:v}},runPointActions:function(b,e){var d=this.chart,c=d.tooltip,g=c?c.shared:!1,n=e||d.hoverPoint,f=n&&n.series||d.hoverSeries,f=this.getHoverData(n,
	f,d.series,!!e||f&&f.directTouch&&this.isDirectTouch,g,b),v,n=f.hoverPoint;v=f.hoverPoints;e=(f=f.hoverSeries)&&f.tooltipOptions.followPointer;g=g&&f&&!f.noSharedTooltip;if(n&&(n!==d.hoverPoint||c&&c.isHidden)){l(d.hoverPoints||[],function(b){-1===a.inArray(b,v)&&b.setState()});l(v||[],function(a){a.setState("hover")});if(d.hoverSeries!==f)f.onMouseOver();d.hoverPoint&&d.hoverPoint.firePointEvent("mouseOut");n.firePointEvent("mouseOver");d.hoverPoints=v;d.hoverPoint=n;c&&c.refresh(g?v:n,b)}else e&&
	c&&!c.isHidden&&(n=c.getAnchor([{}],b),c.updatePosition({plotX:n[0],plotY:n[1]}));this.unDocMouseMove||(this.unDocMouseMove=C(d.container.ownerDocument,"mousemove",function(b){var c=F[a.hoverChartIndex];if(c)c.pointer.onDocumentMouseMove(b)}));l(d.axes,function(c){var e=k(c.crosshair.snap,!0),p=e?a.find(v,function(a){return a.series[c.coll]===c}):void 0;p||!e?c.drawCrosshair(b,p):c.hideCrosshair()})},reset:function(a,b){var d=this.chart,c=d.hoverSeries,g=d.hoverPoint,n=d.hoverPoints,f=d.tooltip,k=
	f&&f.shared?n:g;a&&k&&l(e(k),function(b){b.series.isCartesian&&void 0===b.plotX&&(a=!1)});if(a)f&&k&&(f.refresh(k),g&&(g.setState(g.state,!0),l(d.axes,function(a){a.crosshair&&a.drawCrosshair(null,g)})));else{if(g)g.onMouseOut();n&&l(n,function(a){a.setState()});if(c)c.onMouseOut();f&&f.hide(b);this.unDocMouseMove&&(this.unDocMouseMove=this.unDocMouseMove());l(d.axes,function(a){a.hideCrosshair()});this.hoverX=d.hoverPoints=d.hoverPoint=null}},scaleGroups:function(a,b){var e=this.chart,c;l(e.series,
	function(d){c=a||d.getPlotBox();d.xAxis&&d.xAxis.zoomEnabled&&d.group&&(d.group.attr(c),d.markerGroup&&(d.markerGroup.attr(c),d.markerGroup.clip(b?e.clipRect:null)),d.dataLabelsGroup&&d.dataLabelsGroup.attr(c))});e.clipRect.attr(b||e.clipBox)},dragStart:function(a){var b=this.chart;b.mouseIsDown=a.type;b.cancelClick=!1;b.mouseDownX=this.mouseDownX=a.chartX;b.mouseDownY=this.mouseDownY=a.chartY},drag:function(a){var b=this.chart,e=b.options.chart,c=a.chartX,d=a.chartY,g=this.zoomHor,n=this.zoomVert,
	f=b.plotLeft,p=b.plotTop,k=b.plotWidth,v=b.plotHeight,l,h=this.selectionMarker,w=this.mouseDownX,m=this.mouseDownY,r=e.panKey&&a[e.panKey+"Key"];h&&h.touch||(c<f?c=f:c>f+k&&(c=f+k),d<p?d=p:d>p+v&&(d=p+v),this.hasDragged=Math.sqrt(Math.pow(w-c,2)+Math.pow(m-d,2)),10<this.hasDragged&&(l=b.isInsidePlot(w-f,m-p),b.hasCartesianSeries&&(this.zoomX||this.zoomY)&&l&&!r&&!h&&(this.selectionMarker=h=b.renderer.rect(f,p,g?1:k,n?1:v,0).attr({fill:e.selectionMarkerFill||E("#335cad").setOpacity(.25).get(),"class":"highcharts-selection-marker",
	zIndex:7}).add()),h&&g&&(c-=w,h.attr({width:Math.abs(c),x:(0<c?0:c)+w})),h&&n&&(c=d-m,h.attr({height:Math.abs(c),y:(0<c?0:c)+m})),l&&!h&&e.panning&&b.pan(a,e.panning)))},drop:function(a){var b=this,e=this.chart,c=this.hasPinched;if(this.selectionMarker){var d={originalEvent:a,xAxis:[],yAxis:[]},g=this.selectionMarker,n=g.attr?g.attr("x"):g.x,k=g.attr?g.attr("y"):g.y,p=g.attr?g.attr("width"):g.width,v=g.attr?g.attr("height"):g.height,I;if(this.hasDragged||c)l(e.axes,function(e){if(e.zoomEnabled&&f(e.min)&&
	(c||b[{xAxis:"zoomX",yAxis:"zoomY"}[e.coll]])){var h=e.horiz,g="touchend"===a.type?e.minPixelPadding:0,q=e.toValue((h?n:k)+g),h=e.toValue((h?n+p:k+v)-g);d[e.coll].push({axis:e,min:Math.min(q,h),max:Math.max(q,h)});I=!0}}),I&&t(e,"selection",d,function(a){e.zoom(r(a,c?{animation:!1}:null))});this.selectionMarker=this.selectionMarker.destroy();c&&this.scaleGroups()}e&&(m(e.container,{cursor:e._cursor}),e.cancelClick=10<this.hasDragged,e.mouseIsDown=this.hasDragged=this.hasPinched=!1,this.pinchDown=
	[])},onContainerMouseDown:function(a){a=this.normalize(a);this.zoomOption(a);a.preventDefault&&a.preventDefault();this.dragStart(a)},onDocumentMouseUp:function(b){F[a.hoverChartIndex]&&F[a.hoverChartIndex].pointer.drop(b)},onDocumentMouseMove:function(a){var b=this.chart,e=this.chartPosition;a=this.normalize(a,e);!e||this.inClass(a.target,"highcharts-tracker")||b.isInsidePlot(a.chartX-b.plotLeft,a.chartY-b.plotTop)||this.reset()},onContainerMouseLeave:function(b){var e=F[a.hoverChartIndex];e&&(b.relatedTarget||
	b.toElement)&&(e.pointer.reset(),e.pointer.chartPosition=null)},onContainerMouseMove:function(b){var e=this.chart;f(a.hoverChartIndex)&&F[a.hoverChartIndex]&&F[a.hoverChartIndex].mouseIsDown||(a.hoverChartIndex=e.index);b=this.normalize(b);b.returnValue=!1;"mousedown"===e.mouseIsDown&&this.drag(b);!this.inClass(b.target,"highcharts-tracker")&&!e.isInsidePlot(b.chartX-e.plotLeft,b.chartY-e.plotTop)||e.openMenu||this.runPointActions(b)},inClass:function(a,b){for(var e;a;){if(e=A(a,"class")){if(-1!==
	e.indexOf(b))return!0;if(-1!==e.indexOf("highcharts-container"))return!1}a=a.parentNode}},onTrackerMouseOut:function(a){var b=this.chart.hoverSeries;a=a.relatedTarget||a.toElement;this.isDirectTouch=!1;if(!(!b||!a||b.stickyTracking||this.inClass(a,"highcharts-tooltip")||this.inClass(a,"highcharts-series-"+b.index)&&this.inClass(a,"highcharts-tracker")))b.onMouseOut()},onContainerClick:function(a){var b=this.chart,e=b.hoverPoint,c=b.plotLeft,d=b.plotTop;a=this.normalize(a);b.cancelClick||(e&&this.inClass(a.target,
	"highcharts-tracker")?(t(e.series,"click",r(a,{point:e})),b.hoverPoint&&e.firePointEvent("click",a)):(r(a,this.getCoordinates(a)),b.isInsidePlot(a.chartX-c,a.chartY-d)&&t(b,"click",a)))},setDOMEvents:function(){var b=this,e=b.chart.container,d=e.ownerDocument;e.onmousedown=function(a){b.onContainerMouseDown(a)};e.onmousemove=function(a){b.onContainerMouseMove(a)};e.onclick=function(a){b.onContainerClick(a)};C(e,"mouseleave",b.onContainerMouseLeave);1===a.chartCount&&C(d,"mouseup",b.onDocumentMouseUp);
	a.hasTouch&&(e.ontouchstart=function(a){b.onContainerTouchStart(a)},e.ontouchmove=function(a){b.onContainerTouchMove(a)},1===a.chartCount&&C(d,"touchend",b.onDocumentTouchEnd))},destroy:function(){var e=this,d=this.chart.container.ownerDocument;e.unDocMouseMove&&e.unDocMouseMove();b(e.chart.container,"mouseleave",e.onContainerMouseLeave);a.chartCount||(b(d,"mouseup",e.onDocumentMouseUp),a.hasTouch&&b(d,"touchend",e.onDocumentTouchEnd));clearInterval(e.tooltipTimeout);a.objectEach(e,function(a,b){e[b]=
	null})}}})(M);(function(a){var C=a.charts,A=a.each,F=a.extend,E=a.map,m=a.noop,f=a.pick;F(a.Pointer.prototype,{pinchTranslate:function(a,f,m,t,g,d){this.zoomHor&&this.pinchTranslateDirection(!0,a,f,m,t,g,d);this.zoomVert&&this.pinchTranslateDirection(!1,a,f,m,t,g,d)},pinchTranslateDirection:function(a,f,m,t,g,d,k,b){var e=this.chart,v=a?"x":"y",l=a?"X":"Y",n="chart"+l,r=a?"width":"height",u=e["plot"+(a?"Left":"Top")],c,G,q=b||1,B=e.inverted,K=e.bounds[a?"h":"v"],p=1===f.length,z=f[0][n],I=m[0][n],
	L=!p&&f[1][n],h=!p&&m[1][n],w;m=function(){!p&&20<Math.abs(z-L)&&(q=b||Math.abs(I-h)/Math.abs(z-L));G=(u-I)/q+z;c=e["plot"+(a?"Width":"Height")]/q};m();f=G;f<K.min?(f=K.min,w=!0):f+c>K.max&&(f=K.max-c,w=!0);w?(I-=.8*(I-k[v][0]),p||(h-=.8*(h-k[v][1])),m()):k[v]=[I,h];B||(d[v]=G-u,d[r]=c);d=B?1/q:q;g[r]=c;g[v]=f;t[B?a?"scaleY":"scaleX":"scale"+l]=q;t["translate"+l]=d*u+(I-d*z)},pinch:function(a){var l=this,u=l.chart,t=l.pinchDown,g=a.touches,d=g.length,k=l.lastValidTouch,b=l.hasZoom,e=l.selectionMarker,
	v={},y=1===d&&(l.inClass(a.target,"highcharts-tracker")&&u.runTrackerClick||l.runChartClick),n={};1<d&&(l.initiated=!0);b&&l.initiated&&!y&&a.preventDefault();E(g,function(a){return l.normalize(a)});"touchstart"===a.type?(A(g,function(a,b){t[b]={chartX:a.chartX,chartY:a.chartY}}),k.x=[t[0].chartX,t[1]&&t[1].chartX],k.y=[t[0].chartY,t[1]&&t[1].chartY],A(u.axes,function(a){if(a.zoomEnabled){var b=u.bounds[a.horiz?"h":"v"],e=a.minPixelPadding,d=a.toPixels(f(a.options.min,a.dataMin)),g=a.toPixels(f(a.options.max,
	a.dataMax)),k=Math.max(d,g);b.min=Math.min(a.pos,Math.min(d,g)-e);b.max=Math.max(a.pos+a.len,k+e)}}),l.res=!0):l.followTouchMove&&1===d?this.runPointActions(l.normalize(a)):t.length&&(e||(l.selectionMarker=e=F({destroy:m,touch:!0},u.plotBox)),l.pinchTranslate(t,g,v,e,n,k),l.hasPinched=b,l.scaleGroups(v,n),l.res&&(l.res=!1,this.reset(!1,0)))},touch:function(l,m){var r=this.chart,t,g;if(r.index!==a.hoverChartIndex)this.onContainerMouseLeave({relatedTarget:!0});a.hoverChartIndex=r.index;1===l.touches.length?
	(l=this.normalize(l),(g=r.isInsidePlot(l.chartX-r.plotLeft,l.chartY-r.plotTop))&&!r.openMenu?(m&&this.runPointActions(l),"touchmove"===l.type&&(m=this.pinchDown,t=m[0]?4<=Math.sqrt(Math.pow(m[0].chartX-l.chartX,2)+Math.pow(m[0].chartY-l.chartY,2)):!1),f(t,!0)&&this.pinch(l)):m&&this.reset()):2===l.touches.length&&this.pinch(l)},onContainerTouchStart:function(a){this.zoomOption(a);this.touch(a,!0)},onContainerTouchMove:function(a){this.touch(a)},onDocumentTouchEnd:function(f){C[a.hoverChartIndex]&&
	C[a.hoverChartIndex].pointer.drop(f)}})})(M);(function(a){var C=a.addEvent,A=a.charts,F=a.css,E=a.doc,m=a.extend,f=a.noop,l=a.Pointer,r=a.removeEvent,u=a.win,t=a.wrap;if(!a.hasTouch&&(u.PointerEvent||u.MSPointerEvent)){var g={},d=!!u.PointerEvent,k=function(){var b=[];b.item=function(a){return this[a]};a.objectEach(g,function(a){b.push({pageX:a.pageX,pageY:a.pageY,target:a.target})});return b},b=function(b,d,g,n){"touch"!==b.pointerType&&b.pointerType!==b.MSPOINTER_TYPE_TOUCH||!A[a.hoverChartIndex]||
	(n(b),n=A[a.hoverChartIndex].pointer,n[d]({type:g,target:b.currentTarget,preventDefault:f,touches:k()}))};m(l.prototype,{onContainerPointerDown:function(a){b(a,"onContainerTouchStart","touchstart",function(a){g[a.pointerId]={pageX:a.pageX,pageY:a.pageY,target:a.currentTarget}})},onContainerPointerMove:function(a){b(a,"onContainerTouchMove","touchmove",function(a){g[a.pointerId]={pageX:a.pageX,pageY:a.pageY};g[a.pointerId].target||(g[a.pointerId].target=a.currentTarget)})},onDocumentPointerUp:function(a){b(a,
	"onDocumentTouchEnd","touchend",function(a){delete g[a.pointerId]})},batchMSEvents:function(a){a(this.chart.container,d?"pointerdown":"MSPointerDown",this.onContainerPointerDown);a(this.chart.container,d?"pointermove":"MSPointerMove",this.onContainerPointerMove);a(E,d?"pointerup":"MSPointerUp",this.onDocumentPointerUp)}});t(l.prototype,"init",function(a,b,d){a.call(this,b,d);this.hasZoom&&F(b.container,{"-ms-touch-action":"none","touch-action":"none"})});t(l.prototype,"setDOMEvents",function(a){a.apply(this);
	(this.hasZoom||this.followTouchMove)&&this.batchMSEvents(C)});t(l.prototype,"destroy",function(a){this.batchMSEvents(r);a.call(this)})}})(M);(function(a){var C=a.addEvent,A=a.css,F=a.discardElement,E=a.defined,m=a.each,f=a.isFirefox,l=a.marginNames,r=a.merge,u=a.pick,t=a.setAnimation,g=a.stableSort,d=a.win,k=a.wrap;a.Legend=function(a,e){this.init(a,e)};a.Legend.prototype={init:function(a,e){this.chart=a;this.setOptions(e);e.enabled&&(this.render(),C(this.chart,"endResize",function(){this.legend.positionCheckboxes()}))},
	setOptions:function(a){var b=u(a.padding,8);this.options=a;this.itemStyle=a.itemStyle;this.itemHiddenStyle=r(this.itemStyle,a.itemHiddenStyle);this.itemMarginTop=a.itemMarginTop||0;this.padding=b;this.initialItemY=b-5;this.itemHeight=this.maxItemWidth=0;this.symbolWidth=u(a.symbolWidth,16);this.pages=[]},update:function(a,e){var b=this.chart;this.setOptions(r(!0,this.options,a));this.destroy();b.isDirtyLegend=b.isDirtyBox=!0;u(e,!0)&&b.redraw()},colorizeItem:function(a,e){a.legendGroup[e?"removeClass":
	"addClass"]("highcharts-legend-item-hidden");var b=this.options,d=a.legendItem,g=a.legendLine,f=a.legendSymbol,k=this.itemHiddenStyle.color,b=e?b.itemStyle.color:k,c=e?a.color||k:k,l=a.options&&a.options.marker,q={fill:c};d&&d.css({fill:b,color:b});g&&g.attr({stroke:c});f&&(l&&f.isMarker&&(q=a.pointAttribs(),e||(q.stroke=q.fill=k)),f.attr(q))},positionItem:function(a){var b=this.options,d=b.symbolPadding,b=!b.rtl,g=a._legendItemPos,f=g[0],g=g[1],k=a.checkbox;(a=a.legendGroup)&&a.element&&a.translate(b?
	f:this.legendWidth-f-2*d-4,g);k&&(k.x=f,k.y=g)},destroyItem:function(a){var b=a.checkbox;m(["legendItem","legendLine","legendSymbol","legendGroup"],function(b){a[b]&&(a[b]=a[b].destroy())});b&&F(a.checkbox)},destroy:function(){function a(a){this[a]&&(this[a]=this[a].destroy())}m(this.getAllItems(),function(b){m(["legendItem","legendGroup"],a,b)});m("clipRect up down pager nav box title group".split(" "),a,this);this.display=null},positionCheckboxes:function(a){var b=this.group&&this.group.alignAttr,
	d,g=this.clipHeight||this.legendHeight,f=this.titleHeight;b&&(d=b.translateY,m(this.allItems,function(e){var k=e.checkbox,c;k&&(c=d+f+k.y+(a||0)+3,A(k,{left:b.translateX+e.checkboxOffset+k.x-20+"px",top:c+"px",display:c>d-6&&c<d+g-6?"":"none"}))}))},renderTitle:function(){var a=this.options,e=this.padding,d=a.title,g=0;d.text&&(this.title||(this.title=this.chart.renderer.label(d.text,e-3,e-4,null,null,null,a.useHTML,null,"legend-title").attr({zIndex:1}).css(d.style).add(this.group)),a=this.title.getBBox(),
	g=a.height,this.offsetWidth=a.width,this.contentGroup.attr({translateY:g}));this.titleHeight=g},setText:function(b){var e=this.options;b.legendItem.attr({text:e.labelFormat?a.format(e.labelFormat,b):e.labelFormatter.call(b)})},renderItem:function(a){var b=this.chart,d=b.renderer,g=this.options,f="horizontal"===g.layout,k=this.symbolWidth,l=g.symbolPadding,c=this.itemStyle,m=this.itemHiddenStyle,q=this.padding,B=f?u(g.itemDistance,20):0,t=!g.rtl,p=g.width,z=g.itemMarginBottom||0,I=this.itemMarginTop,
	L=a.legendItem,h=!a.series,w=!h&&a.series.drawLegendSymbol?a.series:a,P=w.options,H=this.createCheckboxForItem&&P&&P.showCheckbox,P=k+l+B+(H?20:0),O=g.useHTML,A=a.options.className;L||(a.legendGroup=d.g("legend-item").addClass("highcharts-"+w.type+"-series highcharts-color-"+a.colorIndex+(A?" "+A:"")+(h?" highcharts-series-"+a.index:"")).attr({zIndex:1}).add(this.scrollGroup),a.legendItem=L=d.text("",t?k+l:-l,this.baseline||0,O).css(r(a.visible?c:m)).attr({align:t?"left":"right",zIndex:2}).add(a.legendGroup),
	this.baseline||(k=c.fontSize,this.fontMetrics=d.fontMetrics(k,L),this.baseline=this.fontMetrics.f+3+I,L.attr("y",this.baseline)),this.symbolHeight=g.symbolHeight||this.fontMetrics.f,w.drawLegendSymbol(this,a),this.setItemEvents&&this.setItemEvents(a,L,O),H&&this.createCheckboxForItem(a));this.colorizeItem(a,a.visible);c.width||L.css({width:(g.itemWidth||g.width||b.spacingBox.width)-P});this.setText(a);d=L.getBBox();c=a.checkboxOffset=g.itemWidth||a.legendItemWidth||d.width+P;this.itemHeight=d=Math.round(a.legendItemHeight||
	d.height||this.symbolHeight);f&&this.itemX-q+c>(p||b.spacingBox.width-2*q-g.x)&&(this.itemX=q,this.itemY+=I+this.lastLineHeight+z,this.lastLineHeight=0);this.maxItemWidth=Math.max(this.maxItemWidth,c);this.lastItemY=I+this.itemY+z;this.lastLineHeight=Math.max(d,this.lastLineHeight);a._legendItemPos=[this.itemX,this.itemY];f?this.itemX+=c:(this.itemY+=I+d+z,this.lastLineHeight=d);this.offsetWidth=p||Math.max((f?this.itemX-q-(a.checkbox?0:B):c)+q,this.offsetWidth)},getAllItems:function(){var a=[];m(this.chart.series,
	function(b){var e=b&&b.options;b&&u(e.showInLegend,E(e.linkedTo)?!1:void 0,!0)&&(a=a.concat(b.legendItems||("point"===e.legendType?b.data:b)))});return a},adjustMargins:function(a,e){var b=this.chart,d=this.options,g=d.align.charAt(0)+d.verticalAlign.charAt(0)+d.layout.charAt(0);d.floating||m([/(lth|ct|rth)/,/(rtv|rm|rbv)/,/(rbh|cb|lbh)/,/(lbv|lm|ltv)/],function(f,k){f.test(g)&&!E(a[k])&&(b[l[k]]=Math.max(b[l[k]],b.legend[(k+1)%2?"legendHeight":"legendWidth"]+[1,-1,-1,1][k]*d[k%2?"x":"y"]+u(d.margin,
	12)+e[k]))})},render:function(){var a=this,e=a.chart,d=e.renderer,f=a.group,k,l,t,c,u=a.box,q=a.options,B=a.padding;a.itemX=B;a.itemY=a.initialItemY;a.offsetWidth=0;a.lastItemY=0;f||(a.group=f=d.g("legend").attr({zIndex:7}).add(),a.contentGroup=d.g().attr({zIndex:1}).add(f),a.scrollGroup=d.g().add(a.contentGroup));a.renderTitle();k=a.getAllItems();g(k,function(a,b){return(a.options&&a.options.legendIndex||0)-(b.options&&b.options.legendIndex||0)});q.reversed&&k.reverse();a.allItems=k;a.display=l=
	!!k.length;a.lastLineHeight=0;m(k,function(b){a.renderItem(b)});t=(q.width||a.offsetWidth)+B;c=a.lastItemY+a.lastLineHeight+a.titleHeight;c=a.handleOverflow(c);c+=B;u||(a.box=u=d.rect().addClass("highcharts-legend-box").attr({r:q.borderRadius}).add(f),u.isNew=!0);u.attr({stroke:q.borderColor,"stroke-width":q.borderWidth||0,fill:q.backgroundColor||"none"}).shadow(q.shadow);0<t&&0<c&&(u[u.isNew?"attr":"animate"](u.crisp({x:0,y:0,width:t,height:c},u.strokeWidth())),u.isNew=!1);u[l?"show":"hide"]();a.legendWidth=
	t;a.legendHeight=c;m(k,function(b){a.positionItem(b)});l&&f.align(r(q,{width:t,height:c}),!0,"spacingBox");e.isResizing||this.positionCheckboxes()},handleOverflow:function(a){var b=this,d=this.chart,g=d.renderer,f=this.options,k=f.y,l=this.padding,d=d.spacingBox.height+("top"===f.verticalAlign?-k:k)-l,k=f.maxHeight,c,r=this.clipRect,q=f.navigation,B=u(q.animation,!0),t=q.arrowSize||12,p=this.nav,z=this.pages,I,L=this.allItems,h=function(a){"number"===typeof a?r.attr({height:a}):r&&(b.clipRect=r.destroy(),
	b.contentGroup.clip());b.contentGroup.div&&(b.contentGroup.div.style.clip=a?"rect("+l+"px,9999px,"+(l+a)+"px,0)":"auto")};"horizontal"!==f.layout||"middle"===f.verticalAlign||f.floating||(d/=2);k&&(d=Math.min(d,k));z.length=0;a>d&&!1!==q.enabled?(this.clipHeight=c=Math.max(d-20-this.titleHeight-l,0),this.currentPage=u(this.currentPage,1),this.fullHeight=a,m(L,function(a,b){var e=a._legendItemPos[1];a=Math.round(a.legendItem.getBBox().height);var d=z.length;if(!d||e-z[d-1]>c&&(I||e)!==z[d-1])z.push(I||
	e),d++;b===L.length-1&&e+a-z[d-1]>c&&z.push(e);e!==I&&(I=e)}),r||(r=b.clipRect=g.clipRect(0,l,9999,0),b.contentGroup.clip(r)),h(c),p||(this.nav=p=g.g().attr({zIndex:1}).add(this.group),this.up=g.symbol("triangle",0,0,t,t).on("click",function(){b.scroll(-1,B)}).add(p),this.pager=g.text("",15,10).addClass("highcharts-legend-navigation").css(q.style).add(p),this.down=g.symbol("triangle-down",0,0,t,t).on("click",function(){b.scroll(1,B)}).add(p)),b.scroll(0),a=d):p&&(h(),this.nav=p.destroy(),this.scrollGroup.attr({translateY:1}),
	this.clipHeight=0);return a},scroll:function(a,e){var b=this.pages,d=b.length;a=this.currentPage+a;var g=this.clipHeight,f=this.options.navigation,k=this.pager,c=this.padding;a>d&&(a=d);0<a&&(void 0!==e&&t(e,this.chart),this.nav.attr({translateX:c,translateY:g+this.padding+7+this.titleHeight,visibility:"visible"}),this.up.attr({"class":1===a?"highcharts-legend-nav-inactive":"highcharts-legend-nav-active"}),k.attr({text:a+"/"+d}),this.down.attr({x:18+this.pager.getBBox().width,"class":a===d?"highcharts-legend-nav-inactive":
	"highcharts-legend-nav-active"}),this.up.attr({fill:1===a?f.inactiveColor:f.activeColor}).css({cursor:1===a?"default":"pointer"}),this.down.attr({fill:a===d?f.inactiveColor:f.activeColor}).css({cursor:a===d?"default":"pointer"}),e=-b[a-1]+this.initialItemY,this.scrollGroup.animate({translateY:e}),this.currentPage=a,this.positionCheckboxes(e))}};a.LegendSymbolMixin={drawRectangle:function(a,e){var b=a.symbolHeight,d=a.options.squareSymbol;e.legendSymbol=this.chart.renderer.rect(d?(a.symbolWidth-b)/
	2:0,a.baseline-b+1,d?b:a.symbolWidth,b,u(a.options.symbolRadius,b/2)).addClass("highcharts-point").attr({zIndex:3}).add(e.legendGroup)},drawLineMarker:function(a){var b=this.options,d=b.marker,g=a.symbolWidth,f=a.symbolHeight,k=f/2,l=this.chart.renderer,c=this.legendGroup;a=a.baseline-Math.round(.3*a.fontMetrics.b);var m;m={"stroke-width":b.lineWidth||0};b.dashStyle&&(m.dashstyle=b.dashStyle);this.legendLine=l.path(["M",0,a,"L",g,a]).addClass("highcharts-graph").attr(m).add(c);d&&!1!==d.enabled&&
	(b=Math.min(u(d.radius,k),k),0===this.symbol.indexOf("url")&&(d=r(d,{width:f,height:f}),b=0),this.legendSymbol=d=l.symbol(this.symbol,g/2-b,a-b,2*b,2*b,d).addClass("highcharts-point").add(c),d.isMarker=!0)}};(/Trident\/7\.0/.test(d.navigator.userAgent)||f)&&k(a.Legend.prototype,"positionItem",function(a,e){var b=this,d=function(){e._legendItemPos&&a.call(b,e)};d();setTimeout(d)})})(M);(function(a){var C=a.addEvent,A=a.animate,F=a.animObject,E=a.attr,m=a.doc,f=a.Axis,l=a.createElement,r=a.defaultOptions,
	u=a.discardElement,t=a.charts,g=a.css,d=a.defined,k=a.each,b=a.extend,e=a.find,v=a.fireEvent,y=a.getStyle,n=a.grep,D=a.isNumber,J=a.isObject,c=a.isString,G=a.Legend,q=a.marginNames,B=a.merge,K=a.objectEach,p=a.Pointer,z=a.pick,I=a.pInt,L=a.removeEvent,h=a.seriesTypes,w=a.splat,P=a.svg,H=a.syncTimeout,O=a.win,Q=a.Renderer,R=a.Chart=function(){this.getArgs.apply(this,arguments)};a.chart=function(a,b,c){return new R(a,b,c)};b(R.prototype,{callbacks:[],getArgs:function(){var a=[].slice.call(arguments);
	if(c(a[0])||a[0].nodeName)this.renderTo=a.shift();this.init(a[0],a[1])},init:function(b,c){var e,d,h=b.series,p=b.plotOptions||{};b.series=null;e=B(r,b);for(d in e.plotOptions)e.plotOptions[d].tooltip=p[d]&&B(p[d].tooltip)||void 0;e.tooltip.userOptions=b.chart&&b.chart.forExport&&b.tooltip.userOptions||b.tooltip;e.series=b.series=h;this.userOptions=b;b=e.chart;d=b.events;this.margin=[];this.spacing=[];this.bounds={h:{},v:{}};this.callback=c;this.isResizing=0;this.options=e;this.axes=[];this.series=
	[];this.hasCartesianSeries=b.showAxes;var g=this;g.index=t.length;t.push(g);a.chartCount++;d&&K(d,function(a,b){C(g,b,a)});g.xAxis=[];g.yAxis=[];g.pointCount=g.colorCounter=g.symbolCounter=0;g.firstRender()},initSeries:function(b){var c=this.options.chart;(c=h[b.type||c.type||c.defaultSeriesType])||a.error(17,!0);c=new c;c.init(this,b);return c},orderSeries:function(a){var b=this.series;for(a=a||0;a<b.length;a++)b[a]&&(b[a].index=a,b[a].name=b[a].name||"Series "+(b[a].index+1))},isInsidePlot:function(a,
	b,c){var e=c?b:a;a=c?a:b;return 0<=e&&e<=this.plotWidth&&0<=a&&a<=this.plotHeight},redraw:function(c){var e=this.axes,d=this.series,h=this.pointer,p=this.legend,g=this.isDirtyLegend,f,q,l=this.hasCartesianSeries,n=this.isDirtyBox,z,m=this.renderer,x=m.isHidden(),w=[];this.setResponsive&&this.setResponsive(!1);a.setAnimation(c,this);x&&this.temporaryDisplay();this.layOutTitles();for(c=d.length;c--;)if(z=d[c],z.options.stacking&&(f=!0,z.isDirty)){q=!0;break}if(q)for(c=d.length;c--;)z=d[c],z.options.stacking&&
	(z.isDirty=!0);k(d,function(a){a.isDirty&&"point"===a.options.legendType&&(a.updateTotals&&a.updateTotals(),g=!0);a.isDirtyData&&v(a,"updatedData")});g&&p.options.enabled&&(p.render(),this.isDirtyLegend=!1);f&&this.getStacks();l&&k(e,function(a){a.updateNames();a.setScale()});this.getMargins();l&&(k(e,function(a){a.isDirty&&(n=!0)}),k(e,function(a){var c=a.min+","+a.max;a.extKey!==c&&(a.extKey=c,w.push(function(){v(a,"afterSetExtremes",b(a.eventArgs,a.getExtremes()));delete a.eventArgs}));(n||f)&&
	a.redraw()}));n&&this.drawChartBox();v(this,"predraw");k(d,function(a){(n||a.isDirty)&&a.visible&&a.redraw();a.isDirtyData=!1});h&&h.reset(!0);m.draw();v(this,"redraw");v(this,"render");x&&this.temporaryDisplay(!0);k(w,function(a){a.call()})},get:function(a){function b(b){return b.id===a||b.options&&b.options.id===a}var c,d=this.series,h;c=e(this.axes,b)||e(this.series,b);for(h=0;!c&&h<d.length;h++)c=e(d[h].points||[],b);return c},getAxes:function(){var a=this,b=this.options,c=b.xAxis=w(b.xAxis||
	{}),b=b.yAxis=w(b.yAxis||{});k(c,function(a,b){a.index=b;a.isX=!0});k(b,function(a,b){a.index=b});c=c.concat(b);k(c,function(b){new f(a,b)})},getSelectedPoints:function(){var a=[];k(this.series,function(b){a=a.concat(n(b.data||[],function(a){return a.selected}))});return a},getSelectedSeries:function(){return n(this.series,function(a){return a.selected})},setTitle:function(a,b,c){var e=this,d=e.options,h;h=d.title=B({style:{color:"#333333",fontSize:d.isStock?"16px":"18px"}},d.title,a);d=d.subtitle=
	B({style:{color:"#666666"}},d.subtitle,b);k([["title",a,h],["subtitle",b,d]],function(a,b){var c=a[0],d=e[c],h=a[1];a=a[2];d&&h&&(e[c]=d=d.destroy());a&&a.text&&!d&&(e[c]=e.renderer.text(a.text,0,0,a.useHTML).attr({align:a.align,"class":"highcharts-"+c,zIndex:a.zIndex||4}).add(),e[c].update=function(a){e.setTitle(!b&&a,b&&a)},e[c].css(a.style))});e.layOutTitles(c)},layOutTitles:function(a){var c=0,e,d=this.renderer,h=this.spacingBox;k(["title","subtitle"],function(a){var e=this[a],p=this.options[a];
	a="title"===a?-3:p.verticalAlign?0:c+2;var g;e&&(g=p.style.fontSize,g=d.fontMetrics(g,e).b,e.css({width:(p.width||h.width+p.widthAdjust)+"px"}).align(b({y:a+g},p),!1,"spacingBox"),p.floating||p.verticalAlign||(c=Math.ceil(c+e.getBBox(p.useHTML).height)))},this);e=this.titleOffset!==c;this.titleOffset=c;!this.isDirtyBox&&e&&(this.isDirtyBox=e,this.hasRendered&&z(a,!0)&&this.isDirtyBox&&this.redraw())},getChartSize:function(){var b=this.options.chart,c=b.width,b=b.height,e=this.renderTo;d(c)||(this.containerWidth=
	y(e,"width"));d(b)||(this.containerHeight=y(e,"height"));this.chartWidth=Math.max(0,c||this.containerWidth||600);this.chartHeight=Math.max(0,a.relativeLength(b,this.chartWidth)||this.containerHeight||400)},temporaryDisplay:function(b){var c=this.renderTo;if(b)for(;c&&c.style;)c.hcOrigStyle&&(a.css(c,c.hcOrigStyle),delete c.hcOrigStyle),c.hcOrigDetached&&(m.body.removeChild(c),c.hcOrigDetached=!1),c=c.parentNode;else for(;c&&c.style;){m.body.contains(c)||(c.hcOrigDetached=!0,m.body.appendChild(c));
	if("none"===y(c,"display",!1)||c.hcOricDetached)c.hcOrigStyle={display:c.style.display,height:c.style.height,overflow:c.style.overflow},b={display:"block",overflow:"hidden"},c!==this.renderTo&&(b.height=0),a.css(c,b),c.offsetWidth||c.style.setProperty("display","block","important");c=c.parentNode;if(c===m.body)break}},setClassName:function(a){this.container.className="highcharts-container "+(a||"")},getContainer:function(){var e,d=this.options,h=d.chart,p,g;e=this.renderTo;var f=a.uniqueKey(),k;e||
	(this.renderTo=e=h.renderTo);c(e)&&(this.renderTo=e=m.getElementById(e));e||a.error(13,!0);p=I(E(e,"data-highcharts-chart"));D(p)&&t[p]&&t[p].hasRendered&&t[p].destroy();E(e,"data-highcharts-chart",this.index);e.innerHTML="";h.skipClone||e.offsetWidth||this.temporaryDisplay();this.getChartSize();p=this.chartWidth;g=this.chartHeight;k=b({position:"relative",overflow:"hidden",width:p+"px",height:g+"px",textAlign:"left",lineHeight:"normal",zIndex:0,"-webkit-tap-highlight-color":"rgba(0,0,0,0)"},h.style);
	this.container=e=l("div",{id:f},k,e);this._cursor=e.style.cursor;this.renderer=new (a[h.renderer]||Q)(e,p,g,null,h.forExport,d.exporting&&d.exporting.allowHTML);this.setClassName(h.className);this.renderer.setStyle(h.style);this.renderer.chartIndex=this.index},getMargins:function(a){var b=this.spacing,c=this.margin,e=this.titleOffset;this.resetMargins();e&&!d(c[0])&&(this.plotTop=Math.max(this.plotTop,e+this.options.title.margin+b[0]));this.legend.display&&this.legend.adjustMargins(c,b);this.extraMargin&&
	(this[this.extraMargin.type]=(this[this.extraMargin.type]||0)+this.extraMargin.value);this.extraTopMargin&&(this.plotTop+=this.extraTopMargin);a||this.getAxisMargins()},getAxisMargins:function(){var a=this,b=a.axisOffset=[0,0,0,0],c=a.margin;a.hasCartesianSeries&&k(a.axes,function(a){a.visible&&a.getOffset()});k(q,function(e,h){d(c[h])||(a[e]+=b[h])});a.setChartSize()},reflow:function(a){var b=this,c=b.options.chart,e=b.renderTo,h=d(c.width)&&d(c.height),p=c.width||y(e,"width"),c=c.height||y(e,"height"),
	e=a?a.target:O;if(!h&&!b.isPrinting&&p&&c&&(e===O||e===m)){if(p!==b.containerWidth||c!==b.containerHeight)clearTimeout(b.reflowTimeout),b.reflowTimeout=H(function(){b.container&&b.setSize(void 0,void 0,!1)},a?100:0);b.containerWidth=p;b.containerHeight=c}},initReflow:function(){var a=this,b;b=C(O,"resize",function(b){a.reflow(b)});C(a,"destroy",b)},setSize:function(b,c,e){var d=this,h=d.renderer;d.isResizing+=1;a.setAnimation(e,d);d.oldChartHeight=d.chartHeight;d.oldChartWidth=d.chartWidth;void 0!==
	b&&(d.options.chart.width=b);void 0!==c&&(d.options.chart.height=c);d.getChartSize();b=h.globalAnimation;(b?A:g)(d.container,{width:d.chartWidth+"px",height:d.chartHeight+"px"},b);d.setChartSize(!0);h.setSize(d.chartWidth,d.chartHeight,e);k(d.axes,function(a){a.isDirty=!0;a.setScale()});d.isDirtyLegend=!0;d.isDirtyBox=!0;d.layOutTitles();d.getMargins();d.redraw(e);d.oldChartHeight=null;v(d,"resize");H(function(){d&&v(d,"endResize",null,function(){--d.isResizing})},F(b).duration)},setChartSize:function(a){function b(a){a=
	f[a]||0;return Math.max(m||a,a)/2}var c=this.inverted,e=this.renderer,d=this.chartWidth,h=this.chartHeight,p=this.options.chart,g=this.spacing,f=this.clipOffset,q,n,l,z,m;this.plotLeft=q=Math.round(this.plotLeft);this.plotTop=n=Math.round(this.plotTop);this.plotWidth=l=Math.max(0,Math.round(d-q-this.marginRight));this.plotHeight=z=Math.max(0,Math.round(h-n-this.marginBottom));this.plotSizeX=c?z:l;this.plotSizeY=c?l:z;this.plotBorderWidth=p.plotBorderWidth||0;this.spacingBox=e.spacingBox={x:g[3],y:g[0],
	width:d-g[3]-g[1],height:h-g[0]-g[2]};this.plotBox=e.plotBox={x:q,y:n,width:l,height:z};m=2*Math.floor(this.plotBorderWidth/2);c=Math.ceil(b(3));e=Math.ceil(b(0));this.clipBox={x:c,y:e,width:Math.floor(this.plotSizeX-b(1)-c),height:Math.max(0,Math.floor(this.plotSizeY-b(2)-e))};a||k(this.axes,function(a){a.setAxisSize();a.setAxisTranslation()})},resetMargins:function(){var a=this,b=a.options.chart;k(["margin","spacing"],function(c){var e=b[c],d=J(e)?e:[e,e,e,e];k(["Top","Right","Bottom","Left"],function(e,
	h){a[c][h]=z(b[c+e],d[h])})});k(q,function(b,c){a[b]=z(a.margin[c],a.spacing[c])});a.axisOffset=[0,0,0,0];a.clipOffset=[]},drawChartBox:function(){var a=this.options.chart,b=this.renderer,c=this.chartWidth,e=this.chartHeight,d=this.chartBackground,h=this.plotBackground,p=this.plotBorder,g,f=this.plotBGImage,k=a.backgroundColor,q=a.plotBackgroundColor,l=a.plotBackgroundImage,n,z=this.plotLeft,m=this.plotTop,w=this.plotWidth,I=this.plotHeight,v=this.plotBox,r=this.clipRect,B=this.clipBox,y="animate";
	d||(this.chartBackground=d=b.rect().addClass("highcharts-background").add(),y="attr");g=a.borderWidth||0;n=g+(a.shadow?8:0);k={fill:k||"none"};if(g||d["stroke-width"])k.stroke=a.borderColor,k["stroke-width"]=g;d.attr(k).shadow(a.shadow);d[y]({x:n/2,y:n/2,width:c-n-g%2,height:e-n-g%2,r:a.borderRadius});y="animate";h||(y="attr",this.plotBackground=h=b.rect().addClass("highcharts-plot-background").add());h[y](v);h.attr({fill:q||"none"}).shadow(a.plotShadow);l&&(f?f.animate(v):this.plotBGImage=b.image(l,
	z,m,w,I).add());r?r.animate({width:B.width,height:B.height}):this.clipRect=b.clipRect(B);y="animate";p||(y="attr",this.plotBorder=p=b.rect().addClass("highcharts-plot-border").attr({zIndex:1}).add());p.attr({stroke:a.plotBorderColor,"stroke-width":a.plotBorderWidth||0,fill:"none"});p[y](p.crisp({x:z,y:m,width:w,height:I},-p.strokeWidth()));this.isDirtyBox=!1},propFromSeries:function(){var a=this,b=a.options.chart,c,e=a.options.series,d,p;k(["inverted","angular","polar"],function(g){c=h[b.type||b.defaultSeriesType];
	p=b[g]||c&&c.prototype[g];for(d=e&&e.length;!p&&d--;)(c=h[e[d].type])&&c.prototype[g]&&(p=!0);a[g]=p})},linkSeries:function(){var a=this,b=a.series;k(b,function(a){a.linkedSeries.length=0});k(b,function(b){var e=b.options.linkedTo;c(e)&&(e=":previous"===e?a.series[b.index-1]:a.get(e))&&e.linkedParent!==b&&(e.linkedSeries.push(b),b.linkedParent=e,b.visible=z(b.options.visible,e.options.visible,b.visible))})},renderSeries:function(){k(this.series,function(a){a.translate();a.render()})},renderLabels:function(){var a=
	this,c=a.options.labels;c.items&&k(c.items,function(e){var d=b(c.style,e.style),h=I(d.left)+a.plotLeft,p=I(d.top)+a.plotTop+12;delete d.left;delete d.top;a.renderer.text(e.html,h,p).attr({zIndex:2}).css(d).add()})},render:function(){var a=this.axes,b=this.renderer,c=this.options,e,d,h;this.setTitle();this.legend=new G(this,c.legend);this.getStacks&&this.getStacks();this.getMargins(!0);this.setChartSize();c=this.plotWidth;e=this.plotHeight-=21;k(a,function(a){a.setScale()});this.getAxisMargins();d=
	1.1<c/this.plotWidth;h=1.05<e/this.plotHeight;if(d||h)k(a,function(a){(a.horiz&&d||!a.horiz&&h)&&a.setTickInterval(!0)}),this.getMargins();this.drawChartBox();this.hasCartesianSeries&&k(a,function(a){a.visible&&a.render()});this.seriesGroup||(this.seriesGroup=b.g("series-group").attr({zIndex:3}).add());this.renderSeries();this.renderLabels();this.addCredits();this.setResponsive&&this.setResponsive();this.hasRendered=!0},addCredits:function(a){var b=this;a=B(!0,this.options.credits,a);a.enabled&&!this.credits&&
	(this.credits=this.renderer.text(a.text+(this.mapCredits||""),0,0).addClass("highcharts-credits").on("click",function(){a.href&&(O.location.href=a.href)}).attr({align:a.position.align,zIndex:8}).css(a.style).add().align(a.position),this.credits.update=function(a){b.credits=b.credits.destroy();b.addCredits(a)})},destroy:function(){var b=this,c=b.axes,e=b.series,d=b.container,h,p=d&&d.parentNode;v(b,"destroy");b.renderer.forExport?a.erase(t,b):t[b.index]=void 0;a.chartCount--;b.renderTo.removeAttribute("data-highcharts-chart");
	L(b);for(h=c.length;h--;)c[h]=c[h].destroy();this.scroller&&this.scroller.destroy&&this.scroller.destroy();for(h=e.length;h--;)e[h]=e[h].destroy();k("title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" "),function(a){var c=b[a];c&&c.destroy&&(b[a]=c.destroy())});d&&(d.innerHTML="",L(d),p&&u(d));K(b,function(a,c){delete b[c]})},isReadyToRender:function(){var a=this;return P||O!=O.top||
	"complete"===m.readyState?!0:(m.attachEvent("onreadystatechange",function(){m.detachEvent("onreadystatechange",a.firstRender);"complete"===m.readyState&&a.firstRender()}),!1)},firstRender:function(){var a=this,b=a.options;if(a.isReadyToRender()){a.getContainer();v(a,"init");a.resetMargins();a.setChartSize();a.propFromSeries();a.getAxes();k(b.series||[],function(b){a.initSeries(b)});a.linkSeries();v(a,"beforeRender");p&&(a.pointer=new p(a,b));a.render();if(!a.renderer.imgCount&&a.onload)a.onload();
	a.temporaryDisplay(!0)}},onload:function(){k([this.callback].concat(this.callbacks),function(a){a&&void 0!==this.index&&a.apply(this,[this])},this);v(this,"load");v(this,"render");d(this.index)&&!1!==this.options.chart.reflow&&this.initReflow();this.onload=null}})})(M);(function(a){var C,A=a.each,F=a.extend,E=a.erase,m=a.fireEvent,f=a.format,l=a.isArray,r=a.isNumber,u=a.pick,t=a.removeEvent;a.Point=C=function(){};a.Point.prototype={init:function(a,d,f){this.series=a;this.color=a.color;this.applyOptions(d,
	f);a.options.colorByPoint?(d=a.options.colors||a.chart.options.colors,this.color=this.color||d[a.colorCounter],d=d.length,f=a.colorCounter,a.colorCounter++,a.colorCounter===d&&(a.colorCounter=0)):f=a.colorIndex;this.colorIndex=u(this.colorIndex,f);a.chart.pointCount++;return this},applyOptions:function(a,d){var g=this.series,b=g.options.pointValKey||g.pointValKey;a=C.prototype.optionsToObject.call(this,a);F(this,a);this.options=this.options?F(this.options,a):a;a.group&&delete this.group;b&&(this.y=
	this[b]);this.isNull=u(this.isValid&&!this.isValid(),null===this.x||!r(this.y,!0));this.selected&&(this.state="select");"name"in this&&void 0===d&&g.xAxis&&g.xAxis.hasNames&&(this.x=g.xAxis.nameToX(this));void 0===this.x&&g&&(this.x=void 0===d?g.autoIncrement(this):d);return this},optionsToObject:function(a){var d={},g=this.series,b=g.options.keys,e=b||g.pointArrayMap||["y"],f=e.length,m=0,n=0;if(r(a)||null===a)d[e[0]]=a;else if(l(a))for(!b&&a.length>f&&(g=typeof a[0],"string"===g?d.name=a[0]:"number"===
	g&&(d.x=a[0]),m++);n<f;)b&&void 0===a[m]||(d[e[n]]=a[m]),m++,n++;else"object"===typeof a&&(d=a,a.dataLabels&&(g._hasPointLabels=!0),a.marker&&(g._hasPointMarkers=!0));return d},getClassName:function(){return"highcharts-point"+(this.selected?" highcharts-point-select":"")+(this.negative?" highcharts-negative":"")+(this.isNull?" highcharts-null-point":"")+(void 0!==this.colorIndex?" highcharts-color-"+this.colorIndex:"")+(this.options.className?" "+this.options.className:"")+(this.zone&&this.zone.className?
	" "+this.zone.className.replace("highcharts-negative",""):"")},getZone:function(){var a=this.series,d=a.zones,a=a.zoneAxis||"y",f=0,b;for(b=d[f];this[a]>=b.value;)b=d[++f];b&&b.color&&!this.options.color&&(this.color=b.color);return b},destroy:function(){var a=this.series.chart,d=a.hoverPoints,f;a.pointCount--;d&&(this.setState(),E(d,this),d.length||(a.hoverPoints=null));if(this===a.hoverPoint)this.onMouseOut();if(this.graphic||this.dataLabel)t(this),this.destroyElements();this.legendItem&&a.legend.destroyItem(this);
	for(f in this)this[f]=null},destroyElements:function(){for(var a=["graphic","dataLabel","dataLabelUpper","connector","shadowGroup"],d,f=6;f--;)d=a[f],this[d]&&(this[d]=this[d].destroy())},getLabelConfig:function(){return{x:this.category,y:this.y,color:this.color,colorIndex:this.colorIndex,key:this.name||this.category,series:this.series,point:this,percentage:this.percentage,total:this.total||this.stackTotal}},tooltipFormatter:function(a){var d=this.series,g=d.tooltipOptions,b=u(g.valueDecimals,""),
	e=g.valuePrefix||"",l=g.valueSuffix||"";A(d.pointArrayMap||["y"],function(d){d="{point."+d;if(e||l)a=a.replace(d+"}",e+d+"}"+l);a=a.replace(d+"}",d+":,."+b+"f}")});return f(a,{point:this,series:this.series})},firePointEvent:function(a,d,f){var b=this,e=this.series.options;(e.point.events[a]||b.options&&b.options.events&&b.options.events[a])&&this.importEvents();"click"===a&&e.allowPointSelect&&(f=function(a){b.select&&b.select(null,a.ctrlKey||a.metaKey||a.shiftKey)});m(this,a,d,f)},visible:!0}})(M);
	(function(a){var C=a.addEvent,A=a.animObject,F=a.arrayMax,E=a.arrayMin,m=a.correctFloat,f=a.Date,l=a.defaultOptions,r=a.defaultPlotOptions,u=a.defined,t=a.each,g=a.erase,d=a.extend,k=a.fireEvent,b=a.grep,e=a.isArray,v=a.isNumber,y=a.isString,n=a.merge,D=a.objectEach,J=a.pick,c=a.removeEvent,G=a.splat,q=a.SVGElement,B=a.syncTimeout,K=a.win;a.Series=a.seriesType("line",null,{lineWidth:2,allowPointSelect:!1,showCheckbox:!1,animation:{duration:1E3},events:{},marker:{lineWidth:0,lineColor:"#ffffff",radius:4,
	states:{hover:{animation:{duration:50},enabled:!0,radiusPlus:2,lineWidthPlus:1},select:{fillColor:"#cccccc",lineColor:"#000000",lineWidth:2}}},point:{events:{}},dataLabels:{align:"center",formatter:function(){return null===this.y?"":a.numberFormat(this.y,-1)},style:{fontSize:"11px",fontWeight:"bold",color:"contrast",textOutline:"1px contrast"},verticalAlign:"bottom",x:0,y:0,padding:5},cropThreshold:300,pointRange:0,softThreshold:!0,states:{hover:{animation:{duration:50},lineWidthPlus:1,marker:{},
	halo:{size:10,opacity:.25}},select:{marker:{}}},stickyTracking:!0,turboThreshold:1E3,findNearestPointBy:"x"},{isCartesian:!0,pointClass:a.Point,sorted:!0,requireSorting:!0,directTouch:!1,axisTypes:["xAxis","yAxis"],colorCounter:0,parallelArrays:["x","y"],coll:"series",init:function(a,b){var c=this,e,h=a.series,p;c.chart=a;c.options=b=c.setOptions(b);c.linkedSeries=[];c.bindAxes();d(c,{name:b.name,state:"",visible:!1!==b.visible,selected:!0===b.selected});e=b.events;D(e,function(a,b){C(c,b,a)});if(e&&
	e.click||b.point&&b.point.events&&b.point.events.click||b.allowPointSelect)a.runTrackerClick=!0;c.getColor();c.getSymbol();t(c.parallelArrays,function(a){c[a+"Data"]=[]});c.setData(b.data,!1);c.isCartesian&&(a.hasCartesianSeries=!0);h.length&&(p=h[h.length-1]);c._i=J(p&&p._i,-1)+1;a.orderSeries(this.insert(h))},insert:function(a){var b=this.options.index,c;if(v(b)){for(c=a.length;c--;)if(b>=J(a[c].options.index,a[c]._i)){a.splice(c+1,0,this);break}-1===c&&a.unshift(this);c+=1}else a.push(this);return J(c,
	a.length-1)},bindAxes:function(){var b=this,c=b.options,e=b.chart,d;t(b.axisTypes||[],function(h){t(e[h],function(a){d=a.options;if(c[h]===d.index||void 0!==c[h]&&c[h]===d.id||void 0===c[h]&&0===d.index)b.insert(a.series),b[h]=a,a.isDirty=!0});b[h]||b.optionalAxis===h||a.error(18,!0)})},updateParallelArrays:function(a,b){var c=a.series,e=arguments,d=v(b)?function(e){var d="y"===e&&c.toYData?c.toYData(a):a[e];c[e+"Data"][b]=d}:function(a){Array.prototype[b].apply(c[a+"Data"],Array.prototype.slice.call(e,
	2))};t(c.parallelArrays,d)},autoIncrement:function(){var a=this.options,b=this.xIncrement,c,e=a.pointIntervalUnit,b=J(b,a.pointStart,0);this.pointInterval=c=J(this.pointInterval,a.pointInterval,1);e&&(a=new f(b),"day"===e?a=+a[f.hcSetDate](a[f.hcGetDate]()+c):"month"===e?a=+a[f.hcSetMonth](a[f.hcGetMonth]()+c):"year"===e&&(a=+a[f.hcSetFullYear](a[f.hcGetFullYear]()+c)),c=a-b);this.xIncrement=b+c;return b},setOptions:function(a){var b=this.chart,c=b.options,e=c.plotOptions,d=(b.userOptions||{}).plotOptions||
	{},p=e[this.type];this.userOptions=a;b=n(p,e.series,a);this.tooltipOptions=n(l.tooltip,l.plotOptions.series&&l.plotOptions.series.tooltip,l.plotOptions[this.type].tooltip,c.tooltip.userOptions,e.series&&e.series.tooltip,e[this.type].tooltip,a.tooltip);this.stickyTracking=J(a.stickyTracking,d[this.type]&&d[this.type].stickyTracking,d.series&&d.series.stickyTracking,this.tooltipOptions.shared&&!this.noSharedTooltip?!0:b.stickyTracking);null===p.marker&&delete b.marker;this.zoneAxis=b.zoneAxis;a=this.zones=
	(b.zones||[]).slice();!b.negativeColor&&!b.negativeFillColor||b.zones||a.push({value:b[this.zoneAxis+"Threshold"]||b.threshold||0,className:"highcharts-negative",color:b.negativeColor,fillColor:b.negativeFillColor});a.length&&u(a[a.length-1].value)&&a.push({color:this.color,fillColor:this.fillColor});return b},getCyclic:function(a,b,c){var e,d=this.chart,p=this.userOptions,f=a+"Index",g=a+"Counter",k=c?c.length:J(d.options.chart[a+"Count"],d[a+"Count"]);b||(e=J(p[f],p["_"+f]),u(e)||(d.series.length||
	(d[g]=0),p["_"+f]=e=d[g]%k,d[g]+=1),c&&(b=c[e]));void 0!==e&&(this[f]=e);this[a]=b},getColor:function(){this.options.colorByPoint?this.options.color=null:this.getCyclic("color",this.options.color||r[this.type].color,this.chart.options.colors)},getSymbol:function(){this.getCyclic("symbol",this.options.marker.symbol,this.chart.options.symbols)},drawLegendSymbol:a.LegendSymbolMixin.drawLineMarker,setData:function(b,c,d,f){var h=this,p=h.points,g=p&&p.length||0,k,q=h.options,l=h.chart,n=null,m=h.xAxis,
	z=q.turboThreshold,r=this.xData,B=this.yData,I=(k=h.pointArrayMap)&&k.length;b=b||[];k=b.length;c=J(c,!0);if(!1!==f&&k&&g===k&&!h.cropped&&!h.hasGroupedData&&h.visible)t(b,function(a,b){p[b].update&&a!==q.data[b]&&p[b].update(a,!1,null,!1)});else{h.xIncrement=null;h.colorCounter=0;t(this.parallelArrays,function(a){h[a+"Data"].length=0});if(z&&k>z){for(d=0;null===n&&d<k;)n=b[d],d++;if(v(n))for(d=0;d<k;d++)r[d]=this.autoIncrement(),B[d]=b[d];else if(e(n))if(I)for(d=0;d<k;d++)n=b[d],r[d]=n[0],B[d]=n.slice(1,
	I+1);else for(d=0;d<k;d++)n=b[d],r[d]=n[0],B[d]=n[1];else a.error(12)}else for(d=0;d<k;d++)void 0!==b[d]&&(n={series:h},h.pointClass.prototype.applyOptions.apply(n,[b[d]]),h.updateParallelArrays(n,d));y(B[0])&&a.error(14,!0);h.data=[];h.options.data=h.userOptions.data=b;for(d=g;d--;)p[d]&&p[d].destroy&&p[d].destroy();m&&(m.minRange=m.userMinRange);h.isDirty=l.isDirtyBox=!0;h.isDirtyData=!!p;d=!1}"point"===q.legendType&&(this.processData(),this.generatePoints());c&&l.redraw(d)},processData:function(b){var c=
	this.xData,e=this.yData,d=c.length,h;h=0;var p,f,g=this.xAxis,k,q=this.options;k=q.cropThreshold;var n=this.getExtremesFromAll||q.getExtremesFromAll,l=this.isCartesian,q=g&&g.val2lin,m=g&&g.isLog,v,r;if(l&&!this.isDirty&&!g.isDirty&&!this.yAxis.isDirty&&!b)return!1;g&&(b=g.getExtremes(),v=b.min,r=b.max);if(l&&this.sorted&&!n&&(!k||d>k||this.forceCrop))if(c[d-1]<v||c[0]>r)c=[],e=[];else if(c[0]<v||c[d-1]>r)h=this.cropData(this.xData,this.yData,v,r),c=h.xData,e=h.yData,h=h.start,p=!0;for(k=c.length||
	1;--k;)d=m?q(c[k])-q(c[k-1]):c[k]-c[k-1],0<d&&(void 0===f||d<f)?f=d:0>d&&this.requireSorting&&a.error(15);this.cropped=p;this.cropStart=h;this.processedXData=c;this.processedYData=e;this.closestPointRange=f},cropData:function(a,b,c,e){var d=a.length,p=0,g=d,f=J(this.cropShoulder,1),k;for(k=0;k<d;k++)if(a[k]>=c){p=Math.max(0,k-f);break}for(c=k;c<d;c++)if(a[c]>e){g=c+f;break}return{xData:a.slice(p,g),yData:b.slice(p,g),start:p,end:g}},generatePoints:function(){var a=this.options,b=a.data,c=this.data,
	e,d=this.processedXData,g=this.processedYData,f=this.pointClass,k=d.length,q=this.cropStart||0,n,l=this.hasGroupedData,a=a.keys,m,v=[],r;c||l||(c=[],c.length=b.length,c=this.data=c);a&&l&&(this.options.keys=!1);for(r=0;r<k;r++)n=q+r,l?(m=(new f).init(this,[d[r]].concat(G(g[r]))),m.dataGroup=this.groupMap[r]):(m=c[n])||void 0===b[n]||(c[n]=m=(new f).init(this,b[n],d[r])),m&&(m.index=n,v[r]=m);this.options.keys=a;if(c&&(k!==(e=c.length)||l))for(r=0;r<e;r++)r!==q||l||(r+=k),c[r]&&(c[r].destroyElements(),
	c[r].plotX=void 0);this.data=c;this.points=v},getExtremes:function(a){var b=this.yAxis,c=this.processedXData,d,h=[],p=0;d=this.xAxis.getExtremes();var g=d.min,f=d.max,k,q,n,l;a=a||this.stackedYData||this.processedYData||[];d=a.length;for(l=0;l<d;l++)if(q=c[l],n=a[l],k=(v(n,!0)||e(n))&&(!b.positiveValuesOnly||n.length||0<n),q=this.getExtremesFromAll||this.options.getExtremesFromAll||this.cropped||(c[l]||q)>=g&&(c[l]||q)<=f,k&&q)if(k=n.length)for(;k--;)null!==n[k]&&(h[p++]=n[k]);else h[p++]=n;this.dataMin=
	E(h);this.dataMax=F(h)},translate:function(){this.processedXData||this.processData();this.generatePoints();var a=this.options,b=a.stacking,c=this.xAxis,e=c.categories,d=this.yAxis,g=this.points,f=g.length,k=!!this.modifyValue,q=a.pointPlacement,n="between"===q||v(q),l=a.threshold,r=a.startFromThreshold?l:0,B,y,t,G,D=Number.MAX_VALUE;"between"===q&&(q=.5);v(q)&&(q*=J(a.pointRange||c.pointRange));for(a=0;a<f;a++){var K=g[a],A=K.x,C=K.y;y=K.low;var E=b&&d.stacks[(this.negStacks&&C<(r?0:l)?"-":"")+this.stackKey],
	F;d.positiveValuesOnly&&null!==C&&0>=C&&(K.isNull=!0);K.plotX=B=m(Math.min(Math.max(-1E5,c.translate(A,0,0,0,1,q,"flags"===this.type)),1E5));b&&this.visible&&!K.isNull&&E&&E[A]&&(G=this.getStackIndicator(G,A,this.index),F=E[A],C=F.points[G.key],y=C[0],C=C[1],y===r&&G.key===E[A].base&&(y=J(l,d.min)),d.positiveValuesOnly&&0>=y&&(y=null),K.total=K.stackTotal=F.total,K.percentage=F.total&&K.y/F.total*100,K.stackY=C,F.setOffset(this.pointXOffset||0,this.barW||0));K.yBottom=u(y)?d.translate(y,0,1,0,1):
	null;k&&(C=this.modifyValue(C,K));K.plotY=y="number"===typeof C&&Infinity!==C?Math.min(Math.max(-1E5,d.translate(C,0,1,0,1)),1E5):void 0;K.isInside=void 0!==y&&0<=y&&y<=d.len&&0<=B&&B<=c.len;K.clientX=n?m(c.translate(A,0,0,0,1,q)):B;K.negative=K.y<(l||0);K.category=e&&void 0!==e[K.x]?e[K.x]:K.x;K.isNull||(void 0!==t&&(D=Math.min(D,Math.abs(B-t))),t=B);K.zone=this.zones.length&&K.getZone()}this.closestPointRangePx=D},getValidPoints:function(a,c){var e=this.chart;return b(a||this.points||[],function(a){return c&&
	!e.isInsidePlot(a.plotX,a.plotY,e.inverted)?!1:!a.isNull})},setClip:function(a){var b=this.chart,c=this.options,e=b.renderer,d=b.inverted,p=this.clipBox,g=p||b.clipBox,f=this.sharedClipKey||["_sharedClip",a&&a.duration,a&&a.easing,g.height,c.xAxis,c.yAxis].join(),k=b[f],q=b[f+"m"];k||(a&&(g.width=0,b[f+"m"]=q=e.clipRect(-99,d?-b.plotLeft:-b.plotTop,99,d?b.chartWidth:b.chartHeight)),b[f]=k=e.clipRect(g),k.count={length:0});a&&!k.count[this.index]&&(k.count[this.index]=!0,k.count.length+=1);!1!==c.clip&&
	(this.group.clip(a||p?k:b.clipRect),this.markerGroup.clip(q),this.sharedClipKey=f);a||(k.count[this.index]&&(delete k.count[this.index],--k.count.length),0===k.count.length&&f&&b[f]&&(p||(b[f]=b[f].destroy()),b[f+"m"]&&(b[f+"m"]=b[f+"m"].destroy())))},animate:function(a){var b=this.chart,c=A(this.options.animation),e;a?this.setClip(c):(e=this.sharedClipKey,(a=b[e])&&a.animate({width:b.plotSizeX},c),b[e+"m"]&&b[e+"m"].animate({width:b.plotSizeX+99},c),this.animate=null)},afterAnimate:function(){this.setClip();
	k(this,"afterAnimate");this.finishedAnimating=!0},drawPoints:function(){var a=this.points,b=this.chart,c,e,d,f,g=this.options.marker,k,q,n,l,m=this[this.specialGroup]||this.markerGroup,r=J(g.enabled,this.xAxis.isRadial?!0:null,this.closestPointRangePx>=2*g.radius);if(!1!==g.enabled||this._hasPointMarkers)for(e=0;e<a.length;e++)d=a[e],c=d.plotY,f=d.graphic,k=d.marker||{},q=!!d.marker,n=r&&void 0===k.enabled||k.enabled,l=d.isInside,n&&v(c)&&null!==d.y?(c=J(k.symbol,this.symbol),d.hasImage=0===c.indexOf("url"),
	n=this.markerAttribs(d,d.selected&&"select"),f?f[l?"show":"hide"](!0).animate(n):l&&(0<n.width||d.hasImage)&&(d.graphic=f=b.renderer.symbol(c,n.x,n.y,n.width,n.height,q?k:g).add(m)),f&&f.attr(this.pointAttribs(d,d.selected&&"select")),f&&f.addClass(d.getClassName(),!0)):f&&(d.graphic=f.destroy())},markerAttribs:function(a,b){var c=this.options.marker,e=a.marker||{},d=J(e.radius,c.radius);b&&(c=c.states[b],b=e.states&&e.states[b],d=J(b&&b.radius,c&&c.radius,d+(c&&c.radiusPlus||0)));a.hasImage&&(d=
	0);a={x:Math.floor(a.plotX)-d,y:a.plotY-d};d&&(a.width=a.height=2*d);return a},pointAttribs:function(a,b){var c=this.options.marker,e=a&&a.options,d=e&&e.marker||{},f=this.color,g=e&&e.color,p=a&&a.color,e=J(d.lineWidth,c.lineWidth);a=a&&a.zone&&a.zone.color;f=g||a||p||f;a=d.fillColor||c.fillColor||f;f=d.lineColor||c.lineColor||f;b&&(c=c.states[b],b=d.states&&d.states[b]||{},e=J(b.lineWidth,c.lineWidth,e+J(b.lineWidthPlus,c.lineWidthPlus,0)),a=b.fillColor||c.fillColor||a,f=b.lineColor||c.lineColor||
	f);return{stroke:f,"stroke-width":e,fill:a}},destroy:function(){var a=this,b=a.chart,e=/AppleWebKit\/533/.test(K.navigator.userAgent),d,h,f=a.data||[],n,l;k(a,"destroy");c(a);t(a.axisTypes||[],function(b){(l=a[b])&&l.series&&(g(l.series,a),l.isDirty=l.forceRedraw=!0)});a.legendItem&&a.chart.legend.destroyItem(a);for(h=f.length;h--;)(n=f[h])&&n.destroy&&n.destroy();a.points=null;clearTimeout(a.animationTimeout);D(a,function(a,b){a instanceof q&&!a.survive&&(d=e&&"group"===b?"hide":"destroy",a[d]())});
	b.hoverSeries===a&&(b.hoverSeries=null);g(b.series,a);b.orderSeries();D(a,function(b,c){delete a[c]})},getGraphPath:function(a,b,c){var e=this,d=e.options,f=d.step,g,p=[],k=[],q;a=a||e.points;(g=a.reversed)&&a.reverse();(f={right:1,center:2}[f]||f&&3)&&g&&(f=4-f);!d.connectNulls||b||c||(a=this.getValidPoints(a));t(a,function(h,g){var n=h.plotX,l=h.plotY,m=a[g-1];(h.leftCliff||m&&m.rightCliff)&&!c&&(q=!0);h.isNull&&!u(b)&&0<g?q=!d.connectNulls:h.isNull&&!b?q=!0:(0===g||q?g=["M",h.plotX,h.plotY]:e.getPointSpline?
	g=e.getPointSpline(a,h,g):f?(g=1===f?["L",m.plotX,l]:2===f?["L",(m.plotX+n)/2,m.plotY,"L",(m.plotX+n)/2,l]:["L",n,m.plotY],g.push("L",n,l)):g=["L",n,l],k.push(h.x),f&&k.push(h.x),p.push.apply(p,g),q=!1)});p.xMap=k;return e.graphPath=p},drawGraph:function(){var a=this,b=this.options,c=(this.gappedPath||this.getGraphPath).call(this),e=[["graph","highcharts-graph",b.lineColor||this.color,b.dashStyle]];t(this.zones,function(c,d){e.push(["zone-graph-"+d,"highcharts-graph highcharts-zone-graph-"+d+" "+
	(c.className||""),c.color||a.color,c.dashStyle||b.dashStyle])});t(e,function(e,d){var h=e[0],f=a[h];f?(f.endX=c.xMap,f.animate({d:c})):c.length&&(a[h]=a.chart.renderer.path(c).addClass(e[1]).attr({zIndex:1}).add(a.group),f={stroke:e[2],"stroke-width":b.lineWidth,fill:a.fillGraph&&a.color||"none"},e[3]?f.dashstyle=e[3]:"square"!==b.linecap&&(f["stroke-linecap"]=f["stroke-linejoin"]="round"),f=a[h].attr(f).shadow(2>d&&b.shadow));f&&(f.startX=c.xMap,f.isArea=c.isArea)})},applyZones:function(){var a=
	this,b=this.chart,c=b.renderer,e=this.zones,d,f,g=this.clips||[],k,q=this.graph,n=this.area,l=Math.max(b.chartWidth,b.chartHeight),m=this[(this.zoneAxis||"y")+"Axis"],r,v,B=b.inverted,y,u,G,D,K=!1;e.length&&(q||n)&&m&&void 0!==m.min&&(v=m.reversed,y=m.horiz,q&&q.hide(),n&&n.hide(),r=m.getExtremes(),t(e,function(e,h){d=v?y?b.plotWidth:0:y?0:m.toPixels(r.min);d=Math.min(Math.max(J(f,d),0),l);f=Math.min(Math.max(Math.round(m.toPixels(J(e.value,r.max),!0)),0),l);K&&(d=f=m.toPixels(r.max));u=Math.abs(d-
	f);G=Math.min(d,f);D=Math.max(d,f);m.isXAxis?(k={x:B?D:G,y:0,width:u,height:l},y||(k.x=b.plotHeight-k.x)):(k={x:0,y:B?D:G,width:l,height:u},y&&(k.y=b.plotWidth-k.y));B&&c.isVML&&(k=m.isXAxis?{x:0,y:v?G:D,height:k.width,width:b.chartWidth}:{x:k.y-b.plotLeft-b.spacingBox.x,y:0,width:k.height,height:b.chartHeight});g[h]?g[h].animate(k):(g[h]=c.clipRect(k),q&&a["zone-graph-"+h].clip(g[h]),n&&a["zone-area-"+h].clip(g[h]));K=e.value>r.max}),this.clips=g)},invertGroups:function(a){function b(){t(["group",
	"markerGroup"],function(b){c[b]&&(e.renderer.isVML&&c[b].attr({width:c.yAxis.len,height:c.xAxis.len}),c[b].width=c.yAxis.len,c[b].height=c.xAxis.len,c[b].invert(a))})}var c=this,e=c.chart,d;c.xAxis&&(d=C(e,"resize",b),C(c,"destroy",d),b(a),c.invertGroups=b)},plotGroup:function(a,b,c,e,d){var h=this[a],f=!h;f&&(this[a]=h=this.chart.renderer.g().attr({zIndex:e||.1}).add(d));h.addClass("highcharts-"+b+" highcharts-series-"+this.index+" highcharts-"+this.type+"-series highcharts-color-"+this.colorIndex+
	" "+(this.options.className||""),!0);h.attr({visibility:c})[f?"attr":"animate"](this.getPlotBox());return h},getPlotBox:function(){var a=this.chart,b=this.xAxis,c=this.yAxis;a.inverted&&(b=c,c=this.xAxis);return{translateX:b?b.left:a.plotLeft,translateY:c?c.top:a.plotTop,scaleX:1,scaleY:1}},render:function(){var a=this,b=a.chart,c,e=a.options,d=!!a.animate&&b.renderer.isSVG&&A(e.animation).duration,f=a.visible?"inherit":"hidden",g=e.zIndex,k=a.hasRendered,q=b.seriesGroup,n=b.inverted;c=a.plotGroup("group",
	"series",f,g,q);a.markerGroup=a.plotGroup("markerGroup","markers",f,g,q);d&&a.animate(!0);c.inverted=a.isCartesian?n:!1;a.drawGraph&&(a.drawGraph(),a.applyZones());a.drawDataLabels&&a.drawDataLabels();a.visible&&a.drawPoints();a.drawTracker&&!1!==a.options.enableMouseTracking&&a.drawTracker();a.invertGroups(n);!1===e.clip||a.sharedClipKey||k||c.clip(b.clipRect);d&&a.animate();k||(a.animationTimeout=B(function(){a.afterAnimate()},d));a.isDirty=!1;a.hasRendered=!0},redraw:function(){var a=this.chart,
	b=this.isDirty||this.isDirtyData,c=this.group,e=this.xAxis,d=this.yAxis;c&&(a.inverted&&c.attr({width:a.plotWidth,height:a.plotHeight}),c.animate({translateX:J(e&&e.left,a.plotLeft),translateY:J(d&&d.top,a.plotTop)}));this.translate();this.render();b&&delete this.kdTree},kdAxisArray:["clientX","plotY"],searchPoint:function(a,b){var c=this.xAxis,e=this.yAxis,d=this.chart.inverted;return this.searchKDTree({clientX:d?c.len-a.chartY+c.pos:a.chartX-c.pos,plotY:d?e.len-a.chartX+e.pos:a.chartY-e.pos},b)},
	buildKDTree:function(){function a(c,e,d){var h,f;if(f=c&&c.length)return h=b.kdAxisArray[e%d],c.sort(function(a,b){return a[h]-b[h]}),f=Math.floor(f/2),{point:c[f],left:a(c.slice(0,f),e+1,d),right:a(c.slice(f+1),e+1,d)}}this.buildingKdTree=!0;var b=this,c=-1<b.options.findNearestPointBy.indexOf("y")?2:1;delete b.kdTree;B(function(){b.kdTree=a(b.getValidPoints(null,!b.directTouch),c,c);b.buildingKdTree=!1},b.options.kdNow?0:1)},searchKDTree:function(a,b){function c(a,b,h,k){var p=b.point,q=e.kdAxisArray[h%
	k],n,l,m=p;l=u(a[d])&&u(p[d])?Math.pow(a[d]-p[d],2):null;n=u(a[f])&&u(p[f])?Math.pow(a[f]-p[f],2):null;n=(l||0)+(n||0);p.dist=u(n)?Math.sqrt(n):Number.MAX_VALUE;p.distX=u(l)?Math.sqrt(l):Number.MAX_VALUE;q=a[q]-p[q];n=0>q?"left":"right";l=0>q?"right":"left";b[n]&&(n=c(a,b[n],h+1,k),m=n[g]<m[g]?n:p);b[l]&&Math.sqrt(q*q)<m[g]&&(a=c(a,b[l],h+1,k),m=a[g]<m[g]?a:m);return m}var e=this,d=this.kdAxisArray[0],f=this.kdAxisArray[1],g=b?"distX":"dist";b=-1<e.options.findNearestPointBy.indexOf("y")?2:1;this.kdTree||
	this.buildingKdTree||this.buildKDTree();if(this.kdTree)return c(a,this.kdTree,b,b)}})})(M);(function(a){var C=a.Axis,A=a.Chart,F=a.correctFloat,E=a.defined,m=a.destroyObjectProperties,f=a.each,l=a.format,r=a.objectEach,u=a.pick,t=a.Series;a.StackItem=function(a,d,f,b,e){var g=a.chart.inverted;this.axis=a;this.isNegative=f;this.options=d;this.x=b;this.total=null;this.points={};this.stack=e;this.rightCliff=this.leftCliff=0;this.alignOptions={align:d.align||(g?f?"left":"right":"center"),verticalAlign:d.verticalAlign||
	(g?"middle":f?"bottom":"top"),y:u(d.y,g?4:f?14:-6),x:u(d.x,g?f?-6:6:0)};this.textAlign=d.textAlign||(g?f?"right":"left":"center")};a.StackItem.prototype={destroy:function(){m(this,this.axis)},render:function(a){var d=this.options,f=d.format,f=f?l(f,this):d.formatter.call(this);this.label?this.label.attr({text:f,visibility:"hidden"}):this.label=this.axis.chart.renderer.text(f,null,null,d.useHTML).css(d.style).attr({align:this.textAlign,rotation:d.rotation,visibility:"hidden"}).add(a)},setOffset:function(a,
	d){var f=this.axis,b=f.chart,e=f.translate(f.usePercentage?100:this.total,0,0,0,1),f=f.translate(0),f=Math.abs(e-f);a=b.xAxis[0].translate(this.x)+a;e=this.getStackBox(b,this,a,e,d,f);if(d=this.label)d.align(this.alignOptions,null,e),e=d.alignAttr,d[!1===this.options.crop||b.isInsidePlot(e.x,e.y)?"show":"hide"](!0)},getStackBox:function(a,d,f,b,e,l){var g=d.axis.reversed,k=a.inverted;a=a.plotHeight;d=d.isNegative&&!g||!d.isNegative&&g;return{x:k?d?b:b-l:f,y:k?a-f-e:d?a-b-l:a-b,width:k?l:e,height:k?
	e:l}}};A.prototype.getStacks=function(){var a=this;f(a.yAxis,function(a){a.stacks&&a.hasVisibleSeries&&(a.oldStacks=a.stacks)});f(a.series,function(d){!d.options.stacking||!0!==d.visible&&!1!==a.options.chart.ignoreHiddenSeries||(d.stackKey=d.type+u(d.options.stack,""))})};C.prototype.buildStacks=function(){var a=this.series,d=u(this.options.reversedStacks,!0),f=a.length,b;if(!this.isXAxis){this.usePercentage=!1;for(b=f;b--;)a[d?b:f-b-1].setStackedPoints();if(this.usePercentage)for(b=0;b<f;b++)a[b].setPercentStacks()}};
	C.prototype.renderStackTotals=function(){var a=this.chart,d=a.renderer,f=this.stacks,b=this.stackTotalGroup;b||(this.stackTotalGroup=b=d.g("stack-labels").attr({visibility:"visible",zIndex:6}).add());b.translate(a.plotLeft,a.plotTop);r(f,function(a){r(a,function(a){a.render(b)})})};C.prototype.resetStacks=function(){var a=this,d=a.stacks;a.isXAxis||r(d,function(d){r(d,function(b,e){b.touched<a.stacksTouched?(b.destroy(),delete d[e]):(b.total=null,b.cum=null)})})};C.prototype.cleanStacks=function(){var a;
	this.isXAxis||(this.oldStacks&&(a=this.stacks=this.oldStacks),r(a,function(a){r(a,function(a){a.cum=a.total})}))};t.prototype.setStackedPoints=function(){if(this.options.stacking&&(!0===this.visible||!1===this.chart.options.chart.ignoreHiddenSeries)){var f=this.processedXData,d=this.processedYData,k=[],b=d.length,e=this.options,l=e.threshold,m=e.startFromThreshold?l:0,n=e.stack,e=e.stacking,r=this.stackKey,t="-"+r,c=this.negStacks,G=this.yAxis,q=G.stacks,B=G.oldStacks,K,p,z,I,A,h,w;G.stacksTouched+=
	1;for(A=0;A<b;A++)h=f[A],w=d[A],K=this.getStackIndicator(K,h,this.index),I=K.key,z=(p=c&&w<(m?0:l))?t:r,q[z]||(q[z]={}),q[z][h]||(B[z]&&B[z][h]?(q[z][h]=B[z][h],q[z][h].total=null):q[z][h]=new a.StackItem(G,G.options.stackLabels,p,h,n)),z=q[z][h],null!==w&&(z.points[I]=z.points[this.index]=[u(z.cum,m)],E(z.cum)||(z.base=I),z.touched=G.stacksTouched,0<K.index&&!1===this.singleStacks&&(z.points[I][0]=z.points[this.index+","+h+",0"][0])),"percent"===e?(p=p?r:t,c&&q[p]&&q[p][h]?(p=q[p][h],z.total=p.total=
	Math.max(p.total,z.total)+Math.abs(w)||0):z.total=F(z.total+(Math.abs(w)||0))):z.total=F(z.total+(w||0)),z.cum=u(z.cum,m)+(w||0),null!==w&&(z.points[I].push(z.cum),k[A]=z.cum);"percent"===e&&(G.usePercentage=!0);this.stackedYData=k;G.oldStacks={}}};t.prototype.setPercentStacks=function(){var a=this,d=a.stackKey,k=a.yAxis.stacks,b=a.processedXData,e;f([d,"-"+d],function(d){for(var f=b.length,g,l;f--;)if(g=b[f],e=a.getStackIndicator(e,g,a.index,d),g=(l=k[d]&&k[d][g])&&l.points[e.key])l=l.total?100/
	l.total:0,g[0]=F(g[0]*l),g[1]=F(g[1]*l),a.stackedYData[f]=g[1]})};t.prototype.getStackIndicator=function(a,d,f,b){!E(a)||a.x!==d||b&&a.key!==b?a={x:d,index:0,key:b}:a.index++;a.key=[f,d,a.index].join();return a}})(M);(function(a){var C=a.addEvent,A=a.animate,F=a.Axis,E=a.createElement,m=a.css,f=a.defined,l=a.each,r=a.erase,u=a.extend,t=a.fireEvent,g=a.inArray,d=a.isNumber,k=a.isObject,b=a.isArray,e=a.merge,v=a.objectEach,y=a.pick,n=a.Point,D=a.Series,J=a.seriesTypes,c=a.setAnimation,G=a.splat;u(a.Chart.prototype,
	{addSeries:function(a,b,c){var e,d=this;a&&(b=y(b,!0),t(d,"addSeries",{options:a},function(){e=d.initSeries(a);d.isDirtyLegend=!0;d.linkSeries();b&&d.redraw(c)}));return e},addAxis:function(a,b,c,d){var f=b?"xAxis":"yAxis",g=this.options;a=e(a,{index:this[f].length,isX:b});b=new F(this,a);g[f]=G(g[f]||{});g[f].push(a);y(c,!0)&&this.redraw(d);return b},showLoading:function(a){var b=this,c=b.options,e=b.loadingDiv,d=c.loading,f=function(){e&&m(e,{left:b.plotLeft+"px",top:b.plotTop+"px",width:b.plotWidth+
	"px",height:b.plotHeight+"px"})};e||(b.loadingDiv=e=E("div",{className:"highcharts-loading highcharts-loading-hidden"},null,b.container),b.loadingSpan=E("span",{className:"highcharts-loading-inner"},null,e),C(b,"redraw",f));e.className="highcharts-loading";b.loadingSpan.innerHTML=a||c.lang.loading;m(e,u(d.style,{zIndex:10}));m(b.loadingSpan,d.labelStyle);b.loadingShown||(m(e,{opacity:0,display:""}),A(e,{opacity:d.style.opacity||.5},{duration:d.showDuration||0}));b.loadingShown=!0;f()},hideLoading:function(){var a=
	this.options,b=this.loadingDiv;b&&(b.className="highcharts-loading highcharts-loading-hidden",A(b,{opacity:0},{duration:a.loading.hideDuration||100,complete:function(){m(b,{display:"none"})}}));this.loadingShown=!1},propsRequireDirtyBox:"backgroundColor borderColor borderWidth margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
	propsRequireUpdateSeries:"chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions tooltip".split(" "),update:function(a,b,c){var k=this,n={credits:"addCredits",title:"setTitle",subtitle:"setSubtitle"},q=a.chart,m,h,r=[];if(q){e(!0,k.options.chart,q);"className"in q&&k.setClassName(q.className);if("inverted"in q||"polar"in q)k.propFromSeries(),m=!0;"alignTicks"in q&&(m=!0);v(q,function(a,b){-1!==g("chart."+b,k.propsRequireUpdateSeries)&&(h=!0);-1!==g(b,k.propsRequireDirtyBox)&&
	(k.isDirtyBox=!0)});"style"in q&&k.renderer.setStyle(q.style)}a.colors&&(this.options.colors=a.colors);a.plotOptions&&e(!0,this.options.plotOptions,a.plotOptions);v(a,function(a,b){if(k[b]&&"function"===typeof k[b].update)k[b].update(a,!1);else if("function"===typeof k[n[b]])k[n[b]](a);"chart"!==b&&-1!==g(b,k.propsRequireUpdateSeries)&&(h=!0)});l("xAxis yAxis zAxis series colorAxis pane".split(" "),function(b){a[b]&&(l(G(a[b]),function(a,e){(e=f(a.id)&&k.get(a.id)||k[b][e])&&e.coll===b&&(e.update(a,
	!1),c&&(e.touched=!0));if(!e&&c)if("series"===b)k.addSeries(a,!1).touched=!0;else if("xAxis"===b||"yAxis"===b)k.addAxis(a,"xAxis"===b,!1).touched=!0}),c&&l(k[b],function(a){a.touched?delete a.touched:r.push(a)}))});l(r,function(a){a.remove(!1)});m&&l(k.axes,function(a){a.update({},!1)});h&&l(k.series,function(a){a.update({},!1)});a.loading&&e(!0,k.options.loading,a.loading);m=q&&q.width;q=q&&q.height;d(m)&&m!==k.chartWidth||d(q)&&q!==k.chartHeight?k.setSize(m,q):y(b,!0)&&k.redraw()},setSubtitle:function(a){this.setTitle(void 0,
	a)}});u(n.prototype,{update:function(a,b,c,e){function d(){f.applyOptions(a);null===f.y&&h&&(f.graphic=h.destroy());k(a,!0)&&(h&&h.element&&a&&a.marker&&void 0!==a.marker.symbol&&(f.graphic=h.destroy()),a&&a.dataLabels&&f.dataLabel&&(f.dataLabel=f.dataLabel.destroy()));p=f.index;g.updateParallelArrays(f,p);q.data[p]=k(q.data[p],!0)||k(a,!0)?f.options:a;g.isDirty=g.isDirtyData=!0;!g.fixedBox&&g.hasCartesianSeries&&(l.isDirtyBox=!0);"point"===q.legendType&&(l.isDirtyLegend=!0);b&&l.redraw(c)}var f=
	this,g=f.series,h=f.graphic,p,l=g.chart,q=g.options;b=y(b,!0);!1===e?d():f.firePointEvent("update",{options:a},d)},remove:function(a,b){this.series.removePoint(g(this,this.series.data),a,b)}});u(D.prototype,{addPoint:function(a,b,c,e){var d=this.options,f=this.data,g=this.chart,h=this.xAxis,h=h&&h.hasNames&&h.names,k=d.data,p,l,q=this.xData,n,m;b=y(b,!0);p={series:this};this.pointClass.prototype.applyOptions.apply(p,[a]);m=p.x;n=q.length;if(this.requireSorting&&m<q[n-1])for(l=!0;n&&q[n-1]>m;)n--;
	this.updateParallelArrays(p,"splice",n,0,0);this.updateParallelArrays(p,n);h&&p.name&&(h[m]=p.name);k.splice(n,0,a);l&&(this.data.splice(n,0,null),this.processData());"point"===d.legendType&&this.generatePoints();c&&(f[0]&&f[0].remove?f[0].remove(!1):(f.shift(),this.updateParallelArrays(p,"shift"),k.shift()));this.isDirtyData=this.isDirty=!0;b&&g.redraw(e)},removePoint:function(a,b,e){var d=this,f=d.data,g=f[a],k=d.points,h=d.chart,l=function(){k&&k.length===f.length&&k.splice(a,1);f.splice(a,1);
	d.options.data.splice(a,1);d.updateParallelArrays(g||{series:d},"splice",a,1);g&&g.destroy();d.isDirty=!0;d.isDirtyData=!0;b&&h.redraw()};c(e,h);b=y(b,!0);g?g.firePointEvent("remove",null,l):l()},remove:function(a,b,c){function e(){d.destroy();f.isDirtyLegend=f.isDirtyBox=!0;f.linkSeries();y(a,!0)&&f.redraw(b)}var d=this,f=d.chart;!1!==c?t(d,"remove",null,e):e()},update:function(a,b){var c=this,d=c.chart,f=c.userOptions,g=c.oldType||c.type,k=a.type||f.type||d.options.chart.type,h=J[g].prototype,n,
	q=["group","markerGroup","dataLabelsGroup","navigatorSeries","baseSeries"],m=c.finishedAnimating&&{animation:!1};if(Object.keys&&"data"===Object.keys(a).toString())return this.setData(a.data,b);if(k&&k!==g||void 0!==a.zIndex)q.length=0;l(q,function(a){q[a]=c[a];delete c[a]});a=e(f,m,{index:c.index,pointStart:c.xData[0]},{data:c.options.data},a);c.remove(!1,null,!1);for(n in h)c[n]=void 0;u(c,J[k||g].prototype);l(q,function(a){c[a]=q[a]});c.init(d,a);c.oldType=g;d.linkSeries();y(b,!0)&&d.redraw(!1)}});
	u(F.prototype,{update:function(a,b){var c=this.chart;a=c.options[this.coll][this.options.index]=e(this.userOptions,a);this.destroy(!0);this.init(c,u(a,{events:void 0}));c.isDirtyBox=!0;y(b,!0)&&c.redraw()},remove:function(a){for(var c=this.chart,e=this.coll,d=this.series,f=d.length;f--;)d[f]&&d[f].remove(!1);r(c.axes,this);r(c[e],this);b(c.options[e])?c.options[e].splice(this.options.index,1):delete c.options[e];l(c[e],function(a,b){a.options.index=b});this.destroy();c.isDirtyBox=!0;y(a,!0)&&c.redraw()},
	setTitle:function(a,b){this.update({title:a},b)},setCategories:function(a,b){this.update({categories:a},b)}})})(M);(function(a){var C=a.color,A=a.each,F=a.map,E=a.pick,m=a.Series,f=a.seriesType;f("area","line",{softThreshold:!1,threshold:0},{singleStacks:!1,getStackPoints:function(f){var l=[],m=[],t=this.xAxis,g=this.yAxis,d=g.stacks[this.stackKey],k={},b=this.index,e=g.series,v=e.length,y,n=E(g.options.reversedStacks,!0)?1:-1,D;f=f||this.points;if(this.options.stacking){for(D=0;D<f.length;D++)k[f[D].x]=
	f[D];a.objectEach(d,function(a,b){null!==a.total&&m.push(b)});m.sort(function(a,b){return a-b});y=F(e,function(){return this.visible});A(m,function(a,c){var e=0,f,r;if(k[a]&&!k[a].isNull)l.push(k[a]),A([-1,1],function(e){var g=1===e?"rightNull":"leftNull",l=0,q=d[m[c+e]];if(q)for(D=b;0<=D&&D<v;)f=q.points[D],f||(D===b?k[a][g]=!0:y[D]&&(r=d[a].points[D])&&(l-=r[1]-r[0])),D+=n;k[a][1===e?"rightCliff":"leftCliff"]=l});else{for(D=b;0<=D&&D<v;){if(f=d[a].points[D]){e=f[1];break}D+=n}e=g.translate(e,0,
	1,0,1);l.push({isNull:!0,plotX:t.translate(a,0,0,0,1),x:a,plotY:e,yBottom:e})}})}return l},getGraphPath:function(a){var f=m.prototype.getGraphPath,l=this.options,t=l.stacking,g=this.yAxis,d,k,b=[],e=[],v=this.index,y,n=g.stacks[this.stackKey],D=l.threshold,A=g.getThreshold(l.threshold),c,l=l.connectNulls||"percent"===t,G=function(c,d,f){var k=a[c];c=t&&n[k.x].points[v];var l=k[f+"Null"]||0;f=k[f+"Cliff"]||0;var q,m,k=!0;f||l?(q=(l?c[0]:c[1])+f,m=c[0]+f,k=!!l):!t&&a[d]&&a[d].isNull&&(q=m=D);void 0!==
	q&&(e.push({plotX:y,plotY:null===q?A:g.getThreshold(q),isNull:k,isCliff:!0}),b.push({plotX:y,plotY:null===m?A:g.getThreshold(m),doCurve:!1}))};a=a||this.points;t&&(a=this.getStackPoints(a));for(d=0;d<a.length;d++)if(k=a[d].isNull,y=E(a[d].rectPlotX,a[d].plotX),c=E(a[d].yBottom,A),!k||l)l||G(d,d-1,"left"),k&&!t&&l||(e.push(a[d]),b.push({x:d,plotX:y,plotY:c})),l||G(d,d+1,"right");d=f.call(this,e,!0,!0);b.reversed=!0;k=f.call(this,b,!0,!0);k.length&&(k[0]="L");k=d.concat(k);f=f.call(this,e,!1,l);k.xMap=
	d.xMap;this.areaPath=k;return f},drawGraph:function(){this.areaPath=[];m.prototype.drawGraph.apply(this);var a=this,f=this.areaPath,u=this.options,t=[["area","highcharts-area",this.color,u.fillColor]];A(this.zones,function(f,d){t.push(["zone-area-"+d,"highcharts-area highcharts-zone-area-"+d+" "+f.className,f.color||a.color,f.fillColor||u.fillColor])});A(t,function(g){var d=g[0],k=a[d];k?(k.endX=f.xMap,k.animate({d:f})):(k=a[d]=a.chart.renderer.path(f).addClass(g[1]).attr({fill:E(g[3],C(g[2]).setOpacity(E(u.fillOpacity,
	.75)).get()),zIndex:0}).add(a.group),k.isArea=!0);k.startX=f.xMap;k.shiftUnit=u.step?2:1})},drawLegendSymbol:a.LegendSymbolMixin.drawRectangle})})(M);(function(a){var C=a.pick;a=a.seriesType;a("spline","line",{},{getPointSpline:function(a,F,E){var m=F.plotX,f=F.plotY,l=a[E-1];E=a[E+1];var r,u,t,g;if(l&&!l.isNull&&!1!==l.doCurve&&!F.isCliff&&E&&!E.isNull&&!1!==E.doCurve&&!F.isCliff){a=l.plotY;t=E.plotX;E=E.plotY;var d=0;r=(1.5*m+l.plotX)/2.5;u=(1.5*f+a)/2.5;t=(1.5*m+t)/2.5;g=(1.5*f+E)/2.5;t!==r&&(d=
	(g-u)*(t-m)/(t-r)+f-g);u+=d;g+=d;u>a&&u>f?(u=Math.max(a,f),g=2*f-u):u<a&&u<f&&(u=Math.min(a,f),g=2*f-u);g>E&&g>f?(g=Math.max(E,f),u=2*f-g):g<E&&g<f&&(g=Math.min(E,f),u=2*f-g);F.rightContX=t;F.rightContY=g}F=["C",C(l.rightContX,l.plotX),C(l.rightContY,l.plotY),C(r,m),C(u,f),m,f];l.rightContX=l.rightContY=null;return F}})})(M);(function(a){var C=a.seriesTypes.area.prototype,A=a.seriesType;A("areaspline","spline",a.defaultPlotOptions.area,{getStackPoints:C.getStackPoints,getGraphPath:C.getGraphPath,
	drawGraph:C.drawGraph,drawLegendSymbol:a.LegendSymbolMixin.drawRectangle})})(M);(function(a){var C=a.animObject,A=a.color,F=a.each,E=a.extend,m=a.isNumber,f=a.merge,l=a.pick,r=a.Series,u=a.seriesType,t=a.svg;u("column","line",{borderRadius:0,crisp:!0,groupPadding:.2,marker:null,pointPadding:.1,minPointLength:0,cropThreshold:50,pointRange:null,states:{hover:{halo:!1,brightness:.1,shadow:!1},select:{color:"#cccccc",borderColor:"#000000",shadow:!1}},dataLabels:{align:null,verticalAlign:null,y:null},
	softThreshold:!1,startFromThreshold:!0,stickyTracking:!1,tooltip:{distance:6},threshold:0,borderColor:"#ffffff"},{cropShoulder:0,directTouch:!0,trackerGroups:["group","dataLabelsGroup"],negStacks:!0,init:function(){r.prototype.init.apply(this,arguments);var a=this,d=a.chart;d.hasRendered&&F(d.series,function(d){d.type===a.type&&(d.isDirty=!0)})},getColumnMetrics:function(){var a=this,d=a.options,f=a.xAxis,b=a.yAxis,e=f.reversed,m,r={},n=0;!1===d.grouping?n=1:F(a.chart.series,function(c){var e=c.options,
	d=c.yAxis,f;c.type!==a.type||!c.visible&&a.chart.options.chart.ignoreHiddenSeries||b.len!==d.len||b.pos!==d.pos||(e.stacking?(m=c.stackKey,void 0===r[m]&&(r[m]=n++),f=r[m]):!1!==e.grouping&&(f=n++),c.columnIndex=f)});var t=Math.min(Math.abs(f.transA)*(f.ordinalSlope||d.pointRange||f.closestPointRange||f.tickInterval||1),f.len),u=t*d.groupPadding,c=(t-2*u)/(n||1),d=Math.min(d.maxPointWidth||f.len,l(d.pointWidth,c*(1-2*d.pointPadding)));a.columnMetrics={width:d,offset:(c-d)/2+(u+((a.columnIndex||0)+
	(e?1:0))*c-t/2)*(e?-1:1)};return a.columnMetrics},crispCol:function(a,d,f,b){var e=this.chart,g=this.borderWidth,k=-(g%2?.5:0),g=g%2?.5:1;e.inverted&&e.renderer.isVML&&(g+=1);this.options.crisp&&(f=Math.round(a+f)+k,a=Math.round(a)+k,f-=a);b=Math.round(d+b)+g;k=.5>=Math.abs(d)&&.5<b;d=Math.round(d)+g;b-=d;k&&b&&(--d,b+=1);return{x:a,y:d,width:f,height:b}},translate:function(){var a=this,d=a.chart,f=a.options,b=a.dense=2>a.closestPointRange*a.xAxis.transA,b=a.borderWidth=l(f.borderWidth,b?0:1),e=a.yAxis,
	m=a.translatedThreshold=e.getThreshold(f.threshold),t=l(f.minPointLength,5),n=a.getColumnMetrics(),u=n.width,A=a.barW=Math.max(u,1+2*b),c=a.pointXOffset=n.offset;d.inverted&&(m-=.5);f.pointPadding&&(A=Math.ceil(A));r.prototype.translate.apply(a);F(a.points,function(b){var f=l(b.yBottom,m),g=999+Math.abs(f),g=Math.min(Math.max(-g,b.plotY),e.len+g),k=b.plotX+c,n=A,r=Math.min(g,f),v,y=Math.max(g,f)-r;Math.abs(y)<t&&t&&(y=t,v=!e.reversed&&!b.negative||e.reversed&&b.negative,r=Math.abs(r-m)>t?f-t:m-(v?
	t:0));b.barX=k;b.pointWidth=u;b.tooltipPos=d.inverted?[e.len+e.pos-d.plotLeft-g,a.xAxis.len-k-n/2,y]:[k+n/2,g+e.pos-d.plotTop,y];b.shapeType="rect";b.shapeArgs=a.crispCol.apply(a,b.isNull?[k,m,n,0]:[k,r,n,y])})},getSymbol:a.noop,drawLegendSymbol:a.LegendSymbolMixin.drawRectangle,drawGraph:function(){this.group[this.dense?"addClass":"removeClass"]("highcharts-dense-data")},pointAttribs:function(a,d){var g=this.options,b,e=this.pointAttrToOptions||{};b=e.stroke||"borderColor";var l=e["stroke-width"]||
	"borderWidth",m=a&&a.color||this.color,n=a[b]||g[b]||this.color||m,r=a[l]||g[l]||this[l]||0,e=g.dashStyle;a&&this.zones.length&&(m=a.getZone(),m=a.options.color||m&&m.color||this.color);d&&(a=f(g.states[d],a.options.states&&a.options.states[d]||{}),d=a.brightness,m=a.color||void 0!==d&&A(m).brighten(a.brightness).get()||m,n=a[b]||n,r=a[l]||r,e=a.dashStyle||e);b={fill:m,stroke:n,"stroke-width":r};e&&(b.dashstyle=e);return b},drawPoints:function(){var a=this,d=this.chart,k=a.options,b=d.renderer,e=
	k.animationLimit||250,l;F(a.points,function(g){var n=g.graphic;if(m(g.plotY)&&null!==g.y){l=g.shapeArgs;if(n)n[d.pointCount<e?"animate":"attr"](f(l));else g.graphic=n=b[g.shapeType](l).add(g.group||a.group);k.borderRadius&&n.attr({r:k.borderRadius});n.attr(a.pointAttribs(g,g.selected&&"select")).shadow(k.shadow,null,k.stacking&&!k.borderRadius);n.addClass(g.getClassName(),!0)}else n&&(g.graphic=n.destroy())})},animate:function(a){var d=this,f=this.yAxis,b=d.options,e=this.chart.inverted,g={};t&&(a?
	(g.scaleY=.001,a=Math.min(f.pos+f.len,Math.max(f.pos,f.toPixels(b.threshold))),e?g.translateX=a-f.len:g.translateY=a,d.group.attr(g)):(g[e?"translateX":"translateY"]=f.pos,d.group.animate(g,E(C(d.options.animation),{step:function(a,b){d.group.attr({scaleY:Math.max(.001,b.pos)})}})),d.animate=null))},remove:function(){var a=this,d=a.chart;d.hasRendered&&F(d.series,function(d){d.type===a.type&&(d.isDirty=!0)});r.prototype.remove.apply(a,arguments)}})})(M);(function(a){a=a.seriesType;a("bar","column",
	null,{inverted:!0})})(M);(function(a){var C=a.Series;a=a.seriesType;a("scatter","line",{lineWidth:0,findNearestPointBy:"xy",marker:{enabled:!0},tooltip:{headerFormat:'\x3cspan style\x3d"color:{point.color}"\x3e\u25cf\x3c/span\x3e \x3cspan style\x3d"font-size: 0.85em"\x3e {series.name}\x3c/span\x3e\x3cbr/\x3e',pointFormat:"x: \x3cb\x3e{point.x}\x3c/b\x3e\x3cbr/\x3ey: \x3cb\x3e{point.y}\x3c/b\x3e\x3cbr/\x3e"}},{sorted:!1,requireSorting:!1,noSharedTooltip:!0,trackerGroups:["group","markerGroup","dataLabelsGroup"],
	takeOrdinalPosition:!1,drawGraph:function(){this.options.lineWidth&&C.prototype.drawGraph.call(this)}})})(M);(function(a){var C=a.pick,A=a.relativeLength;a.CenteredSeriesMixin={getCenter:function(){var a=this.options,E=this.chart,m=2*(a.slicedOffset||0),f=E.plotWidth-2*m,E=E.plotHeight-2*m,l=a.center,l=[C(l[0],"50%"),C(l[1],"50%"),a.size||"100%",a.innerSize||0],r=Math.min(f,E),u,t;for(u=0;4>u;++u)t=l[u],a=2>u||2===u&&/%$/.test(t),l[u]=A(t,[f,E,r,l[2]][u])+(a?m:0);l[3]>l[2]&&(l[3]=l[2]);return l}}})(M);
	(function(a){var C=a.addEvent,A=a.defined,F=a.each,E=a.extend,m=a.inArray,f=a.noop,l=a.pick,r=a.Point,u=a.Series,t=a.seriesType,g=a.setAnimation;t("pie","line",{center:[null,null],clip:!1,colorByPoint:!0,dataLabels:{distance:30,enabled:!0,formatter:function(){return this.point.isNull?void 0:this.point.name},x:0},ignoreHiddenPoint:!0,legendType:"point",marker:null,size:null,showInLegend:!1,slicedOffset:10,stickyTracking:!1,tooltip:{followPointer:!0},borderColor:"#ffffff",borderWidth:1,states:{hover:{brightness:.1,
	shadow:!1}}},{isCartesian:!1,requireSorting:!1,directTouch:!0,noSharedTooltip:!0,trackerGroups:["group","dataLabelsGroup"],axisTypes:[],pointAttribs:a.seriesTypes.column.prototype.pointAttribs,animate:function(a){var d=this,b=d.points,e=d.startAngleRad;a||(F(b,function(a){var b=a.graphic,f=a.shapeArgs;b&&(b.attr({r:a.startR||d.center[3]/2,start:e,end:e}),b.animate({r:f.r,start:f.start,end:f.end},d.options.animation))}),d.animate=null)},updateTotals:function(){var a,f=0,b=this.points,e=b.length,g,
	l=this.options.ignoreHiddenPoint;for(a=0;a<e;a++)g=b[a],f+=l&&!g.visible?0:g.isNull?0:g.y;this.total=f;for(a=0;a<e;a++)g=b[a],g.percentage=0<f&&(g.visible||!l)?g.y/f*100:0,g.total=f},generatePoints:function(){u.prototype.generatePoints.call(this);this.updateTotals()},translate:function(a){this.generatePoints();var d=0,b=this.options,e=b.slicedOffset,f=e+(b.borderWidth||0),g,n,m,r=b.startAngle||0,c=this.startAngleRad=Math.PI/180*(r-90),r=(this.endAngleRad=Math.PI/180*(l(b.endAngle,r+360)-90))-c,t=
	this.points,q,B=b.dataLabels.distance,b=b.ignoreHiddenPoint,u,p=t.length,z;a||(this.center=a=this.getCenter());this.getX=function(b,c,e){m=Math.asin(Math.min((b-a[1])/(a[2]/2+e.labelDistance),1));return a[0]+(c?-1:1)*Math.cos(m)*(a[2]/2+e.labelDistance)};for(u=0;u<p;u++){z=t[u];z.labelDistance=l(z.options.dataLabels&&z.options.dataLabels.distance,B);this.maxLabelDistance=Math.max(this.maxLabelDistance||0,z.labelDistance);g=c+d*r;if(!b||z.visible)d+=z.percentage/100;n=c+d*r;z.shapeType="arc";z.shapeArgs=
	{x:a[0],y:a[1],r:a[2]/2,innerR:a[3]/2,start:Math.round(1E3*g)/1E3,end:Math.round(1E3*n)/1E3};m=(n+g)/2;m>1.5*Math.PI?m-=2*Math.PI:m<-Math.PI/2&&(m+=2*Math.PI);z.slicedTranslation={translateX:Math.round(Math.cos(m)*e),translateY:Math.round(Math.sin(m)*e)};n=Math.cos(m)*a[2]/2;q=Math.sin(m)*a[2]/2;z.tooltipPos=[a[0]+.7*n,a[1]+.7*q];z.half=m<-Math.PI/2||m>Math.PI/2?1:0;z.angle=m;g=Math.min(f,z.labelDistance/5);z.labelPos=[a[0]+n+Math.cos(m)*z.labelDistance,a[1]+q+Math.sin(m)*z.labelDistance,a[0]+n+Math.cos(m)*
	g,a[1]+q+Math.sin(m)*g,a[0]+n,a[1]+q,0>z.labelDistance?"center":z.half?"right":"left",m]}},drawGraph:null,drawPoints:function(){var a=this,f=a.chart.renderer,b,e,g,l,n=a.options.shadow;n&&!a.shadowGroup&&(a.shadowGroup=f.g("shadow").add(a.group));F(a.points,function(d){if(!d.isNull){e=d.graphic;l=d.shapeArgs;b=d.getTranslate();var k=d.shadowGroup;n&&!k&&(k=d.shadowGroup=f.g("shadow").add(a.shadowGroup));k&&k.attr(b);g=a.pointAttribs(d,d.selected&&"select");e?e.setRadialReference(a.center).attr(g).animate(E(l,
	b)):(d.graphic=e=f[d.shapeType](l).setRadialReference(a.center).attr(b).add(a.group),d.visible||e.attr({visibility:"hidden"}),e.attr(g).attr({"stroke-linejoin":"round"}).shadow(n,k));e.addClass(d.getClassName())}})},searchPoint:f,sortByAngle:function(a,f){a.sort(function(a,e){return void 0!==a.angle&&(e.angle-a.angle)*f})},drawLegendSymbol:a.LegendSymbolMixin.drawRectangle,getCenter:a.CenteredSeriesMixin.getCenter,getSymbol:f},{init:function(){r.prototype.init.apply(this,arguments);var a=this,f;a.name=
	l(a.name,"Slice");f=function(b){a.slice("select"===b.type)};C(a,"select",f);C(a,"unselect",f);return a},isValid:function(){return a.isNumber(this.y,!0)&&0<=this.y},setVisible:function(a,f){var b=this,e=b.series,d=e.chart,g=e.options.ignoreHiddenPoint;f=l(f,g);a!==b.visible&&(b.visible=b.options.visible=a=void 0===a?!b.visible:a,e.options.data[m(b,e.data)]=b.options,F(["graphic","dataLabel","connector","shadowGroup"],function(e){if(b[e])b[e][a?"show":"hide"](!0)}),b.legendItem&&d.legend.colorizeItem(b,
	a),a||"hover"!==b.state||b.setState(""),g&&(e.isDirty=!0),f&&d.redraw())},slice:function(a,f,b){var e=this.series;g(b,e.chart);l(f,!0);this.sliced=this.options.sliced=A(a)?a:!this.sliced;e.options.data[m(this,e.data)]=this.options;this.graphic.animate(this.getTranslate());this.shadowGroup&&this.shadowGroup.animate(this.getTranslate())},getTranslate:function(){return this.sliced?this.slicedTranslation:{translateX:0,translateY:0}},haloPath:function(a){var d=this.shapeArgs;return this.sliced||!this.visible?
	[]:this.series.chart.renderer.symbols.arc(d.x,d.y,d.r+a,d.r+a,{innerR:this.shapeArgs.r,start:d.start,end:d.end})}})})(M);(function(a){var C=a.addEvent,A=a.arrayMax,F=a.defined,E=a.each,m=a.extend,f=a.format,l=a.map,r=a.merge,u=a.noop,t=a.pick,g=a.relativeLength,d=a.Series,k=a.seriesTypes,b=a.stableSort;a.distribute=function(a,d){function e(a,b){return a.target-b.target}var f,g=!0,k=a,c=[],m;m=0;for(f=a.length;f--;)m+=a[f].size;if(m>d){b(a,function(a,b){return(b.rank||0)-(a.rank||0)});for(m=f=0;m<=
	d;)m+=a[f].size,f++;c=a.splice(f-1,a.length)}b(a,e);for(a=l(a,function(a){return{size:a.size,targets:[a.target]}});g;){for(f=a.length;f--;)g=a[f],m=(Math.min.apply(0,g.targets)+Math.max.apply(0,g.targets))/2,g.pos=Math.min(Math.max(0,m-g.size/2),d-g.size);f=a.length;for(g=!1;f--;)0<f&&a[f-1].pos+a[f-1].size>a[f].pos&&(a[f-1].size+=a[f].size,a[f-1].targets=a[f-1].targets.concat(a[f].targets),a[f-1].pos+a[f-1].size>d&&(a[f-1].pos=d-a[f-1].size),a.splice(f,1),g=!0)}f=0;E(a,function(a){var b=0;E(a.targets,
	function(){k[f].pos=a.pos+b;b+=k[f].size;f++})});k.push.apply(k,c);b(k,e)};d.prototype.drawDataLabels=function(){var b=this,d=b.options,g=d.dataLabels,k=b.points,l,m,c=b.hasRendered||0,u,q,B=t(g.defer,!!d.animation),A=b.chart.renderer;if(g.enabled||b._hasPointLabels)b.dlProcessOptions&&b.dlProcessOptions(g),q=b.plotGroup("dataLabelsGroup","data-labels",B&&!c?"hidden":"visible",g.zIndex||6),B&&(q.attr({opacity:+c}),c||C(b,"afterAnimate",function(){b.visible&&q.show(!0);q[d.animation?"animate":"attr"]({opacity:1},
	{duration:200})})),m=g,E(k,function(c){var e,k=c.dataLabel,n,h,p=c.connector,v=!k,B;l=c.dlOptions||c.options&&c.options.dataLabels;if(e=t(l&&l.enabled,m.enabled)&&null!==c.y)g=r(m,l),n=c.getLabelConfig(),u=g.format?f(g.format,n):g.formatter.call(n,g),B=g.style,n=g.rotation,B.color=t(g.color,B.color,b.color,"#000000"),"contrast"===B.color&&(c.contrastColor=A.getContrast(c.color||b.color),B.color=g.inside||0>t(c.labelDistance,g.distance)||d.stacking?c.contrastColor:"#000000"),d.cursor&&(B.cursor=d.cursor),
	h={fill:g.backgroundColor,stroke:g.borderColor,"stroke-width":g.borderWidth,r:g.borderRadius||0,rotation:n,padding:g.padding,zIndex:1},a.objectEach(h,function(a,b){void 0===a&&delete h[b]});!k||e&&F(u)?e&&F(u)&&(k?h.text=u:(k=c.dataLabel=A[n?"text":"label"](u,0,-9999,g.shape,null,null,g.useHTML,null,"data-label"),k.addClass("highcharts-data-label-color-"+c.colorIndex+" "+(g.className||"")+(g.useHTML?"highcharts-tracker":""))),k.attr(h),k.css(B).shadow(g.shadow),k.added||k.add(q),b.alignDataLabel(c,
	k,g,null,v)):(c.dataLabel=k=k.destroy(),p&&(c.connector=p.destroy()))})};d.prototype.alignDataLabel=function(a,b,d,f,g){var e=this.chart,c=e.inverted,k=t(a.plotX,-9999),l=t(a.plotY,-9999),n=b.getBBox(),r,p=d.rotation,v=d.align,u=this.visible&&(a.series.forceDL||e.isInsidePlot(k,Math.round(l),c)||f&&e.isInsidePlot(k,c?f.x+1:f.y+f.height-1,c)),y="justify"===t(d.overflow,"justify");if(u&&(r=d.style.fontSize,r=e.renderer.fontMetrics(r,b).b,f=m({x:c?this.yAxis.len-l:k,y:Math.round(c?this.xAxis.len-k:l),
	width:0,height:0},f),m(d,{width:n.width,height:n.height}),p?(y=!1,k=e.renderer.rotCorr(r,p),k={x:f.x+d.x+f.width/2+k.x,y:f.y+d.y+{top:0,middle:.5,bottom:1}[d.verticalAlign]*f.height},b[g?"attr":"animate"](k).attr({align:v}),l=(p+720)%360,l=180<l&&360>l,"left"===v?k.y-=l?n.height:0:"center"===v?(k.x-=n.width/2,k.y-=n.height/2):"right"===v&&(k.x-=n.width,k.y-=l?0:n.height)):(b.align(d,null,f),k=b.alignAttr),y?a.isLabelJustified=this.justifyDataLabel(b,d,k,n,f,g):t(d.crop,!0)&&(u=e.isInsidePlot(k.x,
	k.y)&&e.isInsidePlot(k.x+n.width,k.y+n.height)),d.shape&&!p))b[g?"attr":"animate"]({anchorX:c?e.plotWidth-a.plotY:a.plotX,anchorY:c?e.plotHeight-a.plotX:a.plotY});u||(b.attr({y:-9999}),b.placed=!1)};d.prototype.justifyDataLabel=function(a,b,d,f,g,k){var c=this.chart,e=b.align,l=b.verticalAlign,m,n,p=a.box?0:a.padding||0;m=d.x+p;0>m&&("right"===e?b.align="left":b.x=-m,n=!0);m=d.x+f.width-p;m>c.plotWidth&&("left"===e?b.align="right":b.x=c.plotWidth-m,n=!0);m=d.y+p;0>m&&("bottom"===l?b.verticalAlign=
	"top":b.y=-m,n=!0);m=d.y+f.height-p;m>c.plotHeight&&("top"===l?b.verticalAlign="bottom":b.y=c.plotHeight-m,n=!0);n&&(a.placed=!k,a.align(b,null,g));return n};k.pie&&(k.pie.prototype.drawDataLabels=function(){var b=this,f=b.data,g,k=b.chart,l=b.options.dataLabels,m=t(l.connectorPadding,10),c=t(l.connectorWidth,1),r=k.plotWidth,q=k.plotHeight,u,C=b.center,p=C[2]/2,z=C[1],I,L,h,w,M=[[],[]],H,O,Q,R,x=[0,0,0,0];b.visible&&(l.enabled||b._hasPointLabels)&&(E(f,function(a){a.dataLabel&&a.visible&&a.dataLabel.shortened&&
	(a.dataLabel.attr({width:"auto"}).css({width:"auto",textOverflow:"clip"}),a.dataLabel.shortened=!1)}),d.prototype.drawDataLabels.apply(b),E(f,function(a){a.dataLabel&&a.visible&&(M[a.half].push(a),a.dataLabel._pos=null)}),E(M,function(c,d){var e,f,n=c.length,v=[],u;if(n)for(b.sortByAngle(c,d-.5),0<b.maxLabelDistance&&(e=Math.max(0,z-p-b.maxLabelDistance),f=Math.min(z+p+b.maxLabelDistance,k.plotHeight),E(c,function(a){0<a.labelDistance&&a.dataLabel&&(a.top=Math.max(0,z-p-a.labelDistance),a.bottom=
	Math.min(z+p+a.labelDistance,k.plotHeight),u=a.dataLabel.getBBox().height||21,a.positionsIndex=v.push({target:a.labelPos[1]-a.top+u/2,size:u,rank:a.y})-1)}),a.distribute(v,f+u-e)),R=0;R<n;R++)g=c[R],f=g.positionsIndex,h=g.labelPos,I=g.dataLabel,Q=!1===g.visible?"hidden":"inherit",e=h[1],v&&F(v[f])?void 0===v[f].pos?Q="hidden":(w=v[f].size,O=g.top+v[f].pos):O=e,delete g.positionIndex,H=l.justify?C[0]+(d?-1:1)*(p+g.labelDistance):b.getX(O<g.top+2||O>g.bottom-2?e:O,d,g),I._attr={visibility:Q,align:h[6]},
	I._pos={x:H+l.x+({left:m,right:-m}[h[6]]||0),y:O+l.y-10},h.x=H,h.y=O,t(l.crop,!0)&&(L=I.getBBox().width,e=null,H-L<m?(e=Math.round(L-H+m),x[3]=Math.max(e,x[3])):H+L>r-m&&(e=Math.round(H+L-r+m),x[1]=Math.max(e,x[1])),0>O-w/2?x[0]=Math.max(Math.round(-O+w/2),x[0]):O+w/2>q&&(x[2]=Math.max(Math.round(O+w/2-q),x[2])),I.sideOverflow=e)}),0===A(x)||this.verifyDataLabelOverflow(x))&&(this.placeDataLabels(),c&&E(this.points,function(a){var e;u=a.connector;if((I=a.dataLabel)&&I._pos&&a.visible&&0<a.labelDistance){Q=
	I._attr.visibility;if(e=!u)a.connector=u=k.renderer.path().addClass("highcharts-data-label-connector highcharts-color-"+a.colorIndex).add(b.dataLabelsGroup),u.attr({"stroke-width":c,stroke:l.connectorColor||a.color||"#666666"});u[e?"attr":"animate"]({d:b.connectorPath(a.labelPos)});u.attr("visibility",Q)}else u&&(a.connector=u.destroy())}))},k.pie.prototype.connectorPath=function(a){var b=a.x,d=a.y;return t(this.options.dataLabels.softConnector,!0)?["M",b+("left"===a[6]?5:-5),d,"C",b,d,2*a[2]-a[4],
	2*a[3]-a[5],a[2],a[3],"L",a[4],a[5]]:["M",b+("left"===a[6]?5:-5),d,"L",a[2],a[3],"L",a[4],a[5]]},k.pie.prototype.placeDataLabels=function(){E(this.points,function(a){var b=a.dataLabel;b&&a.visible&&((a=b._pos)?(b.sideOverflow&&(b._attr.width=b.getBBox().width-b.sideOverflow,b.css({width:b._attr.width+"px",textOverflow:"ellipsis"}),b.shortened=!0),b.attr(b._attr),b[b.moved?"animate":"attr"](a),b.moved=!0):b&&b.attr({y:-9999}))},this)},k.pie.prototype.alignDataLabel=u,k.pie.prototype.verifyDataLabelOverflow=
	function(a){var b=this.center,d=this.options,e=d.center,f=d.minSize||80,k,c=null!==d.size;c||(null!==e[0]?k=Math.max(b[2]-Math.max(a[1],a[3]),f):(k=Math.max(b[2]-a[1]-a[3],f),b[0]+=(a[3]-a[1])/2),null!==e[1]?k=Math.max(Math.min(k,b[2]-Math.max(a[0],a[2])),f):(k=Math.max(Math.min(k,b[2]-a[0]-a[2]),f),b[1]+=(a[0]-a[2])/2),k<b[2]?(b[2]=k,b[3]=Math.min(g(d.innerSize||0,k),k),this.translate(b),this.drawDataLabels&&this.drawDataLabels()):c=!0);return c});k.column&&(k.column.prototype.alignDataLabel=function(a,
	b,f,g,k){var e=this.chart.inverted,c=a.series,l=a.dlBox||a.shapeArgs,m=t(a.below,a.plotY>t(this.translatedThreshold,c.yAxis.len)),n=t(f.inside,!!this.options.stacking);l&&(g=r(l),0>g.y&&(g.height+=g.y,g.y=0),l=g.y+g.height-c.yAxis.len,0<l&&(g.height-=l),e&&(g={x:c.yAxis.len-g.y-g.height,y:c.xAxis.len-g.x-g.width,width:g.height,height:g.width}),n||(e?(g.x+=m?0:g.width,g.width=0):(g.y+=m?g.height:0,g.height=0)));f.align=t(f.align,!e||n?"center":m?"right":"left");f.verticalAlign=t(f.verticalAlign,e||
	n?"middle":m?"top":"bottom");d.prototype.alignDataLabel.call(this,a,b,f,g,k);a.isLabelJustified&&a.contrastColor&&a.dataLabel.css({color:a.contrastColor})})})(M);(function(a){var C=a.Chart,A=a.each,F=a.objectEach,E=a.pick,m=a.addEvent;C.prototype.callbacks.push(function(a){function f(){var f=[];A(a.yAxis||[],function(a){a.options.stackLabels&&!a.options.stackLabels.allowOverlap&&F(a.stacks,function(a){F(a,function(a){f.push(a.label)})})});A(a.series||[],function(a){var l=a.options.dataLabels,g=a.dataLabelCollections||
	["dataLabel"];(l.enabled||a._hasPointLabels)&&!l.allowOverlap&&a.visible&&A(g,function(d){A(a.points,function(a){a[d]&&(a[d].labelrank=E(a.labelrank,a.shapeArgs&&a.shapeArgs.height),f.push(a[d]))})})});a.hideOverlappingLabels(f)}f();m(a,"redraw",f)});C.prototype.hideOverlappingLabels=function(a){var f=a.length,m,u,t,g,d,k,b,e,v,y=function(a,b,d,c,e,f,g,k){return!(e>a+d||e+g<a||f>b+c||f+k<b)};for(u=0;u<f;u++)if(m=a[u])m.oldOpacity=m.opacity,m.newOpacity=1,m.width||(t=m.getBBox(),m.width=t.width,m.height=
	t.height);a.sort(function(a,b){return(b.labelrank||0)-(a.labelrank||0)});for(u=0;u<f;u++)for(t=a[u],m=u+1;m<f;++m)if(g=a[m],t&&g&&t!==g&&t.placed&&g.placed&&0!==t.newOpacity&&0!==g.newOpacity&&(d=t.alignAttr,k=g.alignAttr,b=t.parentGroup,e=g.parentGroup,v=2*(t.box?0:t.padding||0),d=y(d.x+b.translateX,d.y+b.translateY,t.width-v,t.height-v,k.x+e.translateX,k.y+e.translateY,g.width-v,g.height-v)))(t.labelrank<g.labelrank?t:g).newOpacity=0;A(a,function(a){var b,d;a&&(d=a.newOpacity,a.oldOpacity!==d&&
	a.placed&&(d?a.show(!0):b=function(){a.hide()},a.alignAttr.opacity=d,a[a.isOld?"animate":"attr"](a.alignAttr,null,b)),a.isOld=!0)})}})(M);(function(a){var C=a.addEvent,A=a.Chart,F=a.createElement,E=a.css,m=a.defaultOptions,f=a.defaultPlotOptions,l=a.each,r=a.extend,u=a.fireEvent,t=a.hasTouch,g=a.inArray,d=a.isObject,k=a.Legend,b=a.merge,e=a.pick,v=a.Point,y=a.Series,n=a.seriesTypes,D=a.svg,J;J=a.TrackerMixin={drawTrackerPoint:function(){var a=this,b=a.chart.pointer,d=function(a){var c=b.getPointFromEvent(a);
	void 0!==c&&(b.isDirectTouch=!0,c.onMouseOver(a))};l(a.points,function(a){a.graphic&&(a.graphic.element.point=a);a.dataLabel&&(a.dataLabel.div?a.dataLabel.div.point=a:a.dataLabel.element.point=a)});a._hasTracking||(l(a.trackerGroups,function(c){if(a[c]){a[c].addClass("highcharts-tracker").on("mouseover",d).on("mouseout",function(a){b.onTrackerMouseOut(a)});if(t)a[c].on("touchstart",d);a.options.cursor&&a[c].css(E).css({cursor:a.options.cursor})}}),a._hasTracking=!0)},drawTrackerGraph:function(){var a=
	this,b=a.options,d=b.trackByArea,e=[].concat(d?a.areaPath:a.graphPath),f=e.length,g=a.chart,k=g.pointer,m=g.renderer,n=g.options.tooltip.snap,h=a.tracker,r,u=function(){if(g.hoverSeries!==a)a.onMouseOver()},v="rgba(192,192,192,"+(D?.0001:.002)+")";if(f&&!d)for(r=f+1;r--;)"M"===e[r]&&e.splice(r+1,0,e[r+1]-n,e[r+2],"L"),(r&&"M"===e[r]||r===f)&&e.splice(r,0,"L",e[r-2]+n,e[r-1]);h?h.attr({d:e}):a.graph&&(a.tracker=m.path(e).attr({"stroke-linejoin":"round",visibility:a.visible?"visible":"hidden",stroke:v,
	fill:d?v:"none","stroke-width":a.graph.strokeWidth()+(d?0:2*n),zIndex:2}).add(a.group),l([a.tracker,a.markerGroup],function(a){a.addClass("highcharts-tracker").on("mouseover",u).on("mouseout",function(a){k.onTrackerMouseOut(a)});b.cursor&&a.css({cursor:b.cursor});if(t)a.on("touchstart",u)}))}};n.column&&(n.column.prototype.drawTracker=J.drawTrackerPoint);n.pie&&(n.pie.prototype.drawTracker=J.drawTrackerPoint);n.scatter&&(n.scatter.prototype.drawTracker=J.drawTrackerPoint);r(k.prototype,{setItemEvents:function(a,
	d,e){var c=this,f=c.chart.renderer.boxWrapper,g="highcharts-legend-"+(a.series?"point":"series")+"-active";(e?d:a.legendGroup).on("mouseover",function(){a.setState("hover");f.addClass(g);d.css(c.options.itemHoverStyle)}).on("mouseout",function(){d.css(b(a.visible?c.itemStyle:c.itemHiddenStyle));f.removeClass(g);a.setState()}).on("click",function(b){var c=function(){a.setVisible&&a.setVisible()};b={browserEvent:b};a.firePointEvent?a.firePointEvent("legendItemClick",b,c):u(a,"legendItemClick",b,c)})},
	createCheckboxForItem:function(a){a.checkbox=F("input",{type:"checkbox",checked:a.selected,defaultChecked:a.selected},this.options.itemCheckboxStyle,this.chart.container);C(a.checkbox,"click",function(b){u(a.series||a,"checkboxClick",{checked:b.target.checked,item:a},function(){a.select()})})}});m.legend.itemStyle.cursor="pointer";r(A.prototype,{showResetZoom:function(){var a=this,b=m.lang,d=a.options.chart.resetZoomButton,e=d.theme,f=e.states,g="chart"===d.relativeTo?null:"plotBox";this.resetZoomButton=
	a.renderer.button(b.resetZoom,null,null,function(){a.zoomOut()},e,f&&f.hover).attr({align:d.position.align,title:b.resetZoomTitle}).addClass("highcharts-reset-zoom").add().align(d.position,!1,g)},zoomOut:function(){var a=this;u(a,"selection",{resetSelection:!0},function(){a.zoom()})},zoom:function(a){var b,c=this.pointer,f=!1,g;!a||a.resetSelection?(l(this.axes,function(a){b=a.zoom()}),c.initiated=!1):l(a.xAxis.concat(a.yAxis),function(a){var d=a.axis;c[d.isXAxis?"zoomX":"zoomY"]&&(b=d.zoom(a.min,
	a.max),d.displayBtn&&(f=!0))});g=this.resetZoomButton;f&&!g?this.showResetZoom():!f&&d(g)&&(this.resetZoomButton=g.destroy());b&&this.redraw(e(this.options.chart.animation,a&&a.animation,100>this.pointCount))},pan:function(a,b){var c=this,d=c.hoverPoints,e;d&&l(d,function(a){a.setState()});l("xy"===b?[1,0]:[1],function(b){b=c[b?"xAxis":"yAxis"][0];var d=b.horiz,f=a[d?"chartX":"chartY"],d=d?"mouseDownX":"mouseDownY",g=c[d],h=(b.pointRange||0)/2,k=b.getExtremes(),l=b.toValue(g-f,!0)+h,h=b.toValue(g+
	b.len-f,!0)-h,m=h<l,g=m?h:l,l=m?l:h,h=Math.min(k.dataMin,b.toValue(b.toPixels(k.min)-b.minPixelPadding)),m=Math.max(k.dataMax,b.toValue(b.toPixels(k.max)+b.minPixelPadding)),n;n=h-g;0<n&&(l+=n,g=h);n=l-m;0<n&&(l=m,g-=n);b.series.length&&g!==k.min&&l!==k.max&&(b.setExtremes(g,l,!1,!1,{trigger:"pan"}),e=!0);c[d]=f});e&&c.redraw(!1);E(c.container,{cursor:"move"})}});r(v.prototype,{select:function(a,b){var c=this,d=c.series,f=d.chart;a=e(a,!c.selected);c.firePointEvent(a?"select":"unselect",{accumulate:b},
	function(){c.selected=c.options.selected=a;d.options.data[g(c,d.data)]=c.options;c.setState(a&&"select");b||l(f.getSelectedPoints(),function(a){a.selected&&a!==c&&(a.selected=a.options.selected=!1,d.options.data[g(a,d.data)]=a.options,a.setState(""),a.firePointEvent("unselect"))})})},onMouseOver:function(a){var b=this.series.chart,c=b.pointer;a=a?c.normalize(a):c.getChartCoordinatesFromPoint(this,b.inverted);c.runPointActions(a,this)},onMouseOut:function(){var a=this.series.chart;this.firePointEvent("mouseOut");
	l(a.hoverPoints||[],function(a){a.setState()});a.hoverPoints=a.hoverPoint=null},importEvents:function(){if(!this.hasImportedEvents){var c=this,d=b(c.series.options.point,c.options).events;c.events=d;a.objectEach(d,function(a,b){C(c,b,a)});this.hasImportedEvents=!0}},setState:function(a,b){var c=Math.floor(this.plotX),d=this.plotY,g=this.series,k=g.options.states[a]||{},l=f[g.type].marker&&g.options.marker,m=l&&!1===l.enabled,n=l&&l.states&&l.states[a]||{},h=!1===n.enabled,t=g.stateMarkerGraphic,u=
	this.marker||{},v=g.chart,y=g.halo,A,C=l&&g.markerAttribs;a=a||"";if(!(a===this.state&&!b||this.selected&&"select"!==a||!1===k.enabled||a&&(h||m&&!1===n.enabled)||a&&u.states&&u.states[a]&&!1===u.states[a].enabled)){C&&(A=g.markerAttribs(this,a));if(this.graphic)this.state&&this.graphic.removeClass("highcharts-point-"+this.state),a&&this.graphic.addClass("highcharts-point-"+a),this.graphic.animate(g.pointAttribs(this,a),e(v.options.chart.animation,k.animation)),A&&this.graphic.animate(A,e(v.options.chart.animation,
	n.animation,l.animation)),t&&t.hide();else{if(a&&n){l=u.symbol||g.symbol;t&&t.currentSymbol!==l&&(t=t.destroy());if(t)t[b?"animate":"attr"]({x:A.x,y:A.y});else l&&(g.stateMarkerGraphic=t=v.renderer.symbol(l,A.x,A.y,A.width,A.height).add(g.markerGroup),t.currentSymbol=l);t&&t.attr(g.pointAttribs(this,a))}t&&(t[a&&v.isInsidePlot(c,d,v.inverted)?"show":"hide"](),t.element.point=this)}(c=k.halo)&&c.size?(y||(g.halo=y=v.renderer.path().add((this.graphic||t).parentGroup)),y[b?"animate":"attr"]({d:this.haloPath(c.size)}),
	y.attr({"class":"highcharts-halo highcharts-color-"+e(this.colorIndex,g.colorIndex)}),y.point=this,y.attr(r({fill:this.color||g.color,"fill-opacity":c.opacity,zIndex:-1},c.attributes))):y&&y.point&&y.point.haloPath&&y.animate({d:y.point.haloPath(0)});this.state=a}},haloPath:function(a){return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX)-a,this.plotY-a,2*a,2*a)}});r(y.prototype,{onMouseOver:function(){var a=this.chart,b=a.hoverSeries;if(b&&b!==this)b.onMouseOut();this.options.events.mouseOver&&
	u(this,"mouseOver");this.setState("hover");a.hoverSeries=this},onMouseOut:function(){var a=this.options,b=this.chart,d=b.tooltip,e=b.hoverPoint;b.hoverSeries=null;if(e)e.onMouseOut();this&&a.events.mouseOut&&u(this,"mouseOut");!d||this.stickyTracking||d.shared&&!this.noSharedTooltip||d.hide();this.setState()},setState:function(a){var b=this,c=b.options,d=b.graph,f=c.states,g=c.lineWidth,c=0;a=a||"";if(b.state!==a&&(l([b.group,b.markerGroup,b.dataLabelsGroup],function(c){c&&(b.state&&c.removeClass("highcharts-series-"+
	b.state),a&&c.addClass("highcharts-series-"+a))}),b.state=a,!f[a]||!1!==f[a].enabled)&&(a&&(g=f[a].lineWidth||g+(f[a].lineWidthPlus||0)),d&&!d.dashstyle))for(g={"stroke-width":g},d.animate(g,e(b.chart.options.chart.animation,f[a]&&f[a].animation));b["zone-graph-"+c];)b["zone-graph-"+c].attr(g),c+=1},setVisible:function(a,b){var c=this,d=c.chart,e=c.legendItem,f,g=d.options.chart.ignoreHiddenSeries,k=c.visible;f=(c.visible=a=c.options.visible=c.userOptions.visible=void 0===a?!k:a)?"show":"hide";l(["group",
	"dataLabelsGroup","markerGroup","tracker","tt"],function(a){if(c[a])c[a][f]()});if(d.hoverSeries===c||(d.hoverPoint&&d.hoverPoint.series)===c)c.onMouseOut();e&&d.legend.colorizeItem(c,a);c.isDirty=!0;c.options.stacking&&l(d.series,function(a){a.options.stacking&&a.visible&&(a.isDirty=!0)});l(c.linkedSeries,function(b){b.setVisible(a,!1)});g&&(d.isDirtyBox=!0);!1!==b&&d.redraw();u(c,f)},show:function(){this.setVisible(!0)},hide:function(){this.setVisible(!1)},select:function(a){this.selected=a=void 0===
	a?!this.selected:a;this.checkbox&&(this.checkbox.checked=a);u(this,a?"select":"unselect")},drawTracker:J.drawTrackerGraph})})(M);(function(a){var C=a.Chart,A=a.each,F=a.inArray,E=a.isArray,m=a.isObject,f=a.pick,l=a.splat;C.prototype.setResponsive=function(f){var l=this.options.responsive,m=[],g=this.currentResponsive;l&&l.rules&&A(l.rules,function(d){void 0===d._id&&(d._id=a.uniqueKey());this.matchResponsiveRule(d,m,f)},this);var d=a.merge.apply(0,a.map(m,function(d){return a.find(l.rules,function(a){return a._id===
	d}).chartOptions})),m=m.toString()||void 0;m!==(g&&g.ruleIds)&&(g&&this.update(g.undoOptions,f),m?(this.currentResponsive={ruleIds:m,mergedOptions:d,undoOptions:this.currentOptions(d)},this.update(d,f)):this.currentResponsive=void 0)};C.prototype.matchResponsiveRule=function(a,l){var m=a.condition;(m.callback||function(){return this.chartWidth<=f(m.maxWidth,Number.MAX_VALUE)&&this.chartHeight<=f(m.maxHeight,Number.MAX_VALUE)&&this.chartWidth>=f(m.minWidth,0)&&this.chartHeight>=f(m.minHeight,0)}).call(this)&&
	l.push(a._id)};C.prototype.currentOptions=function(f){function r(f,d,k,b){var e;a.objectEach(f,function(a,g){if(!b&&-1<F(g,["series","xAxis","yAxis"]))for(f[g]=l(f[g]),k[g]=[],e=0;e<f[g].length;e++)d[g][e]&&(k[g][e]={},r(a[e],d[g][e],k[g][e],b+1));else m(a)?(k[g]=E(a)?[]:{},r(a,d[g]||{},k[g],b+1)):k[g]=d[g]||null})}var t={};r(f,this.options,t,0);return t}})(M);return M});


/***/ }),
/* 531 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(384);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(388);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(389);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(393);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(410);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _highcharts = __webpack_require__(530);
	
	var _highcharts2 = _interopRequireDefault(_highcharts);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ColumnChart = function (_React$Component) {
	  (0, _inherits3.default)(ColumnChart, _React$Component);
	
	  function ColumnChart() {
	    var _ref;
	
	    var _temp, _this, _ret;
	
	    (0, _classCallCheck3.default)(this, ColumnChart);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = ColumnChart.__proto__ || (0, _getPrototypeOf2.default)(ColumnChart)).call.apply(_ref, [this].concat(args))), _this), _this.initializeChart = function (data, series, xAxisCategories, container) {
	      _highcharts2.default.chart(container, {
	        colors: ['#616b7c'],
	        chart: {
	          type: 'column',
	          backgroundColor: null
	        },
	        title: {
	          text: data.title
	        },
	        xAxis: {
	          categories: xAxisCategories,
	          crosshair: true,
	          title: {
	            text: series[0].name
	          }
	        },
	        tooltip: {
	          valueSuffix: '%'
	        },
	        yAxis: {
	          min: 0,
	          visible: false
	        },
	        credits: {
	          enabled: false
	        },
	        plotOptions: {
	          column: {
	            pointPadding: 0.2,
	            borderWidth: 0,
	            dataLabels: {
	              enabled: true,
	              format: '{y}%'
	            }
	          }
	        },
	        legend: {
	          enabled: false
	        },
	        series: series
	      });
	    }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
	  }
	
	  (0, _createClass3.default)(ColumnChart, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      var _props = this.props,
	          data = _props.data,
	          series = _props.series,
	          xAxisCategories = _props.xAxisCategories,
	          container = _props.container;
	
	      this.initializeChart(data, series, xAxisCategories, container);
	    }
	  }, {
	    key: 'componentDidUpdate',
	    value: function componentDidUpdate() {
	      var _props2 = this.props,
	          data = _props2.data,
	          series = _props2.series,
	          xAxisCategories = _props2.xAxisCategories,
	          container = _props2.container;
	
	      this.initializeChart(data, series, xAxisCategories, container);
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      return _react2.default.createElement('div', { id: this.props.container,
	        className: 'scroll' });
	    }
	  }]);
	  return ColumnChart;
	}(_react2.default.Component);
	
	ColumnChart.propTypes = {
	  data: _react2.default.PropTypes.object.isRequired,
	  series: _react2.default.PropTypes.array.isRequired,
	  xAxisCategories: _react2.default.PropTypes.array,
	  container: _react2.default.PropTypes.string.isRequired
	};
	exports.default = ColumnChart;

/***/ }),
/* 532 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(533);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(432)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(true) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept(533, function() {
				var newContent = __webpack_require__(533);
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 533 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(431)();
	// imports
	
	
	// module
	exports.push([module.id, ".Team-Performance-Trend__container___Qb5bv{background-color:#def3e2}.Team-Performance-Trend__container___Qb5bv .performace-chart{-ms-flex-align:center;align-items:center;padding-top:10px}.Team-Performance-Trend__teamSelectorContainer___3dTPx{display:-ms-flexbox;display:flex;-ms-flex-pack:left;justify-content:left;padding:20px 40px}.Team-Performance-Trend__whiteLogo___3uyoc{height:160px;margin-right:30px}.Team-Performance-Trend__dropDownContainer___1JkZo{text-align:end;display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;-ms-flex-pack:center;justify-content:center}.Team-Performance-Trend__selectText___1Jm10{color:#fff;font-size:20px;text-align:start;padding:10px}@media screen and (max-width:768px){.Team-Performance-Trend__teamSelectorContainer___3dTPx{display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center;padding:20px 0}.Team-Performance-Trend__whiteLogo___3uyoc{height:160px;margin-right:13px;width:110px}}.react-tabs__tab--selected{border:none!important;border-radius:5px!important;margin:10px!important;padding:15px;background-color:#172376!important;color:#fff!important}.react-tabs__tab--list{border:none!important}", "", {"version":3,"sources":["/./src/components/Team-Performance-Trend/src/components/Team-Performance-Trend/Team-Performance-Trend.scss","/./src/components/Team-Performance-Trend/src/styles/variables.scss"],"names":[],"mappings":"AAEA,2CACE,wBCYyB,CDb3B,6DAIM,sBAAA,mBAAoB,gBACF,CACnB,uDAKH,oBAAA,aAAc,mBACd,qBAAsB,iBACO,CAC9B,2CAGC,aAAc,iBACK,CACpB,mDAGC,eAAgB,oBAChB,aAAc,0BACd,sBAAuB,qBACvB,sBAAwB,CACzB,4CAGC,WAAa,eACG,iBACE,YACJ,CACf,oCAGC,uDACE,oBAAA,aAAc,qBACd,uBAAwB,cACR,CACjB,2CAEC,aAAc,kBACK,WACN,CACd,CAAA,2BAKC,sBAAsB,4BACQ,sBACN,aACV,mCAC0B,oBACV,CAPlC,uBAUI,qBAAwB,CACzB","file":"Team-Performance-Trend.scss","sourcesContent":["@import '../../styles/variables';\n\n.container {\n  background-color: $theme_light_green;\n   :global {\n    .performace-chart {\n      align-items: center;\n      padding-top: 10px;\n    }\n  }\n}\n\n.teamSelectorContainer {\n  display: flex;\n  justify-content: left;\n  padding: 20px 40px 20px 40px;\n}\n\n.whiteLogo {\n  height: 160px;\n  margin-right: 30px;\n}\n\n.dropDownContainer {\n  text-align: end;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n}\n\n.selectText {\n  color: white;\n  font-size: 20px;\n  text-align: start;\n  padding: 10px;\n}\n\n@media screen and (max-width: $mobile_breakpoint) {\n  .teamSelectorContainer {\n    display: flex;\n    justify-content: center;\n    padding: 20px 0;\n  }\n  .whiteLogo {\n    height: 160px;\n    margin-right: 13px;\n    width: 110px;\n  }\n}\n\n:global {\n  .react-tabs__tab--selected {\n    border: none!important;\n    border-radius: 5px !important;\n    margin: 10px !important;\n    padding: 15px;\n    background-color: $theme_blue !important;\n    color: $theme_white !important;\n  }\n  .react-tabs__tab--list {\n    border: none !important;\n  }\n}\n","// Color variables\n$theme_dark_red: #ca0716;\n$theme_grey_light: #e8e8e8;\n$theme_background_grey: #f8f8f8;\n$theme_white: #ffffff;\n$theme_text_grey: #606060;\n$theme_yellow:#fbff5b;\n$theme_green:#3ec654;\n$theme_black: #000000;\n$theme_red: #980411;\n$theme_orange:#F18625;\n$theme_purple:#7824EF;\n$theme_grey:#7F7F7F;\n$theme_blue:#172376;\n$theme_pink: #f9e2e3;\n$theme_light_green: #def3e2;\n\n\n//Font Size Variables\n$font-xs: 10px;\n$font-small: 12px;\n$font-medium: 15px;\n$font-large: 18px;\n\n//mobile breakpoint for css\n$mobile-breakpoint: 768px;"],"sourceRoot":"webpack://"}]);
	
	// exports
	exports.locals = {
		"container": "Team-Performance-Trend__container___Qb5bv",
		"teamSelectorContainer": "Team-Performance-Trend__teamSelectorContainer___3dTPx",
		"whiteLogo": "Team-Performance-Trend__whiteLogo___3uyoc",
		"dropDownContainer": "Team-Performance-Trend__dropDownContainer___1JkZo",
		"selectText": "Team-Performance-Trend__selectText___1Jm10"
	};

/***/ }),
/* 534 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Dropdown = __webpack_require__(535);
	
	var _Dropdown2 = _interopRequireDefault(_Dropdown);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Dropdown = function Dropdown(props) {
	  var options = props.optionList.map(function (data) {
	    return _react2.default.createElement(
	      'option',
	      { value: data.value, key: data.value },
	      data.label
	    );
	  });
	  return _react2.default.createElement(
	    'select',
	    { className: _Dropdown2.default.selected, onChange: props.onChange },
	    options
	  );
	};
	
	Dropdown.propTypes = {
	  optionList: _react2.default.PropTypes.array.isRequired,
	  onChange: _react2.default.PropTypes.func
	};
	
	exports.default = Dropdown;

/***/ }),
/* 535 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(536);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(432)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(true) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept(536, function() {
				var newContent = __webpack_require__(536);
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 536 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(431)();
	// imports
	
	
	// module
	exports.push([module.id, ".Dropdown__selected___2zaaL{background:url(" + __webpack_require__(537) + ") no-repeat 100%;width:215px;font-size:15px;color:#fff;height:50px;border:1px solid #fff;padding:8px}", "", {"version":3,"sources":["/./src/components/Dropdown/src/components/Dropdown/Dropdown.scss"],"names":[],"mappings":"AAEA,4BACE,wDAAqE,YAExD,eACG,WAEhB,YAAa,sBACiB,WACjB,CACd","file":"Dropdown.scss","sourcesContent":["@import '../../styles/variables';\n\n.selected {\n  background: url('../../assets/down-arrow.svg') no-repeat right center;\n  font-size: $font-medium;\n  width: 215px;\n  font-size: 15px;\n  color: $theme_white;\n  height: 50px;\n  border: solid $theme_white 1px;\n  padding: 8px;\n}\n"],"sourceRoot":"webpack://"}]);
	
	// exports
	exports.locals = {
		"selected": "Dropdown__selected___2zaaL"
	};

/***/ }),
/* 537 */
/***/ (function(module, exports) {

	module.exports = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMTJweCIgaGVpZ2h0PSI3cHgiIHZpZXdCb3g9IjAgMCAxMiA3IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0MS4yICgzNTM5NykgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+UGFnZSAxPC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGRlZnM+PC9kZWZzPgogICAgPGcgaWQ9IlBhZ2UtMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIj4KICAgICAgICA8ZyBpZD0iRWZmaWNpZW5jeS0tLVBlcmZvcm1hbmNlLS0tQ3Jvc3MtUE0iIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMjcuMDAwMDAwLCAtMTA0LjAwMDAwMCkiIHN0cm9rZT0iI0NBMDcxNiIgc3Ryb2tlLXdpZHRoPSIxLjUiPgogICAgICAgICAgICA8ZyBpZD0iR3JvdXAiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEyMy4wMDAwMDAsIDk4LjAwMDAwMCkiPgogICAgICAgICAgICAgICAgPHBhdGggZD0iTTEwNSw3IEwxMDkuMjgzNjIyLDExLjExNzE2NTMgQzEwOS42NzkyNjcsMTEuNDk3NDM1NyAxMTAuMzI4MDY0LDExLjQ5MDM5IDExMC43MTYzNzgsMTEuMTE3MTY1MyBMMTE1LDciIGlkPSJQYWdlLTEiPjwvcGF0aD4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+"

/***/ }),
/* 538 */
/***/ (function(module, exports) {

	module.exports = {"Kolkata Knight Riders":"Kolkata","Chennai Super Kings":"Chennai","Rajasthan Royals":"Jaipur","Mumbai Indians":"Mumbai","Deccan Chargers":"Hyderabad","Kings XI Punjab":"Chandigarh","Royal Challengers Bangalore":"Bangalore","Delhi Daredevils":"Delhi","Kochi Tuskers Kerala":"Kochi","Pune Warriors":"Pune","Sunrisers Hyderabad":"Hyderabad","Rising Pune Supergiants":"Pune","Gujarat Lions":"Rajkot"}

/***/ }),
/* 539 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(384);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(388);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(389);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(393);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(410);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _highcharts = __webpack_require__(530);
	
	var _highcharts2 = _interopRequireDefault(_highcharts);
	
	var _Highmaps = __webpack_require__(540);
	
	var _Highmaps2 = _interopRequireDefault(_Highmaps);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var HeatMap = function (_React$Component) {
	  (0, _inherits3.default)(HeatMap, _React$Component);
	
	  function HeatMap() {
	    var _ref;
	
	    var _temp, _this, _ret;
	
	    (0, _classCallCheck3.default)(this, HeatMap);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = HeatMap.__proto__ || (0, _getPrototypeOf2.default)(HeatMap)).call.apply(_ref, [this].concat(args))), _this), _this.initializeChart = function (data, series, container, xAxis, yAxis) {
	      _Highmaps2.default.chart(container, {
	        colors: ['#616b7c'],
	        chart: {
	          type: 'heatmap',
	          backgroundColor: null
	        },
	        title: {
	          text: data.title
	        },
	        credits: {
	          enabled: false
	        },
	        tooltip: {
	          enabled: false
	        },
	        xAxis: {
	          categories: xAxis
	        },
	
	        yAxis: {
	          categories: yAxis,
	          title: null
	        },
	
	        colorAxis: {
	          min: 0,
	          minColor: '#FFFFFF',
	          maxColor: _highcharts2.default.getOptions().colors[0]
	        },
	
	        legend: {
	          align: 'right',
	          layout: 'vertical',
	          margin: 0,
	          verticalAlign: 'top',
	          y: 0,
	          symbolHeight: 280
	        },
	
	        series: [{
	          name: data.name,
	          borderWidth: 1,
	          data: series,
	          dataLabels: {
	            enabled: true,
	            color: '#000000'
	          }
	        }]
	      });
	    }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
	  }
	
	  (0, _createClass3.default)(HeatMap, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      var _props = this.props,
	          data = _props.data,
	          series = _props.series,
	          container = _props.container,
	          xAxis = _props.xAxis,
	          yAxis = _props.yAxis;
	
	      this.initializeChart(data, series, container, xAxis, yAxis);
	    }
	  }, {
	    key: 'componentDidUpdate',
	    value: function componentDidUpdate() {
	      var _props2 = this.props,
	          data = _props2.data,
	          series = _props2.series,
	          container = _props2.container,
	          xAxis = _props2.xAxis,
	          yAxis = _props2.yAxis;
	
	      this.initializeChart(data, series, container, xAxis, yAxis);
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      return _react2.default.createElement('div', { id: this.props.container,
	        className: 'scroll' });
	    }
	  }]);
	  return HeatMap;
	}(_react2.default.Component);
	
	HeatMap.propTypes = {
	  data: _react2.default.PropTypes.object.isRequired,
	  series: _react2.default.PropTypes.array.isRequired,
	  xAxis: _react2.default.PropTypes.array,
	  yAxis: _react2.default.PropTypes.array,
	  container: _react2.default.PropTypes.string.isRequired
	};
	exports.default = HeatMap;

/***/ }),
/* 540 */
/***/ (function(module, exports) {

	/**
	 * @license Highmaps JS v5.0.14 (2017-07-28)
	 *
	 * (c) 2011-2016 Torstein Honsi
	 *
	 * License: www.highcharts.com/license
	 */
	'use strict';
	(function(root, factory) {
	    if (typeof module === 'object' && module.exports) {
	        module.exports = root.document ?
	            factory(root) :
	            factory;
	    } else {
	        root.Highcharts = factory(root);
	    }
	}(typeof window !== 'undefined' ? window : this, function(win) {
	    var Highcharts = (function() {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        /* global window */
	        var win = window,
	            doc = win.document;
	
	        var SVG_NS = 'http://www.w3.org/2000/svg',
	            userAgent = (win.navigator && win.navigator.userAgent) || '',
	            svg = doc && doc.createElementNS && !!doc.createElementNS(SVG_NS, 'svg').createSVGRect,
	            isMS = /(edge|msie|trident)/i.test(userAgent) && !window.opera,
	            vml = !svg,
	            isFirefox = /Firefox/.test(userAgent),
	            hasBidiBug = isFirefox && parseInt(userAgent.split('Firefox/')[1], 10) < 4; // issue #38
	
	        var Highcharts = win.Highcharts ? win.Highcharts.error(16, true) : {
	            product: 'Highmaps',
	            version: '5.0.14',
	            deg2rad: Math.PI * 2 / 360,
	            doc: doc,
	            hasBidiBug: hasBidiBug,
	            hasTouch: doc && doc.documentElement.ontouchstart !== undefined,
	            isMS: isMS,
	            isWebKit: /AppleWebKit/.test(userAgent),
	            isFirefox: isFirefox,
	            isTouchDevice: /(Mobile|Android|Windows Phone)/.test(userAgent),
	            SVG_NS: SVG_NS,
	            chartCount: 0,
	            seriesTypes: {},
	            symbolSizes: {},
	            svg: svg,
	            vml: vml,
	            win: win,
	            marginNames: ['plotTop', 'marginRight', 'marginBottom', 'plotLeft'],
	            noop: function() {
	                return undefined;
	            },
	            /**
	             * An array containing the current chart objects in the page. A chart's
	             * position in the array is preserved throughout the page's lifetime. When
	             * a chart is destroyed, the array item becomes `undefined`.
	             * @type {Array.<Highcharts.Chart>}
	             * @memberOf Highcharts
	             */
	            charts: []
	        };
	        return Highcharts;
	    }());
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        /* eslint max-len: ["warn", 80, 4] */
	
	        /**
	         * The Highcharts object is the placeholder for all other members, and various
	         * utility functions. The most important member of the namespace would be the
	         * chart constructor.
	         *
	         * @example
	         * var chart = Highcharts.chart('container', { ... });
	         * 
	         * @namespace Highcharts
	         */
	
	        var timers = [];
	
	        var charts = H.charts,
	            doc = H.doc,
	            win = H.win;
	
	        /**
	         * Provide error messages for debugging, with links to online explanation. This
	         * function can be overridden to provide custom error handling.
	         *
	         * @function #error
	         * @memberOf Highcharts
	         * @param {Number|String} code - The error code. See [errors.xml]{@link 
	         *     https://github.com/highcharts/highcharts/blob/master/errors/errors.xml}
	         *     for available codes. If it is a string, the error message is printed
	         *     directly in the console.
	         * @param {Boolean} [stop=false] - Whether to throw an error or just log a 
	         *     warning in the console.
	         *
	         * @sample highcharts/chart/highcharts-error/ Custom error handler
	         */
	        H.error = function(code, stop) {
	            var msg = H.isNumber(code) ?
	                'Highcharts error #' + code + ': www.highcharts.com/errors/' + code :
	                code;
	            if (stop) {
	                throw new Error(msg);
	            }
	            // else ...
	            if (win.console) {
	                console.log(msg); // eslint-disable-line no-console
	            }
	        };
	
	        /**
	         * An animator object used internally. One instance applies to one property
	         * (attribute or style prop) on one element. Animation is always initiated
	         * through {@link SVGElement#animate}.
	         *
	         * @constructor Fx
	         * @memberOf Highcharts
	         * @param {HTMLDOMElement|SVGElement} elem - The element to animate.
	         * @param {AnimationOptions} options - Animation options.
	         * @param {string} prop - The single attribute or CSS property to animate.
	         * @private
	         *
	         * @example
	         * var rect = renderer.rect(0, 0, 10, 10).add();
	         * rect.animate({ width: 100 });
	         */
	        H.Fx = function(elem, options, prop) {
	            this.options = options;
	            this.elem = elem;
	            this.prop = prop;
	        };
	        H.Fx.prototype = {
	
	            /**
	             * Set the current step of a path definition on SVGElement.
	             *
	             * @function #dSetter
	             * @memberOf Highcharts.Fx
	             */
	            dSetter: function() {
	                var start = this.paths[0],
	                    end = this.paths[1],
	                    ret = [],
	                    now = this.now,
	                    i = start.length,
	                    startVal;
	
	                // Land on the final path without adjustment points appended in the ends
	                if (now === 1) {
	                    ret = this.toD;
	
	                } else if (i === end.length && now < 1) {
	                    while (i--) {
	                        startVal = parseFloat(start[i]);
	                        ret[i] =
	                            isNaN(startVal) ? // a letter instruction like M or L
	                            start[i] :
	                            now * (parseFloat(end[i] - startVal)) + startVal;
	
	                    }
	                    // If animation is finished or length not matching, land on right value
	                } else {
	                    ret = end;
	                }
	                this.elem.attr('d', ret, null, true);
	            },
	
	            /**
	             * Update the element with the current animation step.
	             *
	             * @function #update
	             * @memberOf Highcharts.Fx
	             */
	            update: function() {
	                var elem = this.elem,
	                    prop = this.prop, // if destroyed, it is null
	                    now = this.now,
	                    step = this.options.step;
	
	                // Animation setter defined from outside
	                if (this[prop + 'Setter']) {
	                    this[prop + 'Setter']();
	
	                    // Other animations on SVGElement
	                } else if (elem.attr) {
	                    if (elem.element) {
	                        elem.attr(prop, now, null, true);
	                    }
	
	                    // HTML styles, raw HTML content like container size
	                } else {
	                    elem.style[prop] = now + this.unit;
	                }
	
	                if (step) {
	                    step.call(elem, now, this);
	                }
	
	            },
	
	            /**
	             * Run an animation.
	             *
	             * @function #run
	             * @memberOf Highcharts.Fx
	             * @param {Number} from - The current value, value to start from.
	             * @param {Number} to - The end value, value to land on.
	             * @param {String} [unit] - The property unit, for example `px`.
	             * 
	             */
	            run: function(from, to, unit) {
	                var self = this,
	                    timer = function(gotoEnd) {
	                        return timer.stopped ? false : self.step(gotoEnd);
	                    },
	                    i;
	
	                this.startTime = +new Date();
	                this.start = from;
	                this.end = to;
	                this.unit = unit;
	                this.now = this.start;
	                this.pos = 0;
	
	                timer.elem = this.elem;
	                timer.prop = this.prop;
	
	                if (timer() && timers.push(timer) === 1) {
	                    timer.timerId = setInterval(function() {
	
	                        for (i = 0; i < timers.length; i++) {
	                            if (!timers[i]()) {
	                                timers.splice(i--, 1);
	                            }
	                        }
	
	                        if (!timers.length) {
	                            clearInterval(timer.timerId);
	                        }
	                    }, 13);
	                }
	            },
	
	            /**
	             * Run a single step in the animation.
	             *
	             * @function #step
	             * @memberOf Highcharts.Fx
	             * @param   {Boolean} [gotoEnd] - Whether to go to the endpoint of the
	             *     animation after abort.
	             * @returns {Boolean} Returns `true` if animation continues.
	             */
	            step: function(gotoEnd) {
	                var t = +new Date(),
	                    ret,
	                    done,
	                    options = this.options,
	                    elem = this.elem,
	                    complete = options.complete,
	                    duration = options.duration,
	                    curAnim = options.curAnim;
	
	                if (elem.attr && !elem.element) { // #2616, element is destroyed
	                    ret = false;
	
	                } else if (gotoEnd || t >= duration + this.startTime) {
	                    this.now = this.end;
	                    this.pos = 1;
	                    this.update();
	
	                    curAnim[this.prop] = true;
	
	                    done = true;
	
	                    H.objectEach(curAnim, function(val) {
	                        if (val !== true) {
	                            done = false;
	                        }
	                    });
	
	                    if (done && complete) {
	                        complete.call(elem);
	                    }
	                    ret = false;
	
	                } else {
	                    this.pos = options.easing((t - this.startTime) / duration);
	                    this.now = this.start + ((this.end - this.start) * this.pos);
	                    this.update();
	                    ret = true;
	                }
	                return ret;
	            },
	
	            /**
	             * Prepare start and end values so that the path can be animated one to one.
	             *
	             * @function #initPath
	             * @memberOf Highcharts.Fx
	             * @param {SVGElement} elem - The SVGElement item.
	             * @param {String} fromD - Starting path definition.
	             * @param {Array} toD - Ending path definition.
	             * @returns {Array} An array containing start and end paths in array form
	             * so that they can be animated in parallel.
	             */
	            initPath: function(elem, fromD, toD) {
	                fromD = fromD || '';
	                var shift,
	                    startX = elem.startX,
	                    endX = elem.endX,
	                    bezier = fromD.indexOf('C') > -1,
	                    numParams = bezier ? 7 : 3,
	                    fullLength,
	                    slice,
	                    i,
	                    start = fromD.split(' '),
	                    end = toD.slice(), // copy
	                    isArea = elem.isArea,
	                    positionFactor = isArea ? 2 : 1,
	                    reverse;
	
	                /**
	                 * In splines make moveTo and lineTo points have six parameters like
	                 * bezier curves, to allow animation one-to-one.
	                 */
	                function sixify(arr) {
	                    var isOperator,
	                        nextIsOperator;
	                    i = arr.length;
	                    while (i--) {
	
	                        // Fill in dummy coordinates only if the next operator comes
	                        // three places behind (#5788)
	                        isOperator = arr[i] === 'M' || arr[i] === 'L';
	                        nextIsOperator = /[a-zA-Z]/.test(arr[i + 3]);
	                        if (isOperator && nextIsOperator) {
	                            arr.splice(
	                                i + 1, 0,
	                                arr[i + 1], arr[i + 2],
	                                arr[i + 1], arr[i + 2]
	                            );
	                        }
	                    }
	                }
	
	                /**
	                 * Insert an array at the given position of another array
	                 */
	                function insertSlice(arr, subArr, index) {
	                    [].splice.apply(
	                        arr, [index, 0].concat(subArr)
	                    );
	                }
	
	                /**
	                 * If shifting points, prepend a dummy point to the end path. 
	                 */
	                function prepend(arr, other) {
	                    while (arr.length < fullLength) {
	
	                        // Move to, line to or curve to?
	                        arr[0] = other[fullLength - arr.length];
	
	                        // Prepend a copy of the first point
	                        insertSlice(arr, arr.slice(0, numParams), 0);
	
	                        // For areas, the bottom path goes back again to the left, so we
	                        // need to append a copy of the last point.
	                        if (isArea) {
	                            insertSlice(
	                                arr,
	                                arr.slice(arr.length - numParams), arr.length
	                            );
	                            i--;
	                        }
	                    }
	                    arr[0] = 'M';
	                }
	
	                /**
	                 * Copy and append last point until the length matches the end length
	                 */
	                function append(arr, other) {
	                    var i = (fullLength - arr.length) / numParams;
	                    while (i > 0 && i--) {
	
	                        // Pull out the slice that is going to be appended or inserted.
	                        // In a line graph, the positionFactor is 1, and the last point
	                        // is sliced out. In an area graph, the positionFactor is 2,
	                        // causing the middle two points to be sliced out, since an area
	                        // path starts at left, follows the upper path then turns and
	                        // follows the bottom back. 
	                        slice = arr.slice().splice(
	                            (arr.length / positionFactor) - numParams,
	                            numParams * positionFactor
	                        );
	
	                        // Move to, line to or curve to?
	                        slice[0] = other[fullLength - numParams - (i * numParams)];
	
	                        // Disable first control point
	                        if (bezier) {
	                            slice[numParams - 6] = slice[numParams - 2];
	                            slice[numParams - 5] = slice[numParams - 1];
	                        }
	
	                        // Now insert the slice, either in the middle (for areas) or at
	                        // the end (for lines)
	                        insertSlice(arr, slice, arr.length / positionFactor);
	
	                        if (isArea) {
	                            i--;
	                        }
	                    }
	                }
	
	                if (bezier) {
	                    sixify(start);
	                    sixify(end);
	                }
	
	                // For sideways animation, find out how much we need to shift to get the
	                // start path Xs to match the end path Xs.
	                if (startX && endX) {
	                    for (i = 0; i < startX.length; i++) {
	                        // Moving left, new points coming in on right
	                        if (startX[i] === endX[0]) {
	                            shift = i;
	                            break;
	                            // Moving right
	                        } else if (startX[0] ===
	                            endX[endX.length - startX.length + i]) {
	                            shift = i;
	                            reverse = true;
	                            break;
	                        }
	                    }
	                    if (shift === undefined) {
	                        start = [];
	                    }
	                }
	
	                if (start.length && H.isNumber(shift)) {
	
	                    // The common target length for the start and end array, where both 
	                    // arrays are padded in opposite ends
	                    fullLength = end.length + shift * positionFactor * numParams;
	
	                    if (!reverse) {
	                        prepend(end, start);
	                        append(start, end);
	                    } else {
	                        prepend(start, end);
	                        append(end, start);
	                    }
	                }
	
	                return [start, end];
	            }
	        }; // End of Fx prototype
	
	        /**
	         * Handle animation of the color attributes directly.
	         */
	        H.Fx.prototype.fillSetter =
	            H.Fx.prototype.strokeSetter = function() {
	                this.elem.attr(
	                    this.prop,
	                    H.color(this.start).tweenTo(H.color(this.end), this.pos),
	                    null,
	                    true
	                );
	            };
	
	
	        /**
	         * Utility function to extend an object with the members of another.
	         *
	         * @function #extend
	         * @memberOf Highcharts
	         * @param {Object} a - The object to be extended.
	         * @param {Object} b - The object to add to the first one.
	         * @returns {Object} Object a, the original object.
	         */
	        H.extend = function(a, b) {
	            var n;
	            if (!a) {
	                a = {};
	            }
	            for (n in b) {
	                a[n] = b[n];
	            }
	            return a;
	        };
	
	        /**
	         * Utility function to deep merge two or more objects and return a third object.
	         * If the first argument is true, the contents of the second object is copied
	         * into the first object. The merge function can also be used with a single 
	         * object argument to create a deep copy of an object.
	         *
	         * @function #merge
	         * @memberOf Highcharts
	         * @param {Boolean} [extend] - Whether to extend the left-side object (a) or
	                  return a whole new object.
	         * @param {Object} a - The first object to extend. When only this is given, the
	                  function returns a deep copy.
	         * @param {...Object} [n] - An object to merge into the previous one.
	         * @returns {Object} - The merged object. If the first argument is true, the 
	         * return is the same as the second argument.
	         */
	        H.merge = function() {
	            var i,
	                args = arguments,
	                len,
	                ret = {},
	                doCopy = function(copy, original) {
	                    // An object is replacing a primitive
	                    if (typeof copy !== 'object') {
	                        copy = {};
	                    }
	
	                    H.objectEach(original, function(value, key) {
	
	                        // Copy the contents of objects, but not arrays or DOM nodes
	                        if (
	                            H.isObject(value, true) &&
	                            !H.isClass(value) &&
	                            !H.isDOMElement(value)
	                        ) {
	                            copy[key] = doCopy(copy[key] || {}, value);
	
	                            // Primitives and arrays are copied over directly
	                        } else {
	                            copy[key] = original[key];
	                        }
	                    });
	                    return copy;
	                };
	
	            // If first argument is true, copy into the existing object. Used in
	            // setOptions.
	            if (args[0] === true) {
	                ret = args[1];
	                args = Array.prototype.slice.call(args, 2);
	            }
	
	            // For each argument, extend the return
	            len = args.length;
	            for (i = 0; i < len; i++) {
	                ret = doCopy(ret, args[i]);
	            }
	
	            return ret;
	        };
	
	        /**
	         * Shortcut for parseInt
	         * @ignore
	         * @param {Object} s
	         * @param {Number} mag Magnitude
	         */
	        H.pInt = function(s, mag) {
	            return parseInt(s, mag || 10);
	        };
	
	        /**
	         * Utility function to check for string type.
	         *
	         * @function #isString
	         * @memberOf Highcharts
	         * @param {Object} s - The item to check.
	         * @returns {Boolean} - True if the argument is a string.
	         */
	        H.isString = function(s) {
	            return typeof s === 'string';
	        };
	
	        /**
	         * Utility function to check if an item is an array.
	         *
	         * @function #isArray
	         * @memberOf Highcharts
	         * @param {Object} obj - The item to check.
	         * @returns {Boolean} - True if the argument is an array.
	         */
	        H.isArray = function(obj) {
	            var str = Object.prototype.toString.call(obj);
	            return str === '[object Array]' || str === '[object Array Iterator]';
	        };
	
	        /**
	         * Utility function to check if an item is of type object.
	         *
	         * @function #isObject
	         * @memberOf Highcharts
	         * @param {Object} obj - The item to check.
	         * @param {Boolean} [strict=false] - Also checks that the object is not an
	         *    array.
	         * @returns {Boolean} - True if the argument is an object.
	         */
	        H.isObject = function(obj, strict) {
	            return !!obj && typeof obj === 'object' && (!strict || !H.isArray(obj));
	        };
	
	        /**
	         * Utility function to check if an Object is a HTML Element.
	         *
	         * @function #isDOMElement
	         * @memberOf Highcharts
	         * @param {Object} obj - The item to check.
	         * @returns {Boolean} - True if the argument is a HTML Element.
	         */
	        H.isDOMElement = function(obj) {
	            return H.isObject(obj) && typeof obj.nodeType === 'number';
	        };
	
	        /**
	         * Utility function to check if an Object is an class.
	         *
	         * @function #isClass
	         * @memberOf Highcharts
	         * @param {Object} obj - The item to check.
	         * @returns {Boolean} - True if the argument is an class.
	         */
	        H.isClass = function(obj) {
	            var c = obj && obj.constructor;
	            return !!(
	                H.isObject(obj, true) &&
	                !H.isDOMElement(obj) &&
	                (c && c.name && c.name !== 'Object')
	            );
	        };
	
	        /**
	         * Utility function to check if an item is of type number.
	         *
	         * @function #isNumber
	         * @memberOf Highcharts
	         * @param {Object} n - The item to check.
	         * @returns {Boolean} - True if the item is a number and is not NaN.
	         */
	        H.isNumber = function(n) {
	            return typeof n === 'number' && !isNaN(n);
	        };
	
	        /**
	         * Remove the last occurence of an item from an array.
	         *
	         * @function #erase
	         * @memberOf Highcharts
	         * @param {Array} arr - The array.
	         * @param {*} item - The item to remove.
	         */
	        H.erase = function(arr, item) {
	            var i = arr.length;
	            while (i--) {
	                if (arr[i] === item) {
	                    arr.splice(i, 1);
	                    break;
	                }
	            }
	        };
	
	        /**
	         * Check if an object is null or undefined.
	         *
	         * @function #defined
	         * @memberOf Highcharts
	         * @param {Object} obj - The object to check.
	         * @returns {Boolean} - False if the object is null or undefined, otherwise
	         *        true.
	         */
	        H.defined = function(obj) {
	            return obj !== undefined && obj !== null;
	        };
	
	        /**
	         * Set or get an attribute or an object of attributes. To use as a setter, pass
	         * a key and a value, or let the second argument be a collection of keys and
	         * values. To use as a getter, pass only a string as the second argument.
	         *
	         * @function #attr
	         * @memberOf Highcharts
	         * @param {Object} elem - The DOM element to receive the attribute(s).
	         * @param {String|Object} [prop] - The property or an object of key-value pairs.
	         * @param {String} [value] - The value if a single property is set.
	         * @returns {*} When used as a getter, return the value.
	         */
	        H.attr = function(elem, prop, value) {
	            var ret;
	
	            // if the prop is a string
	            if (H.isString(prop)) {
	                // set the value
	                if (H.defined(value)) {
	                    elem.setAttribute(prop, value);
	
	                    // get the value
	                } else if (elem && elem.getAttribute) {
	                    ret = elem.getAttribute(prop);
	                }
	
	                // else if prop is defined, it is a hash of key/value pairs
	            } else if (H.defined(prop) && H.isObject(prop)) {
	                H.objectEach(prop, function(val, key) {
	                    elem.setAttribute(key, val);
	                });
	            }
	            return ret;
	        };
	
	        /**
	         * Check if an element is an array, and if not, make it into an array.
	         *
	         * @function #splat
	         * @memberOf Highcharts
	         * @param obj {*} - The object to splat.
	         * @returns {Array} The produced or original array.
	         */
	        H.splat = function(obj) {
	            return H.isArray(obj) ? obj : [obj];
	        };
	
	        /**
	         * Set a timeout if the delay is given, otherwise perform the function
	         * synchronously.
	         *
	         * @function #syncTimeout
	         * @memberOf Highcharts
	         * @param   {Function} fn - The function callback.
	         * @param   {Number}   delay - Delay in milliseconds.
	         * @param   {Object}   [context] - The context.
	         * @returns {Number} An identifier for the timeout that can later be cleared
	         * with clearTimeout.
	         */
	        H.syncTimeout = function(fn, delay, context) {
	            if (delay) {
	                return setTimeout(fn, delay, context);
	            }
	            fn.call(0, context);
	        };
	
	
	        /**
	         * Return the first value that is not null or undefined.
	         *
	         * @function #pick
	         * @memberOf Highcharts
	         * @param {...*} items - Variable number of arguments to inspect.
	         * @returns {*} The value of the first argument that is not null or undefined.
	         */
	        H.pick = function() {
	            var args = arguments,
	                i,
	                arg,
	                length = args.length;
	            for (i = 0; i < length; i++) {
	                arg = args[i];
	                if (arg !== undefined && arg !== null) {
	                    return arg;
	                }
	            }
	        };
	
	        /**
	         * @typedef {Object} CSSObject - A style object with camel case property names.
	         * The properties can be whatever styles are supported on the given SVG or HTML
	         * element.
	         * @example
	         * {
	         *    fontFamily: 'monospace',
	         *    fontSize: '1.2em'
	         * }
	         */
	        /**
	         * Set CSS on a given element.
	         *
	         * @function #css
	         * @memberOf Highcharts
	         * @param {HTMLDOMElement} el - A HTML DOM element.
	         * @param {CSSObject} styles - Style object with camel case property names.
	         * 
	         */
	        H.css = function(el, styles) {
	            if (H.isMS && !H.svg) { // #2686
	                if (styles && styles.opacity !== undefined) {
	                    styles.filter = 'alpha(opacity=' + (styles.opacity * 100) + ')';
	                }
	            }
	            H.extend(el.style, styles);
	        };
	
	        /**
	         * A HTML DOM element.
	         * @typedef {Object} HTMLDOMElement
	         */
	
	        /**
	         * Utility function to create an HTML element with attributes and styles.
	         *
	         * @function #createElement
	         * @memberOf Highcharts
	         * @param {String} tag - The HTML tag.
	         * @param {Object} [attribs] - Attributes as an object of key-value pairs.
	         * @param {CSSObject} [styles] - Styles as an object of key-value pairs.
	         * @param {Object} [parent] - The parent HTML object.
	         * @param {Boolean} [nopad=false] - If true, remove all padding, border and
	         *    margin.
	         * @returns {HTMLDOMElement} The created DOM element.
	         */
	        H.createElement = function(tag, attribs, styles, parent, nopad) {
	            var el = doc.createElement(tag),
	                css = H.css;
	            if (attribs) {
	                H.extend(el, attribs);
	            }
	            if (nopad) {
	                css(el, {
	                    padding: 0,
	                    border: 'none',
	                    margin: 0
	                });
	            }
	            if (styles) {
	                css(el, styles);
	            }
	            if (parent) {
	                parent.appendChild(el);
	            }
	            return el;
	        };
	
	        /**
	         * Extend a prototyped class by new members.
	         *
	         * @function #extendClass
	         * @memberOf Highcharts
	         * @param {Object} parent - The parent prototype to inherit.
	         * @param {Object} members - A collection of prototype members to add or
	         *        override compared to the parent prototype.
	         * @returns {Object} A new prototype.
	         */
	        H.extendClass = function(parent, members) {
	            var object = function() {};
	            object.prototype = new parent(); // eslint-disable-line new-cap
	            H.extend(object.prototype, members);
	            return object;
	        };
	
	        /**
	         * Left-pad a string to a given length by adding a character repetetively.
	         *
	         * @function #pad
	         * @memberOf Highcharts
	         * @param {Number} number - The input string or number.
	         * @param {Number} length - The desired string length.
	         * @param {String} [padder=0] - The character to pad with.
	         * @returns {String} The padded string.
	         */
	        H.pad = function(number, length, padder) {
	            return new Array((length || 2) + 1 -
	                String(number).length).join(padder || 0) + number;
	        };
	
	        /**
	         * @typedef {Number|String} RelativeSize - If a number is given, it defines the
	         *    pixel length. If a percentage string is given, like for example `'50%'`,
	         *    the setting defines a length relative to a base size, for example the size
	         *    of a container.
	         */
	        /**
	         * Return a length based on either the integer value, or a percentage of a base.
	         *
	         * @function #relativeLength
	         * @memberOf Highcharts
	         * @param  {RelativeSize} value
	         *         A percentage string or a number.
	         * @param  {number} base
	         *         The full length that represents 100%.
	         * @param  {number} [offset=0]
	         *         A pixel offset to apply for percentage values. Used internally in 
	         *         axis positioning.
	         * @return {number}
	         *         The computed length.
	         */
	        H.relativeLength = function(value, base, offset) {
	            return (/%$/).test(value) ?
	                (base * parseFloat(value) / 100) + (offset || 0) :
	                parseFloat(value);
	        };
	
	        /**
	         * Wrap a method with extended functionality, preserving the original function.
	         *
	         * @function #wrap
	         * @memberOf Highcharts
	         * @param {Object} obj - The context object that the method belongs to. In real
	         *        cases, this is often a prototype.
	         * @param {String} method - The name of the method to extend.
	         * @param {Function} func - A wrapper function callback. This function is called
	         *        with the same arguments as the original function, except that the
	         *        original function is unshifted and passed as the first argument.
	         * 
	         */
	        H.wrap = function(obj, method, func) {
	            var proceed = obj[method];
	            obj[method] = function() {
	                var args = Array.prototype.slice.call(arguments),
	                    outerArgs = arguments,
	                    ctx = this,
	                    ret;
	                ctx.proceed = function() {
	                    proceed.apply(ctx, arguments.length ? arguments : outerArgs);
	                };
	                args.unshift(proceed);
	                ret = func.apply(this, args);
	                ctx.proceed = null;
	                return ret;
	            };
	        };
	
	        /**
	         * Get the time zone offset based on the current timezone information as set in
	         * the global options.
	         *
	         * @function #getTZOffset
	         * @memberOf Highcharts
	         * @param  {Number} timestamp - The JavaScript timestamp to inspect.
	         * @return {Number} - The timezone offset in minutes compared to UTC.
	         */
	        H.getTZOffset = function(timestamp) {
	            var d = H.Date;
	            return ((d.hcGetTimezoneOffset && d.hcGetTimezoneOffset(timestamp)) ||
	                d.hcTimezoneOffset || 0) * 60000;
	        };
	
	        /**
	         * Formats a JavaScript date timestamp (milliseconds since Jan 1st 1970) into a
	         * human readable date string. The format is a subset of the formats for PHP's
	         * [strftime]{@link
	         * http://www.php.net/manual/en/function.strftime.php} function. Additional
	         * formats can be given in the {@link Highcharts.dateFormats} hook.
	         *
	         * @function #dateFormat
	         * @memberOf Highcharts
	         * @param {String} format - The desired format where various time
	         *        representations are prefixed with %.
	         * @param {Number} timestamp - The JavaScript timestamp.
	         * @param {Boolean} [capitalize=false] - Upper case first letter in the return.
	         * @returns {String} The formatted date.
	         */
	        H.dateFormat = function(format, timestamp, capitalize) {
	            if (!H.defined(timestamp) || isNaN(timestamp)) {
	                return H.defaultOptions.lang.invalidDate || '';
	            }
	            format = H.pick(format, '%Y-%m-%d %H:%M:%S');
	
	            var D = H.Date,
	                date = new D(timestamp - H.getTZOffset(timestamp)),
	                // get the basic time values
	                hours = date[D.hcGetHours](),
	                day = date[D.hcGetDay](),
	                dayOfMonth = date[D.hcGetDate](),
	                month = date[D.hcGetMonth](),
	                fullYear = date[D.hcGetFullYear](),
	                lang = H.defaultOptions.lang,
	                langWeekdays = lang.weekdays,
	                shortWeekdays = lang.shortWeekdays,
	                pad = H.pad,
	
	                // List all format keys. Custom formats can be added from the outside. 
	                replacements = H.extend({
	
	                        //-- Day
	                        // Short weekday, like 'Mon'
	                        'a': shortWeekdays ?
	                            shortWeekdays[day] : langWeekdays[day].substr(0, 3),
	                        // Long weekday, like 'Monday'
	                        'A': langWeekdays[day],
	                        // Two digit day of the month, 01 to 31
	                        'd': pad(dayOfMonth),
	                        // Day of the month, 1 through 31
	                        'e': pad(dayOfMonth, 2, ' '),
	                        'w': day,
	
	                        // Week (none implemented)
	                        //'W': weekNumber(),
	
	                        //-- Month
	                        // Short month, like 'Jan'
	                        'b': lang.shortMonths[month],
	                        // Long month, like 'January'
	                        'B': lang.months[month],
	                        // Two digit month number, 01 through 12
	                        'm': pad(month + 1),
	
	                        //-- Year
	                        // Two digits year, like 09 for 2009
	                        'y': fullYear.toString().substr(2, 2),
	                        // Four digits year, like 2009
	                        'Y': fullYear,
	
	                        //-- Time
	                        // Two digits hours in 24h format, 00 through 23
	                        'H': pad(hours),
	                        // Hours in 24h format, 0 through 23
	                        'k': hours,
	                        // Two digits hours in 12h format, 00 through 11
	                        'I': pad((hours % 12) || 12),
	                        // Hours in 12h format, 1 through 12
	                        'l': (hours % 12) || 12,
	                        // Two digits minutes, 00 through 59
	                        'M': pad(date[D.hcGetMinutes]()),
	                        // Upper case AM or PM
	                        'p': hours < 12 ? 'AM' : 'PM',
	                        // Lower case AM or PM
	                        'P': hours < 12 ? 'am' : 'pm',
	                        // Two digits seconds, 00 through  59
	                        'S': pad(date.getSeconds()),
	                        // Milliseconds (naming from Ruby)
	                        'L': pad(Math.round(timestamp % 1000), 3)
	                    },
	
	                    /**
	                     * A hook for defining additional date format specifiers. New
	                     * specifiers are defined as key-value pairs by using the specifier
	                     * as key, and a function which takes the timestamp as value. This
	                     * function returns the formatted portion of the date.
	                     *
	                     * @type {Object}
	                     * @name dateFormats
	                     * @memberOf Highcharts
	                     * @sample highcharts/global/dateformats/ Adding support for week
	                     * number
	                     */
	                    H.dateFormats
	                );
	
	
	            // Do the replaces
	            H.objectEach(replacements, function(val, key) {
	                // Regex would do it in one line, but this is faster
	                while (format.indexOf('%' + key) !== -1) {
	                    format = format.replace(
	                        '%' + key,
	                        typeof val === 'function' ? val(timestamp) : val
	                    );
	                }
	
	            });
	
	            // Optionally capitalize the string and return
	            return capitalize ?
	                format.substr(0, 1).toUpperCase() + format.substr(1) :
	                format;
	        };
	
	        /**
	         * Format a single variable. Similar to sprintf, without the % prefix.
	         *
	         * @example
	         * formatSingle('.2f', 5); // => '5.00'.
	         *
	         * @function #formatSingle
	         * @memberOf Highcharts
	         * @param {String} format The format string.
	         * @param {*} val The value.
	         * @returns {String} The formatted representation of the value.
	         */
	        H.formatSingle = function(format, val) {
	            var floatRegex = /f$/,
	                decRegex = /\.([0-9])/,
	                lang = H.defaultOptions.lang,
	                decimals;
	
	            if (floatRegex.test(format)) { // float
	                decimals = format.match(decRegex);
	                decimals = decimals ? decimals[1] : -1;
	                if (val !== null) {
	                    val = H.numberFormat(
	                        val,
	                        decimals,
	                        lang.decimalPoint,
	                        format.indexOf(',') > -1 ? lang.thousandsSep : ''
	                    );
	                }
	            } else {
	                val = H.dateFormat(format, val);
	            }
	            return val;
	        };
	
	        /**
	         * Format a string according to a subset of the rules of Python's String.format
	         * method.
	         *
	         * @function #format
	         * @memberOf Highcharts
	         * @param {String} str The string to format.
	         * @param {Object} ctx The context, a collection of key-value pairs where each
	         *        key is replaced by its value.
	         * @returns {String} The formatted string.
	         *
	         * @example
	         * var s = Highcharts.format(
	         *     'The {color} fox was {len:.2f} feet long',
	         *     { color: 'red', len: Math.PI }
	         * );
	         * // => The red fox was 3.14 feet long
	         */
	        H.format = function(str, ctx) {
	            var splitter = '{',
	                isInside = false,
	                segment,
	                valueAndFormat,
	                path,
	                i,
	                len,
	                ret = [],
	                val,
	                index;
	
	            while (str) {
	                index = str.indexOf(splitter);
	                if (index === -1) {
	                    break;
	                }
	
	                segment = str.slice(0, index);
	                if (isInside) { // we're on the closing bracket looking back
	
	                    valueAndFormat = segment.split(':');
	                    path = valueAndFormat.shift().split('.'); // get first and leave
	                    len = path.length;
	                    val = ctx;
	
	                    // Assign deeper paths
	                    for (i = 0; i < len; i++) {
	                        val = val[path[i]];
	                    }
	
	                    // Format the replacement
	                    if (valueAndFormat.length) {
	                        val = H.formatSingle(valueAndFormat.join(':'), val);
	                    }
	
	                    // Push the result and advance the cursor
	                    ret.push(val);
	
	                } else {
	                    ret.push(segment);
	
	                }
	                str = str.slice(index + 1); // the rest
	                isInside = !isInside; // toggle
	                splitter = isInside ? '}' : '{'; // now look for next matching bracket
	            }
	            ret.push(str);
	            return ret.join('');
	        };
	
	        /**
	         * Get the magnitude of a number.
	         *
	         * @function #getMagnitude
	         * @memberOf Highcharts
	         * @param {Number} number The number.
	         * @returns {Number} The magnitude, where 1-9 are magnitude 1, 10-99 magnitude 2
	         *        etc.
	         */
	        H.getMagnitude = function(num) {
	            return Math.pow(10, Math.floor(Math.log(num) / Math.LN10));
	        };
	
	        /**
	         * Take an interval and normalize it to multiples of round numbers.
	         *
	         * @todo  Move this function to the Axis prototype. It is here only for
	         *        historical reasons.
	         * @function #normalizeTickInterval
	         * @memberOf Highcharts
	         * @param {Number} interval - The raw, un-rounded interval.
	         * @param {Array} [multiples] - Allowed multiples.
	         * @param {Number} [magnitude] - The magnitude of the number.
	         * @param {Boolean} [allowDecimals] - Whether to allow decimals.
	         * @param {Boolean} [hasTickAmount] - If it has tickAmount, avoid landing
	         *        on tick intervals lower than original.
	         * @returns {Number} The normalized interval.
	         */
	        H.normalizeTickInterval = function(interval, multiples, magnitude,
	            allowDecimals, hasTickAmount) {
	            var normalized,
	                i,
	                retInterval = interval;
	
	            // round to a tenfold of 1, 2, 2.5 or 5
	            magnitude = H.pick(magnitude, 1);
	            normalized = interval / magnitude;
	
	            // multiples for a linear scale
	            if (!multiples) {
	                multiples = hasTickAmount ?
	                    // Finer grained ticks when the tick amount is hard set, including
	                    // when alignTicks is true on multiple axes (#4580).
	                    [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] :
	
	                    // Else, let ticks fall on rounder numbers
	                    [1, 2, 2.5, 5, 10];
	
	
	                // the allowDecimals option
	                if (allowDecimals === false) {
	                    if (magnitude === 1) {
	                        multiples = H.grep(multiples, function(num) {
	                            return num % 1 === 0;
	                        });
	                    } else if (magnitude <= 0.1) {
	                        multiples = [1 / magnitude];
	                    }
	                }
	            }
	
	            // normalize the interval to the nearest multiple
	            for (i = 0; i < multiples.length; i++) {
	                retInterval = multiples[i];
	                // only allow tick amounts smaller than natural
	                if ((hasTickAmount && retInterval * magnitude >= interval) ||
	                    (!hasTickAmount && (normalized <= (multiples[i] +
	                        (multiples[i + 1] || multiples[i])) / 2))) {
	                    break;
	                }
	            }
	
	            // Multiply back to the correct magnitude. Correct floats to appropriate 
	            // precision (#6085).
	            retInterval = H.correctFloat(
	                retInterval * magnitude, -Math.round(Math.log(0.001) / Math.LN10)
	            );
	
	            return retInterval;
	        };
	
	
	        /**
	         * Sort an object array and keep the order of equal items. The ECMAScript
	         * standard does not specify the behaviour when items are equal.
	         *
	         * @function #stableSort
	         * @memberOf Highcharts
	         * @param {Array} arr - The array to sort.
	         * @param {Function} sortFunction - The function to sort it with, like with 
	         *        regular Array.prototype.sort.
	         * 
	         */
	        H.stableSort = function(arr, sortFunction) {
	            var length = arr.length,
	                sortValue,
	                i;
	
	            // Add index to each item
	            for (i = 0; i < length; i++) {
	                arr[i].safeI = i; // stable sort index
	            }
	
	            arr.sort(function(a, b) {
	                sortValue = sortFunction(a, b);
	                return sortValue === 0 ? a.safeI - b.safeI : sortValue;
	            });
	
	            // Remove index from items
	            for (i = 0; i < length; i++) {
	                delete arr[i].safeI; // stable sort index
	            }
	        };
	
	        /**
	         * Non-recursive method to find the lowest member of an array. `Math.min` raises
	         * a maximum call stack size exceeded error in Chrome when trying to apply more
	         * than 150.000 points. This method is slightly slower, but safe.
	         *
	         * @function #arrayMin
	         * @memberOf  Highcharts
	         * @param {Array} data An array of numbers.
	         * @returns {Number} The lowest number.
	         */
	        H.arrayMin = function(data) {
	            var i = data.length,
	                min = data[0];
	
	            while (i--) {
	                if (data[i] < min) {
	                    min = data[i];
	                }
	            }
	            return min;
	        };
	
	        /**
	         * Non-recursive method to find the lowest member of an array. `Math.max` raises
	         * a maximum call stack size exceeded error in Chrome when trying to apply more
	         * than 150.000 points. This method is slightly slower, but safe.
	         *
	         * @function #arrayMax
	         * @memberOf  Highcharts
	         * @param {Array} data - An array of numbers.
	         * @returns {Number} The highest number.
	         */
	        H.arrayMax = function(data) {
	            var i = data.length,
	                max = data[0];
	
	            while (i--) {
	                if (data[i] > max) {
	                    max = data[i];
	                }
	            }
	            return max;
	        };
	
	        /**
	         * Utility method that destroys any SVGElement instances that are properties on
	         * the given object. It loops all properties and invokes destroy if there is a
	         * destroy method. The property is then delete.
	         *
	         * @function #destroyObjectProperties
	         * @memberOf Highcharts
	         * @param {Object} obj - The object to destroy properties on.
	         * @param {Object} [except] - Exception, do not destroy this property, only
	         *    delete it.
	         * 
	         */
	        H.destroyObjectProperties = function(obj, except) {
	            H.objectEach(obj, function(val, n) {
	                // If the object is non-null and destroy is defined
	                if (val && val !== except && val.destroy) {
	                    // Invoke the destroy
	                    val.destroy();
	                }
	
	                // Delete the property from the object.
	                delete obj[n];
	            });
	        };
	
	
	        /**
	         * Discard a HTML element by moving it to the bin and delete.
	         *
	         * @function #discardElement
	         * @memberOf Highcharts
	         * @param {HTMLDOMElement} element - The HTML node to discard.
	         * 
	         */
	        H.discardElement = function(element) {
	            var garbageBin = H.garbageBin;
	            // create a garbage bin element, not part of the DOM
	            if (!garbageBin) {
	                garbageBin = H.createElement('div');
	            }
	
	            // move the node and empty bin
	            if (element) {
	                garbageBin.appendChild(element);
	            }
	            garbageBin.innerHTML = '';
	        };
	
	        /**
	         * Fix JS round off float errors.
	         *
	         * @function #correctFloat
	         * @memberOf Highcharts
	         * @param {Number} num - A float number to fix.
	         * @param {Number} [prec=14] - The precision.
	         * @returns {Number} The corrected float number.
	         */
	        H.correctFloat = function(num, prec) {
	            return parseFloat(
	                num.toPrecision(prec || 14)
	            );
	        };
	
	        /**
	         * Set the global animation to either a given value, or fall back to the given
	         * chart's animation option.
	         *
	         * @function #setAnimation
	         * @memberOf Highcharts
	         * @param {Boolean|Animation} animation - The animation object.
	         * @param {Object} chart - The chart instance.
	         * 
	         * @todo This function always relates to a chart, and sets a property on the
	         *        renderer, so it should be moved to the SVGRenderer.
	         */
	        H.setAnimation = function(animation, chart) {
	            chart.renderer.globalAnimation = H.pick(
	                animation,
	                chart.options.chart.animation,
	                true
	            );
	        };
	
	        /**
	         * Get the animation in object form, where a disabled animation is always
	         * returned as `{ duration: 0 }`.
	         *
	         * @function #animObject
	         * @memberOf Highcharts
	         * @param {Boolean|AnimationOptions} animation - An animation setting. Can be an
	         *        object with duration, complete and easing properties, or a boolean to
	         *        enable or disable.
	         * @returns {AnimationOptions} An object with at least a duration property.
	         */
	        H.animObject = function(animation) {
	            return H.isObject(animation) ?
	                H.merge(animation) : {
	                    duration: animation ? 500 : 0
	                };
	        };
	
	        /**
	         * The time unit lookup
	         */
	        H.timeUnits = {
	            millisecond: 1,
	            second: 1000,
	            minute: 60000,
	            hour: 3600000,
	            day: 24 * 3600000,
	            week: 7 * 24 * 3600000,
	            month: 28 * 24 * 3600000,
	            year: 364 * 24 * 3600000
	        };
	
	        /**
	         * Format a number and return a string based on input settings.
	         *
	         * @function #numberFormat
	         * @memberOf Highcharts
	         * @param {Number} number - The input number to format.
	         * @param {Number} decimals - The amount of decimals. A value of -1 preserves
	         *        the amount in the input number.
	         * @param {String} [decimalPoint] - The decimal point, defaults to the one given
	         *        in the lang options, or a dot.
	         * @param {String} [thousandsSep] - The thousands separator, defaults to the one
	         *        given in the lang options, or a space character.
	         * @returns {String} The formatted number.
	         *
	         * @sample members/highcharts-numberformat/ Custom number format
	         */
	        H.numberFormat = function(number, decimals, decimalPoint, thousandsSep) {
	            number = +number || 0;
	            decimals = +decimals;
	
	            var lang = H.defaultOptions.lang,
	                origDec = (number.toString().split('.')[1] || '').split('e')[0].length,
	                strinteger,
	                thousands,
	                ret,
	                roundedNumber,
	                exponent = number.toString().split('e');
	
	            if (decimals === -1) {
	                // Preserve decimals. Not huge numbers (#3793).
	                decimals = Math.min(origDec, 20);
	            } else if (!H.isNumber(decimals)) {
	                decimals = 2;
	            }
	
	            // Add another decimal to avoid rounding errors of float numbers. (#4573)
	            // Then use toFixed to handle rounding.
	            roundedNumber = (
	                Math.abs(exponent[1] ? exponent[0] : number) +
	                Math.pow(10, -Math.max(decimals, origDec) - 1)
	            ).toFixed(decimals);
	
	            // A string containing the positive integer component of the number
	            strinteger = String(H.pInt(roundedNumber));
	
	            // Leftover after grouping into thousands. Can be 0, 1 or 3.
	            thousands = strinteger.length > 3 ? strinteger.length % 3 : 0;
	
	            // Language
	            decimalPoint = H.pick(decimalPoint, lang.decimalPoint);
	            thousandsSep = H.pick(thousandsSep, lang.thousandsSep);
	
	            // Start building the return
	            ret = number < 0 ? '-' : '';
	
	            // Add the leftover after grouping into thousands. For example, in the
	            // number 42 000 000, this line adds 42.
	            ret += thousands ? strinteger.substr(0, thousands) + thousandsSep : '';
	
	            // Add the remaining thousands groups, joined by the thousands separator
	            ret += strinteger
	                .substr(thousands)
	                .replace(/(\d{3})(?=\d)/g, '$1' + thousandsSep);
	
	            // Add the decimal point and the decimal component
	            if (decimals) {
	                // Get the decimal component
	                ret += decimalPoint + roundedNumber.slice(-decimals);
	            }
	
	            if (exponent[1]) {
	                ret += 'e' + exponent[1];
	            }
	
	            return ret;
	        };
	
	        /**
	         * Easing definition
	         * @ignore
	         * @param   {Number} pos Current position, ranging from 0 to 1.
	         */
	        Math.easeInOutSine = function(pos) {
	            return -0.5 * (Math.cos(Math.PI * pos) - 1);
	        };
	
	        /**
	         * Get the computed CSS value for given element and property, only for numerical
	         * properties. For width and height, the dimension of the inner box (excluding
	         * padding) is returned. Used for fitting the chart within the container.
	         *
	         * @function #getStyle
	         * @memberOf Highcharts
	         * @param {HTMLDOMElement} el - A HTML element.
	         * @param {String} prop - The property name.
	         * @param {Boolean} [toInt=true] - Parse to integer.
	         * @returns {Number} - The numeric value.
	         */
	        H.getStyle = function(el, prop, toInt) {
	
	            var style;
	
	            // For width and height, return the actual inner pixel size (#4913)
	            if (prop === 'width') {
	                return Math.min(el.offsetWidth, el.scrollWidth) -
	                    H.getStyle(el, 'padding-left') -
	                    H.getStyle(el, 'padding-right');
	            } else if (prop === 'height') {
	                return Math.min(el.offsetHeight, el.scrollHeight) -
	                    H.getStyle(el, 'padding-top') -
	                    H.getStyle(el, 'padding-bottom');
	            }
	
	            // Otherwise, get the computed style
	            style = win.getComputedStyle(el, undefined);
	            if (style) {
	                style = style.getPropertyValue(prop);
	                if (H.pick(toInt, true)) {
	                    style = H.pInt(style);
	                }
	            }
	            return style;
	        };
	
	        /**
	         * Search for an item in an array.
	         *
	         * @function #inArray
	         * @memberOf Highcharts
	         * @param {*} item - The item to search for.
	         * @param {arr} arr - The array or node collection to search in.
	         * @returns {Number} - The index within the array, or -1 if not found.
	         */
	        H.inArray = function(item, arr) {
	            return arr.indexOf ? arr.indexOf(item) : [].indexOf.call(arr, item);
	        };
	
	        /**
	         * Filter an array by a callback.
	         *
	         * @function #grep
	         * @memberOf Highcharts
	         * @param {Array} arr - The array to filter.
	         * @param {Function} callback - The callback function. The function receives the
	         *        item as the first argument. Return `true` if the item is to be
	         *        preserved.
	         * @returns {Array} - A new, filtered array.
	         */
	        H.grep = function(arr, callback) {
	            return [].filter.call(arr, callback);
	        };
	
	        /**
	         * Return the value of the first element in the array that satisfies the 
	         * provided testing function.
	         *
	         * @function #find
	         * @memberOf Highcharts
	         * @param {Array} arr - The array to test.
	         * @param {Function} callback - The callback function. The function receives the
	         *        item as the first argument. Return `true` if this item satisfies the
	         *        condition.
	         * @returns {Mixed} - The value of the element.
	         */
	        H.find = function(arr, callback) {
	            return [].find.call(arr, callback);
	        };
	
	        /**
	         * Map an array by a callback.
	         *
	         * @function #map
	         * @memberOf Highcharts
	         * @param {Array} arr - The array to map.
	         * @param {Function} fn - The callback function. Return the new value for the 
	         *        new array.
	         * @returns {Array} - A new array item with modified items.
	         */
	        H.map = function(arr, fn) {
	            var results = [],
	                i = 0,
	                len = arr.length;
	
	            for (; i < len; i++) {
	                results[i] = fn.call(arr[i], arr[i], i, arr);
	            }
	
	            return results;
	        };
	
	        /**
	         * Get the element's offset position, corrected for `overflow: auto`.
	         *
	         * @function #offset
	         * @memberOf Highcharts
	         * @param {HTMLDOMElement} el - The HTML element.
	         * @returns {Object} An object containing `left` and `top` properties for the
	         * position in the page.
	         */
	        H.offset = function(el) {
	            var docElem = doc.documentElement,
	                box = el.getBoundingClientRect();
	
	            return {
	                top: box.top + (win.pageYOffset || docElem.scrollTop) -
	                    (docElem.clientTop || 0),
	                left: box.left + (win.pageXOffset || docElem.scrollLeft) -
	                    (docElem.clientLeft || 0)
	            };
	        };
	
	        /**
	         * Stop running animation.
	         *
	         * @todo A possible extension to this would be to stop a single property, when
	         * we want to continue animating others. Then assign the prop to the timer
	         * in the Fx.run method, and check for the prop here. This would be an
	         * improvement in all cases where we stop the animation from .attr. Instead of
	         * stopping everything, we can just stop the actual attributes we're setting.
	         *
	         * @function #stop
	         * @memberOf Highcharts
	         * @param {SVGElement} el - The SVGElement to stop animation on.
	         * @param {string} [prop] - The property to stop animating. If given, the stop
	         *    method will stop a single property from animating, while others continue.
	         * 
	         */
	        H.stop = function(el, prop) {
	
	            var i = timers.length;
	
	            // Remove timers related to this element (#4519)
	            while (i--) {
	                if (timers[i].elem === el && (!prop || prop === timers[i].prop)) {
	                    timers[i].stopped = true; // #4667
	                }
	            }
	        };
	
	        /**
	         * Iterate over an array.
	         *
	         * @function #each
	         * @memberOf Highcharts
	         * @param {Array} arr - The array to iterate over.
	         * @param {Function} fn - The iterator callback. It passes three arguments:
	         * * item - The array item.
	         * * index - The item's index in the array.
	         * * arr - The array that each is being applied to.
	         * @param {Object} [ctx] The context.
	         */
	        H.each = function(arr, fn, ctx) { // modern browsers
	            return Array.prototype.forEach.call(arr, fn, ctx);
	        };
	
	        /**
	         * Iterate over object key pairs in an object.
	         *
	         * @function #objectEach
	         * @memberOf Highcharts
	         * @param  {Object}   obj - The object to iterate over.
	         * @param  {Function} fn  - The iterator callback. It passes three arguments:
	         * * value - The property value.
	         * * key - The property key.
	         * * obj - The object that objectEach is being applied to.
	         * @param  {Object}   ctx The context
	         */
	        H.objectEach = function(obj, fn, ctx) {
	            for (var key in obj) {
	                if (obj.hasOwnProperty(key)) {
	                    fn.call(ctx, obj[key], key, obj);
	                }
	            }
	        };
	
	        /**
	         * Add an event listener.
	         *
	         * @function #addEvent
	         * @memberOf Highcharts
	         * @param {Object} el - The element or object to add a listener to. It can be a
	         *        {@link HTMLDOMElement}, an {@link SVGElement} or any other object.
	         * @param {String} type - The event type.
	         * @param {Function} fn - The function callback to execute when the event is 
	         *        fired.
	         * @returns {Function} A callback function to remove the added event.
	         */
	        H.addEvent = function(el, type, fn) {
	
	            var events = el.hcEvents = el.hcEvents || {};
	
	            function wrappedFn(e) {
	                e.target = e.srcElement || win; // #2820
	                fn.call(el, e);
	            }
	
	            // Handle DOM events in modern browsers
	            if (el.addEventListener) {
	                el.addEventListener(type, fn, false);
	
	                // Handle old IE implementation
	            } else if (el.attachEvent) {
	
	                if (!el.hcEventsIE) {
	                    el.hcEventsIE = {};
	                }
	
	                // unique function string (#6746)
	                if (!fn.hcGetKey) {
	                    fn.hcGetKey = H.uniqueKey();
	                }
	
	                // Link wrapped fn with original fn, so we can get this in removeEvent
	                el.hcEventsIE[fn.hcGetKey] = wrappedFn;
	
	                el.attachEvent('on' + type, wrappedFn);
	            }
	
	            if (!events[type]) {
	                events[type] = [];
	            }
	
	            events[type].push(fn);
	
	            // Return a function that can be called to remove this event.
	            return function() {
	                H.removeEvent(el, type, fn);
	            };
	        };
	
	        /**
	         * Remove an event that was added with {@link Highcharts#addEvent}.
	         *
	         * @function #removeEvent
	         * @memberOf Highcharts
	         * @param {Object} el - The element to remove events on.
	         * @param {String} [type] - The type of events to remove. If undefined, all
	         *        events are removed from the element.
	         * @param {Function} [fn] - The specific callback to remove. If undefined, all
	         *        events that match the element and optionally the type are removed.
	         * 
	         */
	        H.removeEvent = function(el, type, fn) {
	
	            var events,
	                hcEvents = el.hcEvents,
	                index;
	
	            function removeOneEvent(type, fn) {
	                if (el.removeEventListener) {
	                    el.removeEventListener(type, fn, false);
	                } else if (el.attachEvent) {
	                    fn = el.hcEventsIE[fn.hcGetKey];
	                    el.detachEvent('on' + type, fn);
	                }
	            }
	
	            function removeAllEvents() {
	                var types,
	                    len;
	
	                if (!el.nodeName) {
	                    return; // break on non-DOM events
	                }
	
	                if (type) {
	                    types = {};
	                    types[type] = true;
	                } else {
	                    types = hcEvents;
	                }
	
	                H.objectEach(types, function(val, n) {
	                    if (hcEvents[n]) {
	                        len = hcEvents[n].length;
	                        while (len--) {
	                            removeOneEvent(n, hcEvents[n][len]);
	                        }
	                    }
	                });
	            }
	
	            if (hcEvents) {
	                if (type) {
	                    events = hcEvents[type] || [];
	                    if (fn) {
	                        index = H.inArray(fn, events);
	                        if (index > -1) {
	                            events.splice(index, 1);
	                            hcEvents[type] = events;
	                        }
	                        removeOneEvent(type, fn);
	
	                    } else {
	                        removeAllEvents();
	                        hcEvents[type] = [];
	                    }
	                } else {
	                    removeAllEvents();
	                    el.hcEvents = {};
	                }
	            }
	        };
	
	        /**
	         * Fire an event that was registered with {@link Highcharts#addEvent}.
	         *
	         * @function #fireEvent
	         * @memberOf Highcharts
	         * @param {Object} el - The object to fire the event on. It can be a
	         *        {@link HTMLDOMElement}, an {@link SVGElement} or any other object.
	         * @param {String} type - The type of event.
	         * @param {Object} [eventArguments] - Custom event arguments that are passed on
	         *        as an argument to the event handler.
	         * @param {Function} [defaultFunction] - The default function to execute if the 
	         *        other listeners haven't returned false.
	         * 
	         */
	        H.fireEvent = function(el, type, eventArguments, defaultFunction) {
	            var e,
	                hcEvents = el.hcEvents,
	                events,
	                len,
	                i,
	                fn;
	
	            eventArguments = eventArguments || {};
	
	            if (doc.createEvent && (el.dispatchEvent || el.fireEvent)) {
	                e = doc.createEvent('Events');
	                e.initEvent(type, true, true);
	                //e.target = el;
	
	                H.extend(e, eventArguments);
	
	                if (el.dispatchEvent) {
	                    el.dispatchEvent(e);
	                } else {
	                    el.fireEvent(type, e);
	                }
	
	            } else if (hcEvents) {
	
	                events = hcEvents[type] || [];
	                len = events.length;
	
	                if (!eventArguments.target) { // We're running a custom event
	
	                    H.extend(eventArguments, {
	                        // Attach a simple preventDefault function to skip default
	                        // handler if called. The built-in defaultPrevented property is
	                        // not overwritable (#5112)
	                        preventDefault: function() {
	                            eventArguments.defaultPrevented = true;
	                        },
	                        // Setting target to native events fails with clicking the
	                        // zoom-out button in Chrome.
	                        target: el,
	                        // If the type is not set, we're running a custom event (#2297).
	                        // If it is set, we're running a browser event, and setting it
	                        // will cause en error in IE8 (#2465).		
	                        type: type
	                    });
	                }
	
	
	                for (i = 0; i < len; i++) {
	                    fn = events[i];
	
	                    // If the event handler return false, prevent the default handler
	                    // from executing
	                    if (fn && fn.call(el, eventArguments) === false) {
	                        eventArguments.preventDefault();
	                    }
	                }
	            }
	
	            // Run the default if not prevented
	            if (defaultFunction && !eventArguments.defaultPrevented) {
	                defaultFunction(eventArguments);
	            }
	        };
	
	        /**
	         * An animation configuration. Animation configurations can also be defined as
	         * booleans, where `false` turns off animation and `true` defaults to a duration
	         * of 500ms.
	         * @typedef {Object} AnimationOptions
	         * @property {Number} duration - The animation duration in milliseconds.
	         * @property {String} [easing] - The name of an easing function as defined on
	         *     the `Math` object.
	         * @property {Function} [complete] - A callback function to exectute when the
	         *     animation finishes.
	         * @property {Function} [step] - A callback function to execute on each step of
	         *     each attribute or CSS property that's being animated. The first argument
	         *     contains information about the animation and progress.
	         */
	
	
	        /**
	         * The global animate method, which uses Fx to create individual animators.
	         *
	         * @function #animate
	         * @memberOf Highcharts
	         * @param {HTMLDOMElement|SVGElement} el - The element to animate.
	         * @param {Object} params - An object containing key-value pairs of the
	         *        properties to animate. Supports numeric as pixel-based CSS properties
	         *        for HTML objects and attributes for SVGElements.
	         * @param {AnimationOptions} [opt] - Animation options.
	         */
	        H.animate = function(el, params, opt) {
	            var start,
	                unit = '',
	                end,
	                fx,
	                args;
	
	            if (!H.isObject(opt)) { // Number or undefined/null
	                args = arguments;
	                opt = {
	                    duration: args[2],
	                    easing: args[3],
	                    complete: args[4]
	                };
	            }
	            if (!H.isNumber(opt.duration)) {
	                opt.duration = 400;
	            }
	            opt.easing = typeof opt.easing === 'function' ?
	                opt.easing :
	                (Math[opt.easing] || Math.easeInOutSine);
	            opt.curAnim = H.merge(params);
	
	            H.objectEach(params, function(val, prop) {
	                // Stop current running animation of this property
	                H.stop(el, prop);
	
	                fx = new H.Fx(el, opt, prop);
	                end = null;
	
	                if (prop === 'd') {
	                    fx.paths = fx.initPath(
	                        el,
	                        el.d,
	                        params.d
	                    );
	                    fx.toD = params.d;
	                    start = 0;
	                    end = 1;
	                } else if (el.attr) {
	                    start = el.attr(prop);
	                } else {
	                    start = parseFloat(H.getStyle(el, prop)) || 0;
	                    if (prop !== 'opacity') {
	                        unit = 'px';
	                    }
	                }
	
	                if (!end) {
	                    end = val;
	                }
	                if (end && end.match && end.match('px')) {
	                    end = end.replace(/px/g, ''); // #4351
	                }
	                fx.run(start, end, unit);
	            });
	        };
	
	        /**
	         * Factory to create new series prototypes.
	         *
	         * @function #seriesType
	         * @memberOf Highcharts
	         *
	         * @param {String} type - The series type name.
	         * @param {String} parent - The parent series type name. Use `line` to inherit
	         *        from the basic {@link Series} object.
	         * @param {Object} options - The additional default options that is merged with
	         *        the parent's options.
	         * @param {Object} props - The properties (functions and primitives) to set on
	         *        the new prototype.
	         * @param {Object} [pointProps] - Members for a series-specific extension of the
	         *        {@link Point} prototype if needed.
	         * @returns {*} - The newly created prototype as extended from {@link Series}
	         * or its derivatives.
	         */
	        // docs: add to API + extending Highcharts
	        H.seriesType = function(type, parent, options, props, pointProps) {
	            var defaultOptions = H.getOptions(),
	                seriesTypes = H.seriesTypes;
	
	            // Merge the options
	            defaultOptions.plotOptions[type] = H.merge(
	                defaultOptions.plotOptions[parent],
	                options
	            );
	
	            // Create the class
	            seriesTypes[type] = H.extendClass(seriesTypes[parent] ||
	                function() {}, props);
	            seriesTypes[type].prototype.type = type;
	
	            // Create the point class if needed
	            if (pointProps) {
	                seriesTypes[type].prototype.pointClass =
	                    H.extendClass(H.Point, pointProps);
	            }
	
	            return seriesTypes[type];
	        };
	
	        /**
	         * Get a unique key for using in internal element id's and pointers. The key
	         * is composed of a random hash specific to this Highcharts instance, and a 
	         * counter.
	         * @function #uniqueKey
	         * @memberOf Highcharts
	         * @return {string} The key.
	         * @example
	         * var id = H.uniqueKey(); // => 'highcharts-x45f6hp-0'
	         */
	        H.uniqueKey = (function() {
	
	            var uniqueKeyHash = Math.random().toString(36).substring(2, 9),
	                idCounter = 0;
	
	            return function() {
	                return 'highcharts-' + uniqueKeyHash + '-' + idCounter++;
	            };
	        }());
	
	        /**
	         * Register Highcharts as a plugin in jQuery
	         */
	        if (win.jQuery) {
	            win.jQuery.fn.highcharts = function() {
	                var args = [].slice.call(arguments);
	
	                if (this[0]) { // this[0] is the renderTo div
	
	                    // Create the chart
	                    if (args[0]) {
	                        new H[ // eslint-disable-line no-new
	                            // Constructor defaults to Chart
	                            H.isString(args[0]) ? args.shift() : 'Chart'
	                        ](this[0], args[0], args[1]);
	                        return this;
	                    }
	
	                    // When called without parameters or with the return argument,
	                    // return an existing chart
	                    return charts[H.attr(this[0], 'data-highcharts-chart')];
	                }
	            };
	        }
	
	
	        /**
	         * Compatibility section to add support for legacy IE. This can be removed if
	         * old IE support is not needed.
	         */
	        if (doc && !doc.defaultView) {
	            H.getStyle = function(el, prop) {
	                var val,
	                    alias = {
	                        width: 'clientWidth',
	                        height: 'clientHeight'
	                    }[prop];
	
	                if (el.style[prop]) {
	                    return H.pInt(el.style[prop]);
	                }
	                if (prop === 'opacity') {
	                    prop = 'filter';
	                }
	
	                // Getting the rendered width and height
	                if (alias) {
	                    el.style.zoom = 1;
	                    return Math.max(el[alias] - 2 * H.getStyle(el, 'padding'), 0);
	                }
	
	                val = el.currentStyle[prop.replace(/\-(\w)/g, function(a, b) {
	                    return b.toUpperCase();
	                })];
	                if (prop === 'filter') {
	                    val = val.replace(
	                        /alpha\(opacity=([0-9]+)\)/,
	                        function(a, b) {
	                            return b / 100;
	                        }
	                    );
	                }
	
	                return val === '' ? 1 : H.pInt(val);
	            };
	        }
	
	        if (!Array.prototype.forEach) {
	            H.each = function(arr, fn, ctx) { // legacy
	                var i = 0,
	                    len = arr.length;
	                for (; i < len; i++) {
	                    if (fn.call(ctx, arr[i], i, arr) === false) {
	                        return i;
	                    }
	                }
	            };
	        }
	
	        if (!Array.prototype.indexOf) {
	            H.inArray = function(item, arr) {
	                var len,
	                    i = 0;
	
	                if (arr) {
	                    len = arr.length;
	
	                    for (; i < len; i++) {
	                        if (arr[i] === item) {
	                            return i;
	                        }
	                    }
	                }
	
	                return -1;
	            };
	        }
	
	        if (!Array.prototype.filter) {
	            H.grep = function(elements, fn) {
	                var ret = [],
	                    i = 0,
	                    length = elements.length;
	
	                for (; i < length; i++) {
	                    if (fn(elements[i], i)) {
	                        ret.push(elements[i]);
	                    }
	                }
	
	                return ret;
	            };
	        }
	
	        if (!Array.prototype.find) {
	            H.find = function(arr, fn) {
	                var i,
	                    length = arr.length;
	
	                for (i = 0; i < length; i++) {
	                    if (fn(arr[i], i)) {
	                        return arr[i];
	                    }
	                }
	            };
	        }
	
	        //--- End compatibility section ---
	
	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var each = H.each,
	            isNumber = H.isNumber,
	            map = H.map,
	            merge = H.merge,
	            pInt = H.pInt;
	
	        /**
	         * @typedef {string} ColorString
	         * A valid color to be parsed and handled by Highcharts. Highcharts internally 
	         * supports hex colors like `#ffffff`, rgb colors like `rgb(255,255,255)` and
	         * rgba colors like `rgba(255,255,255,1)`. Other colors may be supported by the
	         * browsers and displayed correctly, but Highcharts is not able to process them
	         * and apply concepts like opacity and brightening.
	         */
	        /**
	         * Handle color operations. The object methods are chainable.
	         * @param {String} input The input color in either rbga or hex format
	         */
	        H.Color = function(input) {
	            // Backwards compatibility, allow instanciation without new
	            if (!(this instanceof H.Color)) {
	                return new H.Color(input);
	            }
	            // Initialize
	            this.init(input);
	        };
	        H.Color.prototype = {
	
	            // Collection of parsers. This can be extended from the outside by pushing parsers
	            // to Highcharts.Color.prototype.parsers.
	            parsers: [{
	                // RGBA color
	                regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
	                parse: function(result) {
	                    return [pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10)];
	                }
	            }, {
	                // RGB color
	                regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
	                parse: function(result) {
	                    return [pInt(result[1]), pInt(result[2]), pInt(result[3]), 1];
	                }
	            }],
	
	            // Collection of named colors. Can be extended from the outside by adding
	            // colors to Highcharts.Color.prototype.names.
	            names: {
	                none: 'rgba(255,255,255,0)',
	                white: '#ffffff',
	                black: '#000000'
	            },
	
	            /**
	             * Parse the input color to rgba array
	             * @param {String} input
	             */
	            init: function(input) {
	                var result,
	                    rgba,
	                    i,
	                    parser,
	                    len;
	
	                this.input = input = this.names[
	                    input && input.toLowerCase ?
	                    input.toLowerCase() :
	                    ''
	                ] || input;
	
	                // Gradients
	                if (input && input.stops) {
	                    this.stops = map(input.stops, function(stop) {
	                        return new H.Color(stop[1]);
	                    });
	
	                    // Solid colors
	                } else {
	
	                    // Bitmasking as input[0] is not working for legacy IE.
	                    if (input && input.charAt() === '#') {
	
	                        len = input.length;
	                        input = parseInt(input.substr(1), 16);
	
	                        // Handle long-form, e.g. #AABBCC
	                        if (len === 7) {
	
	                            rgba = [
	                                (input & 0xFF0000) >> 16,
	                                (input & 0xFF00) >> 8,
	                                (input & 0xFF),
	                                1
	                            ];
	
	                            // Handle short-form, e.g. #ABC
	                            // In short form, the value is assumed to be the same 
	                            // for both nibbles for each component. e.g. #ABC = #AABBCC
	                        } else if (len === 4) {
	
	                            rgba = [
	                                ((input & 0xF00) >> 4) | (input & 0xF00) >> 8,
	                                ((input & 0xF0) >> 4) | (input & 0xF0),
	                                ((input & 0xF) << 4) | (input & 0xF),
	                                1
	                            ];
	                        }
	                    }
	
	                    // Otherwise, check regex parsers
	                    if (!rgba) {
	                        i = this.parsers.length;
	                        while (i-- && !rgba) {
	                            parser = this.parsers[i];
	                            result = parser.regex.exec(input);
	                            if (result) {
	                                rgba = parser.parse(result);
	                            }
	                        }
	                    }
	                }
	                this.rgba = rgba || [];
	            },
	
	            /**
	             * Return the color a specified format
	             * @param {String} format
	             */
	            get: function(format) {
	                var input = this.input,
	                    rgba = this.rgba,
	                    ret;
	
	                if (this.stops) {
	                    ret = merge(input);
	                    ret.stops = [].concat(ret.stops);
	                    each(this.stops, function(stop, i) {
	                        ret.stops[i] = [ret.stops[i][0], stop.get(format)];
	                    });
	
	                    // it's NaN if gradient colors on a column chart
	                } else if (rgba && isNumber(rgba[0])) {
	                    if (format === 'rgb' || (!format && rgba[3] === 1)) {
	                        ret = 'rgb(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ')';
	                    } else if (format === 'a') {
	                        ret = rgba[3];
	                    } else {
	                        ret = 'rgba(' + rgba.join(',') + ')';
	                    }
	                } else {
	                    ret = input;
	                }
	                return ret;
	            },
	
	            /**
	             * Brighten the color
	             * @param {Number} alpha
	             */
	            brighten: function(alpha) {
	                var i,
	                    rgba = this.rgba;
	
	                if (this.stops) {
	                    each(this.stops, function(stop) {
	                        stop.brighten(alpha);
	                    });
	
	                } else if (isNumber(alpha) && alpha !== 0) {
	                    for (i = 0; i < 3; i++) {
	                        rgba[i] += pInt(alpha * 255);
	
	                        if (rgba[i] < 0) {
	                            rgba[i] = 0;
	                        }
	                        if (rgba[i] > 255) {
	                            rgba[i] = 255;
	                        }
	                    }
	                }
	                return this;
	            },
	
	            /**
	             * Set the color's opacity to a given alpha value
	             * @param {Number} alpha
	             */
	            setOpacity: function(alpha) {
	                this.rgba[3] = alpha;
	                return this;
	            },
	
	            /*
	             * Return an intermediate color between two colors.
	             *
	             * @param  {Highcharts.Color} to
	             *         The color object to tween to.
	             * @param  {Number} pos
	             *         The intermediate position, where 0 is the from color (current
	             *         color item), and 1 is the `to` color.
	             *
	             * @return {String}
	             *         The intermediate color in rgba notation.
	             */
	            tweenTo: function(to, pos) {
	                // Check for has alpha, because rgba colors perform worse due to lack of
	                // support in WebKit.
	                var from = this,
	                    hasAlpha,
	                    ret;
	
	                // Unsupported color, return to-color (#3920)
	                if (!to.rgba.length) {
	                    ret = to.input || 'none';
	
	                    // Interpolate
	                } else {
	                    from = from.rgba;
	                    to = to.rgba;
	                    hasAlpha = (to[3] !== 1 || from[3] !== 1);
	                    ret = (hasAlpha ? 'rgba(' : 'rgb(') +
	                        Math.round(to[0] + (from[0] - to[0]) * (1 - pos)) + ',' +
	                        Math.round(to[1] + (from[1] - to[1]) * (1 - pos)) + ',' +
	                        Math.round(to[2] + (from[2] - to[2]) * (1 - pos)) +
	                        (hasAlpha ?
	                            (',' + (to[3] + (from[3] - to[3]) * (1 - pos))) :
	                            '') + ')';
	                }
	                return ret;
	            }
	        };
	        H.color = function(input) {
	            return new H.Color(input);
	        };
	
	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var color = H.color,
	            each = H.each,
	            getTZOffset = H.getTZOffset,
	            isTouchDevice = H.isTouchDevice,
	            merge = H.merge,
	            pick = H.pick,
	            svg = H.svg,
	            win = H.win;
	
	        /* ****************************************************************************
	         * Handle the options                                                         *
	         *****************************************************************************/
	        /** 	 
	         * @optionparent
	         */
	        H.defaultOptions = {
	
	
	            /**
	             * An array containing the default colors for the chart's series. When
	             * all colors are used, new colors are pulled from the start again.
	             * 
	             * Default colors can also be set on a series or series.type basis,
	             * see [column.colors](#plotOptions.column.colors), [pie.colors](#plotOptions.
	             * pie.colors).
	             * 
	             * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	             * style/style-by-css), the colors option doesn't exist. Instead, colors
	             * are defined in CSS and applied either through series or point class
	             * names, or through the [chart.colorCount](#chart.colorCount) option.
	             * 
	             * 
	             * ### Legacy
	             * 
	             * In Highcharts 3.x, the default colors were:
	             * 
	             * <pre>colors: ['#2f7ed8', '#0d233a', '#8bbc21', '#910000', '#1aadce',
	             * 
	             * '#492970', '#f28f43', '#77a1e5', '#c42525', '#a6c96a']</pre>
	             * 
	             * In Highcharts 2.x, the default colors were:
	             * 
	             * <pre>colors: ['#4572A7', '#AA4643', '#89A54E', '#80699B', '#3D96AE',
	             * 
	             *    '#DB843D', '#92A8CD', '#A47D7C', '#B5CA92']</pre>
	             * 
	             * @type {Array<Color>}
	             * @sample {highcharts} highcharts/chart/colors/ Assign a global color theme
	             * @default [ "#7cb5ec" , "#434348" , "#90ed7d" , "#f7a35c" , "#8085e9" ,
	             *          "#f15c80" , "#e4d354" , "#2b908f" , "#f45b5b" , "#91e8e1"]
	             * @product highcharts highstock highmaps
	             */
	            colors: '#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1'.split(' '),
	
	
	            /**
	             */
	            symbols: ['circle', 'diamond', 'square', 'triangle', 'triangle-down'],
	            lang: {
	
	                /**
	                 * The loading text that appears when the chart is set into the loading
	                 * state following a call to `chart.showLoading`.
	                 * 
	                 * @type {String}
	                 * @default Loading...
	                 * @product highcharts highstock highmaps
	                 */
	                loading: 'Loading...',
	
	                /**
	                 * An array containing the months names. Corresponds to the `%B` format
	                 * in `Highcharts.dateFormat()`.
	                 * 
	                 * @type {Array<String>}
	                 * @default [ "January" , "February" , "March" , "April" , "May" ,
	                 *          "June" , "July" , "August" , "September" , "October" ,
	                 *          "November" , "December"]
	                 * @product highcharts highstock highmaps
	                 */
	                months: [
	                    'January', 'February', 'March', 'April', 'May', 'June', 'July',
	                    'August', 'September', 'October', 'November', 'December'
	                ],
	
	                /**
	                 * An array containing the months names in abbreviated form. Corresponds
	                 * to the `%b` format in `Highcharts.dateFormat()`.
	                 * 
	                 * @type {Array<String>}
	                 * @default [ "Jan" , "Feb" , "Mar" , "Apr" , "May" , "Jun" ,
	                 *          "Jul" , "Aug" , "Sep" , "Oct" , "Nov" , "Dec"]
	                 */
	                shortMonths: [
	                    'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul',
	                    'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
	                ],
	
	                /**
	                 * An array containing the weekday names.
	                 * 
	                 * @type {Array<String>}
	                 * @default ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday",
	                 *          "Friday", "Saturday"]
	                 * @product highcharts highstock highmaps
	                 */
	                weekdays: [
	                    'Sunday', 'Monday', 'Tuesday', 'Wednesday',
	                    'Thursday', 'Friday', 'Saturday'
	                ],
	                // invalidDate: '',
	
	                /**
	                 * The default decimal point used in the `Highcharts.numberFormat`
	                 * method unless otherwise specified in the function arguments.
	                 * 
	                 * @type {String}
	                 * @default .
	                 * @since 1.2.2
	                 * @product highcharts highstock highmaps
	                 */
	                decimalPoint: '.',
	
	                /**
	                 * [Metric prefixes](http://en.wikipedia.org/wiki/Metric_prefix) used
	                 * to shorten high numbers in axis labels. Replacing any of the positions
	                 * with `null` causes the full number to be written. Setting `numericSymbols`
	                 * to `null` disables shortening altogether.
	                 * 
	                 * @type {Array<String>}
	                 * @sample {highcharts} highcharts/lang/numericsymbols/ Replacing the symbols with text
	                 * @sample {highstock} highcharts/lang/numericsymbols/ Replacing the symbols with text
	                 * @default [ "k" , "M" , "G" , "T" , "P" , "E"]
	                 * @since 2.3.0
	                 * @product highcharts highstock highmaps
	                 */
	                numericSymbols: ['k', 'M', 'G', 'T', 'P', 'E'], // SI prefixes used in axis labels
	
	                /**
	                 * The text for the label appearing when a chart is zoomed.
	                 * 
	                 * @type {String}
	                 * @default Reset zoom
	                 * @since 1.2.4
	                 * @product highcharts highstock highmaps
	                 */
	                resetZoom: 'Reset zoom',
	
	                /**
	                 * The tooltip title for the label appearing when a chart is zoomed.
	                 * 
	                 * @type {String}
	                 * @default Reset zoom level 1:1
	                 * @since 1.2.4
	                 * @product highcharts highstock highmaps
	                 */
	                resetZoomTitle: 'Reset zoom level 1:1',
	
	                /**
	                 * The default thousands separator used in the `Highcharts.numberFormat`
	                 * method unless otherwise specified in the function arguments. Since
	                 * Highcharts 4.1 it defaults to a single space character, which is
	                 * compatible with ISO and works across Anglo-American and continental
	                 * European languages.
	                 * 
	                 * The default is a single space.
	                 * 
	                 * @type {String}
	                 * @default  
	                 * @since 1.2.2
	                 * @product highcharts highstock highmaps
	                 */
	                thousandsSep: ' '
	            },
	
	            /**
	             * Global options that don't apply to each chart. These options, like
	             * the `lang` options, must be set using the `Highcharts.setOptions`
	             * method.
	             * 
	             * <pre>Highcharts.setOptions({
	             * global: {
	             * useUTC: false
	             * }
	             * });</pre>
	             * 
	             * @product highcharts highstock highmaps
	             */
	            global: {
	
	                /**
	                 * Whether to use UTC time for axis scaling, tickmark placement and
	                 * time display in `Highcharts.dateFormat`. Advantages of using UTC
	                 * is that the time displays equally regardless of the user agent's
	                 * time zone settings. Local time can be used when the data is loaded
	                 * in real time or when correct Daylight Saving Time transitions are
	                 * required.
	                 * 
	                 * @type {Boolean}
	                 * @sample {highcharts} highcharts/global/useutc-true/ True by default
	                 * @sample {highcharts} highcharts/global/useutc-false/ False
	                 * @default true
	                 * @product highcharts highstock highmaps
	                 */
	                useUTC: true,
	                //timezoneOffset: 0,
	
	
	                /**
	                 * Path to the pattern image required by VML browsers in order to
	                 * draw radial gradients.
	                 * 
	                 * @type {String}
	                 * @default {highcharts} http://code.highcharts.com/{version}/gfx/vml-radial-gradient.png
	                 * @default {highstock} http://code.highcharts.com/highstock/{version}/gfx/vml-radial-gradient.png
	                 * @default {highmaps} http://code.highcharts.com/{version}/gfx/vml-radial-gradient.png
	                 * @since 2.3.0
	                 * @product highcharts highstock highmaps
	                 */
	                VMLRadialGradientURL: 'http://code.highcharts.com/5.0.14/gfx/vml-radial-gradient.png'
	
	            },
	            chart: {
	
	                /**
	                 * When using multiple axis, the ticks of two or more opposite axes
	                 * will automatically be aligned by adding ticks to the axis or axes
	                 * with the least ticks, as if `tickAmount` were specified.
	                 * 
	                 * This can be prevented by setting `alignTicks` to false. If the grid
	                 * lines look messy, it's a good idea to hide them for the secondary
	                 * axis by setting `gridLineWidth` to 0.
	                 * 
	                 * @type {Boolean}
	                 * @sample {highcharts} highcharts/chart/alignticks-true/ True by default
	                 * @sample {highcharts} highcharts/chart/alignticks-false/ False
	                 * @sample {highstock} stock/chart/alignticks-true/
	                 *         True by default
	                 * @sample {highstock} stock/chart/alignticks-false/
	                 *         False
	                 * @default true
	                 * @product highcharts highstock
	                 * @apioption chart.alignTicks
	                 */
	
	
	                /**
	                 * Set the overall animation for all chart updating. Animation can be
	                 * disabled throughout the chart by setting it to false here. It can
	                 * be overridden for each individual API method as a function parameter.
	                 * The only animation not affected by this option is the initial series
	                 * animation, see [plotOptions.series.animation](#plotOptions.series.
	                 * animation).
	                 * 
	                 * The animation can either be set as a boolean or a configuration
	                 * object. If `true`, it will use the 'swing' jQuery easing and a
	                 * duration of 500 ms. If used as a configuration object, the following
	                 * properties are supported:
	                 * 
	                 * <dl>
	                 * 
	                 * <dt>duration</dt>
	                 * 
	                 * <dd>The duration of the animation in milliseconds.</dd>
	                 * 
	                 * <dt>easing</dt>
	                 * 
	                 * <dd>A string reference to an easing function set on the `Math` object.
	                 * See [the easing demo](http://jsfiddle.net/gh/get/library/pure/
	                 * highcharts/highcharts/tree/master/samples/highcharts/plotoptions/
	                 * series-animation-easing/).</dd>
	                 * 
	                 * </dl>
	                 * 
	                 * @type {Boolean|Object}
	                 * @sample {highcharts} highcharts/chart/animation-none/
	                 *         Updating with no animation
	                 * @sample {highcharts} highcharts/chart/animation-duration/
	                 *         With a longer duration
	                 * @sample {highcharts} highcharts/chart/animation-easing/
	                 *         With a jQuery UI easing
	                 * @sample {highmaps} maps/chart/animation-none/
	                 *         Updating with no animation
	                 * @sample {highmaps} maps/chart/animation-duration/
	                 *         With a longer duration
	                 * @default true
	                 * @apioption chart.animation
	                 */
	
	                /**
	                 * A CSS class name to apply to the charts container `div`, allowing
	                 * unique CSS styling for each chart.
	                 * 
	                 * @type {String}
	                 * @apioption chart.className
	                 */
	
	                /**
	                 * Event listeners for the chart.
	                 * 
	                 * @apioption chart.events
	                 */
	
	                /**
	                 * Fires when a series is added to the chart after load time, using
	                 * the `addSeries` method. One parameter, `event`, is passed to the
	                 * function, containing common event information.
	                 * Through `event.options` you can access the series options that was
	                 * passed to the `addSeries` method. Returning false prevents the series
	                 * from being added.
	                 * 
	                 * @type {Function}
	                 * @context Chart
	                 * @sample {highcharts} highcharts/chart/events-addseries/ Alert on add series
	                 * @sample {highstock} stock/chart/events-addseries/ Alert on add series
	                 * @since 1.2.0
	                 * @apioption chart.events.addSeries
	                 */
	
	                /**
	                 * Fires when clicking on the plot background. One parameter, `event`,
	                 * is passed to the function, containing common event information.
	                 * 
	                 * Information on the clicked spot can be found through `event.xAxis`
	                 * and `event.yAxis`, which are arrays containing the axes of each dimension
	                 * and each axis' value at the clicked spot. The primary axes are `event.
	                 * xAxis[0]` and `event.yAxis[0]`. Remember the unit of a datetime axis
	                 * is milliseconds since 1970-01-01 00:00:00.
	                 * 
	                 * <pre>click: function(e) {
	                 * console.log(
	                 * Highcharts.dateFormat('%Y-%m-%d %H:%M:%S', e.xAxis[0].value),
	                 * e.yAxis[0].value
	                 * )
	                 * }</pre>
	                 * 
	                 * @type {Function}
	                 * @context Chart
	                 * @sample {highcharts} highcharts/chart/events-click/
	                 *         Alert coordinates on click
	                 * @sample {highcharts} highcharts/chart/events-container/
	                 *         Alternatively, attach event to container
	                 * @sample {highstock} stock/chart/events-click/
	                 *         Alert coordinates on click
	                 * @sample {highstock} highcharts/chart/events-container/
	                 *         Alternatively, attach event to container
	                 * @sample {highmaps} maps/chart/events-click/
	                 *         Record coordinates on click
	                 * @sample {highmaps} highcharts/chart/events-container/
	                 *         Alternatively, attach event to container
	                 * @since 1.2.0
	                 * @apioption chart.events.click
	                 */
	
	
	                /**
	                 * Fires when the chart is finished loading. Since v4.2.2, it also waits
	                 * for images to be loaded, for example from point markers. One parameter,
	                 * `event`, is passed to the function, containing common event information.
	                 * 
	                 * There is also a second parameter to the chart constructor where a
	                 * callback function can be passed to be executed on chart.load.
	                 * 
	                 * @type {Function}
	                 * @context Chart
	                 * @sample {highcharts} highcharts/chart/events-load/
	                 *         Alert on chart load
	                 * @sample {highstock} stock/chart/events-load/
	                 *         Alert on chart load
	                 * @sample {highmaps} maps/chart/events-load/
	                 *         Add series on chart load
	                 * @apioption chart.events.load
	                 */
	
	                /**
	                 * Fires when the chart is redrawn, either after a call to chart.redraw()
	                 * or after an axis, series or point is modified with the `redraw` option
	                 * set to true. One parameter, `event`, is passed to the function, containing common event information.
	                 * 
	                 * @type {Function}
	                 * @context Chart
	                 * @sample {highcharts} highcharts/chart/events-redraw/
	                 *         Alert on chart redraw
	                 * @sample {highstock} stock/chart/events-redraw/
	                 *         Alert on chart redraw when adding a series or moving the
	                 *         zoomed range
	                 * @sample {highmaps} maps/chart/events-redraw/
	                 *         Set subtitle on chart redraw
	                 * @since 1.2.0
	                 * @apioption chart.events.redraw
	                 */
	
	                /**
	                 * Fires after initial load of the chart (directly after the `load`
	                 * event), and after each redraw (directly after the `redraw` event).
	                 * 
	                 * @type {Function}
	                 * @context Chart
	                 * @since 5.0.7
	                 * @apioption chart.events.render
	                 */
	
	                /**
	                 * Fires when an area of the chart has been selected. Selection is enabled
	                 * by setting the chart's zoomType. One parameter, `event`, is passed
	                 * to the function, containing common event information. The default action for the selection event is to
	                 * zoom the chart to the selected area. It can be prevented by calling
	                 * `event.preventDefault()`.
	                 * 
	                 * Information on the selected area can be found through `event.xAxis`
	                 * and `event.yAxis`, which are arrays containing the axes of each dimension
	                 * and each axis' min and max values. The primary axes are `event.xAxis[0]`
	                 * and `event.yAxis[0]`. Remember the unit of a datetime axis is milliseconds
	                 * since 1970-01-01 00:00:00.
	                 * 
	                 * <pre>selection: function(event) {
	                 * // log the min and max of the primary, datetime x-axis
	                 * console.log(
	                 * Highcharts.dateFormat('%Y-%m-%d %H:%M:%S', event.xAxis[0].min),
	                 * 
	                 * Highcharts.dateFormat('%Y-%m-%d %H:%M:%S', event.xAxis[0].max)
	                 * );
	                 * // log the min and max of the y axis
	                 * console.log(event.yAxis[0].min, event.yAxis[0].max);
	                 * }</pre>
	                 * 
	                 * @type {Function}
	                 * @sample {highcharts} highcharts/chart/events-selection/
	                 *         Report on selection and reset
	                 * @sample {highcharts} highcharts/chart/events-selection-points/
	                 *         Select a range of points through a drag selection
	                 * @sample {highstock} stock/chart/events-selection/
	                 *         Report on selection and reset
	                 * @sample {highstock} highcharts/chart/events-selection-points/
	                 *         Select a range of points through a drag selection (Highcharts)
	                 * @apioption chart.events.selection
	                 */
	
	                /**
	                 * The margin between the outer edge of the chart and the plot area.
	                 * The numbers in the array designate top, right, bottom and left
	                 * respectively. Use the options `marginTop`, `marginRight`,
	                 * `marginBottom` and `marginLeft` for shorthand setting of one option.
	                 * 
	                 * By default there is no margin. The actual space is dynamically calculated
	                 * from the offset of axis labels, axis title, title, subtitle and legend
	                 * in addition to the `spacingTop`, `spacingRight`, `spacingBottom`
	                 * and `spacingLeft` options.
	                 * 
	                 * @type {Array}
	                 * @sample {highcharts} highcharts/chart/margins-zero/
	                 *         Zero margins
	                 * @sample {highstock} stock/chart/margin-zero/
	                 *         Zero margins
	                 *
	                 * @defaults {all} null
	                 * @apioption chart.margin
	                 */
	
	                /**
	                 * The margin between the bottom outer edge of the chart and the plot
	                 * area. Use this to set a fixed pixel value for the margin as opposed
	                 * to the default dynamic margin. See also `spacingBottom`.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/chart/marginbottom/
	                 *         100px bottom margin
	                 * @sample {highstock} stock/chart/marginbottom/
	                 *         100px bottom margin
	                 * @sample {highmaps} maps/chart/margin/
	                 *         100px margins
	                 * @since 2.0
	                 * @apioption chart.marginBottom
	                 */
	
	                /**
	                 * The margin between the left outer edge of the chart and the plot
	                 * area. Use this to set a fixed pixel value for the margin as opposed
	                 * to the default dynamic margin. See also `spacingLeft`.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/chart/marginleft/
	                 *         150px left margin
	                 * @sample {highstock} stock/chart/marginleft/
	                 *         150px left margin
	                 * @sample {highmaps} maps/chart/margin/
	                 *         100px margins
	                 * @default null
	                 * @since 2.0
	                 * @apioption chart.marginLeft
	                 */
	
	                /**
	                 * The margin between the right outer edge of the chart and the plot
	                 * area. Use this to set a fixed pixel value for the margin as opposed
	                 * to the default dynamic margin. See also `spacingRight`.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/chart/marginright/
	                 *         100px right margin
	                 * @sample {highstock} stock/chart/marginright/
	                 *         100px right margin
	                 * @sample {highmaps} maps/chart/margin/
	                 *         100px margins
	                 * @default null
	                 * @since 2.0
	                 * @apioption chart.marginRight
	                 */
	
	                /**
	                 * The margin between the top outer edge of the chart and the plot area.
	                 * Use this to set a fixed pixel value for the margin as opposed to
	                 * the default dynamic margin. See also `spacingTop`.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/chart/margintop/ 100px top margin
	                 * @sample {highstock} stock/chart/margintop/
	                 *         100px top margin
	                 * @sample {highmaps} maps/chart/margin/
	                 *         100px margins
	                 * @default null
	                 * @since 2.0
	                 * @apioption chart.marginTop
	                 */
	
	                /**
	                 * Allows setting a key to switch between zooming and panning. Can be
	                 * one of `alt`, `ctrl`, `meta` (the command key on Mac and Windows
	                 * key on Windows) or `shift`. The keys are mapped directly to the key
	                 * properties of the click event argument (`event.altKey`, `event.ctrlKey`,
	                 * `event.metaKey` and `event.shiftKey`).
	                 * 
	                 * @validvalue [null, "alt", "ctrl", "meta", "shift"]
	                 * @type {String}
	                 * @since 4.0.3
	                 * @product highcharts
	                 * @apioption chart.panKey
	                 */
	
	                /**
	                 * Allow panning in a chart. Best used with [panKey](#chart.panKey)
	                 * to combine zooming and panning.
	                 * 
	                 * On touch devices, when the [tooltip.followTouchMove](#tooltip.followTouchMove)
	                 * option is `true` (default), panning requires two fingers. To allow
	                 * panning with one finger, set `followTouchMove` to `false`.
	                 * 
	                 * @type {Boolean}
	                 * @sample {highcharts} highcharts/chart/pankey/ Zooming and panning
	                 * @default {highcharts} false
	                 * @default {highstock} true
	                 * @since 4.0.3
	                 * @product highcharts highstock
	                 * @apioption chart.panning
	                 */
	
	
	                /**
	                 * Equivalent to [zoomType](#chart.zoomType), but for multitouch gestures
	                 * only. By default, the `pinchType` is the same as the `zoomType` setting.
	                 * However, pinching can be enabled separately in some cases, for example
	                 * in stock charts where a mouse drag pans the chart, while pinching
	                 * is enabled. When [tooltip.followTouchMove](#tooltip.followTouchMove)
	                 * is true, pinchType only applies to two-finger touches.
	                 * 
	                 * @validvalue ["x", "y", "xy"]
	                 * @type {String}
	                 * @default {highcharts} null
	                 * @default {highstock} x
	                 * @since 3.0
	                 * @product highcharts highstock
	                 * @apioption chart.pinchType
	                 */
	
	                /**
	                 * The corner radius of the outer chart border.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/chart/borderradius/ 20px radius
	                 * @sample {highstock} stock/chart/border/ 10px radius
	                 * @sample {highmaps} maps/chart/border/ Border options
	                 * @default 0
	                 * @product highcharts highstock highmaps
	                 */
	                borderRadius: 0,
	
	
	                /**
	                 * Alias of `type`.
	                 * 
	                 * @validvalue ["line", "spline", "column", "area", "areaspline", "pie"]
	                 * @type {String}
	                 * @deprecated
	                 * @sample {highcharts} highcharts/chart/defaultseriestype/ Bar
	                 * @default line
	                 * @product highcharts
	                 */
	                defaultSeriesType: 'line',
	
	                /**
	                 * If true, the axes will scale to the remaining visible series once
	                 * one series is hidden. If false, hiding and showing a series will
	                 * not affect the axes or the other series. For stacks, once one series
	                 * within the stack is hidden, the rest of the stack will close in
	                 * around it even if the axis is not affected.
	                 * 
	                 * @type {Boolean}
	                 * @sample {highcharts} highcharts/chart/ignorehiddenseries-true/
	                 *         True by default
	                 * @sample {highcharts} highcharts/chart/ignorehiddenseries-false/
	                 *         False
	                 * @sample {highcharts} highcharts/chart/ignorehiddenseries-true-stacked/
	                 *         True with stack
	                 * @sample {highstock} stock/chart/ignorehiddenseries-true/
	                 *         True by default
	                 * @sample {highstock} stock/chart/ignorehiddenseries-false/
	                 *         False
	                 * @default true
	                 * @since 1.2.0
	                 * @product highcharts highstock
	                 */
	                ignoreHiddenSeries: true,
	
	
	                /**
	                 * Whether to invert the axes so that the x axis is vertical and y axis
	                 * is horizontal. When `true`, the x axis is [reversed](#xAxis.reversed)
	                 * by default.
	                 *
	                 * @productdesc {highcharts}
	                 * If a bar series is present in the chart, it will be inverted
	                 * automatically. Inverting the chart doesn't have an effect if there
	                 * are no cartesian series in the chart, or if the chart is
	                 * [polar](#chart.polar).
	                 * 
	                 * @type {Boolean}
	                 * @sample {highcharts} highcharts/chart/inverted/
	                 *         Inverted line
	                 * @sample {highstock} stock/navigator/inverted/
	                 *         Inverted stock chart
	                 * @default false
	                 * @product highcharts highstock
	                 * @apioption chart.inverted
	                 */
	
	                /**
	                 * The distance between the outer edge of the chart and the content,
	                 * like title or legend, or axis title and labels if present. The
	                 * numbers in the array designate top, right, bottom and left respectively.
	                 * Use the options spacingTop, spacingRight, spacingBottom and spacingLeft
	                 * options for shorthand setting of one option.
	                 * 
	                 * @type {Array<Number>}
	                 * @see [chart.margin](#chart.margin)
	                 * @default [10, 10, 15, 10]
	                 * @since 3.0.6
	                 * @product highcharts highstock highmaps
	                 */
	                spacing: [10, 10, 15, 10],
	
	                /**
	                 * The button that appears after a selection zoom, allowing the user
	                 * to reset zoom.
	                 * 
	                 * @product highcharts highstock highmaps
	                 */
	                resetZoomButton: {
	
	                    /**
	                     * A collection of attributes for the button. The object takes SVG
	                     * attributes like `fill`, `stroke`, `stroke-width` or `r`, the border
	                     * radius. The theme also supports `style`, a collection of CSS properties
	                     * for the text. Equivalent attributes for the hover state are given
	                     * in `theme.states.hover`.
	                     * 
	                     * @type {Object}
	                     * @sample {highcharts} highcharts/chart/resetzoombutton-theme/ Theming the button
	                     * @sample {highstock} highcharts/chart/resetzoombutton-theme/ Theming the button
	                     * @since 2.2
	                     * @product highcharts highstock highmaps
	                     */
	                    theme: {
	
	                        /**
	                         */
	                        zIndex: 20
	                    },
	
	                    /**
	                     * The position of the button.
	                     * 
	                     * @type {Object}
	                     * @sample {highcharts} highcharts/chart/resetzoombutton-position/
	                     *         Above the plot area
	                     * @sample {highstock} highcharts/chart/resetzoombutton-position/
	                     *         Above the plot area
	                     * @sample {highmaps} highcharts/chart/resetzoombutton-position/
	                     *         Above the plot area
	                     * @since 2.2
	                     * @product highcharts highstock highmaps
	                     */
	                    position: {
	
	                        /**
	                         * The horizontal alignment of the button.
	                         * 
	                         * @type {String}
	                         */
	                        align: 'right',
	
	                        /**
	                         * The horizontal offset of the button.
	                         * 
	                         * @type {Number}
	                         */
	                        x: -10,
	
	                        /**
	                         * The vertical alignment of the button.
	                         * 
	                         * @validvalue ["top", "middle", "bottom"]
	                         * @type {String}
	                         * @default top
	                         * @apioption chart.resetZoomButton.position.verticalAlign
	                         */
	
	                        /**
	                         * The vertical offset of the button.
	                         * 
	                         * @type {Number}
	                         */
	                        y: 10
	                    }
	
	                    /**
	                     * What frame the button should be placed related to. Can be either
	                     * `plot` or `chart`
	                     * 
	                     * @validvalue ["plot", "chart"]
	                     * @type {String}
	                     * @sample {highcharts} highcharts/chart/resetzoombutton-relativeto/
	                     *         Relative to the chart
	                     * @sample {highstock} highcharts/chart/resetzoombutton-relativeto/
	                     *         Relative to the chart
	                     * @default plot
	                     * @since 2.2
	                     * @apioption chart.resetZoomButton.relativeTo
	                     */
	                },
	
	                /**
	                 * An explicit width for the chart. By default (when `null`) the width
	                 * is calculated from the offset width of the containing element.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/chart/width/ 800px wide
	                 * @sample {highstock} stock/chart/width/ 800px wide
	                 * @sample {highmaps} maps/chart/size/ Chart with explicit size
	                 * @default null
	                 * @product highcharts highstock highmaps
	                 */
	                width: null,
	
	                /**
	                 * An explicit height for the chart. If a _number_, the height is
	                 * given in pixels. If given a _percentage string_ (for example `'56%'`),
	                 * the height is given as the percentage of the actual chart width.
	                 * This allows for preserving the aspect ratio across responsive
	                 * sizes.
	                 * 
	                 * By default (when `null`) the height is calculated from the offset
	                 * height of the containing element, or 400 pixels if the containing
	                 * element's height is 0.
	                 * 
	                 * @type {Number|String}
	                 * @sample {highcharts} highcharts/chart/height/
	                 *         500px height
	                 * @sample {highstock} stock/chart/height/
	                 *         300px height
	                 * @sample {highmaps} maps/chart/size/
	                 *         Chart with explicit size
	                 * @sample highcharts/chart/height-percent/
	                 *         Highcharts with percentage height
	                 * @default null
	                 * @product highcharts highstock highmaps
	                 */
	                height: null,
	
	
	
	                /**
	                 * The color of the outer chart border.
	                 * 
	                 * @type {Color}
	                 * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the stroke is set with the `.highcharts-background`
	                 * class.
	                 * @sample {highcharts} highcharts/chart/bordercolor/ Brown border
	                 * @sample {highstock} stock/chart/border/ Brown border
	                 * @sample {highmaps} maps/chart/border/ Border options
	                 * @default #335cad
	                 * @product highcharts highstock highmaps
	                 */
	                borderColor: '#335cad',
	
	                /**
	                 * The pixel width of the outer chart border.
	                 * 
	                 * @type {Number}
	                 * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the stroke is set with the `.highcharts-background`
	                 * class.
	                 * @sample {highcharts} highcharts/chart/borderwidth/ 5px border
	                 * @sample {highstock} stock/chart/border/
	                 *         2px border
	                 * @sample {highmaps} maps/chart/border/
	                 *         Border options
	                 * @default 0
	                 * @apioption chart.borderWidth
	                 */
	
	                //style: {
	                //	fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Verdana, Arial, Helvetica, sans-serif', // default font
	                //	fontSize: '12px'
	                //},
	
	                /**
	                 * The background color or gradient for the outer chart area.
	                 * 
	                 * @type {Color}
	                 * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the background is set with the `.highcharts-
	                 * background` class.
	                 * @sample {highcharts} highcharts/chart/backgroundcolor-color/ Color
	                 * @sample {highcharts} highcharts/chart/backgroundcolor-gradient/ Gradient
	                 * @sample {highstock} stock/chart/backgroundcolor-color/
	                 *         Color
	                 * @sample {highstock} stock/chart/backgroundcolor-gradient/
	                 *         Gradient
	                 * @sample {highmaps} maps/chart/backgroundcolor-color/
	                 *         Color
	                 * @sample {highmaps} maps/chart/backgroundcolor-gradient/
	                 *         Gradient
	                 * @default #FFFFFF
	                 * @product highcharts highstock highmaps
	                 */
	                backgroundColor: '#ffffff',
	
	                /**
	                 * The background color or gradient for the plot area.
	                 * 
	                 * @type {Color}
	                 * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the plot background is set with the `.highcharts-
	                 * plot-background` class.
	                 * @sample {highcharts} highcharts/chart/plotbackgroundcolor-color/
	                 *         Color
	                 * @sample {highcharts} highcharts/chart/plotbackgroundcolor-gradient/
	                 *         Gradient
	                 * @sample {highstock} stock/chart/plotbackgroundcolor-color/
	                 *         Color
	                 * @sample {highstock} stock/chart/plotbackgroundcolor-gradient/
	                 *         Gradient
	                 * @sample {highmaps} maps/chart/plotbackgroundcolor-color/
	                 *         Color
	                 * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/
	                 *         Gradient
	                 * @default null
	                 * @apioption chart.plotBackgroundColor
	                 */
	
	
	                /**
	                 * The URL for an image to use as the plot background. To set an image
	                 * as the background for the entire chart, set a CSS background image
	                 * to the container element. Note that for the image to be applied to
	                 * exported charts, its URL needs to be accessible by the export server.
	                 * 
	                 * @type {String}
	                 * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), a plot background image can be set with the
	                 * `.highcharts-plot-background` class and a [custom pattern](http://www.
	                 * highcharts.com/docs/chart-design-and-style/gradients-shadows-and-
	                 * patterns).
	                 * @sample {highcharts} highcharts/chart/plotbackgroundimage/ Skies
	                 * @sample {highstock} stock/chart/plotbackgroundimage/ Skies
	                 * @default null
	                 * @apioption chart.plotBackgroundImage
	                 */
	
	                /**
	                 * The color of the inner chart or plot area border.
	                 * 
	                 * @type {Color}
	                 * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), a plot border stroke can be set with the `.
	                 * highcharts-plot-border` class.
	                 * @sample {highcharts} highcharts/chart/plotbordercolor/ Blue border
	                 * @sample {highstock} stock/chart/plotborder/ Blue border
	                 * @sample {highmaps} maps/chart/plotborder/ Plot border options
	                 * @default #cccccc
	                 * @product highcharts highstock highmaps
	                 */
	                plotBorderColor: '#cccccc'
	
	
	                /**
	                 * The pixel width of the plot area border.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/chart/plotborderwidth/ 1px border
	                 * @sample {highstock} stock/chart/plotborder/
	                 *         2px border
	                 * @sample {highmaps} maps/chart/plotborder/
	                 *         Plot border options
	                 * @default 0
	                 * @apioption chart.plotBorderWidth
	                 */
	
	                /**
	                 * Whether to apply a drop shadow to the plot area. Requires that
	                 * plotBackgroundColor be set. The shadow can be an object configuration
	                 * containing `color`, `offsetX`, `offsetY`, `opacity` and `width`.
	                 * 
	                 * @type {Boolean|Object}
	                 * @sample {highcharts} highcharts/chart/plotshadow/ Plot shadow
	                 * @sample {highstock} stock/chart/plotshadow/
	                 *         Plot shadow
	                 * @sample {highmaps} maps/chart/plotborder/
	                 *         Plot border options
	                 * @default false
	                 * @apioption chart.plotShadow
	                 */
	
	                /**
	                 * When true, cartesian charts like line, spline, area and column are
	                 * transformed into the polar coordinate system. Requires `highcharts-
	                 * more.js`.
	                 * 
	                 * @type {Boolean}
	                 * @default false
	                 * @since 2.3.0
	                 * @product highcharts
	                 * @apioption chart.polar
	                 */
	
	                /**
	                 * Whether to reflow the chart to fit the width of the container div
	                 * on resizing the window.
	                 * 
	                 * @type {Boolean}
	                 * @sample {highcharts} highcharts/chart/reflow-true/ True by default
	                 * @sample {highcharts} highcharts/chart/reflow-false/ False
	                 * @sample {highstock} stock/chart/reflow-true/
	                 *         True by default
	                 * @sample {highstock} stock/chart/reflow-false/
	                 *         False
	                 * @sample {highmaps} maps/chart/reflow-true/
	                 *         True by default
	                 * @sample {highmaps} maps/chart/reflow-false/
	                 *         False
	                 * @default true
	                 * @since 2.1
	                 * @apioption chart.reflow
	                 */
	
	
	
	
	                /**
	                 * The HTML element where the chart will be rendered. If it is a string,
	                 * the element by that id is used. The HTML element can also be passed
	                 * by direct reference, or as the first argument of the chart constructor,
	                 *  in which case the option is not needed.
	                 * 
	                 * @type {String|Object}
	                 * @sample {highcharts} highcharts/chart/reflow-true/
	                 *         String
	                 * @sample {highcharts} highcharts/chart/renderto-object/
	                 *         Object reference
	                 * @sample {highcharts} highcharts/chart/renderto-jquery/
	                 *         Object reference through jQuery
	                 * @sample {highstock} stock/chart/renderto-string/
	                 *         String
	                 * @sample {highstock} stock/chart/renderto-object/
	                 *         Object reference
	                 * @sample {highstock} stock/chart/renderto-jquery/
	                 *         Object reference through jQuery
	                 * @apioption chart.renderTo
	                 */
	
	                /**
	                 * The background color of the marker square when selecting (zooming
	                 * in on) an area of the chart.
	                 * 
	                 * @type {Color}
	                 * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the selection marker fill is set with the
	                 * `.highcharts-selection-marker` class.
	                 * @default rgba(51,92,173,0.25)
	                 * @since 2.1.7
	                 * @apioption chart.selectionMarkerFill
	                 */
	
	                /**
	                 * Whether to apply a drop shadow to the outer chart area. Requires
	                 * that backgroundColor be set. The shadow can be an object configuration
	                 * containing `color`, `offsetX`, `offsetY`, `opacity` and `width`.
	                 * 
	                 * @type {Boolean|Object}
	                 * @sample {highcharts} highcharts/chart/shadow/ Shadow
	                 * @sample {highstock} stock/chart/shadow/
	                 *         Shadow
	                 * @sample {highmaps} maps/chart/border/
	                 *         Chart border and shadow
	                 * @default false
	                 * @apioption chart.shadow
	                 */
	
	                /**
	                 * Whether to show the axes initially. This only applies to empty charts
	                 * where series are added dynamically, as axes are automatically added
	                 * to cartesian series.
	                 * 
	                 * @type {Boolean}
	                 * @sample {highcharts} highcharts/chart/showaxes-false/ False by default
	                 * @sample {highcharts} highcharts/chart/showaxes-true/ True
	                 * @since 1.2.5
	                 * @product highcharts
	                 * @apioption chart.showAxes
	                 */
	
	                /**
	                 * The space between the bottom edge of the chart and the content (plot
	                 * area, axis title and labels, title, subtitle or legend in top position).
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/chart/spacingbottom/
	                 *         Spacing bottom set to 100
	                 * @sample {highstock} stock/chart/spacingbottom/
	                 *         Spacing bottom set to 100
	                 * @sample {highmaps} maps/chart/spacing/
	                 *         Spacing 100 all around
	                 * @default 15
	                 * @since 2.1
	                 * @apioption chart.spacingBottom
	                 */
	
	                /**
	                 * The space between the left edge of the chart and the content (plot
	                 * area, axis title and labels, title, subtitle or legend in top position).
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/chart/spacingleft/
	                 *         Spacing left set to 100
	                 * @sample {highstock} stock/chart/spacingleft/
	                 *         Spacing left set to 100
	                 * @sample {highmaps} maps/chart/spacing/
	                 *         Spacing 100 all around
	                 * @default 10
	                 * @since 2.1
	                 * @apioption chart.spacingLeft
	                 */
	
	                /**
	                 * The space between the right edge of the chart and the content (plot
	                 * area, axis title and labels, title, subtitle or legend in top
	                 * position).
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/chart/spacingright-100/
	                 *         Spacing set to 100
	                 * @sample {highcharts} highcharts/chart/spacingright-legend/
	                 *         Legend in right position with default spacing
	                 * @sample {highstock} stock/chart/spacingright/
	                 *         Spacing set to 100
	                 * @sample {highmaps} maps/chart/spacing/
	                 *         Spacing 100 all around
	                 * @default 10
	                 * @since 2.1
	                 * @apioption chart.spacingRight
	                 */
	
	                /**
	                 * The space between the top edge of the chart and the content (plot
	                 * area, axis title and labels, title, subtitle or legend in top
	                 * position).
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/chart/spacingtop-100/
	                 * A top spacing of 100
	                 * @sample {highcharts} highcharts/chart/spacingtop-10/
	                 *         Floating chart title makes the plot area align to the default
	                 *         spacingTop of 10.
	                 * @sample {highstock} stock/chart/spacingtop/
	                 *         A top spacing of 100
	                 * @sample {highmaps} maps/chart/spacing/
	                 *         Spacing 100 all around
	                 * @default 10
	                 * @since 2.1
	                 * @apioption chart.spacingTop
	                 */
	
	                /**
	                 * Additional CSS styles to apply inline to the container `div`. Note
	                 * that since the default font styles are applied in the renderer, it
	                 * is ignorant of the individual chart options and must be set globally.
	                 * 
	                 * @type {CSSObject}
	                 * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), general chart styles can be set with the `.highcharts-
	                 * root` class.
	                 * @sample {highcharts} highcharts/chart/style-serif-font/
	                 *         Using a serif type font
	                 * @sample {highcharts} highcharts/css/em/
	                 *         Styled mode with relative font sizes
	                 * @sample {highstock} stock/chart/style/
	                 *         Using a serif type font
	                 * @sample {highmaps} maps/chart/style-serif-font/
	                 *         Using a serif type font
	                 * @default {"fontFamily":"\"Lucida Grande\", \"Lucida Sans Unicode\", Verdana, Arial, Helvetica, sans-serif","fontSize":"12px"}
	                 * @apioption chart.style
	                 */
	
	                /**
	                 * The default series type for the chart. Can be any of the chart types
	                 * listed under [plotOptions](#plotOptions).
	                 * 
	                 * @validvalue ["line", "spline", "column", "bar", "area", "areaspline", "pie", "arearange", "areasplinerange", "boxplot", "bubble", "columnrange", "errorbar", "funnel", "gauge", "heatmap", "polygon", "pyramid", "scatter", "solidgauge", "treemap", "waterfall"]
	                 * @type {String}
	                 * @sample {highcharts} highcharts/chart/type-bar/ Bar
	                 * @sample {highstock} stock/chart/type/
	                 *         Areaspline
	                 * @sample {highmaps} maps/chart/type-mapline/
	                 *         Mapline
	                 * @default {highcharts} line
	                 * @default {highstock} line
	                 * @default {highmaps} map
	                 * @since 2.1.0
	                 * @apioption chart.type
	                 */
	
	                /**
	                 * Decides in what dimensions the user can zoom by dragging the mouse.
	                 * Can be one of `x`, `y` or `xy`.
	                 * 
	                 * @validvalue [null, "x", "y", "xy"]
	                 * @type {String}
	                 * @see [panKey](#chart.panKey)
	                 * @sample {highcharts} highcharts/chart/zoomtype-none/ None by default
	                 * @sample {highcharts} highcharts/chart/zoomtype-x/ X
	                 * @sample {highcharts} highcharts/chart/zoomtype-y/ Y
	                 * @sample {highcharts} highcharts/chart/zoomtype-xy/ Xy
	                 * @sample {highstock} stock/demo/basic-line/ None by default
	                 * @sample {highstock} stock/chart/zoomtype-x/ X
	                 * @sample {highstock} stock/chart/zoomtype-y/ Y
	                 * @sample {highstock} stock/chart/zoomtype-xy/ Xy
	                 * @product highcharts highstock
	                 * @apioption chart.zoomType
	                 */
	            },
	
	            /**
	             * The chart's main title.
	             * 
	             * @sample {highmaps} maps/title/title/ Title options demonstrated
	             * @product highcharts highstock highmaps
	             */
	            title: {
	
	                /**
	                 * The title of the chart. To disable the title, set the `text` to
	                 * `null`.
	                 * 
	                 * @type {String}
	                 * @sample {highcharts} highcharts/title/text/ Custom title
	                 * @sample {highstock} stock/chart/title-text/ Custom title
	                 * @default {highcharts} Chart title
	                 * @default {highstock} null
	                 * @default {highmaps} Chart title
	                 * @product highcharts highstock highmaps
	                 */
	                text: 'Chart title',
	
	                /**
	                 * The horizontal alignment of the title. Can be one of "left", "center"
	                 * and "right".
	                 * 
	                 * @validvalue ["left", "center", "right"]
	                 * @type {String}
	                 * @sample {highcharts} highcharts/title/align/ Aligned to the plot area (x = 70px     = margin left - spacing left)
	                 * @sample {highstock} stock/chart/title-align/ Aligned to the plot area (x = 50px     = margin left - spacing left)
	                 * @default center
	                 * @since 2.0
	                 * @product highcharts highstock highmaps
	                 */
	                align: 'center',
	                // floating: false,
	
	                /**
	                 * The margin between the title and the plot area, or if a subtitle
	                 * is present, the margin between the subtitle and the plot area.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/title/margin-50/ A chart title margin of 50
	                 * @sample {highcharts} highcharts/title/margin-subtitle/ The same margin applied with a subtitle
	                 * @sample {highstock} stock/chart/title-margin/ A chart title margin of 50
	                 * @default 15
	                 * @since 2.1
	                 * @product highcharts highstock highmaps
	                 */
	                margin: 15,
	                // x: 0,
	                // verticalAlign: 'top',
	                // y: null,
	                // style: {}, // defined inline
	
	                /**
	                 * Adjustment made to the title width, normally to reserve space for
	                 * the exporting burger menu.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/title/widthadjust/ Wider menu, greater padding
	                 * @sample {highstock} highcharts/title/widthadjust/ Wider menu, greater padding
	                 * @sample {highmaps} highcharts/title/widthadjust/ Wider menu, greater padding
	                 * @default -44
	                 * @since 4.2.5
	                 * @product highcharts highstock highmaps
	                 */
	                widthAdjust: -44
	
	            },
	
	            /**
	             * The chart's subtitle. This can be used both to display a subtitle below
	             * the main title, and to display random text anywhere in the chart. The
	             * subtitle can be updated after chart initialization through the 
	             * `Chart.setTitle` method.
	             * 
	             * @sample {highmaps} maps/title/subtitle/ Subtitle options demonstrated
	             * @product highcharts highstock highmaps
	             */
	            subtitle: {
	
	                /**
	                 * The subtitle of the chart.
	                 * 
	                 * @type {String}
	                 * @sample {highcharts} highcharts/subtitle/text/ Custom subtitle
	                 * @sample {highcharts} highcharts/subtitle/text-formatted/ Formatted and linked text.
	                 * @sample {highstock} stock/chart/subtitle-text Custom subtitle
	                 * @sample {highstock} stock/chart/subtitle-text-formatted Formatted and linked text.
	                 * @product highcharts highstock highmaps
	                 */
	                text: '',
	
	                /**
	                 * The horizontal alignment of the subtitle. Can be one of "left",
	                 *  "center" and "right".
	                 * 
	                 * @validvalue ["left", "center", "right"]
	                 * @type {String}
	                 * @sample {highcharts} highcharts/subtitle/align/ Footnote at right of plot area
	                 * @sample {highstock} stock/chart/subtitle-footnote Footnote at bottom right of plot area
	                 * @default center
	                 * @since 2.0
	                 * @product highcharts highstock highmaps
	                 */
	                align: 'center',
	                // floating: false
	                // x: 0,
	                // verticalAlign: 'top',
	                // y: null,
	                // style: {}, // defined inline
	
	                /**
	                 * Adjustment made to the subtitle width, normally to reserve space
	                 * for the exporting burger menu.
	                 * 
	                 * @type {Number}
	                 * @see [title.widthAdjust](#title.widthAdjust)
	                 * @sample {highcharts} highcharts/title/widthadjust/ Wider menu, greater padding
	                 * @sample {highstock} highcharts/title/widthadjust/ Wider menu, greater padding
	                 * @sample {highmaps} highcharts/title/widthadjust/ Wider menu, greater padding
	                 * @default -44
	                 * @since 4.2.5
	                 * @product highcharts highstock highmaps
	                 */
	                widthAdjust: -44
	            },
	
	            /**
	             * The plotOptions is a wrapper object for config objects for each series
	             * type. The config objects for each series can also be overridden for
	             * each series item as given in the series array.
	             * 
	             * Configuration options for the series are given in three levels. Options
	             * for all series in a chart are given in the [plotOptions.series](#plotOptions.
	             * series) object. Then options for all series of a specific type are
	             * given in the plotOptions of that type, for example plotOptions.line.
	             * Next, options for one single series are given in [the series array](#series).
	             * 
	             * @product highcharts highstock highmaps
	             */
	            plotOptions: {},
	
	            /**
	             * HTML labels that can be positioned anywhere in the chart area.
	             * 
	             * @product highcharts highstock highmaps
	             */
	            labels: {
	                //items: [],
	
	                /**
	                 * Shared CSS styles for all labels.
	                 * 
	                 * @type {CSSObject}
	                 * @default { "color": "#333333" }
	                 * @product highcharts highstock highmaps
	                 */
	                style: {
	                    //font: defaultFont,
	
	                    /**
	                     */
	                    position: 'absolute',
	
	                    /**
	                     */
	                    color: '#333333'
	                }
	            },
	
	            /**
	             * The legend is a box containing a symbol and name for each series
	             * item or point item in the chart. Each series (or points in case
	             * of pie charts) is represented by a symbol and its name in the legend.
	             *  
	             * It is possible to override the symbol creator function and
	             * create [custom legend symbols](http://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/studies/legend-
	             * custom-symbol/).
	             * 
	             * @productdesc {highmaps}
	             * A Highmaps legend by default contains one legend item per series, but if
	             * a `colorAxis` is defined, the axis will be displayed in the legend.
	             * Either as a gradient, or as multiple legend items for `dataClasses`.
	             */
	            legend: {
	
	                /**
	                 * Enable or disable the legend.
	                 * 
	                 * @type {Boolean}
	                 * @sample {highcharts} highcharts/legend/enabled-false/ Legend disabled
	                 * @sample {highstock} stock/legend/align/ Various legend options
	                 * @sample {highmaps} maps/legend/enabled-false/ Legend disabled
	                 * @default {highstock} false
	                 * @default {highmaps} true
	                 * @product highcharts highstock highmaps
	                 */
	                enabled: true,
	
	                /**
	                 * The horizontal alignment of the legend box within the chart area.
	                 * Valid values are `left`, `center` and `right`.
	                 * 
	                 * In the case that the legend is aligned in a corner position, the
	                 * `layout` option will determine whether to place it above/below
	                 * or on the side of the plot area.
	                 * 
	                 * @validvalue ["left", "center", "right"]
	                 * @type {String}
	                 * @sample {highcharts} highcharts/legend/align/ Legend at the right of the chart
	                 * @sample {highstock} stock/legend/align/ Various legend options
	                 * @sample {highmaps} maps/legend/alignment/ Legend alignment
	                 * @default center
	                 * @since 2.0
	                 * @product highcharts highstock highmaps
	                 */
	                align: 'center',
	                //floating: false,
	
	                /**
	                 * The layout of the legend items. Can be one of "horizontal" or "vertical".
	                 * 
	                 * @validvalue ["horizontal", "vertical"]
	                 * @type {String}
	                 * @sample {highcharts} highcharts/legend/layout-horizontal/ Horizontal by default
	                 * @sample {highcharts} highcharts/legend/layout-vertical/ Vertical
	                 * @sample {highstock} stock/legend/layout-horizontal/ Horizontal by default
	                 * @sample {highmaps} maps/legend/padding-itemmargin/ Vertical with data classes
	                 * @sample {highmaps} maps/legend/layout-vertical/ Vertical with color axis gradient
	                 * @default horizontal
	                 * @product highcharts highstock highmaps
	                 */
	                layout: 'horizontal',
	
	                /**
	                 * Callback function to format each of the series' labels. The `this`
	                 * keyword refers to the series object, or the point object in case
	                 * of pie charts. By default the series or point name is printed.
	                 *
	                 * @productdesc {highmaps}
	                 *              In Highmaps the context can also be a data class in case
	                 *              of a `colorAxis`.
	                 * 
	                 * @type {Function}
	                 * @sample {highcharts} highcharts/legend/labelformatter/ Add text
	                 * @sample {highmaps} maps/legend/labelformatter/ Data classes with label formatter
	                 * @context {Series|Point}
	                 */
	                labelFormatter: function() {
	                    return this.name;
	                },
	                //borderWidth: 0,
	
	                /**
	                 * The color of the drawn border around the legend.
	                 * 
	                 * @type {Color}
	                 * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the legend border stroke can be applied with
	                 * the `.highcharts-legend-box` class.
	                 * @sample {highcharts} highcharts/legend/bordercolor/ Brown border
	                 * @sample {highstock} stock/legend/align/ Various legend options
	                 * @sample {highmaps} maps/legend/border-background/ Border and background options
	                 * @default #999999
	                 * @product highcharts highstock highmaps
	                 */
	                borderColor: '#999999',
	
	                /**
	                 * The border corner radius of the legend.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/legend/borderradius-default/ Square by default
	                 * @sample {highcharts} highcharts/legend/borderradius-round/ 5px rounded
	                 * @sample {highmaps} maps/legend/border-background/ Border and background options
	                 * @default 0
	                 * @product highcharts highstock highmaps
	                 */
	                borderRadius: 0,
	
	                /**
	                 * Options for the paging or navigation appearing when the legend
	                 * is overflown. Navigation works well on screen, but not in static
	                 * exported images. One way of working around that is to [increase
	                 * the chart height in export](http://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/legend/navigation-
	                 * enabled-false/).
	                 * 
	                 * @product highcharts highstock highmaps
	                 */
	                navigation: {
	
	
	                    /**
	                     * The color for the active up or down arrow in the legend page navigation.
	                     * 
	                     * @type {Color}
	                     * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                     * style/style-by-css), the active arrow be styled with the `.highcharts-
	                     * legend-nav-active` class.
	                     * @sample {highcharts} highcharts/legend/navigation/ Legend page navigation demonstrated
	                     * @sample {highstock} highcharts/legend/navigation/ Legend page navigation demonstrated
	                     * @default #003399
	                     * @since 2.2.4
	                     * @product highcharts highstock highmaps
	                     */
	                    activeColor: '#003399',
	
	                    /**
	                     * The color of the inactive up or down arrow in the legend page
	                     * navigation. .
	                     * 
	                     * @type {Color}
	                     * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                     * style/style-by-css), the inactive arrow be styled with the `.highcharts-
	                     * legend-nav-inactive` class.
	                     * @sample {highcharts} highcharts/legend/navigation/ Legend page navigation demonstrated
	                     * @sample {highstock} highcharts/legend/navigation/ Legend page navigation demonstrated
	                     * @default {highcharts} #cccccc
	                     * @default {highstock} #cccccc
	                     * @default {highmaps} ##cccccc
	                     * @since 2.2.4
	                     * @product highcharts highstock highmaps
	                     */
	                    inactiveColor: '#cccccc'
	
	                    // animation: true,
	                    // arrowSize: 12
	                    // style: {} // text styles
	                },
	                // margin: 20,
	                // reversed: false,
	                // backgroundColor: null,
	                /*style: {
	                	padding: '5px'
	                },*/
	
	
	                /**
	                 * CSS styles for each legend item. Only a subset of CSS is supported,
	                 * notably those options related to text. The default `textOverflow`
	                 * property makes long texts truncate. Set it to `null` to wrap text
	                 * instead. A `width` property can be added to control the text width.
	                 * 
	                 * @type {CSSObject}
	                 * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the legend items can be styled with the `.
	                 * highcharts-legend-item` class.
	                 * @sample {highcharts} highcharts/legend/itemstyle/ Bold black text
	                 * @sample {highmaps} maps/legend/itemstyle/ Item text styles
	                 * @default { "color": "#333333", "cursor": "pointer", "fontSize": "12px", "fontWeight": "bold", "textOverflow": "ellipsis" }
	                 * @product highcharts highstock highmaps
	                 */
	                itemStyle: {
	
	                    /**
	                     */
	                    color: '#333333',
	
	                    /**
	                     */
	                    fontSize: '12px',
	
	                    /**
	                     */
	                    fontWeight: 'bold',
	
	                    /**
	                     */
	                    textOverflow: 'ellipsis'
	                },
	
	                /**
	                 * CSS styles for each legend item in hover mode. Only a subset of
	                 * CSS is supported, notably those options related to text. Properties
	                 * are inherited from `style` unless overridden here.
	                 * 
	                 * @type {CSSObject}
	                 * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the hovered legend items can be styled with
	                 * the `.highcharts-legend-item:hover` pesudo-class.
	                 * @sample {highcharts} highcharts/legend/itemhoverstyle/ Red on hover
	                 * @sample {highmaps} maps/legend/itemstyle/ Item text styles
	                 * @default { "color": "#000000" }
	                 * @product highcharts highstock highmaps
	                 */
	                itemHoverStyle: {
	                    //cursor: 'pointer', removed as of #601
	
	                    /**
	                     */
	                    color: '#000000'
	                },
	
	                /**
	                 * CSS styles for each legend item when the corresponding series or
	                 * point is hidden. Only a subset of CSS is supported, notably those
	                 * options related to text. Properties are inherited from `style`
	                 * unless overridden here.
	                 * 
	                 * @type {CSSObject}
	                 * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the hidden legend items can be styled with
	                 * the `.highcharts-legend-item-hidden` class.
	                 * @sample {highcharts} highcharts/legend/itemhiddenstyle/ Darker gray color
	                 * @default { "color": "#cccccc" }
	                 * @product highcharts highstock highmaps
	                 */
	                itemHiddenStyle: {
	
	                    /**
	                     */
	                    color: '#cccccc'
	                },
	
	                /**
	                 * Whether to apply a drop shadow to the legend. A `backgroundColor`
	                 * also needs to be applied for this to take effect. The shadow can be
	                 * an object configuration containing `color`, `offsetX`, `offsetY`,
	                 * `opacity` and `width`.
	                 * 
	                 * @type {Boolean|Object}
	                 * @sample {highcharts} highcharts/legend/shadow/
	                 *         White background and drop shadow
	                 * @sample {highstock} stock/legend/align/
	                 *         Various legend options
	                 * @sample {highmaps} maps/legend/border-background/
	                 *         Border and background options
	                 * @default false
	                 * @product highcharts highstock highmaps
	                 */
	                shadow: false,
	
	
	                /**
	                 */
	                itemCheckboxStyle: {
	
	                    /**
	                     */
	                    position: 'absolute',
	
	                    /**
	                     */
	                    width: '13px', // for IE precision
	
	                    /**
	                     */
	                    height: '13px'
	                },
	                // itemWidth: undefined,
	
	                /**
	                 * When this is true, the legend symbol width will be the same as
	                 * the symbol height, which in turn defaults to the font size of the
	                 * legend items.
	                 * 
	                 * @type {Boolean}
	                 * @default true
	                 * @since 5.0.0
	                 * @product highcharts highstock highmaps
	                 */
	                squareSymbol: true,
	
	                /**
	                 * The pixel height of the symbol for series types that use a rectangle
	                 * in the legend. Defaults to the font size of legend items.
	                 *
	                 * @productdesc {highmaps}
	                 * In Highmaps, when the symbol is the gradient of a vertical color
	                 * axis, the height defaults to 200.
	                 * 
	                 * @type {Number}
	                 * @sample {highmaps} maps/legend/layout-vertical-sized/
	                 *         Sized vertical gradient
	                 * @sample {highmaps} maps/legend/padding-itemmargin/
	                 *         No distance between data classes
	                 * @since 3.0.8
	                 * @apioption legend.symbolHeight
	                 */
	
	                /**
	                 * The border radius of the symbol for series types that use a rectangle
	                 * in the legend. Defaults to half the `symbolHeight`.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/legend/symbolradius/ Round symbols
	                 * @sample {highstock} highcharts/legend/symbolradius/ Round symbols
	                 * @sample {highmaps} highcharts/legend/symbolradius/ Round symbols
	                 * @since 3.0.8
	                 * @apioption legend.symbolRadius
	                 */
	
	                /**
	                 * The pixel width of the legend item symbol. When the `squareSymbol`
	                 * option is set, this defaults to the `symbolHeight`, otherwise 16.
	                 * 
	                 * @productdesc {highmaps}
	                 * In Highmaps, when the symbol is the gradient of a horizontal color
	                 * axis, the width defaults to 200.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/legend/symbolwidth/
	                 *         Greater symbol width and padding
	                 * @sample {highmaps} maps/legend/padding-itemmargin/
	                 *         Padding and item margins demonstrated
	                 * @sample {highmaps} maps/legend/layout-vertical-sized/
	                 *         Sized vertical gradient
	                 * @apioption legend.symbolWidth
	                 */
	
	                /**
	                 * Whether to [use HTML](http://www.highcharts.com/docs/chart-concepts/labels-
	                 * and-string-formatting#html) to render the legend item texts. Prior
	                 * to 4.1.7, when using HTML, [legend.navigation](#legend.navigation)
	                 * was disabled.
	                 * 
	                 * @type {Boolean}
	                 * @default false
	                 * @apioption legend.useHTML
	                 */
	
	                /**
	                 * The width of the legend box.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/legend/width/ Aligned to the plot area
	                 * @default null
	                 * @since 2.0
	                 * @apioption legend.width
	                 */
	
	                /**
	                 * The pixel padding between the legend item symbol and the legend
	                 * item text.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/legend/symbolpadding/ Greater symbol width and padding
	                 * @default 5
	                 * @product highcharts highstock highmaps
	                 */
	                symbolPadding: 5,
	
	                /**
	                 * The vertical alignment of the legend box. Can be one of `top`,
	                 * `middle` or `bottom`. Vertical position can be further determined
	                 * by the `y` option.
	                 * 
	                 * In the case that the legend is aligned in a corner position, the
	                 * `layout` option will determine whether to place it above/below
	                 * or on the side of the plot area.
	                 * 
	                 * @validvalue ["top", "middle", "bottom"]
	                 * @type {String}
	                 * @sample {highcharts} highcharts/legend/verticalalign/ Legend 100px from the top of the chart
	                 * @sample {highstock} stock/legend/align/ Various legend options
	                 * @sample {highmaps} maps/legend/alignment/ Legend alignment
	                 * @default bottom
	                 * @since 2.0
	                 * @product highcharts highstock highmaps
	                 */
	                verticalAlign: 'bottom',
	                // width: undefined,
	
	                /**
	                 * The x offset of the legend relative to its horizontal alignment
	                 * `align` within chart.spacingLeft and chart.spacingRight. Negative
	                 * x moves it to the left, positive x moves it to the right.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/legend/width/ Aligned to the plot area
	                 * @default 0
	                 * @since 2.0
	                 * @product highcharts highstock highmaps
	                 */
	                x: 0,
	
	                /**
	                 * The vertical offset of the legend relative to it's vertical alignment
	                 * `verticalAlign` within chart.spacingTop and chart.spacingBottom.
	                 *  Negative y moves it up, positive y moves it down.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/legend/verticalalign/ Legend 100px from the top of the chart
	                 * @sample {highstock} stock/legend/align/ Various legend options
	                 * @sample {highmaps} maps/legend/alignment/ Legend alignment
	                 * @default 0
	                 * @since 2.0
	                 * @product highcharts highstock highmaps
	                 */
	                y: 0,
	
	                /**
	                 * A title to be added on top of the legend.
	                 * 
	                 * @sample {highcharts} highcharts/legend/title/ Legend title
	                 * @sample {highmaps} maps/legend/alignment/ Legend with title
	                 * @since 3.0
	                 * @product highcharts highstock highmaps
	                 */
	                title: {
	                    //text: null,
	
	
	                    /**
	                     * Generic CSS styles for the legend title.
	                     * 
	                     * @type {CSSObject}
	                     * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                     * style/style-by-css), the legend title is styled with the `.highcharts-
	                     * legend-title` class.
	                     * @default {"fontWeight":"bold"}
	                     * @since 3.0
	                     * @product highcharts highstock highmaps
	                     */
	                    style: {
	
	                        /**
	                         */
	                        fontWeight: 'bold'
	                    }
	
	                }
	            },
	
	
	            /**
	             * The loading options control the appearance of the loading screen
	             * that covers the plot area on chart operations. This screen only
	             * appears after an explicit call to `chart.showLoading()`. It is a
	             * utility for developers to communicate to the end user that something
	             * is going on, for example while retrieving new data via an XHR connection.
	             * The "Loading..." text itself is not part of this configuration
	             * object, but part of the `lang` object.
	             * 
	             * @product highcharts highstock highmaps
	             */
	            loading: {
	
	                /**
	                 * The duration in milliseconds of the fade out effect.
	                 * 
	                 * @type {Number}
	                 * @sample highcharts/loading/hideduration/ Fade in and out over a second
	                 * @default 100
	                 * @since 1.2.0
	                 * @apioption loading.hideDuration
	                 */
	
	                /**
	                 * The duration in milliseconds of the fade in effect.
	                 * 
	                 * @type {Number}
	                 * @sample highcharts/loading/hideduration/ Fade in and out over a second
	                 * @default 100
	                 * @since 1.2.0
	                 * @apioption loading.showDuration
	                 */
	
	
	                /**
	                 * CSS styles for the loading label `span`.
	                 * 
	                 * @type {CSSObject}
	                 * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the loading label is styled with the
	                 * `.highcharts-legend-loading-inner` class.
	                 * @sample {highcharts|highmaps} highcharts/loading/labelstyle/ Vertically centered
	                 * @sample {highstock} stock/loading/general/ Label styles
	                 * @default { "fontWeight": "bold", "position": "relative", "top": "45%" }
	                 * @since 1.2.0
	                 * @product highcharts highstock highmaps
	                 */
	                labelStyle: {
	                    fontWeight: 'bold',
	                    position: 'relative',
	                    top: '45%'
	                },
	
	                /**
	                 * CSS styles for the loading screen that covers the plot area.
	                 * 
	                 * @type {CSSObject}
	                 * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the loading label is styled with the `.highcharts-
	                 * legend-loading` class.
	                 * @sample {highcharts|highmaps} highcharts/loading/style/ Gray plot area, white text
	                 * @sample {highstock} stock/loading/general/ Gray plot area, white text
	                 * @default { "position": "absolute", "backgroundColor": "#ffffff", "opacity": 0.5, "textAlign": "center" }
	                 * @since 1.2.0
	                 */
	                style: {
	                    position: 'absolute',
	                    backgroundColor: '#ffffff',
	                    opacity: 0.5,
	                    textAlign: 'center'
	                }
	
	            },
	
	
	            /**
	             * Options for the tooltip that appears when the user hovers over a
	             * series or point.
	             * 
	             * @product highcharts highstock highmaps
	             */
	            tooltip: {
	
	                /**
	                 * Enable or disable the tooltip.
	                 * 
	                 * @type {Boolean}
	                 * @sample {highcharts} highcharts/tooltip/enabled/ Disabled
	                 * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/ Disable tooltip and show values on chart instead
	                 * @default true
	                 * @product highcharts highstock highmaps
	                 */
	                enabled: true,
	
	                /**
	                 * Enable or disable animation of the tooltip. In slow legacy IE browsers
	                 * the animation is disabled by default.
	                 * 
	                 * @type {Boolean}
	                 * @default true
	                 * @since 2.3.0
	                 * @product highcharts highstock highmaps
	                 */
	                animation: svg,
	                //crosshairs: null,
	
	                /**
	                 * The radius of the rounded border corners.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/tooltip/bordercolor-default/ 5px by default
	                 * @sample {highcharts} highcharts/tooltip/borderradius-0/ Square borders
	                 * @sample {highmaps} maps/tooltip/background-border/ Background and border demo
	                 * @default 3
	                 * @product highcharts highstock highmaps
	                 */
	                borderRadius: 3,
	
	                /**
	                 * For series on a datetime axes, the date format in the tooltip's
	                 * header will by default be guessed based on the closest data points.
	                 * This member gives the default string representations used for
	                 * each unit. For an overview of the replacement codes, see [dateFormat](#Highcharts.
	                 * dateFormat).
	                 * 
	                 * Defaults to:
	                 * 
	                 * <pre>{
	                 * millisecond:"%A, %b %e, %H:%M:%S.%L",
	                 * second:"%A, %b %e, %H:%M:%S",
	                 * minute:"%A, %b %e, %H:%M",
	                 * hour:"%A, %b %e, %H:%M",
	                 * day:"%A, %b %e, %Y",
	                 * week:"Week from %A, %b %e, %Y",
	                 * month:"%B %Y",
	                 * year:"%Y"
	                 * }</pre>
	                 * 
	                 * @type {Object}
	                 * @see [xAxis.dateTimeLabelFormats](#xAxis.dateTimeLabelFormats)
	                 * @product highcharts highstock
	                 */
	                dateTimeLabelFormats: {
	
	                    /**
	                     */
	                    millisecond: '%A, %b %e, %H:%M:%S.%L',
	
	                    /**
	                     */
	                    second: '%A, %b %e, %H:%M:%S',
	
	                    /**
	                     */
	                    minute: '%A, %b %e, %H:%M',
	
	                    /**
	                     */
	                    hour: '%A, %b %e, %H:%M',
	
	                    /**
	                     */
	                    day: '%A, %b %e, %Y',
	
	                    /**
	                     */
	                    week: 'Week from %A, %b %e, %Y',
	
	                    /**
	                     */
	                    month: '%B %Y',
	
	                    /**
	                     */
	                    year: '%Y'
	                },
	
	                /**
	                 * A string to append to the tooltip format.
	                 * 
	                 * @type {String}
	                 * @sample {highcharts} highcharts/tooltip/footerformat/ A table for value alignment
	                 * @sample {highmaps} maps/tooltip/format/ Format demo
	                 * @default false
	                 * @since 2.2
	                 * @product highcharts highmaps
	                 */
	                footerFormat: '',
	                //formatter: defaultFormatter,
	                /* todo: em font-size when finished comparing against HC4
	                headerFormat: '<span style="font-size: 0.85em">{point.key}</span><br/>',
	                */
	
	                /**
	                 * Padding inside the tooltip, in pixels.
	                 * 
	                 * @type {Number}
	                 * @default 8
	                 * @since 5.0.0
	                 * @product highcharts highstock highmaps
	                 */
	                padding: 8,
	
	                //shape: 'callout',
	                //shared: false,
	
	                /**
	                 * Proximity snap for graphs or single points. It defaults to 10 for
	                 * mouse-powered devices and 25 for touch devices.
	                 * 
	                 * Note that in most cases the whole plot area captures the mouse
	                 * movement, and in these cases `tooltip.snap` doesn't make sense.
	                 * This applies when [stickyTracking](#plotOptions.series.stickyTracking)
	                 * is `true` (default) and when the tooltip is [shared](#tooltip.shared)
	                 * or [split](#tooltip.split).
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/tooltip/bordercolor-default/ 10 px by default
	                 * @sample {highcharts} highcharts/tooltip/snap-50/ 50 px on graph
	                 * @default 10/25
	                 * @since 1.2.0
	                 * @product highcharts highstock
	                 */
	                snap: isTouchDevice ? 25 : 10,
	
	
	                /**
	                 * The background color or gradient for the tooltip.
	                 * 
	                 * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the stroke width is set in the `.highcharts-
	                 * tooltip-box` class.
	                 * 
	                 * @type {Color}
	                 * @sample {highcharts} highcharts/tooltip/backgroundcolor-solid/ Yellowish background
	                 * @sample {highcharts} highcharts/tooltip/backgroundcolor-gradient/ Gradient
	                 * @sample {highcharts} highcharts/css/tooltip-border-background/ Tooltip in styled mode
	                 * @sample {highstock} stock/tooltip/general/ Custom tooltip
	                 * @sample {highstock} highcharts/css/tooltip-border-background/ Tooltip in styled mode
	                 * @sample {highmaps} maps/tooltip/background-border/ Background and border demo
	                 * @sample {highmaps} highcharts/css/tooltip-border-background/ Tooltip in styled mode
	                 * @default rgba(247,247,247,0.85)
	                 * @product highcharts highstock highmaps
	                 */
	                backgroundColor: color('#f7f7f7').setOpacity(0.85).get(),
	
	                /**
	                 * The pixel width of the tooltip border.
	                 * 
	                 * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the stroke width is set in the `.highcharts-
	                 * tooltip-box` class.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/tooltip/bordercolor-default/ 2px by default
	                 * @sample {highcharts} highcharts/tooltip/borderwidth/ No border (shadow only)
	                 * @sample {highcharts} highcharts/css/tooltip-border-background/ Tooltip in styled mode
	                 * @sample {highstock} stock/tooltip/general/ Custom tooltip
	                 * @sample {highstock} highcharts/css/tooltip-border-background/ Tooltip in styled mode
	                 * @sample {highmaps} maps/tooltip/background-border/ Background and border demo
	                 * @sample {highmaps} highcharts/css/tooltip-border-background/ Tooltip in styled mode
	                 * @default 1
	                 * @product highcharts highstock highmaps
	                 */
	                borderWidth: 1,
	
	                /**
	                 * The HTML of the tooltip header line. Variables are enclosed by
	                 * curly brackets. Available variables are `point.key`, `series.name`,
	                 * `series.color` and other members from the `point` and `series`
	                 * objects. The `point.key` variable contains the category name, x
	                 * value or datetime string depending on the type of axis. For datetime
	                 * axes, the `point.key` date format can be set using tooltip.xDateFormat.
	                 * 
	                 * 
	                 * Defaults to `<span style="font-size: 10px">{point.key}</span><br/>`
	                 * 
	                 * @type {String}
	                 * @sample {highcharts} highcharts/tooltip/footerformat/ A HTML table in the tooltip
	                 * @sample {highstock} highcharts/tooltip/footerformat/ A HTML table in the tooltip
	                 * @sample {highmaps} maps/tooltip/format/ Format demo
	                 * @product highcharts highstock highmaps
	                 */
	                headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
	
	                /**
	                 * The HTML of the point's line in the tooltip. Variables are enclosed
	                 * by curly brackets. Available variables are point.x, point.y, series.
	                 * name and series.color and other properties on the same form. Furthermore,
	                 * point.y can be extended by the `tooltip.valuePrefix` and `tooltip.
	                 * valueSuffix` variables. This can also be overridden for each series,
	                 * which makes it a good hook for displaying units.
	                 * 
	                 * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the dot is colored by a class name rather
	                 * than the point color.
	                 * 
	                 * @type {String}
	                 * @sample {highcharts} highcharts/tooltip/pointformat/ A different point format with value suffix
	                 * @sample {highmaps} maps/tooltip/format/ Format demo
	                 * @default <span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y}</b><br/>
	                 * @since 2.2
	                 * @product highcharts highstock highmaps
	                 */
	                pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y}</b><br/>',
	
	                /**
	                 * Whether to apply a drop shadow to the tooltip.
	                 * 
	                 * @type {Boolean}
	                 * @sample {highcharts} highcharts/tooltip/bordercolor-default/ True by default
	                 * @sample {highcharts} highcharts/tooltip/shadow/ False
	                 * @sample {highmaps} maps/tooltip/positioner/ Fixed tooltip position, border and shadow disabled
	                 * @default true
	                 * @product highcharts highstock highmaps
	                 */
	                shadow: true,
	
	                /**
	                 * CSS styles for the tooltip. The tooltip can also be styled through
	                 * the CSS class `.highcharts-tooltip`.
	                 * 
	                 * @type {CSSObject}
	                 * @sample {highcharts} highcharts/tooltip/style/ Greater padding, bold text
	                 * @default { "color": "#333333", "cursor": "default", "fontSize": "12px", "pointerEvents": "none", "whiteSpace": "nowrap" }
	                 * @product highcharts highstock highmaps
	                 */
	                style: {
	
	                    /**
	                     */
	                    color: '#333333',
	
	                    /**
	                     */
	                    cursor: 'default',
	
	                    /**
	                     */
	                    fontSize: '12px',
	
	                    /**
	                     */
	                    pointerEvents: 'none', // #1686 http://caniuse.com/#feat=pointer-events
	
	                    /**
	                     */
	                    whiteSpace: 'nowrap'
	                }
	
	                //xDateFormat: '%A, %b %e, %Y',
	                //valueDecimals: null,
	                //valuePrefix: '',
	                //valueSuffix: ''
	            },
	
	
	            /**
	             * Highchart by default puts a credits label in the lower right corner
	             * of the chart. This can be changed using these options.
	             * 
	             * @product highcharts highstock highmaps
	             */
	            credits: {
	
	                /**
	                 * Whether to show the credits text.
	                 * 
	                 * @type {Boolean}
	                 * @sample {highcharts} highcharts/credits/enabled-false/ Credits disabled
	                 * @sample {highstock} stock/credits/enabled/ Credits disabled
	                 * @sample {highmaps} maps/credits/enabled-false/ Credits disabled
	                 * @default true
	                 * @product highcharts highstock highmaps
	                 */
	                enabled: true,
	
	                /**
	                 * The URL for the credits label.
	                 * 
	                 * @type {String}
	                 * @sample {highcharts} highcharts/credits/href/ Custom URL and text
	                 * @sample {highmaps} maps/credits/customized/ Custom URL and text
	                 * @default {highcharts} http://www.highcharts.com
	                 * @default {highstock} "http://www.highcharts.com"
	                 * @default {highmaps} http://www.highcharts.com
	                 * @product highcharts highstock highmaps
	                 */
	                href: 'http://www.highcharts.com',
	
	                /**
	                 * Position configuration for the credits label.
	                 * 
	                 * @type {Object}
	                 * @sample {highcharts} highcharts/credits/position-left/ Left aligned
	                 * @sample {highcharts} highcharts/credits/position-left/ Left aligned
	                 * @sample {highmaps} maps/credits/customized/ Left aligned
	                 * @sample {highmaps} maps/credits/customized/ Left aligned
	                 * @since 2.1
	                 * @product highcharts highstock highmaps
	                 */
	                position: {
	
	                    /**
	                     * Horizontal alignment of the credits.
	                     * 
	                     * @validvalue ["left", "center", "right"]
	                     * @type {String}
	                     * @default right
	                     * @product highcharts highstock highmaps
	                     */
	                    align: 'right',
	
	                    /**
	                     * Horizontal pixel offset of the credits.
	                     * 
	                     * @type {Number}
	                     * @default -10
	                     * @product highcharts highstock highmaps
	                     */
	                    x: -10,
	
	                    /**
	                     * Vertical alignment of the credits.
	                     * 
	                     * @validvalue ["top", "middle", "bottom"]
	                     * @type {String}
	                     * @default bottom
	                     * @product highcharts highstock highmaps
	                     */
	                    verticalAlign: 'bottom',
	
	                    /**
	                     * Vertical pixel offset of the credits.
	                     * 
	                     * @type {Number}
	                     * @default -5
	                     * @product highcharts highstock highmaps
	                     */
	                    y: -5
	                },
	
	
	                /**
	                 * CSS styles for the credits label.
	                 * 
	                 * @type {CSSObject}
	                 * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), credits styles can be set with the `.highcharts-
	                 * credits` class.
	                 * @default { "cursor": "pointer", "color": "#999999", "fontSize": "10px" }
	                 * @product highcharts highstock highmaps
	                 */
	                style: {
	
	                    /**
	                     */
	                    cursor: 'pointer',
	
	                    /**
	                     */
	                    color: '#999999',
	
	                    /**
	                     */
	                    fontSize: '9px'
	                },
	
	
	                /**
	                 * The text for the credits label.
	                 *
	                 * @productdesc {highmaps}
	                 * If a map is loaded as GeoJSON, the text defaults to `Highcharts @
	                 * {map-credits}`. Otherwise, it defaults to `Highcharts.com`.
	                 * 
	                 * @type {String}
	                 * @sample {highcharts} highcharts/credits/href/ Custom URL and text
	                 * @sample {highmaps} maps/credits/customized/ Custom URL and text
	                 * @default {highcharts|highstock} Highcharts.com
	                 */
	                text: 'Highcharts.com'
	            }
	        };
	
	
	
	        /**
	         * Sets the getTimezoneOffset function. If the timezone option is set, a default
	         * getTimezoneOffset function with that timezone is returned. If not, the
	         * specified getTimezoneOffset function is returned. If neither are specified,
	         * undefined is returned.
	         * @return {function} a getTimezoneOffset function or undefined
	         */
	        function getTimezoneOffsetOption() {
	            var globalOptions = H.defaultOptions.global,
	                moment = win.moment;
	
	            if (globalOptions.timezone) {
	                if (!moment) {
	                    // getTimezoneOffset-function stays undefined because it depends on
	                    // Moment.js
	                    H.error(25);
	
	                } else {
	                    return function(timestamp) {
	                        return -moment.tz(
	                            timestamp,
	                            globalOptions.timezone
	                        ).utcOffset();
	                    };
	                }
	            }
	
	            // If not timezone is set, look for the getTimezoneOffset callback
	            return globalOptions.useUTC && globalOptions.getTimezoneOffset;
	        }
	
	        /**
	         * Set the time methods globally based on the useUTC option. Time method can be
	         *   either local time or UTC (default). It is called internally on initiating
	         *   Highcharts and after running `Highcharts.setOptions`.
	         *
	         * @private
	         */
	        function setTimeMethods() {
	            var globalOptions = H.defaultOptions.global,
	                Date,
	                useUTC = globalOptions.useUTC,
	                GET = useUTC ? 'getUTC' : 'get',
	                SET = useUTC ? 'setUTC' : 'set';
	
	            H.Date = Date = globalOptions.Date || win.Date; // Allow using a different Date class
	            Date.hcTimezoneOffset = useUTC && globalOptions.timezoneOffset;
	            Date.hcGetTimezoneOffset = getTimezoneOffsetOption();
	            Date.hcMakeTime = function(year, month, date, hours, minutes, seconds) {
	                var d;
	                if (useUTC) {
	                    d = Date.UTC.apply(0, arguments);
	                    d += getTZOffset(d);
	                } else {
	                    d = new Date(
	                        year,
	                        month,
	                        pick(date, 1),
	                        pick(hours, 0),
	                        pick(minutes, 0),
	                        pick(seconds, 0)
	                    ).getTime();
	                }
	                return d;
	            };
	            each(['Minutes', 'Hours', 'Day', 'Date', 'Month', 'FullYear'], function(s) {
	                Date['hcGet' + s] = GET + s;
	            });
	            each(['Milliseconds', 'Seconds', 'Minutes', 'Hours', 'Date', 'Month', 'FullYear'], function(s) {
	                Date['hcSet' + s] = SET + s;
	            });
	        }
	
	        /**
	         * Merge the default options with custom options and return the new options
	         * structure. Commonly used for defining reusable templates.
	         *
	         * @function #setOptions
	         * @memberOf  Highcharts
	         * @sample highcharts/global/useutc-false Setting a global option
	         * @sample highcharts/members/setoptions Applying a global theme
	         * @param {Object} options The new custom chart options.
	         * @returns {Object} Updated options.
	         */
	        H.setOptions = function(options) {
	
	            // Copy in the default options
	            H.defaultOptions = merge(true, H.defaultOptions, options);
	
	            // Apply UTC
	            setTimeMethods();
	
	            return H.defaultOptions;
	        };
	
	        /**
	         * Get the updated default options. Until 3.0.7, merely exposing defaultOptions for outside modules
	         * wasn't enough because the setOptions method created a new object.
	         */
	        H.getOptions = function() {
	            return H.defaultOptions;
	        };
	
	
	        // Series defaults
	        H.defaultPlotOptions = H.defaultOptions.plotOptions;
	
	        // set the default time methods
	        setTimeMethods();
	
	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var SVGElement,
	            SVGRenderer,
	
	            addEvent = H.addEvent,
	            animate = H.animate,
	            attr = H.attr,
	            charts = H.charts,
	            color = H.color,
	            css = H.css,
	            createElement = H.createElement,
	            defined = H.defined,
	            deg2rad = H.deg2rad,
	            destroyObjectProperties = H.destroyObjectProperties,
	            doc = H.doc,
	            each = H.each,
	            extend = H.extend,
	            erase = H.erase,
	            grep = H.grep,
	            hasTouch = H.hasTouch,
	            inArray = H.inArray,
	            isArray = H.isArray,
	            isFirefox = H.isFirefox,
	            isMS = H.isMS,
	            isObject = H.isObject,
	            isString = H.isString,
	            isWebKit = H.isWebKit,
	            merge = H.merge,
	            noop = H.noop,
	            objectEach = H.objectEach,
	            pick = H.pick,
	            pInt = H.pInt,
	            removeEvent = H.removeEvent,
	            splat = H.splat,
	            stop = H.stop,
	            svg = H.svg,
	            SVG_NS = H.SVG_NS,
	            symbolSizes = H.symbolSizes,
	            win = H.win;
	
	        /**
	         * @typedef {Object} SVGDOMElement - An SVG DOM element.
	         */
	        /**
	         * The SVGElement prototype is a JavaScript wrapper for SVG elements used in the
	         * rendering layer of Highcharts. Combined with the {@link
	         * Highcharts.SVGRenderer} object, these prototypes allow freeform annotation
	         * in the charts or even in HTML pages without instanciating a chart. The
	         * SVGElement can also wrap HTML labels, when `text` or `label` elements are
	         * created with the `useHTML` parameter.
	         *
	         * The SVGElement instances are created through factory functions on the 
	         * {@link Highcharts.SVGRenderer} object, like
	         * [rect]{@link Highcharts.SVGRenderer#rect}, [path]{@link
	         * Highcharts.SVGRenderer#path}, [text]{@link Highcharts.SVGRenderer#text},
	         * [label]{@link Highcharts.SVGRenderer#label}, [g]{@link
	         * Highcharts.SVGRenderer#g} and more.
	         *
	         * @class Highcharts.SVGElement
	         */
	        SVGElement = H.SVGElement = function() {
	            return this;
	        };
	        extend(SVGElement.prototype, /** @lends Highcharts.SVGElement.prototype */ {
	
	            // Default base for animation
	            opacity: 1,
	            SVG_NS: SVG_NS,
	
	            /**
	             * For labels, these CSS properties are applied to the `text` node directly.
	             *
	             * @private
	             * @type {Array.<string>}
	             */
	            textProps: ['direction', 'fontSize', 'fontWeight', 'fontFamily',
	                'fontStyle', 'color', 'lineHeight', 'width', 'textAlign',
	                'textDecoration', 'textOverflow', 'textOutline'
	            ],
	
	            /**
	             * Initialize the SVG renderer. This function only exists to make the
	             * initiation process overridable. It should not be called directly.
	             *
	             * @param  {SVGRenderer} renderer
	             *         The SVGRenderer instance to initialize to.
	             * @param  {String} nodeName
	             *         The SVG node name.
	             * 
	             */
	            init: function(renderer, nodeName) {
	
	                /** 
	                 * The primary DOM node. Each `SVGElement` instance wraps a main DOM
	                 * node, but may also represent more nodes.
	                 *
	                 * @name  element
	                 * @memberOf SVGElement
	                 * @type {SVGDOMNode|HTMLDOMNode}
	                 */
	                this.element = nodeName === 'span' ?
	                    createElement(nodeName) :
	                    doc.createElementNS(this.SVG_NS, nodeName);
	
	                /**
	                 * The renderer that the SVGElement belongs to.
	                 *
	                 * @name renderer
	                 * @memberOf SVGElement
	                 * @type {SVGRenderer}
	                 */
	                this.renderer = renderer;
	            },
	
	            /**
	             * Animate to given attributes or CSS properties.
	             * 
	             * @param {SVGAttributes} params SVG attributes or CSS to animate.
	             * @param {AnimationOptions} [options] Animation options.
	             * @param {Function} [complete] Function to perform at the end of animation.
	             *
	             * @sample highcharts/members/element-on/
	             *         Setting some attributes by animation
	             * 
	             * @returns {SVGElement} Returns the SVGElement for chaining.
	             */
	            animate: function(params, options, complete) {
	                var animOptions = H.animObject(
	                    pick(options, this.renderer.globalAnimation, true)
	                );
	                if (animOptions.duration !== 0) {
	                    // allows using a callback with the global animation without
	                    // overwriting it
	                    if (complete) {
	                        animOptions.complete = complete;
	                    }
	                    animate(this, params, animOptions);
	                } else {
	                    this.attr(params, null, complete);
	                    if (animOptions.step) {
	                        animOptions.step.call(this);
	                    }
	                }
	                return this;
	            },
	
	            /**
	             * @typedef {Object} GradientOptions
	             * @property {Object} linearGradient Holds an object that defines the start
	             *    position and the end position relative to the shape.
	             * @property {Number} linearGradient.x1 Start horizontal position of the
	             *    gradient. Ranges 0-1.
	             * @property {Number} linearGradient.x2 End horizontal position of the
	             *    gradient. Ranges 0-1.
	             * @property {Number} linearGradient.y1 Start vertical position of the
	             *    gradient. Ranges 0-1.
	             * @property {Number} linearGradient.y2 End vertical position of the
	             *    gradient. Ranges 0-1.
	             * @property {Object} radialGradient Holds an object that defines the center
	             *    position and the radius.
	             * @property {Number} radialGradient.cx Center horizontal position relative
	             *    to the shape. Ranges 0-1.
	             * @property {Number} radialGradient.cy Center vertical position relative
	             *    to the shape. Ranges 0-1.
	             * @property {Number} radialGradient.r Radius relative to the shape. Ranges
	             *    0-1.
	             * @property {Array.<Array>} stops The first item in each tuple is the
	             *    position in the gradient, where 0 is the start of the gradient and 1
	             *    is the end of the gradient. Multiple stops can be applied. The second
	             *    item is the color for each stop. This color can also be given in the
	             *    rgba format.
	             *
	             * @example
	             * // Linear gradient used as a color option
	             * color: {
	             *     linearGradient: { x1: 0, x2: 0, y1: 0, y2: 1 },
	             *         stops: [
	             *             [0, '#003399'], // start
	             *             [0.5, '#ffffff'], // middle
	             *             [1, '#3366AA'] // end
	             *         ]
	             *     }
	             * }
	             */
	            /**
	             * Build and apply an SVG gradient out of a common JavaScript configuration
	             * object. This function is called from the attribute setters.
	             *
	             * @private
	             * @param {GradientOptions} color The gradient options structure.
	             * @param {string} prop The property to apply, can either be `fill` or
	             * `stroke`. 
	             * @param {SVGDOMElement} elem SVG DOM element to apply the gradient on.
	             */
	            colorGradient: function(color, prop, elem) {
	                var renderer = this.renderer,
	                    colorObject,
	                    gradName,
	                    gradAttr,
	                    radAttr,
	                    gradients,
	                    gradientObject,
	                    stops,
	                    stopColor,
	                    stopOpacity,
	                    radialReference,
	                    id,
	                    key = [],
	                    value;
	
	                // Apply linear or radial gradients
	                if (color.radialGradient) {
	                    gradName = 'radialGradient';
	                } else if (color.linearGradient) {
	                    gradName = 'linearGradient';
	                }
	
	                if (gradName) {
	                    gradAttr = color[gradName];
	                    gradients = renderer.gradients;
	                    stops = color.stops;
	                    radialReference = elem.radialReference;
	
	                    // Keep < 2.2 kompatibility
	                    if (isArray(gradAttr)) {
	                        color[gradName] = gradAttr = {
	                            x1: gradAttr[0],
	                            y1: gradAttr[1],
	                            x2: gradAttr[2],
	                            y2: gradAttr[3],
	                            gradientUnits: 'userSpaceOnUse'
	                        };
	                    }
	
	                    // Correct the radial gradient for the radial reference system
	                    if (
	                        gradName === 'radialGradient' &&
	                        radialReference &&
	                        !defined(gradAttr.gradientUnits)
	                    ) {
	                        radAttr = gradAttr; // Save the radial attributes for updating
	                        gradAttr = merge(
	                            gradAttr,
	                            renderer.getRadialAttr(radialReference, radAttr), {
	                                gradientUnits: 'userSpaceOnUse'
	                            }
	                        );
	                    }
	
	                    // Build the unique key to detect whether we need to create a new
	                    // element (#1282)
	                    objectEach(gradAttr, function(val, n) {
	                        if (n !== 'id') {
	                            key.push(n, val);
	                        }
	                    });
	                    objectEach(stops, function(val) {
	                        key.push(val);
	                    });
	                    key = key.join(',');
	
	                    // Check if a gradient object with the same config object is created
	                    // within this renderer
	                    if (gradients[key]) {
	                        id = gradients[key].attr('id');
	
	                    } else {
	
	                        // Set the id and create the element
	                        gradAttr.id = id = H.uniqueKey();
	                        gradients[key] = gradientObject =
	                            renderer.createElement(gradName)
	                            .attr(gradAttr)
	                            .add(renderer.defs);
	
	                        gradientObject.radAttr = radAttr;
	
	                        // The gradient needs to keep a list of stops to be able to
	                        // destroy them
	                        gradientObject.stops = [];
	                        each(stops, function(stop) {
	                            var stopObject;
	                            if (stop[1].indexOf('rgba') === 0) {
	                                colorObject = H.color(stop[1]);
	                                stopColor = colorObject.get('rgb');
	                                stopOpacity = colorObject.get('a');
	                            } else {
	                                stopColor = stop[1];
	                                stopOpacity = 1;
	                            }
	                            stopObject = renderer.createElement('stop').attr({
	                                offset: stop[0],
	                                'stop-color': stopColor,
	                                'stop-opacity': stopOpacity
	                            }).add(gradientObject);
	
	                            // Add the stop element to the gradient
	                            gradientObject.stops.push(stopObject);
	                        });
	                    }
	
	                    // Set the reference to the gradient object
	                    value = 'url(' + renderer.url + '#' + id + ')';
	                    elem.setAttribute(prop, value);
	                    elem.gradient = key;
	
	                    // Allow the color to be concatenated into tooltips formatters etc.
	                    // (#2995)
	                    color.toString = function() {
	                        return value;
	                    };
	                }
	            },
	
	            /**
	             * Apply a text outline through a custom CSS property, by copying the text
	             * element and apply stroke to the copy. Used internally. Contrast checks
	             * at http://jsfiddle.net/highcharts/43soe9m1/2/ .
	             *
	             * @private
	             * @param {String} textOutline A custom CSS `text-outline` setting, defined
	             *    by `width color`. 
	             * @example
	             * // Specific color
	             * text.css({
	             *    textOutline: '1px black'
	             * });
	             * // Automatic contrast
	             * text.css({
	             *    color: '#000000', // black text
	             *    textOutline: '1px contrast' // => white outline
	             * });
	             */
	            applyTextOutline: function(textOutline) {
	                var elem = this.element,
	                    tspans,
	                    tspan,
	                    hasContrast = textOutline.indexOf('contrast') !== -1,
	                    styles = {},
	                    color,
	                    strokeWidth,
	                    firstRealChild,
	                    i;
	
	                // When the text shadow is set to contrast, use dark stroke for light
	                // text and vice versa.
	                if (hasContrast) {
	                    styles.textOutline = textOutline = textOutline.replace(
	                        /contrast/g,
	                        this.renderer.getContrast(elem.style.fill)
	                    );
	                }
	
	                // Extract the stroke width and color
	                textOutline = textOutline.split(' ');
	                color = textOutline[textOutline.length - 1];
	                strokeWidth = textOutline[0];
	
	                if (strokeWidth && strokeWidth !== 'none' && H.svg) {
	
	                    this.fakeTS = true; // Fake text shadow
	
	                    tspans = [].slice.call(elem.getElementsByTagName('tspan'));
	
	                    // In order to get the right y position of the clone,
	                    // copy over the y setter
	                    this.ySetter = this.xSetter;
	
	                    // Since the stroke is applied on center of the actual outline, we
	                    // need to double it to get the correct stroke-width outside the 
	                    // glyphs.
	                    strokeWidth = strokeWidth.replace(
	                        /(^[\d\.]+)(.*?)$/g,
	                        function(match, digit, unit) {
	                            return (2 * digit) + unit;
	                        }
	                    );
	
	                    // Remove shadows from previous runs. Iterate from the end to
	                    // support removing items inside the cycle (#6472).
	                    i = tspans.length;
	                    while (i--) {
	                        tspan = tspans[i];
	                        if (tspan.getAttribute('class') === 'highcharts-text-outline') {
	                            // Remove then erase
	                            erase(tspans, elem.removeChild(tspan));
	                        }
	                    }
	
	                    // For each of the tspans, create a stroked copy behind it.
	                    firstRealChild = elem.firstChild;
	                    each(tspans, function(tspan, y) {
	                        var clone;
	
	                        // Let the first line start at the correct X position
	                        if (y === 0) {
	                            tspan.setAttribute('x', elem.getAttribute('x'));
	                            y = elem.getAttribute('y');
	                            tspan.setAttribute('y', y || 0);
	                            if (y === null) {
	                                elem.setAttribute('y', 0);
	                            }
	                        }
	
	                        // Create the clone and apply outline properties
	                        clone = tspan.cloneNode(1);
	                        attr(clone, {
	                            'class': 'highcharts-text-outline',
	                            'fill': color,
	                            'stroke': color,
	                            'stroke-width': strokeWidth,
	                            'stroke-linejoin': 'round'
	                        });
	                        elem.insertBefore(clone, firstRealChild);
	                    });
	                }
	            },
	
	            /**
	             *
	             * @typedef {Object} SVGAttributes An object of key-value pairs for SVG
	             *   attributes. Attributes in Highcharts elements for the most parts
	             *   correspond to SVG, but some are specific to Highcharts, like `zIndex`,
	             *   `rotation`, `translateX`, `translateY`, `scaleX` and `scaleY`. SVG
	             *   attributes containing a hyphen are _not_ camel-cased, they should be
	             *   quoted to preserve the hyphen.
	             * @example
	             * {
	             *     'stroke': '#ff0000', // basic
	             *     'stroke-width': 2, // hyphenated
	             *     'rotation': 45 // custom
	             *     'd': ['M', 10, 10, 'L', 30, 30, 'z'] // path definition, note format
	             * }
	             */
	            /**
	             * Apply native and custom attributes to the SVG elements.
	             * 
	             * In order to set the rotation center for rotation, set x and y to 0 and
	             * use `translateX` and `translateY` attributes to position the element
	             * instead.
	             *
	             * Attributes frequently used in Highcharts are `fill`, `stroke`,
	             * `stroke-width`.
	             *
	             * @param {SVGAttributes|String} hash - The native and custom SVG
	             *    attributes. 
	             * @param {string} [val] - If the type of the first argument is `string`, 
	             *    the second can be a value, which will serve as a single attribute
	             *    setter. If the first argument is a string and the second is undefined,
	             *    the function serves as a getter and the current value of the property
	             *    is returned.
	             * @param {Function} [complete] - A callback function to execute after
	             *    setting the attributes. This makes the function compliant and
	             *    interchangeable with the {@link SVGElement#animate} function.
	             * @param {boolean} [continueAnimation=true] Used internally when `.attr` is
	             *    called as part of an animation step. Otherwise, calling `.attr` for an
	             *    attribute will stop animation for that attribute.
	             *    
	             * @returns {SVGElement|string|number} If used as a setter, it returns the 
	             *    current {@link SVGElement} so the calls can be chained. If used as a 
	             *    getter, the current value of the attribute is returned.
	             *
	             * @sample highcharts/members/renderer-rect/
	             *         Setting some attributes
	             * 
	             * @example
	             * // Set multiple attributes
	             * element.attr({
	             *     stroke: 'red',
	             *     fill: 'blue',
	             *     x: 10,
	             *     y: 10
	             * });
	             *
	             * // Set a single attribute
	             * element.attr('stroke', 'red');
	             *
	             * // Get an attribute
	             * element.attr('stroke'); // => 'red'
	             * 
	             */
	            attr: function(hash, val, complete, continueAnimation) {
	                var key,
	                    element = this.element,
	                    hasSetSymbolSize,
	                    ret = this,
	                    skipAttr,
	                    setter;
	
	                // single key-value pair
	                if (typeof hash === 'string' && val !== undefined) {
	                    key = hash;
	                    hash = {};
	                    hash[key] = val;
	                }
	
	                // used as a getter: first argument is a string, second is undefined
	                if (typeof hash === 'string') {
	                    ret = (this[hash + 'Getter'] || this._defaultGetter).call(
	                        this,
	                        hash,
	                        element
	                    );
	
	                    // setter
	                } else {
	
	                    objectEach(hash, function(val, key) {
	                        skipAttr = false;
	
	                        // Unless .attr is from the animator update, stop current
	                        // running animation of this property
	                        if (!continueAnimation) {
	                            stop(this, key);
	                        }
	
	                        // Special handling of symbol attributes
	                        if (
	                            this.symbolName &&
	                            /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)$/
	                            .test(key)
	                        ) {
	                            if (!hasSetSymbolSize) {
	                                this.symbolAttr(hash);
	                                hasSetSymbolSize = true;
	                            }
	                            skipAttr = true;
	                        }
	
	                        if (this.rotation && (key === 'x' || key === 'y')) {
	                            this.doTransform = true;
	                        }
	
	                        if (!skipAttr) {
	                            setter = this[key + 'Setter'] || this._defaultSetter;
	                            setter.call(this, val, key, element);
	
	
	                            // Let the shadow follow the main element
	                            if (
	                                this.shadows &&
	                                /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/
	                                .test(key)
	                            ) {
	                                this.updateShadows(key, val, setter);
	                            }
	
	                        }
	                    }, this);
	
	                    this.afterSetters();
	                }
	
	                // In accordance with animate, run a complete callback
	                if (complete) {
	                    complete();
	                }
	
	                return ret;
	            },
	
	            /**
	             * This method is executed in the end of `attr()`, after setting all
	             * attributes in the hash. In can be used to efficiently consolidate
	             * multiple attributes in one SVG property -- e.g., translate, rotate and
	             * scale are merged in one "transform" attribute in the SVG node.
	             *
	             * @private
	             */
	            afterSetters: function() {
	                // Update transform. Do this outside the loop to prevent redundant
	                // updating for batch setting of attributes.
	                if (this.doTransform) {
	                    this.updateTransform();
	                    this.doTransform = false;
	                }
	            },
	
	
	            /**
	             * Update the shadow elements with new attributes.
	             *
	             * @private
	             * @param {String} key - The attribute name.
	             * @param {String|Number} value - The value of the attribute.
	             * @param {Function} setter - The setter function, inherited from the
	             *   parent wrapper
	             * 
	             */
	            updateShadows: function(key, value, setter) {
	                var shadows = this.shadows,
	                    i = shadows.length;
	
	                while (i--) {
	                    setter.call(
	                        shadows[i],
	                        key === 'height' ?
	                        Math.max(value - (shadows[i].cutHeight || 0), 0) :
	                        key === 'd' ? this.d : value,
	                        key,
	                        shadows[i]
	                    );
	                }
	            },
	
	
	            /**
	             * Add a class name to an element.
	             *
	             * @param {string} className - The new class name to add.
	             * @param {boolean} [replace=false] - When true, the existing class name(s)
	             *    will be overwritten with the new one. When false, the new one is
	             *    added.
	             * @returns {SVGElement} Return the SVG element for chainability.
	             */
	            addClass: function(className, replace) {
	                var currentClassName = this.attr('class') || '';
	                if (currentClassName.indexOf(className) === -1) {
	                    if (!replace) {
	                        className =
	                            (currentClassName + (currentClassName ? ' ' : '') +
	                                className).replace('  ', ' ');
	                    }
	                    this.attr('class', className);
	                }
	
	                return this;
	            },
	
	            /**
	             * Check if an element has the given class name.
	             * @param  {string} className
	             *         The class name to check for.
	             * @return {Boolean}
	             *         Whether the class name is found.
	             */
	            hasClass: function(className) {
	                return inArray(
	                    className,
	                    (this.attr('class') || '').split(' ')
	                ) !== -1;
	            },
	
	            /**
	             * Remove a class name from the element.
	             * @param  {string} className The class name to remove.
	             * @return {SVGElement} Returns the SVG element for chainability.
	             */
	            removeClass: function(className) {
	                return this.attr(
	                    'class',
	                    (this.attr('class') || '').replace(className, '')
	                );
	            },
	
	            /**
	             * If one of the symbol size affecting parameters are changed,
	             * check all the others only once for each call to an element's
	             * .attr() method
	             * @param {Object} hash - The attributes to set.
	             * @private
	             */
	            symbolAttr: function(hash) {
	                var wrapper = this;
	
	                each([
	                    'x',
	                    'y',
	                    'r',
	                    'start',
	                    'end',
	                    'width',
	                    'height',
	                    'innerR',
	                    'anchorX',
	                    'anchorY'
	                ], function(key) {
	                    wrapper[key] = pick(hash[key], wrapper[key]);
	                });
	
	                wrapper.attr({
	                    d: wrapper.renderer.symbols[wrapper.symbolName](
	                        wrapper.x,
	                        wrapper.y,
	                        wrapper.width,
	                        wrapper.height,
	                        wrapper
	                    )
	                });
	            },
	
	            /**
	             * Apply a clipping rectangle to this element.
	             * 
	             * @param {ClipRect} [clipRect] - The clipping rectangle. If skipped, the
	             *    current clip is removed.
	             * @returns {SVGElement} Returns the SVG element to allow chaining.
	             */
	            clip: function(clipRect) {
	                return this.attr(
	                    'clip-path',
	                    clipRect ?
	                    'url(' + this.renderer.url + '#' + clipRect.id + ')' :
	                    'none'
	                );
	            },
	
	            /**
	             * Calculate the coordinates needed for drawing a rectangle crisply and
	             * return the calculated attributes.
	             * 
	             * @param {Object} rect - A rectangle.
	             * @param {number} rect.x - The x position.
	             * @param {number} rect.y - The y position.
	             * @param {number} rect.width - The width.
	             * @param {number} rect.height - The height.
	             * @param {number} [strokeWidth] - The stroke width to consider when
	             *    computing crisp positioning. It can also be set directly on the rect
	             *    parameter.
	             *
	             * @returns {{x: Number, y: Number, width: Number, height: Number}} The
	             *    modified rectangle arguments.
	             */
	            crisp: function(rect, strokeWidth) {
	
	                var wrapper = this,
	                    attribs = {},
	                    normalizer;
	
	                strokeWidth = strokeWidth || rect.strokeWidth || 0;
	                // Math.round because strokeWidth can sometimes have roundoff errors
	                normalizer = Math.round(strokeWidth) % 2 / 2;
	
	                // normalize for crisp edges
	                rect.x = Math.floor(rect.x || wrapper.x || 0) + normalizer;
	                rect.y = Math.floor(rect.y || wrapper.y || 0) + normalizer;
	                rect.width = Math.floor(
	                    (rect.width || wrapper.width || 0) - 2 * normalizer
	                );
	                rect.height = Math.floor(
	                    (rect.height || wrapper.height || 0) - 2 * normalizer
	                );
	                if (defined(rect.strokeWidth)) {
	                    rect.strokeWidth = strokeWidth;
	                }
	
	                objectEach(rect, function(val, key) {
	                    if (wrapper[key] !== val) { // only set attribute if changed
	                        wrapper[key] = attribs[key] = val;
	                    }
	                });
	
	                return attribs;
	            },
	
	            /**
	             * Set styles for the element. In addition to CSS styles supported by 
	             * native SVG and HTML elements, there are also some custom made for 
	             * Highcharts, like `width`, `ellipsis` and `textOverflow` for SVG text
	             * elements.
	             * @param {CSSObject} styles The new CSS styles.
	             * @returns {SVGElement} Return the SVG element for chaining.
	             *
	             * @sample highcharts/members/renderer-text-on-chart/
	             *         Styled text
	             */
	            css: function(styles) {
	                var oldStyles = this.styles,
	                    newStyles = {},
	                    elem = this.element,
	                    textWidth,
	                    serializedCss = '',
	                    hyphenate,
	                    hasNew = !oldStyles,
	                    // These CSS properties are interpreted internally by the SVG
	                    // renderer, but are not supported by SVG and should not be added to
	                    // the DOM. In styled mode, no CSS should find its way to the DOM
	                    // whatsoever (#6173, #6474).
	                    svgPseudoProps = ['textOutline', 'textOverflow', 'width'];
	
	                // convert legacy
	                if (styles && styles.color) {
	                    styles.fill = styles.color;
	                }
	
	                // Filter out existing styles to increase performance (#2640)
	                if (oldStyles) {
	                    objectEach(styles, function(style, n) {
	                        if (style !== oldStyles[n]) {
	                            newStyles[n] = style;
	                            hasNew = true;
	                        }
	                    });
	                }
	                if (hasNew) {
	
	                    // Merge the new styles with the old ones
	                    if (oldStyles) {
	                        styles = extend(
	                            oldStyles,
	                            newStyles
	                        );
	                    }
	
	                    // Get the text width from style
	                    textWidth = this.textWidth = (
	                        styles &&
	                        styles.width &&
	                        styles.width !== 'auto' &&
	                        elem.nodeName.toLowerCase() === 'text' &&
	                        pInt(styles.width)
	                    );
	
	                    // store object
	                    this.styles = styles;
	
	                    if (textWidth && (!svg && this.renderer.forExport)) {
	                        delete styles.width;
	                    }
	
	                    // serialize and set style attribute
	                    if (isMS && !svg) {
	                        css(this.element, styles);
	                    } else {
	                        hyphenate = function(a, b) {
	                            return '-' + b.toLowerCase();
	                        };
	                        objectEach(styles, function(style, n) {
	                            if (inArray(n, svgPseudoProps) === -1) {
	                                serializedCss +=
	                                    n.replace(/([A-Z])/g, hyphenate) + ':' +
	                                    style + ';';
	                            }
	                        });
	                        if (serializedCss) {
	                            attr(elem, 'style', serializedCss); // #1881
	                        }
	                    }
	
	
	                    if (this.added) {
	
	                        // Rebuild text after added. Cache mechanisms in the buildText
	                        // will prevent building if there are no significant changes.
	                        if (this.element.nodeName === 'text') {
	                            this.renderer.buildText(this);
	                        }
	
	                        // Apply text outline after added
	                        if (styles && styles.textOutline) {
	                            this.applyTextOutline(styles.textOutline);
	                        }
	                    }
	                }
	
	                return this;
	            },
	
	
	            /**
	             * Get the current stroke width. In classic mode, the setter registers it 
	             * directly on the element.
	             * @returns {number} The stroke width in pixels.
	             * @ignore
	             */
	            strokeWidth: function() {
	                return this['stroke-width'] || 0;
	            },
	
	
	            /**
	             * Add an event listener. This is a simple setter that replaces all other
	             * events of the same type, opposed to the {@link Highcharts#addEvent}
	             * function.
	             * @param {string} eventType - The event type. If the type is `click`, 
	             *    Highcharts will internally translate it to a `touchstart` event on 
	             *    touch devices, to prevent the browser from waiting for a click event
	             *    from firing.
	             * @param {Function} handler - The handler callback.
	             * @returns {SVGElement} The SVGElement for chaining.
	             *
	             * @sample highcharts/members/element-on/
	             *         A clickable rectangle
	             */
	            on: function(eventType, handler) {
	                var svgElement = this,
	                    element = svgElement.element;
	
	                // touch
	                if (hasTouch && eventType === 'click') {
	                    element.ontouchstart = function(e) {
	                        svgElement.touchEventFired = Date.now(); // #2269
	                        e.preventDefault();
	                        handler.call(element, e);
	                    };
	                    element.onclick = function(e) {
	                        if (win.navigator.userAgent.indexOf('Android') === -1 ||
	                            Date.now() - (svgElement.touchEventFired || 0) > 1100) {
	                            handler.call(element, e);
	                        }
	                    };
	                } else {
	                    // simplest possible event model for internal use
	                    element['on' + eventType] = handler;
	                }
	                return this;
	            },
	
	            /**
	             * Set the coordinates needed to draw a consistent radial gradient across
	             * a shape regardless of positioning inside the chart. Used on pie slices
	             * to make all the slices have the same radial reference point.
	             *
	             * @param {Array} coordinates The center reference. The format is
	             *    `[centerX, centerY, diameter]` in pixels.
	             * @returns {SVGElement} Returns the SVGElement for chaining.
	             */
	            setRadialReference: function(coordinates) {
	                var existingGradient = this.renderer.gradients[this.element.gradient];
	
	                this.element.radialReference = coordinates;
	
	                // On redrawing objects with an existing gradient, the gradient needs
	                // to be repositioned (#3801)
	                if (existingGradient && existingGradient.radAttr) {
	                    existingGradient.animate(
	                        this.renderer.getRadialAttr(
	                            coordinates,
	                            existingGradient.radAttr
	                        )
	                    );
	                }
	
	                return this;
	            },
	
	            /**
	             * Move an object and its children by x and y values.
	             * 
	             * @param {number} x - The x value.
	             * @param {number} y - The y value.
	             */
	            translate: function(x, y) {
	                return this.attr({
	                    translateX: x,
	                    translateY: y
	                });
	            },
	
	            /**
	             * Invert a group, rotate and flip. This is used internally on inverted 
	             * charts, where the points and graphs are drawn as if not inverted, then
	             * the series group elements are inverted.
	             *
	             * @param  {boolean} inverted
	             *         Whether to invert or not. An inverted shape can be un-inverted by
	             *         setting it to false.
	             * @return {SVGElement}
	             *         Return the SVGElement for chaining.
	             */
	            invert: function(inverted) {
	                var wrapper = this;
	                wrapper.inverted = inverted;
	                wrapper.updateTransform();
	                return wrapper;
	            },
	
	            /**
	             * Update the transform attribute based on internal properties. Deals with
	             * the custom `translateX`, `translateY`, `rotation`, `scaleX` and `scaleY`
	             * attributes and updates the SVG `transform` attribute.
	             * @private
	             * 
	             */
	            updateTransform: function() {
	                var wrapper = this,
	                    translateX = wrapper.translateX || 0,
	                    translateY = wrapper.translateY || 0,
	                    scaleX = wrapper.scaleX,
	                    scaleY = wrapper.scaleY,
	                    inverted = wrapper.inverted,
	                    rotation = wrapper.rotation,
	                    element = wrapper.element,
	                    transform;
	
	                // Flipping affects translate as adjustment for flipping around the
	                // group's axis
	                if (inverted) {
	                    translateX += wrapper.width;
	                    translateY += wrapper.height;
	                }
	
	                // Apply translate. Nearly all transformed elements have translation,
	                // so instead of checking for translate = 0, do it always (#1767,
	                // #1846).
	                transform = ['translate(' + translateX + ',' + translateY + ')'];
	
	                // apply rotation
	                if (inverted) {
	                    transform.push('rotate(90) scale(-1,1)');
	                } else if (rotation) { // text rotation
	                    transform.push(
	                        'rotate(' + rotation + ' ' + (element.getAttribute('x') || 0) +
	                        ' ' + (element.getAttribute('y') || 0) + ')'
	                    );
	                }
	
	                // apply scale
	                if (defined(scaleX) || defined(scaleY)) {
	                    transform.push(
	                        'scale(' + pick(scaleX, 1) + ' ' + pick(scaleY, 1) + ')'
	                    );
	                }
	
	                if (transform.length) {
	                    element.setAttribute('transform', transform.join(' '));
	                }
	            },
	
	            /**
	             * Bring the element to the front. Alternatively, a new zIndex can be set.
	             *
	             * @returns {SVGElement} Returns the SVGElement for chaining.
	             *
	             * @sample highcharts/members/element-tofront/
	             *         Click an element to bring it to front
	             */
	            toFront: function() {
	                var element = this.element;
	                element.parentNode.appendChild(element);
	                return this;
	            },
	
	
	            /**
	             * Align the element relative to the chart or another box.
	             * 
	             * @param {Object} [alignOptions] The alignment options. The function can be
	             *   called without this parameter in order to re-align an element after the
	             *   box has been updated.
	             * @param {string} [alignOptions.align=left] Horizontal alignment. Can be
	             *   one of `left`, `center` and `right`.
	             * @param {string} [alignOptions.verticalAlign=top] Vertical alignment. Can
	             *   be one of `top`, `middle` and `bottom`.
	             * @param {number} [alignOptions.x=0] Horizontal pixel offset from
	             *   alignment.
	             * @param {number} [alignOptions.y=0] Vertical pixel offset from alignment.
	             * @param {Boolean} [alignByTranslate=false] Use the `transform` attribute
	             *   with translateX and translateY custom attributes to align this elements
	             *   rather than `x` and `y` attributes.
	             * @param {String|Object} box The box to align to, needs a width and height.
	             *   When the box is a string, it refers to an object in the Renderer. For
	             *   example, when box is `spacingBox`, it refers to `Renderer.spacingBox`
	             *   which holds `width`, `height`, `x` and `y` properties.
	             * @returns {SVGElement} Returns the SVGElement for chaining.
	             */
	            align: function(alignOptions, alignByTranslate, box) {
	                var align,
	                    vAlign,
	                    x,
	                    y,
	                    attribs = {},
	                    alignTo,
	                    renderer = this.renderer,
	                    alignedObjects = renderer.alignedObjects,
	                    alignFactor,
	                    vAlignFactor;
	
	                // First call on instanciate
	                if (alignOptions) {
	                    this.alignOptions = alignOptions;
	                    this.alignByTranslate = alignByTranslate;
	                    if (!box || isString(box)) { // boxes other than renderer handle this internally
	                        this.alignTo = alignTo = box || 'renderer';
	                        erase(alignedObjects, this); // prevent duplicates, like legendGroup after resize
	                        alignedObjects.push(this);
	                        box = null; // reassign it below
	                    }
	
	                    // When called on resize, no arguments are supplied
	                } else {
	                    alignOptions = this.alignOptions;
	                    alignByTranslate = this.alignByTranslate;
	                    alignTo = this.alignTo;
	                }
	
	                box = pick(box, renderer[alignTo], renderer);
	
	                // Assign variables
	                align = alignOptions.align;
	                vAlign = alignOptions.verticalAlign;
	                x = (box.x || 0) + (alignOptions.x || 0); // default: left align
	                y = (box.y || 0) + (alignOptions.y || 0); // default: top align
	
	                // Align
	                if (align === 'right') {
	                    alignFactor = 1;
	                } else if (align === 'center') {
	                    alignFactor = 2;
	                }
	                if (alignFactor) {
	                    x += (box.width - (alignOptions.width || 0)) / alignFactor;
	                }
	                attribs[alignByTranslate ? 'translateX' : 'x'] = Math.round(x);
	
	
	                // Vertical align
	                if (vAlign === 'bottom') {
	                    vAlignFactor = 1;
	                } else if (vAlign === 'middle') {
	                    vAlignFactor = 2;
	                }
	                if (vAlignFactor) {
	                    y += (box.height - (alignOptions.height || 0)) / vAlignFactor;
	                }
	                attribs[alignByTranslate ? 'translateY' : 'y'] = Math.round(y);
	
	                // Animate only if already placed
	                this[this.placed ? 'animate' : 'attr'](attribs);
	                this.placed = true;
	                this.alignAttr = attribs;
	
	                return this;
	            },
	
	            /**
	             * Get the bounding box (width, height, x and y) for the element. Generally
	             * used to get rendered text size. Since this is called a lot in charts,
	             * the results are cached based on text properties, in order to save DOM
	             * traffic. The returned bounding box includes the rotation, so for example
	             * a single text line of rotation 90 will report a greater height, and a
	             * width corresponding to the line-height.
	             *
	             * @param {boolean} [reload] Skip the cache and get the updated DOM bouding
	             *   box.
	             * @param {number} [rot] Override the element's rotation. This is internally
	             *   used on axis labels with a value of 0 to find out what the bounding box
	             *   would be have been if it were not rotated.
	             * @returns {Object} The bounding box with `x`, `y`, `width` and `height`
	             * properties.
	             *
	             * @sample highcharts/members/renderer-on-chart/
	             *         Draw a rectangle based on a text's bounding box
	             */
	            getBBox: function(reload, rot) {
	                var wrapper = this,
	                    bBox, // = wrapper.bBox,
	                    renderer = wrapper.renderer,
	                    width,
	                    height,
	                    rotation,
	                    rad,
	                    element = wrapper.element,
	                    styles = wrapper.styles,
	                    fontSize,
	                    textStr = wrapper.textStr,
	                    toggleTextShadowShim,
	                    cache = renderer.cache,
	                    cacheKeys = renderer.cacheKeys,
	                    cacheKey;
	
	                rotation = pick(rot, wrapper.rotation);
	                rad = rotation * deg2rad;
	
	
	                fontSize = styles && styles.fontSize;
	
	
	                if (textStr !== undefined) {
	
	                    cacheKey = textStr.toString();
	
	                    // Since numbers are monospaced, and numerical labels appear a lot
	                    // in a chart, we assume that a label of n characters has the same
	                    // bounding box as others of the same length. Unless there is inner
	                    // HTML in the label. In that case, leave the numbers as is (#5899).
	                    if (cacheKey.indexOf('<') === -1) {
	                        cacheKey = cacheKey.replace(/[0-9]/g, '0');
	                    }
	
	                    // Properties that affect bounding box
	                    cacheKey += [
	                            '',
	                            rotation || 0,
	                            fontSize,
	                            styles && styles.width,
	                            styles && styles.textOverflow // #5968
	                        ]
	                        .join(',');
	
	                }
	
	                if (cacheKey && !reload) {
	                    bBox = cache[cacheKey];
	                }
	
	                // No cache found
	                if (!bBox) {
	
	                    // SVG elements
	                    if (element.namespaceURI === wrapper.SVG_NS || renderer.forExport) {
	                        try { // Fails in Firefox if the container has display: none.
	
	                            // When the text shadow shim is used, we need to hide the fake shadows
	                            // to get the correct bounding box (#3872)
	                            toggleTextShadowShim = this.fakeTS && function(display) {
	                                each(element.querySelectorAll('.highcharts-text-outline'), function(tspan) {
	                                    tspan.style.display = display;
	                                });
	                            };
	
	                            // Workaround for #3842, Firefox reporting wrong bounding box for shadows
	                            if (toggleTextShadowShim) {
	                                toggleTextShadowShim('none');
	                            }
	
	                            bBox = element.getBBox ?
	                                // SVG: use extend because IE9 is not allowed to change width and height in case
	                                // of rotation (below)
	                                extend({}, element.getBBox()) : {
	
	                                    // Legacy IE in export mode
	                                    width: element.offsetWidth,
	                                    height: element.offsetHeight
	                                };
	
	                            // #3842
	                            if (toggleTextShadowShim) {
	                                toggleTextShadowShim('');
	                            }
	                        } catch (e) {}
	
	                        // If the bBox is not set, the try-catch block above failed. The other condition
	                        // is for Opera that returns a width of -Infinity on hidden elements.
	                        if (!bBox || bBox.width < 0) {
	                            bBox = {
	                                width: 0,
	                                height: 0
	                            };
	                        }
	
	
	                        // VML Renderer or useHTML within SVG
	                    } else {
	
	                        bBox = wrapper.htmlGetBBox();
	
	                    }
	
	                    // True SVG elements as well as HTML elements in modern browsers using the .useHTML option
	                    // need to compensated for rotation
	                    if (renderer.isSVG) {
	                        width = bBox.width;
	                        height = bBox.height;
	
	                        // Workaround for wrong bounding box in IE, Edge and Chrome on
	                        // Windows. With Highcharts' default font, IE and Edge report
	                        // a box height of 16.899 and Chrome rounds it to 17. If this 
	                        // stands uncorrected, it results in more padding added below
	                        // the text than above when adding a label border or background.
	                        // Also vertical positioning is affected.
	                        // http://jsfiddle.net/highcharts/em37nvuj/
	                        // (#1101, #1505, #1669, #2568, #6213).
	                        if (
	                            styles &&
	                            styles.fontSize === '11px' &&
	                            Math.round(height) === 17
	                        ) {
	                            bBox.height = height = 14;
	                        }
	
	                        // Adjust for rotated text
	                        if (rotation) {
	                            bBox.width = Math.abs(height * Math.sin(rad)) + Math.abs(width * Math.cos(rad));
	                            bBox.height = Math.abs(height * Math.cos(rad)) + Math.abs(width * Math.sin(rad));
	                        }
	                    }
	
	                    // Cache it. When loading a chart in a hidden iframe in Firefox and IE/Edge, the
	                    // bounding box height is 0, so don't cache it (#5620).
	                    if (cacheKey && bBox.height > 0) {
	
	                        // Rotate (#4681)
	                        while (cacheKeys.length > 250) {
	                            delete cache[cacheKeys.shift()];
	                        }
	
	                        if (!cache[cacheKey]) {
	                            cacheKeys.push(cacheKey);
	                        }
	                        cache[cacheKey] = bBox;
	                    }
	                }
	                return bBox;
	            },
	
	            /**
	             * Show the element after it has been hidden. 
	             *
	             * @param {boolean} [inherit=false] Set the visibility attribute to
	             * `inherit` rather than `visible`. The difference is that an element with
	             * `visibility="visible"` will be visible even if the parent is hidden.
	             *
	             * @returns {SVGElement} Returns the SVGElement for chaining.
	             */
	            show: function(inherit) {
	                return this.attr({
	                    visibility: inherit ? 'inherit' : 'visible'
	                });
	            },
	
	            /**
	             * Hide the element, equivalent to setting the `visibility` attribute to
	             * `hidden`.
	             *
	             * @returns {SVGElement} Returns the SVGElement for chaining.
	             */
	            hide: function() {
	                return this.attr({
	                    visibility: 'hidden'
	                });
	            },
	
	            /**
	             * Fade out an element by animating its opacity down to 0, and hide it on
	             * complete. Used internally for the tooltip.
	             * 
	             * @param {number} [duration=150] The fade duration in milliseconds.
	             */
	            fadeOut: function(duration) {
	                var elemWrapper = this;
	                elemWrapper.animate({
	                    opacity: 0
	                }, {
	                    duration: duration || 150,
	                    complete: function() {
	                        // #3088, assuming we're only using this for tooltips
	                        elemWrapper.attr({
	                            y: -9999
	                        });
	                    }
	                });
	            },
	
	            /**
	             * Add the element to the DOM. All elements must be added this way.
	             * 
	             * @param {SVGElement|SVGDOMElement} [parent] The parent item to add it to.
	             *   If undefined, the element is added to the {@link
	             *   Highcharts.SVGRenderer.box}.
	             *
	             * @returns {SVGElement} Returns the SVGElement for chaining.
	             *
	             * @sample highcharts/members/renderer-g - Elements added to a group
	             */
	            add: function(parent) {
	
	                var renderer = this.renderer,
	                    element = this.element,
	                    inserted;
	
	                if (parent) {
	                    this.parentGroup = parent;
	                }
	
	                // mark as inverted
	                this.parentInverted = parent && parent.inverted;
	
	                // build formatted text
	                if (this.textStr !== undefined) {
	                    renderer.buildText(this);
	                }
	
	                // Mark as added
	                this.added = true;
	
	                // If we're adding to renderer root, or other elements in the group
	                // have a z index, we need to handle it
	                if (!parent || parent.handleZ || this.zIndex) {
	                    inserted = this.zIndexSetter();
	                }
	
	                // If zIndex is not handled, append at the end
	                if (!inserted) {
	                    (parent ? parent.element : renderer.box).appendChild(element);
	                }
	
	                // fire an event for internal hooks
	                if (this.onAdd) {
	                    this.onAdd();
	                }
	
	                return this;
	            },
	
	            /**
	             * Removes an element from the DOM.
	             *
	             * @private
	             * @param {SVGDOMElement|HTMLDOMElement} element The DOM node to remove.
	             */
	            safeRemoveChild: function(element) {
	                var parentNode = element.parentNode;
	                if (parentNode) {
	                    parentNode.removeChild(element);
	                }
	            },
	
	            /**
	             * Destroy the element and element wrapper and clear up the DOM and event
	             * hooks.
	             *
	             * 
	             */
	            destroy: function() {
	                var wrapper = this,
	                    element = wrapper.element || {},
	                    parentToClean =
	                    wrapper.renderer.isSVG &&
	                    element.nodeName === 'SPAN' &&
	                    wrapper.parentGroup,
	                    grandParent,
	                    ownerSVGElement = element.ownerSVGElement,
	                    i;
	
	                // remove events
	                element.onclick = element.onmouseout = element.onmouseover =
	                    element.onmousemove = element.point = null;
	                stop(wrapper); // stop running animations
	
	                if (wrapper.clipPath && ownerSVGElement) {
	                    // Look for existing references to this clipPath and remove them
	                    // before destroying the element (#6196).
	                    each(
	                        ownerSVGElement.querySelectorAll('[clip-path]'),
	                        function(el) {
	                            // Include the closing paranthesis in the test to rule out
	                            // id's from 10 and above (#6550)
	                            if (el.getAttribute('clip-path')
	                                .indexOf(wrapper.clipPath.element.id + ')') > -1) {
	                                el.removeAttribute('clip-path');
	                            }
	                        }
	                    );
	                    wrapper.clipPath = wrapper.clipPath.destroy();
	                }
	
	                // Destroy stops in case this is a gradient object
	                if (wrapper.stops) {
	                    for (i = 0; i < wrapper.stops.length; i++) {
	                        wrapper.stops[i] = wrapper.stops[i].destroy();
	                    }
	                    wrapper.stops = null;
	                }
	
	                // remove element
	                wrapper.safeRemoveChild(element);
	
	
	                wrapper.destroyShadows();
	
	
	                // In case of useHTML, clean up empty containers emulating SVG groups
	                // (#1960, #2393, #2697).
	                while (
	                    parentToClean &&
	                    parentToClean.div &&
	                    parentToClean.div.childNodes.length === 0
	                ) {
	                    grandParent = parentToClean.parentGroup;
	                    wrapper.safeRemoveChild(parentToClean.div);
	                    delete parentToClean.div;
	                    parentToClean = grandParent;
	                }
	
	                // remove from alignObjects
	                if (wrapper.alignTo) {
	                    erase(wrapper.renderer.alignedObjects, wrapper);
	                }
	
	                objectEach(wrapper, function(val, key) {
	                    delete wrapper[key];
	                });
	
	                return null;
	            },
	
	
	            /**
	             * @typedef {Object} ShadowOptions
	             * @property {string} [color=#000000] The shadow color.
	             * @property {number} [offsetX=1] The horizontal offset from the element.
	             * @property {number} [offsetY=1] The vertical offset from the element.
	             * @property {number} [opacity=0.15] The shadow opacity.
	             * @property {number} [width=3] The shadow width or distance from the
	             *    element.
	             */
	            /**
	             * Add a shadow to the element. Must be called after the element is added to
	             * the DOM. In styled mode, this method is not used, instead use `defs` and
	             * filters.
	             * 
	             * @param {boolean|ShadowOptions} shadowOptions The shadow options. If
	             *    `true`, the default options are applied. If `false`, the current
	             *    shadow will be removed.
	             * @param {SVGElement} [group] The SVG group element where the shadows will 
	             *    be applied. The default is to add it to the same parent as the current
	             *    element. Internally, this is ised for pie slices, where all the
	             *    shadows are added to an element behind all the slices.
	             * @param {boolean} [cutOff] Used internally for column shadows.
	             *
	             * @returns {SVGElement} Returns the SVGElement for chaining.
	             *
	             * @example
	             * renderer.rect(10, 100, 100, 100)
	             *     .attr({ fill: 'red' })
	             *     .shadow(true);
	             */
	            shadow: function(shadowOptions, group, cutOff) {
	                var shadows = [],
	                    i,
	                    shadow,
	                    element = this.element,
	                    strokeWidth,
	                    shadowWidth,
	                    shadowElementOpacity,
	
	                    // compensate for inverted plot area
	                    transform;
	
	                if (!shadowOptions) {
	                    this.destroyShadows();
	
	                } else if (!this.shadows) {
	                    shadowWidth = pick(shadowOptions.width, 3);
	                    shadowElementOpacity = (shadowOptions.opacity || 0.15) /
	                        shadowWidth;
	                    transform = this.parentInverted ?
	                        '(-1,-1)' :
	                        '(' + pick(shadowOptions.offsetX, 1) + ', ' +
	                        pick(shadowOptions.offsetY, 1) + ')';
	                    for (i = 1; i <= shadowWidth; i++) {
	                        shadow = element.cloneNode(0);
	                        strokeWidth = (shadowWidth * 2) + 1 - (2 * i);
	                        attr(shadow, {
	                            'isShadow': 'true',
	                            'stroke': shadowOptions.color || '#000000',
	                            'stroke-opacity': shadowElementOpacity * i,
	                            'stroke-width': strokeWidth,
	                            'transform': 'translate' + transform,
	                            'fill': 'none'
	                        });
	                        if (cutOff) {
	                            attr(
	                                shadow,
	                                'height',
	                                Math.max(attr(shadow, 'height') - strokeWidth, 0)
	                            );
	                            shadow.cutHeight = strokeWidth;
	                        }
	
	                        if (group) {
	                            group.element.appendChild(shadow);
	                        } else {
	                            element.parentNode.insertBefore(shadow, element);
	                        }
	
	                        shadows.push(shadow);
	                    }
	
	                    this.shadows = shadows;
	                }
	                return this;
	
	            },
	
	            /**
	             * Destroy shadows on the element.
	             * @private
	             */
	            destroyShadows: function() {
	                each(this.shadows || [], function(shadow) {
	                    this.safeRemoveChild(shadow);
	                }, this);
	                this.shadows = undefined;
	            },
	
	
	
	            xGetter: function(key) {
	                if (this.element.nodeName === 'circle') {
	                    if (key === 'x') {
	                        key = 'cx';
	                    } else if (key === 'y') {
	                        key = 'cy';
	                    }
	                }
	                return this._defaultGetter(key);
	            },
	
	            /**
	             * Get the current value of an attribute or pseudo attribute, used mainly
	             * for animation. Called internally from the {@link
	             * Highcharts.SVGRenderer#attr}
	             * function.
	             *
	             * @private
	             */
	            _defaultGetter: function(key) {
	                var ret = pick(
	                    this[key],
	                    this.element ? this.element.getAttribute(key) : null,
	                    0
	                );
	
	                if (/^[\-0-9\.]+$/.test(ret)) { // is numerical
	                    ret = parseFloat(ret);
	                }
	                return ret;
	            },
	
	
	            dSetter: function(value, key, element) {
	                if (value && value.join) { // join path
	                    value = value.join(' ');
	                }
	                if (/(NaN| {2}|^$)/.test(value)) {
	                    value = 'M 0 0';
	                }
	
	                // Check for cache before resetting. Resetting causes disturbance in the
	                // DOM, causing flickering in some cases in Edge/IE (#6747). Also
	                // possible performance gain.
	                if (this[key] !== value) {
	                    element.setAttribute(key, value);
	                    this[key] = value;
	                }
	
	            },
	
	            dashstyleSetter: function(value) {
	                var i,
	                    strokeWidth = this['stroke-width'];
	
	                // If "inherit", like maps in IE, assume 1 (#4981). With HC5 and the new
	                // strokeWidth function, we should be able to use that instead.
	                if (strokeWidth === 'inherit') {
	                    strokeWidth = 1;
	                }
	                value = value && value.toLowerCase();
	                if (value) {
	                    value = value
	                        .replace('shortdashdotdot', '3,1,1,1,1,1,')
	                        .replace('shortdashdot', '3,1,1,1')
	                        .replace('shortdot', '1,1,')
	                        .replace('shortdash', '3,1,')
	                        .replace('longdash', '8,3,')
	                        .replace(/dot/g, '1,3,')
	                        .replace('dash', '4,3,')
	                        .replace(/,$/, '')
	                        .split(','); // ending comma
	
	                    i = value.length;
	                    while (i--) {
	                        value[i] = pInt(value[i]) * strokeWidth;
	                    }
	                    value = value.join(',')
	                        .replace(/NaN/g, 'none'); // #3226
	                    this.element.setAttribute('stroke-dasharray', value);
	                }
	            },
	
	            alignSetter: function(value) {
	                var convert = {
	                    left: 'start',
	                    center: 'middle',
	                    right: 'end'
	                };
	                this.element.setAttribute('text-anchor', convert[value]);
	            },
	            opacitySetter: function(value, key, element) {
	                this[key] = value;
	                element.setAttribute(key, value);
	            },
	            titleSetter: function(value) {
	                var titleNode = this.element.getElementsByTagName('title')[0];
	                if (!titleNode) {
	                    titleNode = doc.createElementNS(this.SVG_NS, 'title');
	                    this.element.appendChild(titleNode);
	                }
	
	                // Remove text content if it exists
	                if (titleNode.firstChild) {
	                    titleNode.removeChild(titleNode.firstChild);
	                }
	
	                titleNode.appendChild(
	                    doc.createTextNode(
	                        (String(pick(value), '')).replace(/<[^>]*>/g, '') // #3276, #3895
	                    )
	                );
	            },
	            textSetter: function(value) {
	                if (value !== this.textStr) {
	                    // Delete bBox memo when the text changes
	                    delete this.bBox;
	
	                    this.textStr = value;
	                    if (this.added) {
	                        this.renderer.buildText(this);
	                    }
	                }
	            },
	            fillSetter: function(value, key, element) {
	                if (typeof value === 'string') {
	                    element.setAttribute(key, value);
	                } else if (value) {
	                    this.colorGradient(value, key, element);
	                }
	            },
	            visibilitySetter: function(value, key, element) {
	                // IE9-11 doesn't handle visibilty:inherit well, so we remove the attribute instead (#2881, #3909)
	                if (value === 'inherit') {
	                    element.removeAttribute(key);
	                } else if (this[key] !== value) { // #6747
	                    element.setAttribute(key, value);
	                }
	                this[key] = value;
	            },
	            zIndexSetter: function(value, key) {
	                var renderer = this.renderer,
	                    parentGroup = this.parentGroup,
	                    parentWrapper = parentGroup || renderer,
	                    parentNode = parentWrapper.element || renderer.box,
	                    childNodes,
	                    otherElement,
	                    otherZIndex,
	                    element = this.element,
	                    inserted,
	                    run = this.added,
	                    i;
	
	                if (defined(value)) {
	                    element.zIndex = value; // So we can read it for other elements in the group
	                    value = +value;
	                    if (this[key] === value) { // Only update when needed (#3865)
	                        run = false;
	                    }
	                    this[key] = value;
	                }
	
	                // Insert according to this and other elements' zIndex. Before .add() is called,
	                // nothing is done. Then on add, or by later calls to zIndexSetter, the node
	                // is placed on the right place in the DOM.
	                if (run) {
	                    value = this.zIndex;
	
	                    if (value && parentGroup) {
	                        parentGroup.handleZ = true;
	                    }
	
	                    childNodes = parentNode.childNodes;
	                    for (i = 0; i < childNodes.length && !inserted; i++) {
	                        otherElement = childNodes[i];
	                        otherZIndex = otherElement.zIndex;
	                        if (otherElement !== element && (
	                                // Insert before the first element with a higher zIndex
	                                pInt(otherZIndex) > value ||
	                                // If no zIndex given, insert before the first element with a zIndex
	                                (!defined(value) && defined(otherZIndex)) ||
	                                // Negative zIndex versus no zIndex:
	                                // On all levels except the highest. If the parent is <svg>,
	                                // then we don't want to put items before <desc> or <defs>
	                                (value < 0 && !defined(otherZIndex) && parentNode !== renderer.box)
	
	                            )) {
	                            parentNode.insertBefore(element, otherElement);
	                            inserted = true;
	                        }
	                    }
	                    if (!inserted) {
	                        parentNode.appendChild(element);
	                    }
	                }
	                return inserted;
	            },
	            _defaultSetter: function(value, key, element) {
	                element.setAttribute(key, value);
	            }
	        });
	
	        // Some shared setters and getters
	        SVGElement.prototype.yGetter = SVGElement.prototype.xGetter;
	        SVGElement.prototype.translateXSetter = SVGElement.prototype.translateYSetter =
	            SVGElement.prototype.rotationSetter = SVGElement.prototype.verticalAlignSetter =
	            SVGElement.prototype.scaleXSetter = SVGElement.prototype.scaleYSetter = function(value, key) {
	                this[key] = value;
	                this.doTransform = true;
	            };
	
	
	        // WebKit and Batik have problems with a stroke-width of zero, so in this case we remove the 
	        // stroke attribute altogether. #1270, #1369, #3065, #3072.
	        SVGElement.prototype['stroke-widthSetter'] = SVGElement.prototype.strokeSetter = function(value, key, element) {
	            this[key] = value;
	            // Only apply the stroke attribute if the stroke width is defined and larger than 0
	            if (this.stroke && this['stroke-width']) {
	                SVGElement.prototype.fillSetter.call(this, this.stroke, 'stroke', element); // use prototype as instance may be overridden
	                element.setAttribute('stroke-width', this['stroke-width']);
	                this.hasStroke = true;
	            } else if (key === 'stroke-width' && value === 0 && this.hasStroke) {
	                element.removeAttribute('stroke');
	                this.hasStroke = false;
	            }
	        };
	
	
	        /**
	         * Allows direct access to the Highcharts rendering layer in order to draw
	         * primitive shapes like circles, rectangles, paths or text directly on a chart,
	         * or independent from any chart. The SVGRenderer represents a wrapper object
	         * for SVGin modern browsers and through the VMLRenderer, for VML in IE < 8.
	         *
	         * An existing chart's renderer can be accessed through {@link Chart.renderer}.
	         * The renderer can also be used completely decoupled from a chart.
	         *
	         * @param {HTMLDOMElement} container - Where to put the SVG in the web page.
	         * @param {number} width - The width of the SVG.
	         * @param {number} height - The height of the SVG.
	         * @param {boolean} [forExport=false] - Whether the rendered content is intended
	         *   for export.
	         * @param {boolean} [allowHTML=true] - Whether the renderer is allowed to
	         *   include HTML text, which will be projected on top of the SVG.
	         *
	         * @example
	         * // Use directly without a chart object.
	         * var renderer = new Highcharts.Renderer(parentNode, 600, 400);
	         *
	         * @sample highcharts/members/renderer-on-chart - Annotating a chart programmatically.
	         * @sample highcharts/members/renderer-basic - Independent SVG drawing.
	         *
	         * @class Highcharts.SVGRenderer
	         */
	        SVGRenderer = H.SVGRenderer = function() {
	            this.init.apply(this, arguments);
	        };
	        extend(SVGRenderer.prototype, /** @lends Highcharts.SVGRenderer.prototype */ {
	            /**
	             * A pointer to the renderer's associated Element class. The VMLRenderer
	             * will have a pointer to VMLElement here.
	             * @type {SVGElement}
	             */
	            Element: SVGElement,
	            SVG_NS: SVG_NS,
	            /**
	             * Initialize the SVGRenderer. Overridable initiator function that takes
	             * the same parameters as the constructor.
	             */
	            init: function(container, width, height, style, forExport, allowHTML) {
	                var renderer = this,
	                    boxWrapper,
	                    element,
	                    desc;
	
	                boxWrapper = renderer.createElement('svg')
	                    .attr({
	                        'version': '1.1',
	                        'class': 'highcharts-root'
	                    })
	
	                    .css(this.getStyle(style));
	                element = boxWrapper.element;
	                container.appendChild(element);
	
	                // For browsers other than IE, add the namespace attribute (#1978)
	                if (container.innerHTML.indexOf('xmlns') === -1) {
	                    attr(element, 'xmlns', this.SVG_NS);
	                }
	
	                // object properties
	                renderer.isSVG = true;
	
	                /** 
	                 * The root `svg` node of the renderer.
	                 * @name box
	                 * @memberOf SVGRenderer
	                 * @type {SVGDOMElement}
	                 */
	                this.box = element;
	                /** 
	                 * The wrapper for the root `svg` node of the renderer.
	                 *
	                 * @name boxWrapper
	                 * @memberOf SVGRenderer
	                 * @type {SVGElement}
	                 */
	                this.boxWrapper = boxWrapper;
	                renderer.alignedObjects = [];
	
	                /**
	                 * Page url used for internal references.
	                 * @type {string}
	                 */
	                // #24, #672, #1070
	                this.url = (isFirefox || isWebKit) && doc.getElementsByTagName('base').length ?
	                    win.location.href
	                    .replace(/#.*?$/, '') // remove the hash
	                    .replace(/<[^>]*>/g, '') // wing cut HTML
	                    .replace(/([\('\)])/g, '\\$1') // escape parantheses and quotes
	                    .replace(/ /g, '%20') : // replace spaces (needed for Safari only)
	                    '';
	
	                // Add description
	                desc = this.createElement('desc').add();
	                desc.element.appendChild(doc.createTextNode('Created with Highmaps 5.0.14'));
	
	                /**
	                 * A pointer to the `defs` node of the root SVG.
	                 * @type {SVGElement}
	                 * @name defs
	                 * @memberOf SVGRenderer
	                 */
	                renderer.defs = this.createElement('defs').add();
	                renderer.allowHTML = allowHTML;
	                renderer.forExport = forExport;
	                renderer.gradients = {}; // Object where gradient SvgElements are stored
	                renderer.cache = {}; // Cache for numerical bounding boxes
	                renderer.cacheKeys = [];
	                renderer.imgCount = 0;
	
	                renderer.setSize(width, height, false);
	
	
	
	                // Issue 110 workaround:
	                // In Firefox, if a div is positioned by percentage, its pixel position may land
	                // between pixels. The container itself doesn't display this, but an SVG element
	                // inside this container will be drawn at subpixel precision. In order to draw
	                // sharp lines, this must be compensated for. This doesn't seem to work inside
	                // iframes though (like in jsFiddle).
	                var subPixelFix, rect;
	                if (isFirefox && container.getBoundingClientRect) {
	                    subPixelFix = function() {
	                        css(container, {
	                            left: 0,
	                            top: 0
	                        });
	                        rect = container.getBoundingClientRect();
	                        css(container, {
	                            left: (Math.ceil(rect.left) - rect.left) + 'px',
	                            top: (Math.ceil(rect.top) - rect.top) + 'px'
	                        });
	                    };
	
	                    // run the fix now
	                    subPixelFix();
	
	                    // run it on resize
	                    renderer.unSubPixelFix = addEvent(win, 'resize', subPixelFix);
	                }
	            },
	
	
	
	            /**
	             * Get the global style setting for the renderer.
	             * @private
	             * @param  {CSSObject} style - Style settings.
	             * @return {CSSObject} The style settings mixed with defaults.
	             */
	            getStyle: function(style) {
	                this.style = extend({
	
	                    fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif', // default font
	                    fontSize: '12px'
	
	                }, style);
	                return this.style;
	            },
	            /**
	             * Apply the global style on the renderer, mixed with the default styles.
	             * 
	             * @param {CSSObject} style - CSS to apply.
	             */
	            setStyle: function(style) {
	                this.boxWrapper.css(this.getStyle(style));
	            },
	
	
	            /**
	             * Detect whether the renderer is hidden. This happens when one of the
	             * parent elements has `display: none`. Used internally to detect when we
	             * needto render preliminarily in another div to get the text bounding boxes 
	             * right.
	             *
	             * @returns {boolean} True if it is hidden.
	             */
	            isHidden: function() { // #608
	                return !this.boxWrapper.getBBox().width;
	            },
	
	            /**
	             * Destroys the renderer and its allocated members.
	             */
	            destroy: function() {
	                var renderer = this,
	                    rendererDefs = renderer.defs;
	                renderer.box = null;
	                renderer.boxWrapper = renderer.boxWrapper.destroy();
	
	                // Call destroy on all gradient elements
	                destroyObjectProperties(renderer.gradients || {});
	                renderer.gradients = null;
	
	                // Defs are null in VMLRenderer
	                // Otherwise, destroy them here.
	                if (rendererDefs) {
	                    renderer.defs = rendererDefs.destroy();
	                }
	
	                // Remove sub pixel fix handler (#982)
	                if (renderer.unSubPixelFix) {
	                    renderer.unSubPixelFix();
	                }
	
	                renderer.alignedObjects = null;
	
	                return null;
	            },
	
	            /**
	             * Create a wrapper for an SVG element. Serves as a factory for 
	             * {@link SVGElement}, but this function is itself mostly called from 
	             * primitive factories like {@link SVGRenderer#path}, {@link
	             * SVGRenderer#rect} or {@link SVGRenderer#text}.
	             * 
	             * @param {string} nodeName - The node name, for example `rect`, `g` etc.
	             * @returns {SVGElement} The generated SVGElement.
	             */
	            createElement: function(nodeName) {
	                var wrapper = new this.Element();
	                wrapper.init(this, nodeName);
	                return wrapper;
	            },
	
	            /**
	             * Dummy function for plugins, called every time the renderer is updated.
	             * Prior to Highcharts 5, this was used for the canvg renderer.
	             * @function
	             */
	            draw: noop,
	
	            /**
	             * Get converted radial gradient attributes according to the radial
	             * reference. Used internally from the {@link SVGElement#colorGradient}
	             * function.
	             *
	             * @private
	             */
	            getRadialAttr: function(radialReference, gradAttr) {
	                return {
	                    cx: (radialReference[0] - radialReference[2] / 2) + gradAttr.cx * radialReference[2],
	                    cy: (radialReference[1] - radialReference[2] / 2) + gradAttr.cy * radialReference[2],
	                    r: gradAttr.r * radialReference[2]
	                };
	            },
	
	            getSpanWidth: function(wrapper, tspan) {
	                var renderer = this,
	                    bBox = wrapper.getBBox(true),
	                    actualWidth = bBox.width;
	
	                // Old IE cannot measure the actualWidth for SVG elements (#2314)
	                if (!svg && renderer.forExport) {
	                    actualWidth = renderer.measureSpanWidth(tspan.firstChild.data, wrapper.styles);
	                }
	                return actualWidth;
	            },
	
	            applyEllipsis: function(wrapper, tspan, text, width) {
	                var renderer = this,
	                    rotation = wrapper.rotation,
	                    str = text,
	                    currentIndex,
	                    minIndex = 0,
	                    maxIndex = text.length,
	                    updateTSpan = function(s) {
	                        tspan.removeChild(tspan.firstChild);
	                        if (s) {
	                            tspan.appendChild(doc.createTextNode(s));
	                        }
	                    },
	                    actualWidth,
	                    wasTooLong;
	                wrapper.rotation = 0; // discard rotation when computing box
	                actualWidth = renderer.getSpanWidth(wrapper, tspan);
	                wasTooLong = actualWidth > width;
	                if (wasTooLong) {
	                    while (minIndex <= maxIndex) {
	                        currentIndex = Math.ceil((minIndex + maxIndex) / 2);
	                        str = text.substring(0, currentIndex) + '\u2026';
	                        updateTSpan(str);
	                        actualWidth = renderer.getSpanWidth(wrapper, tspan);
	                        if (minIndex === maxIndex) {
	                            // Complete
	                            minIndex = maxIndex + 1;
	                        } else if (actualWidth > width) {
	                            // Too large. Set max index to current.
	                            maxIndex = currentIndex - 1;
	                        } else {
	                            // Within width. Set min index to current.
	                            minIndex = currentIndex;
	                        }
	                    }
	                    // If max index was 0 it means just ellipsis was also to large.
	                    if (maxIndex === 0) {
	                        // Remove ellipses.
	                        updateTSpan('');
	                    }
	                }
	                wrapper.rotation = rotation; // Apply rotation again.
	                return wasTooLong;
	            },
	
	            /**
	             * Parse a simple HTML string into SVG tspans. Called internally when text
	             *   is set on an SVGElement. The function supports a subset of HTML tags,
	             *   CSS text features like `width`, `text-overflow`, `white-space`, and
	             *   also attributes like `href` and `style`.
	             * @private
	             * @param {SVGElement} wrapper The parent SVGElement.
	             */
	            buildText: function(wrapper) {
	                var textNode = wrapper.element,
	                    renderer = this,
	                    forExport = renderer.forExport,
	                    textStr = pick(wrapper.textStr, '').toString(),
	                    hasMarkup = textStr.indexOf('<') !== -1,
	                    lines,
	                    childNodes = textNode.childNodes,
	                    clsRegex,
	                    styleRegex,
	                    hrefRegex,
	                    wasTooLong,
	                    parentX = attr(textNode, 'x'),
	                    textStyles = wrapper.styles,
	                    width = wrapper.textWidth,
	                    textLineHeight = textStyles && textStyles.lineHeight,
	                    textOutline = textStyles && textStyles.textOutline,
	                    ellipsis = textStyles && textStyles.textOverflow === 'ellipsis',
	                    noWrap = textStyles && textStyles.whiteSpace === 'nowrap',
	                    fontSize = textStyles && textStyles.fontSize,
	                    textCache,
	                    isSubsequentLine,
	                    i = childNodes.length,
	                    tempParent = width && !wrapper.added && this.box,
	                    getLineHeight = function(tspan) {
	                        var fontSizeStyle;
	
	                        fontSizeStyle = /(px|em)$/.test(tspan && tspan.style.fontSize) ?
	                            tspan.style.fontSize :
	                            (fontSize || renderer.style.fontSize || 12);
	
	
	                        return textLineHeight ?
	                            pInt(textLineHeight) :
	                            renderer.fontMetrics(
	                                fontSizeStyle,
	                                // Get the computed size from parent if not explicit
	                                tspan.getAttribute('style') ? tspan : textNode
	                            ).h;
	                    },
	                    unescapeAngleBrackets = function(inputStr) {
	                        return inputStr.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
	                    };
	
	                // The buildText code is quite heavy, so if we're not changing something
	                // that affects the text, skip it (#6113).
	                textCache = [
	                    textStr,
	                    ellipsis,
	                    noWrap,
	                    textLineHeight,
	                    textOutline,
	                    fontSize,
	                    width
	                ].join(',');
	                if (textCache === wrapper.textCache) {
	                    return;
	                }
	                wrapper.textCache = textCache;
	
	                /// remove old text
	                while (i--) {
	                    textNode.removeChild(childNodes[i]);
	                }
	
	                // Skip tspans, add text directly to text node. The forceTSpan is a hook
	                // used in text outline hack.
	                if (!hasMarkup && !textOutline && !ellipsis && !width && textStr.indexOf(' ') === -1) {
	                    textNode.appendChild(doc.createTextNode(unescapeAngleBrackets(textStr)));
	
	                    // Complex strings, add more logic
	                } else {
	
	                    clsRegex = /<.*class="([^"]+)".*>/;
	                    styleRegex = /<.*style="([^"]+)".*>/;
	                    hrefRegex = /<.*href="([^"]+)".*>/;
	
	                    if (tempParent) {
	                        tempParent.appendChild(textNode); // attach it to the DOM to read offset width
	                    }
	
	                    if (hasMarkup) {
	                        lines = textStr
	
	                            .replace(/<(b|strong)>/g, '<span style="font-weight:bold">')
	                            .replace(/<(i|em)>/g, '<span style="font-style:italic">')
	
	                            .replace(/<a/g, '<span')
	                            .replace(/<\/(b|strong|i|em|a)>/g, '</span>')
	                            .split(/<br.*?>/g);
	
	                    } else {
	                        lines = [textStr];
	                    }
	
	
	                    // Trim empty lines (#5261)
	                    lines = grep(lines, function(line) {
	                        return line !== '';
	                    });
	
	
	                    // build the lines
	                    each(lines, function buildTextLines(line, lineNo) {
	                        var spans,
	                            spanNo = 0;
	                        line = line
	                            .replace(/^\s+|\s+$/g, '') // Trim to prevent useless/costly process on the spaces (#5258)
	                            .replace(/<span/g, '|||<span')
	                            .replace(/<\/span>/g, '</span>|||');
	                        spans = line.split('|||');
	
	                        each(spans, function buildTextSpans(span) {
	                            if (span !== '' || spans.length === 1) {
	                                var attributes = {},
	                                    tspan = doc.createElementNS(renderer.SVG_NS, 'tspan'),
	                                    spanCls,
	                                    spanStyle; // #390
	                                if (clsRegex.test(span)) {
	                                    spanCls = span.match(clsRegex)[1];
	                                    attr(tspan, 'class', spanCls);
	                                }
	                                if (styleRegex.test(span)) {
	                                    spanStyle = span.match(styleRegex)[1].replace(/(;| |^)color([ :])/, '$1fill$2');
	                                    attr(tspan, 'style', spanStyle);
	                                }
	                                if (hrefRegex.test(span) && !forExport) { // Not for export - #1529
	                                    attr(tspan, 'onclick', 'location.href=\"' + span.match(hrefRegex)[1] + '\"');
	                                    css(tspan, {
	                                        cursor: 'pointer'
	                                    });
	                                }
	
	                                span = unescapeAngleBrackets(span.replace(/<(.|\n)*?>/g, '') || ' ');
	
	                                // Nested tags aren't supported, and cause crash in Safari (#1596)
	                                if (span !== ' ') {
	
	                                    // add the text node
	                                    tspan.appendChild(doc.createTextNode(span));
	
	                                    if (!spanNo) { // first span in a line, align it to the left
	                                        if (lineNo && parentX !== null) {
	                                            attributes.x = parentX;
	                                        }
	                                    } else {
	                                        attributes.dx = 0; // #16
	                                    }
	
	                                    // add attributes
	                                    attr(tspan, attributes);
	
	                                    // Append it
	                                    textNode.appendChild(tspan);
	
	                                    // first span on subsequent line, add the line height
	                                    if (!spanNo && isSubsequentLine) {
	
	                                        // allow getting the right offset height in exporting in IE
	                                        if (!svg && forExport) {
	                                            css(tspan, {
	                                                display: 'block'
	                                            });
	                                        }
	
	                                        // Set the line height based on the font size of either
	                                        // the text element or the tspan element
	                                        attr(
	                                            tspan,
	                                            'dy',
	                                            getLineHeight(tspan)
	                                        );
	                                    }
	
	                                    /*if (width) {
	                                    	renderer.breakText(wrapper, width);
	                                    }*/
	
	                                    // Check width and apply soft breaks or ellipsis
	                                    if (width) {
	                                        var words = span.replace(/([^\^])-/g, '$1- ').split(' '), // #1273
	                                            hasWhiteSpace = spans.length > 1 || lineNo || (words.length > 1 && !noWrap),
	                                            tooLong,
	                                            rest = [],
	                                            actualWidth,
	                                            dy = getLineHeight(tspan),
	                                            rotation = wrapper.rotation;
	
	                                        if (ellipsis) {
	                                            wasTooLong = renderer.applyEllipsis(wrapper, tspan, span, width);
	                                        }
	
	                                        while (!ellipsis && hasWhiteSpace && (words.length || rest.length)) {
	                                            wrapper.rotation = 0; // discard rotation when computing box
	                                            actualWidth = renderer.getSpanWidth(wrapper, tspan);
	                                            tooLong = actualWidth > width;
	
	                                            // For ellipsis, do a binary search for the correct string length
	                                            if (wasTooLong === undefined) {
	                                                wasTooLong = tooLong; // First time
	                                            }
	
	                                            // Looping down, this is the first word sequence that is not too long,
	                                            // so we can move on to build the next line.
	                                            if (!tooLong || words.length === 1) {
	                                                words = rest;
	                                                rest = [];
	
	                                                if (words.length && !noWrap) {
	                                                    tspan = doc.createElementNS(SVG_NS, 'tspan');
	                                                    attr(tspan, {
	                                                        dy: dy,
	                                                        x: parentX
	                                                    });
	                                                    if (spanStyle) { // #390
	                                                        attr(tspan, 'style', spanStyle);
	                                                    }
	                                                    textNode.appendChild(tspan);
	                                                }
	                                                if (actualWidth > width) { // a single word is pressing it out
	                                                    width = actualWidth;
	                                                }
	                                            } else { // append to existing line tspan
	                                                tspan.removeChild(tspan.firstChild);
	                                                rest.unshift(words.pop());
	                                            }
	                                            if (words.length) {
	                                                tspan.appendChild(doc.createTextNode(words.join(' ').replace(/- /g, '-')));
	                                            }
	                                        }
	                                        wrapper.rotation = rotation;
	                                    }
	
	                                    spanNo++;
	                                }
	                            }
	                        });
	                        // To avoid beginning lines that doesn't add to the textNode (#6144)
	                        isSubsequentLine = isSubsequentLine || textNode.childNodes.length;
	                    });
	
	                    if (wasTooLong) {
	                        wrapper.attr('title', wrapper.textStr);
	                    }
	                    if (tempParent) {
	                        tempParent.removeChild(textNode); // attach it to the DOM to read offset width
	                    }
	
	                    // Apply the text outline
	                    if (textOutline && wrapper.applyTextOutline) {
	                        wrapper.applyTextOutline(textOutline);
	                    }
	                }
	            },
	
	
	
	            /*
	            breakText: function (wrapper, width) {
	            	var bBox = wrapper.getBBox(),
	            		node = wrapper.element,
	            		textLength = node.textContent.length,
	            		pos = Math.round(width * textLength / bBox.width), // try this position first, based on average character width
	            		increment = 0,
	            		finalPos;
	
	            	if (bBox.width > width) {
	            		while (finalPos === undefined) {
	            			textLength = node.getSubStringLength(0, pos);
	
	            			if (textLength <= width) {
	            				if (increment === -1) {
	            					finalPos = pos;
	            				} else {
	            					increment = 1;
	            				}
	            			} else {
	            				if (increment === 1) {
	            					finalPos = pos - 1;
	            				} else {
	            					increment = -1;
	            				}
	            			}
	            			pos += increment;
	            		}
	            	}
	            	console.log('width', width, 'stringWidth', node.getSubStringLength(0, finalPos))
	            },
	            */
	
	            /**
	             * Returns white for dark colors and black for bright colors.
	             *
	             * @param {ColorString} rgba - The color to get the contrast for.
	             * @returns {string} The contrast color, either `#000000` or `#FFFFFF`.
	             */
	            getContrast: function(rgba) {
	                rgba = color(rgba).rgba;
	
	                // The threshold may be discussed. Here's a proposal for adding
	                // different weight to the color channels (#6216)
	                /*
	        rgba[0] *= 1; // red
	        rgba[1] *= 1.2; // green
	        rgba[2] *= 0.7; // blue
	        */
	
	                return rgba[0] + rgba[1] + rgba[2] > 2 * 255 ? '#000000' : '#FFFFFF';
	            },
	
	            /**
	             * Create a button with preset states.
	             * @param {string} text - The text or HTML to draw.
	             * @param {number} x - The x position of the button's left side.
	             * @param {number} y - The y position of the button's top side.
	             * @param {Function} callback - The function to execute on button click or 
	             *    touch.
	             * @param {SVGAttributes} [normalState] - SVG attributes for the normal
	             *    state.
	             * @param {SVGAttributes} [hoverState] - SVG attributes for the hover state.
	             * @param {SVGAttributes} [pressedState] - SVG attributes for the pressed
	             *    state.
	             * @param {SVGAttributes} [disabledState] - SVG attributes for the disabled
	             *    state.
	             * @param {Symbol} [shape=rect] - The shape type.
	             * @returns {SVGRenderer} The button element.
	             */
	            button: function(text, x, y, callback, normalState, hoverState, pressedState, disabledState, shape) {
	                var label = this.label(text, x, y, shape, null, null, null, null, 'button'),
	                    curState = 0;
	
	                // Default, non-stylable attributes
	                label.attr(merge({
	                    'padding': 8,
	                    'r': 2
	                }, normalState));
	
	
	                // Presentational
	                var normalStyle,
	                    hoverStyle,
	                    pressedStyle,
	                    disabledStyle;
	
	                // Normal state - prepare the attributes
	                normalState = merge({
	                    fill: '#f7f7f7',
	                    stroke: '#cccccc',
	                    'stroke-width': 1,
	                    style: {
	                        color: '#333333',
	                        cursor: 'pointer',
	                        fontWeight: 'normal'
	                    }
	                }, normalState);
	                normalStyle = normalState.style;
	                delete normalState.style;
	
	                // Hover state
	                hoverState = merge(normalState, {
	                    fill: '#e6e6e6'
	                }, hoverState);
	                hoverStyle = hoverState.style;
	                delete hoverState.style;
	
	                // Pressed state
	                pressedState = merge(normalState, {
	                    fill: '#e6ebf5',
	                    style: {
	                        color: '#000000',
	                        fontWeight: 'bold'
	                    }
	                }, pressedState);
	                pressedStyle = pressedState.style;
	                delete pressedState.style;
	
	                // Disabled state
	                disabledState = merge(normalState, {
	                    style: {
	                        color: '#cccccc'
	                    }
	                }, disabledState);
	                disabledStyle = disabledState.style;
	                delete disabledState.style;
	
	
	                // Add the events. IE9 and IE10 need mouseover and mouseout to funciton (#667).
	                addEvent(label.element, isMS ? 'mouseover' : 'mouseenter', function() {
	                    if (curState !== 3) {
	                        label.setState(1);
	                    }
	                });
	                addEvent(label.element, isMS ? 'mouseout' : 'mouseleave', function() {
	                    if (curState !== 3) {
	                        label.setState(curState);
	                    }
	                });
	
	                label.setState = function(state) {
	                    // Hover state is temporary, don't record it
	                    if (state !== 1) {
	                        label.state = curState = state;
	                    }
	                    // Update visuals
	                    label.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/)
	                        .addClass('highcharts-button-' + ['normal', 'hover', 'pressed', 'disabled'][state || 0]);
	
	
	                    label.attr([normalState, hoverState, pressedState, disabledState][state || 0])
	                        .css([normalStyle, hoverStyle, pressedStyle, disabledStyle][state || 0]);
	
	                };
	
	
	
	                // Presentational attributes
	                label
	                    .attr(normalState)
	                    .css(extend({
	                        cursor: 'default'
	                    }, normalStyle));
	
	
	                return label
	                    .on('click', function(e) {
	                        if (curState !== 3) {
	                            callback.call(label, e);
	                        }
	                    });
	            },
	
	            /**
	             * Make a straight line crisper by not spilling out to neighbour pixels.
	             * 
	             * @param {Array} points - The original points on the format `['M', 0, 0,
	             *    'L', 100, 0]`.
	             * @param {number} width - The width of the line.
	             * @returns {Array} The original points array, but modified to render
	             * crisply.
	             */
	            crispLine: function(points, width) {
	                // normalize to a crisp line
	                if (points[1] === points[4]) {
	                    // Substract due to #1129. Now bottom and left axis gridlines behave the same.
	                    points[1] = points[4] = Math.round(points[1]) - (width % 2 / 2);
	                }
	                if (points[2] === points[5]) {
	                    points[2] = points[5] = Math.round(points[2]) + (width % 2 / 2);
	                }
	                return points;
	            },
	
	
	            /**
	             * Draw a path, wraps the SVG `path` element.
	             * 
	             * @param {Array} [path] An SVG path definition in array form.
	             * 
	             * @example
	             * var path = renderer.path(['M', 10, 10, 'L', 30, 30, 'z'])
	             *     .attr({ stroke: '#ff00ff' })
	             *     .add();
	             * @returns {SVGElement} The generated wrapper element.
	             *
	             * @sample highcharts/members/renderer-path-on-chart/
	             *         Draw a path in a chart
	             * @sample highcharts/members/renderer-path/
	             *         Draw a path independent from a chart
	             *
	             */
	            /**
	             * Draw a path, wraps the SVG `path` element.
	             * 
	             * @param {SVGAttributes} [attribs] The initial attributes.
	             * @returns {SVGElement} The generated wrapper element.
	             */
	            path: function(path) {
	                var attribs = {
	
	                    fill: 'none'
	
	                };
	                if (isArray(path)) {
	                    attribs.d = path;
	                } else if (isObject(path)) { // attributes
	                    extend(attribs, path);
	                }
	                return this.createElement('path').attr(attribs);
	            },
	
	            /**
	             * Draw a circle, wraps the SVG `circle` element.
	             * 
	             * @param {number} [x] The center x position.
	             * @param {number} [y] The center y position.
	             * @param {number} [r] The radius.
	             * @returns {SVGElement} The generated wrapper element.
	             *
	             * @sample highcharts/members/renderer-circle/ Drawing a circle
	             */
	            /**
	             * Draw a circle, wraps the SVG `circle` element.
	             * 
	             * @param {SVGAttributes} [attribs] The initial attributes.
	             * @returns {SVGElement} The generated wrapper element.
	             */
	            circle: function(x, y, r) {
	                var attribs = isObject(x) ? x : {
	                        x: x,
	                        y: y,
	                        r: r
	                    },
	                    wrapper = this.createElement('circle');
	
	                // Setting x or y translates to cx and cy
	                wrapper.xSetter = wrapper.ySetter = function(value, key, element) {
	                    element.setAttribute('c' + key, value);
	                };
	
	                return wrapper.attr(attribs);
	            },
	
	            /**
	             * Draw and return an arc.
	             * @param {number} [x=0] Center X position.
	             * @param {number} [y=0] Center Y position.
	             * @param {number} [r=0] The outer radius of the arc.
	             * @param {number} [innerR=0] Inner radius like used in donut charts.
	             * @param {number} [start=0] The starting angle of the arc in radians, where
	             *    0 is to the right and `-Math.PI/2` is up.
	             * @param {number} [end=0] The ending angle of the arc in radians, where 0
	             *    is to the right and `-Math.PI/2` is up.
	             * @returns {SVGElement} The generated wrapper element.
	             *
	             * @sample highcharts/members/renderer-arc/
	             *         Drawing an arc
	             */
	            /**
	             * Draw and return an arc. Overloaded function that takes arguments object.
	             * @param {SVGAttributes} attribs Initial SVG attributes.
	             * @returns {SVGElement} The generated wrapper element.
	             */
	            arc: function(x, y, r, innerR, start, end) {
	                var arc,
	                    options;
	
	                if (isObject(x)) {
	                    options = x;
	                    y = options.y;
	                    r = options.r;
	                    innerR = options.innerR;
	                    start = options.start;
	                    end = options.end;
	                    x = options.x;
	                } else {
	                    options = {
	                        innerR: innerR,
	                        start: start,
	                        end: end
	                    };
	                }
	
	                // Arcs are defined as symbols for the ability to set
	                // attributes in attr and animate
	                arc = this.symbol('arc', x, y, r, r, options);
	                arc.r = r; // #959
	                return arc;
	            },
	
	            /**
	             * Draw and return a rectangle.
	             * @param {number} [x] Left position.
	             * @param {number} [y] Top position.
	             * @param {number} [width] Width of the rectangle.
	             * @param {number} [height] Height of the rectangle.
	             * @param {number} [r] Border corner radius.
	             * @param {number} [strokeWidth] A stroke width can be supplied to allow
	             *    crisp drawing.
	             * @returns {SVGElement} The generated wrapper element.
	             */
	            /**
	             * Draw and return a rectangle.
	             * @param  {SVGAttributes} [attributes]
	             *         General SVG attributes for the rectangle.
	             * @return {SVGElement}
	             *         The generated wrapper element.
	             *
	             * @sample highcharts/members/renderer-rect-on-chart/
	             *         Draw a rectangle in a chart
	             * @sample highcharts/members/renderer-rect/
	             *         Draw a rectangle independent from a chart
	             */
	            rect: function(x, y, width, height, r, strokeWidth) {
	
	                r = isObject(x) ? x.r : r;
	
	                var wrapper = this.createElement('rect'),
	                    attribs = isObject(x) ? x : x === undefined ? {} : {
	                        x: x,
	                        y: y,
	                        width: Math.max(width, 0),
	                        height: Math.max(height, 0)
	                    };
	
	
	                if (strokeWidth !== undefined) {
	                    attribs.strokeWidth = strokeWidth;
	                    attribs = wrapper.crisp(attribs);
	                }
	                attribs.fill = 'none';
	
	
	                if (r) {
	                    attribs.r = r;
	                }
	
	                wrapper.rSetter = function(value, key, element) {
	                    attr(element, {
	                        rx: value,
	                        ry: value
	                    });
	                };
	
	                return wrapper.attr(attribs);
	            },
	
	            /**
	             * Resize the {@link SVGRenderer#box} and re-align all aligned child
	             * elements.
	             * @param  {number} width
	             *         The new pixel width.
	             * @param  {number} height
	             *         The new pixel height.
	             * @param  {Boolean|AnimationOptions} [animate=true]
	             *         Whether and how to animate.
	             */
	            setSize: function(width, height, animate) {
	                var renderer = this,
	                    alignedObjects = renderer.alignedObjects,
	                    i = alignedObjects.length;
	
	                renderer.width = width;
	                renderer.height = height;
	
	                renderer.boxWrapper.animate({
	                    width: width,
	                    height: height
	                }, {
	                    step: function() {
	                        this.attr({
	                            viewBox: '0 0 ' + this.attr('width') + ' ' + this.attr('height')
	                        });
	                    },
	                    duration: pick(animate, true) ? undefined : 0
	                });
	
	                while (i--) {
	                    alignedObjects[i].align();
	                }
	            },
	
	            /**
	             * Create and return an svg group element. Child {@link Highcharts.SVGElement}
	             * objects are added to the group by using the group as the first parameter
	             * in {@link Highcharts.SVGElement#add|add()}.
	             * 
	             * @param {string} [name] The group will be given a class name of
	             * `highcharts-{name}`. This can be used for styling and scripting.
	             * @returns {SVGElement} The generated wrapper element.
	             *
	             * @sample highcharts/members/renderer-g/
	             *         Show and hide grouped objects
	             */
	            g: function(name) {
	                var elem = this.createElement('g');
	                return name ? elem.attr({
	                    'class': 'highcharts-' + name
	                }) : elem;
	            },
	
	            /**
	             * Display an image.
	             * @param {string} src The image source.
	             * @param {number} [x] The X position.
	             * @param {number} [y] The Y position.
	             * @param {number} [width] The image width. If omitted, it defaults to the 
	             *    image file width.
	             * @param {number} [height] The image height. If omitted it defaults to the
	             *    image file height.
	             * @returns {SVGElement} The generated wrapper element.
	             *
	             * @sample highcharts/members/renderer-image-on-chart/
	             *         Add an image in a chart
	             * @sample highcharts/members/renderer-image/
	             *         Add an image independent of a chart
	             */
	            image: function(src, x, y, width, height) {
	                var attribs = {
	                        preserveAspectRatio: 'none'
	                    },
	                    elemWrapper;
	
	                // optional properties
	                if (arguments.length > 1) {
	                    extend(attribs, {
	                        x: x,
	                        y: y,
	                        width: width,
	                        height: height
	                    });
	                }
	
	                elemWrapper = this.createElement('image').attr(attribs);
	
	                // set the href in the xlink namespace
	                if (elemWrapper.element.setAttributeNS) {
	                    elemWrapper.element.setAttributeNS('http://www.w3.org/1999/xlink',
	                        'href', src);
	                } else {
	                    // could be exporting in IE
	                    // using href throws "not supported" in ie7 and under, requries regex shim to fix later
	                    elemWrapper.element.setAttribute('hc-svg-href', src);
	                }
	                return elemWrapper;
	            },
	
	            /**
	             * Draw a symbol out of pre-defined shape paths from {@link SVGRenderer#symbols}.
	             * It is used in Highcharts for point makers, which cake a `symbol` option,
	             * and label and button backgrounds like in the tooltip and stock flags.
	             *
	             * @param {Symbol} symbol - The symbol name.
	             * @param {number} x - The X coordinate for the top left position.
	             * @param {number} y - The Y coordinate for the top left position.
	             * @param {number} width - The pixel width.
	             * @param {number} height - The pixel height.
	             * @param {Object} [options] - Additional options, depending on the actual
	             *    symbol drawn. 
	             * @param {number} [options.anchorX] - The anchor X position for the
	             *    `callout` symbol. This is where the chevron points to.
	             * @param {number} [options.anchorY] - The anchor Y position for the
	             *    `callout` symbol. This is where the chevron points to.
	             * @param {number} [options.end] - The end angle of an `arc` symbol.
	             * @param {boolean} [options.open] - Whether to draw `arc` symbol open or
	             *    closed.
	             * @param {number} [options.r] - The radius of an `arc` symbol, or the
	             *    border radius for the `callout` symbol.
	             * @param {number} [options.start] - The start angle of an `arc` symbol.
	             */
	            symbol: function(symbol, x, y, width, height, options) {
	
	                var ren = this,
	                    obj,
	                    imageRegex = /^url\((.*?)\)$/,
	                    isImage = imageRegex.test(symbol),
	                    sym = !isImage && (this.symbols[symbol] ? symbol : 'circle'),
	
	
	                    // get the symbol definition function
	                    symbolFn = sym && this.symbols[sym],
	
	                    // check if there's a path defined for this symbol
	                    path = defined(x) && symbolFn && symbolFn.call(
	                        this.symbols,
	                        Math.round(x),
	                        Math.round(y),
	                        width,
	                        height,
	                        options
	                    ),
	                    imageSrc,
	                    centerImage;
	
	                if (symbolFn) {
	                    obj = this.path(path);
	
	
	                    obj.attr('fill', 'none');
	
	
	                    // expando properties for use in animate and attr
	                    extend(obj, {
	                        symbolName: sym,
	                        x: x,
	                        y: y,
	                        width: width,
	                        height: height
	                    });
	                    if (options) {
	                        extend(obj, options);
	                    }
	
	
	                    // Image symbols
	                } else if (isImage) {
	
	
	                    imageSrc = symbol.match(imageRegex)[1];
	
	                    // Create the image synchronously, add attribs async
	                    obj = this.image(imageSrc);
	
	                    // The image width is not always the same as the symbol width. The
	                    // image may be centered within the symbol, as is the case when
	                    // image shapes are used as label backgrounds, for example in flags.
	                    obj.imgwidth = pick(
	                        symbolSizes[imageSrc] && symbolSizes[imageSrc].width,
	                        options && options.width
	                    );
	                    obj.imgheight = pick(
	                        symbolSizes[imageSrc] && symbolSizes[imageSrc].height,
	                        options && options.height
	                    );
	                    /**
	                     * Set the size and position
	                     */
	                    centerImage = function() {
	                        obj.attr({
	                            width: obj.width,
	                            height: obj.height
	                        });
	                    };
	
	                    /**
	                     * Width and height setters that take both the image's physical size
	                     * and the label size into consideration, and translates the image
	                     * to center within the label.
	                     */
	                    each(['width', 'height'], function(key) {
	                        obj[key + 'Setter'] = function(value, key) {
	                            var attribs = {},
	                                imgSize = this['img' + key],
	                                trans = key === 'width' ? 'translateX' : 'translateY';
	                            this[key] = value;
	                            if (defined(imgSize)) {
	                                if (this.element) {
	                                    this.element.setAttribute(key, imgSize);
	                                }
	                                if (!this.alignByTranslate) {
	                                    attribs[trans] = ((this[key] || 0) - imgSize) / 2;
	                                    this.attr(attribs);
	                                }
	                            }
	                        };
	                    });
	
	
	                    if (defined(x)) {
	                        obj.attr({
	                            x: x,
	                            y: y
	                        });
	                    }
	                    obj.isImg = true;
	
	                    if (defined(obj.imgwidth) && defined(obj.imgheight)) {
	                        centerImage();
	                    } else {
	                        // Initialize image to be 0 size so export will still function if there's no cached sizes.
	                        obj.attr({
	                            width: 0,
	                            height: 0
	                        });
	
	                        // Create a dummy JavaScript image to get the width and height. Due to a bug in IE < 8,
	                        // the created element must be assigned to a variable in order to load (#292).
	                        createElement('img', {
	                            onload: function() {
	
	                                var chart = charts[ren.chartIndex];
	
	                                // Special case for SVGs on IE11, the width is not accessible until the image is
	                                // part of the DOM (#2854).
	                                if (this.width === 0) {
	                                    css(this, {
	                                        position: 'absolute',
	                                        top: '-999em'
	                                    });
	                                    doc.body.appendChild(this);
	                                }
	
	                                // Center the image
	                                symbolSizes[imageSrc] = { // Cache for next	
	                                    width: this.width,
	                                    height: this.height
	                                };
	                                obj.imgwidth = this.width;
	                                obj.imgheight = this.height;
	
	                                if (obj.element) {
	                                    centerImage();
	                                }
	
	                                // Clean up after #2854 workaround.
	                                if (this.parentNode) {
	                                    this.parentNode.removeChild(this);
	                                }
	
	                                // Fire the load event when all external images are loaded
	                                ren.imgCount--;
	                                if (!ren.imgCount && chart && chart.onload) {
	                                    chart.onload();
	                                }
	                            },
	                            src: imageSrc
	                        });
	                        this.imgCount++;
	                    }
	                }
	
	                return obj;
	            },
	
	            /**
	             * @typedef {string} Symbol
	             * 
	             * Can be one of `arc`, `callout`, `circle`, `diamond`, `square`,
	             * `triangle`, `triangle-down`. Symbols are used internally for point
	             * markers, button and label borders and backgrounds, or custom shapes.
	             * Extendable by adding to {@link SVGRenderer#symbols}.
	             */
	            /**
	             * An extendable collection of functions for defining symbol paths.
	             */
	            symbols: {
	                'circle': function(x, y, w, h) {
	                    // Return a full arc
	                    return this.arc(x + w / 2, y + h / 2, w / 2, h / 2, {
	                        start: 0,
	                        end: Math.PI * 2,
	                        open: false
	                    });
	                },
	
	                'square': function(x, y, w, h) {
	                    return [
	                        'M', x, y,
	                        'L', x + w, y,
	                        x + w, y + h,
	                        x, y + h,
	                        'Z'
	                    ];
	                },
	
	                'triangle': function(x, y, w, h) {
	                    return [
	                        'M', x + w / 2, y,
	                        'L', x + w, y + h,
	                        x, y + h,
	                        'Z'
	                    ];
	                },
	
	                'triangle-down': function(x, y, w, h) {
	                    return [
	                        'M', x, y,
	                        'L', x + w, y,
	                        x + w / 2, y + h,
	                        'Z'
	                    ];
	                },
	                'diamond': function(x, y, w, h) {
	                    return [
	                        'M', x + w / 2, y,
	                        'L', x + w, y + h / 2,
	                        x + w / 2, y + h,
	                        x, y + h / 2,
	                        'Z'
	                    ];
	                },
	                'arc': function(x, y, w, h, options) {
	                    var start = options.start,
	                        rx = options.r || w,
	                        ry = options.r || h || w,
	                        proximity = 0.001,
	                        fullCircle =
	                        Math.abs(options.end - options.start - 2 * Math.PI) <
	                        proximity,
	                        // Substract a small number to prevent cos and sin of start and
	                        // end from becoming equal on 360 arcs (related: #1561)
	                        end = options.end - proximity,
	                        innerRadius = options.innerR,
	                        open = pick(options.open, fullCircle),
	                        cosStart = Math.cos(start),
	                        sinStart = Math.sin(start),
	                        cosEnd = Math.cos(end),
	                        sinEnd = Math.sin(end),
	                        // Proximity takes care of rounding errors around PI (#6971)
	                        longArc = options.end - start - Math.PI < proximity ? 0 : 1,
	                        arc;
	
	                    arc = [
	                        'M',
	                        x + rx * cosStart,
	                        y + ry * sinStart,
	                        'A', // arcTo
	                        rx, // x radius
	                        ry, // y radius
	                        0, // slanting
	                        longArc, // long or short arc
	                        1, // clockwise
	                        x + rx * cosEnd,
	                        y + ry * sinEnd
	                    ];
	
	                    if (defined(innerRadius)) {
	                        arc.push(
	                            open ? 'M' : 'L',
	                            x + innerRadius * cosEnd,
	                            y + innerRadius * sinEnd,
	                            'A', // arcTo
	                            innerRadius, // x radius
	                            innerRadius, // y radius
	                            0, // slanting
	                            longArc, // long or short arc
	                            0, // clockwise
	                            x + innerRadius * cosStart,
	                            y + innerRadius * sinStart
	                        );
	                    }
	
	                    arc.push(open ? '' : 'Z'); // close
	                    return arc;
	                },
	
	                /**
	                 * Callout shape used for default tooltips, also used for rounded rectangles in VML
	                 */
	                callout: function(x, y, w, h, options) {
	                    var arrowLength = 6,
	                        halfDistance = 6,
	                        r = Math.min((options && options.r) || 0, w, h),
	                        safeDistance = r + halfDistance,
	                        anchorX = options && options.anchorX,
	                        anchorY = options && options.anchorY,
	                        path;
	
	                    path = [
	                        'M', x + r, y,
	                        'L', x + w - r, y, // top side
	                        'C', x + w, y, x + w, y, x + w, y + r, // top-right corner
	                        'L', x + w, y + h - r, // right side
	                        'C', x + w, y + h, x + w, y + h, x + w - r, y + h, // bottom-right corner
	                        'L', x + r, y + h, // bottom side
	                        'C', x, y + h, x, y + h, x, y + h - r, // bottom-left corner
	                        'L', x, y + r, // left side
	                        'C', x, y, x, y, x + r, y // top-left corner
	                    ];
	
	                    // Anchor on right side
	                    if (anchorX && anchorX > w) {
	
	                        // Chevron
	                        if (anchorY > y + safeDistance && anchorY < y + h - safeDistance) {
	                            path.splice(13, 3,
	                                'L', x + w, anchorY - halfDistance,
	                                x + w + arrowLength, anchorY,
	                                x + w, anchorY + halfDistance,
	                                x + w, y + h - r
	                            );
	
	                            // Simple connector
	                        } else {
	                            path.splice(13, 3,
	                                'L', x + w, h / 2,
	                                anchorX, anchorY,
	                                x + w, h / 2,
	                                x + w, y + h - r
	                            );
	                        }
	
	                        // Anchor on left side
	                    } else if (anchorX && anchorX < 0) {
	
	                        // Chevron
	                        if (anchorY > y + safeDistance && anchorY < y + h - safeDistance) {
	                            path.splice(33, 3,
	                                'L', x, anchorY + halfDistance,
	                                x - arrowLength, anchorY,
	                                x, anchorY - halfDistance,
	                                x, y + r
	                            );
	
	                            // Simple connector
	                        } else {
	                            path.splice(33, 3,
	                                'L', x, h / 2,
	                                anchorX, anchorY,
	                                x, h / 2,
	                                x, y + r
	                            );
	                        }
	
	                    } else if (anchorY && anchorY > h && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace bottom
	                        path.splice(23, 3,
	                            'L', anchorX + halfDistance, y + h,
	                            anchorX, y + h + arrowLength,
	                            anchorX - halfDistance, y + h,
	                            x + r, y + h
	                        );
	                    } else if (anchorY && anchorY < 0 && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace top
	                        path.splice(3, 3,
	                            'L', anchorX - halfDistance, y,
	                            anchorX, y - arrowLength,
	                            anchorX + halfDistance, y,
	                            w - r, y
	                        );
	                    }
	
	                    return path;
	                }
	            },
	
	            /**
	             * @typedef {SVGElement} ClipRect - A clipping rectangle that can be applied
	             * to one or more {@link SVGElement} instances. It is instanciated with the
	             * {@link SVGRenderer#clipRect} function and applied with the {@link 
	             * SVGElement#clip} function.
	             *
	             * @example
	             * var circle = renderer.circle(100, 100, 100)
	             *     .attr({ fill: 'red' })
	             *     .add();
	             * var clipRect = renderer.clipRect(100, 100, 100, 100);
	             *
	             * // Leave only the lower right quarter visible
	             * circle.clip(clipRect);
	             */
	            /**
	             * Define a clipping rectangle. The clipping rectangle is later applied
	             * to {@link SVGElement} objects through the {@link SVGElement#clip}
	             * function.
	             * 
	             * @param {String} id
	             * @param {number} x
	             * @param {number} y
	             * @param {number} width
	             * @param {number} height
	             * @returns {ClipRect} A clipping rectangle.
	             *
	             * @example
	             * var circle = renderer.circle(100, 100, 100)
	             *     .attr({ fill: 'red' })
	             *     .add();
	             * var clipRect = renderer.clipRect(100, 100, 100, 100);
	             *
	             * // Leave only the lower right quarter visible
	             * circle.clip(clipRect);
	             */
	            clipRect: function(x, y, width, height) {
	                var wrapper,
	                    id = H.uniqueKey(),
	
	                    clipPath = this.createElement('clipPath').attr({
	                        id: id
	                    }).add(this.defs);
	
	                wrapper = this.rect(x, y, width, height, 0).add(clipPath);
	                wrapper.id = id;
	                wrapper.clipPath = clipPath;
	                wrapper.count = 0;
	
	                return wrapper;
	            },
	
	
	
	
	
	            /**
	             * Draw text. The text can contain a subset of HTML, like spans and anchors
	             * and some basic text styling of these. For more advanced features like
	             * border and background, use {@link Highcharts.SVGRenderer#label} instead.
	             * To update the text after render, run `text.attr({ text: 'New text' })`.
	             * @param  {String} str
	             *         The text of (subset) HTML to draw.
	             * @param  {number} x
	             *         The x position of the text's lower left corner.
	             * @param  {number} y
	             *         The y position of the text's lower left corner.
	             * @param  {Boolean} [useHTML=false]
	             *         Use HTML to render the text.
	             *
	             * @return {SVGElement} The text object.
	             *
	             * @sample highcharts/members/renderer-text-on-chart/
	             *         Annotate the chart freely
	             * @sample highcharts/members/renderer-on-chart/
	             *         Annotate with a border and in response to the data
	             * @sample highcharts/members/renderer-text/
	             *         Formatted text
	             */
	            text: function(str, x, y, useHTML) {
	
	                // declare variables
	                var renderer = this,
	                    fakeSVG = !svg && renderer.forExport,
	                    wrapper,
	                    attribs = {};
	
	                if (useHTML && (renderer.allowHTML || !renderer.forExport)) {
	                    return renderer.html(str, x, y);
	                }
	
	                attribs.x = Math.round(x || 0); // X is always needed for line-wrap logic
	                if (y) {
	                    attribs.y = Math.round(y);
	                }
	                if (str || str === 0) {
	                    attribs.text = str;
	                }
	
	                wrapper = renderer.createElement('text')
	                    .attr(attribs);
	
	                // Prevent wrapping from creating false offsetWidths in export in legacy IE (#1079, #1063)
	                if (fakeSVG) {
	                    wrapper.css({
	                        position: 'absolute'
	                    });
	                }
	
	                if (!useHTML) {
	                    wrapper.xSetter = function(value, key, element) {
	                        var tspans = element.getElementsByTagName('tspan'),
	                            tspan,
	                            parentVal = element.getAttribute(key),
	                            i;
	                        for (i = 0; i < tspans.length; i++) {
	                            tspan = tspans[i];
	                            // If the x values are equal, the tspan represents a linebreak
	                            if (tspan.getAttribute(key) === parentVal) {
	                                tspan.setAttribute(key, value);
	                            }
	                        }
	                        element.setAttribute(key, value);
	                    };
	                }
	
	                return wrapper;
	            },
	
	            /**
	             * Utility to return the baseline offset and total line height from the font
	             * size.
	             *
	             * @param {?string} fontSize The current font size to inspect. If not given,
	             *   the font size will be found from the DOM element.
	             * @param {SVGElement|SVGDOMElement} [elem] The element to inspect for a
	             *   current font size.
	             * @returns {Object} An object containing `h`: the line height, `b`: the
	             * baseline relative to the top of the box, and `f`: the font size.
	             */
	            fontMetrics: function(fontSize, elem) {
	                var lineHeight,
	                    baseline;
	
	
	                fontSize = fontSize ||
	                    // When the elem is a DOM element (#5932)
	                    (elem && elem.style && elem.style.fontSize) ||
	                    // Fall back on the renderer style default
	                    (this.style && this.style.fontSize);
	
	
	
	                // Handle different units
	                if (/px/.test(fontSize)) {
	                    fontSize = pInt(fontSize);
	                } else if (/em/.test(fontSize)) {
	                    // The em unit depends on parent items
	                    fontSize = parseFloat(fontSize) *
	                        (elem ? this.fontMetrics(null, elem.parentNode).f : 16);
	                } else {
	                    fontSize = 12;
	                }
	
	                // Empirical values found by comparing font size and bounding box
	                // height. Applies to the default font family.
	                // http://jsfiddle.net/highcharts/7xvn7/
	                lineHeight = fontSize < 24 ? fontSize + 3 : Math.round(fontSize * 1.2);
	                baseline = Math.round(lineHeight * 0.8);
	
	                return {
	                    h: lineHeight,
	                    b: baseline,
	                    f: fontSize
	                };
	            },
	
	            /**
	             * Correct X and Y positioning of a label for rotation (#1764).
	             *
	             * @private
	             */
	            rotCorr: function(baseline, rotation, alterY) {
	                var y = baseline;
	                if (rotation && alterY) {
	                    y = Math.max(y * Math.cos(rotation * deg2rad), 4);
	                }
	                return {
	                    x: (-baseline / 3) * Math.sin(rotation * deg2rad),
	                    y: y
	                };
	            },
	
	            /**
	             * Draw a label, which is an extended text element with support for border
	             * and background. Highcharts creates a `g` element with a text and a `path`
	             * or `rect` inside, to make it behave somewhat like a HTML div. Border and
	             * background are set through `stroke`, `stroke-width` and `fill` attributes
	             * using the {@link Highcharts.SVGElement#attr|attr} method. To update the
	             * text after render, run `label.attr({ text: 'New text' })`.
	             * 
	             * @param  {string} str
	             *         The initial text string or (subset) HTML to render.
	             * @param  {number} x
	             *         The x position of the label's left side.
	             * @param  {number} y
	             *         The y position of the label's top side or baseline, depending on
	             *         the `baseline` parameter.
	             * @param  {String} shape
	             *         The shape of the label's border/background, if any. Defaults to
	             *         `rect`. Other possible values are `callout` or other shapes
	             *         defined in {@link Highcharts.SVGRenderer#symbols}.
	             * @param  {number} anchorX
	             *         In case the `shape` has a pointer, like a flag, this is the
	             *         coordinates it should be pinned to.
	             * @param  {number} anchorY
	             *         In case the `shape` has a pointer, like a flag, this is the
	             *         coordinates it should be pinned to.
	             * @param  {Boolean} baseline
	             *         Whether to position the label relative to the text baseline,
	             *	       like {@link Highcharts.SVGRenderer#text|renderer.text}, or to the
	             *	       upper border of the rectangle.
	             * @param  {String} className
	             *         Class name for the group.
	             *
	             * @return {SVGElement}
	             *         The generated label.
	             *
	             * @sample highcharts/members/renderer-label-on-chart/
	             *         A label on the chart
	             */
	            label: function(str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {
	
	                var renderer = this,
	                    wrapper = renderer.g(className !== 'button' && 'label'),
	                    text = wrapper.text = renderer.text('', 0, 0, useHTML)
	                    .attr({
	                        zIndex: 1
	                    }),
	                    box,
	                    bBox,
	                    alignFactor = 0,
	                    padding = 3,
	                    paddingLeft = 0,
	                    width,
	                    height,
	                    wrapperX,
	                    wrapperY,
	                    textAlign,
	                    deferredAttr = {},
	                    strokeWidth,
	                    baselineOffset,
	                    hasBGImage = /^url\((.*?)\)$/.test(shape),
	                    needsBox = hasBGImage,
	                    getCrispAdjust,
	                    updateBoxSize,
	                    updateTextPadding,
	                    boxAttr;
	
	                if (className) {
	                    wrapper.addClass('highcharts-' + className);
	                }
	
	
	                needsBox = hasBGImage;
	                getCrispAdjust = function() {
	                    return (strokeWidth || 0) % 2 / 2;
	                };
	
	
	
	                /**
	                 * This function runs after the label is added to the DOM (when the bounding box is
	                 * available), and after the text of the label is updated to detect the new bounding
	                 * box and reflect it in the border box.
	                 */
	                updateBoxSize = function() {
	                    var style = text.element.style,
	                        crispAdjust,
	                        attribs = {};
	
	                    bBox = (width === undefined || height === undefined || textAlign) && defined(text.textStr) &&
	                        text.getBBox(); //#3295 && 3514 box failure when string equals 0
	                    wrapper.width = (width || bBox.width || 0) + 2 * padding + paddingLeft;
	                    wrapper.height = (height || bBox.height || 0) + 2 * padding;
	
	                    // Update the label-scoped y offset
	                    baselineOffset = padding + renderer.fontMetrics(style && style.fontSize, text).b;
	
	
	                    if (needsBox) {
	
	                        // Create the border box if it is not already present
	                        if (!box) {
	                            wrapper.box = box = renderer.symbols[shape] || hasBGImage ? // Symbol definition exists (#5324)
	                                renderer.symbol(shape) :
	                                renderer.rect();
	
	                            box.addClass(
	                                (className === 'button' ? '' : 'highcharts-label-box') + // Don't use label className for buttons
	                                (className ? ' highcharts-' + className + '-box' : '')
	                            );
	
	                            box.add(wrapper);
	
	                            crispAdjust = getCrispAdjust();
	                            attribs.x = crispAdjust;
	                            attribs.y = (baseline ? -baselineOffset : 0) + crispAdjust;
	                        }
	
	                        // Apply the box attributes
	                        attribs.width = Math.round(wrapper.width);
	                        attribs.height = Math.round(wrapper.height);
	
	                        box.attr(extend(attribs, deferredAttr));
	                        deferredAttr = {};
	                    }
	                };
	
	                /**
	                 * This function runs after setting text or padding, but only if padding is changed
	                 */
	                updateTextPadding = function() {
	                    var textX = paddingLeft + padding,
	                        textY;
	
	                    // determin y based on the baseline
	                    textY = baseline ? 0 : baselineOffset;
	
	                    // compensate for alignment
	                    if (defined(width) && bBox && (textAlign === 'center' || textAlign === 'right')) {
	                        textX += {
	                            center: 0.5,
	                            right: 1
	                        }[textAlign] * (width - bBox.width);
	                    }
	
	                    // update if anything changed
	                    if (textX !== text.x || textY !== text.y) {
	                        text.attr('x', textX);
	                        if (textY !== undefined) {
	                            text.attr('y', textY);
	                        }
	                    }
	
	                    // record current values
	                    text.x = textX;
	                    text.y = textY;
	                };
	
	                /**
	                 * Set a box attribute, or defer it if the box is not yet created
	                 * @param {Object} key
	                 * @param {Object} value
	                 */
	                boxAttr = function(key, value) {
	                    if (box) {
	                        box.attr(key, value);
	                    } else {
	                        deferredAttr[key] = value;
	                    }
	                };
	
	                /**
	                 * After the text element is added, get the desired size of the border box
	                 * and add it before the text in the DOM.
	                 */
	                wrapper.onAdd = function() {
	                    text.add(wrapper);
	                    wrapper.attr({
	                        text: (str || str === 0) ? str : '', // alignment is available now // #3295: 0 not rendered if given as a value
	                        x: x,
	                        y: y
	                    });
	
	                    if (box && defined(anchorX)) {
	                        wrapper.attr({
	                            anchorX: anchorX,
	                            anchorY: anchorY
	                        });
	                    }
	                };
	
	                /*
	                 * Add specific attribute setters.
	                 */
	
	                // only change local variables
	                wrapper.widthSetter = function(value) {
	                    width = H.isNumber(value) ? value : null; // width:auto => null
	                };
	                wrapper.heightSetter = function(value) {
	                    height = value;
	                };
	                wrapper['text-alignSetter'] = function(value) {
	                    textAlign = value;
	                };
	                wrapper.paddingSetter = function(value) {
	                    if (defined(value) && value !== padding) {
	                        padding = wrapper.padding = value;
	                        updateTextPadding();
	                    }
	                };
	                wrapper.paddingLeftSetter = function(value) {
	                    if (defined(value) && value !== paddingLeft) {
	                        paddingLeft = value;
	                        updateTextPadding();
	                    }
	                };
	
	
	                // change local variable and prevent setting attribute on the group
	                wrapper.alignSetter = function(value) {
	                    value = {
	                        left: 0,
	                        center: 0.5,
	                        right: 1
	                    }[value];
	                    if (value !== alignFactor) {
	                        alignFactor = value;
	                        if (bBox) { // Bounding box exists, means we're dynamically changing
	                            wrapper.attr({
	                                x: wrapperX
	                            }); // #5134
	                        }
	                    }
	                };
	
	                // apply these to the box and the text alike
	                wrapper.textSetter = function(value) {
	                    if (value !== undefined) {
	                        text.textSetter(value);
	                    }
	                    updateBoxSize();
	                    updateTextPadding();
	                };
	
	                // apply these to the box but not to the text
	                wrapper['stroke-widthSetter'] = function(value, key) {
	                    if (value) {
	                        needsBox = true;
	                    }
	                    strokeWidth = this['stroke-width'] = value;
	                    boxAttr(key, value);
	                };
	
	                wrapper.strokeSetter = wrapper.fillSetter = wrapper.rSetter = function(value, key) {
	                    if (key !== 'r') {
	                        if (key === 'fill' && value) {
	                            needsBox = true;
	                        }
	                        // for animation getter (#6776)
	                        wrapper[key] = value;
	                    }
	                    boxAttr(key, value);
	                };
	
	                wrapper.anchorXSetter = function(value, key) {
	                    anchorX = wrapper.anchorX = value;
	                    boxAttr(key, Math.round(value) - getCrispAdjust() - wrapperX);
	                };
	                wrapper.anchorYSetter = function(value, key) {
	                    anchorY = wrapper.anchorY = value;
	                    boxAttr(key, value - wrapperY);
	                };
	
	                // rename attributes
	                wrapper.xSetter = function(value) {
	                    wrapper.x = value; // for animation getter
	                    if (alignFactor) {
	                        value -= alignFactor * ((width || bBox.width) + 2 * padding);
	                    }
	                    wrapperX = Math.round(value);
	                    wrapper.attr('translateX', wrapperX);
	                };
	                wrapper.ySetter = function(value) {
	                    wrapperY = wrapper.y = Math.round(value);
	                    wrapper.attr('translateY', wrapperY);
	                };
	
	                // Redirect certain methods to either the box or the text
	                var baseCss = wrapper.css;
	                return extend(wrapper, {
	                    /**
	                     * Pick up some properties and apply them to the text instead of the
	                     * wrapper.
	                     * @ignore
	                     */
	                    css: function(styles) {
	                        if (styles) {
	                            var textStyles = {};
	                            styles = merge(styles); // create a copy to avoid altering the original object (#537)
	                            each(wrapper.textProps, function(prop) {
	                                if (styles[prop] !== undefined) {
	                                    textStyles[prop] = styles[prop];
	                                    delete styles[prop];
	                                }
	                            });
	                            text.css(textStyles);
	                        }
	                        return baseCss.call(wrapper, styles);
	                    },
	                    /**
	                     * Return the bounding box of the box, not the group.
	                     * @ignore
	                     */
	                    getBBox: function() {
	                        return {
	                            width: bBox.width + 2 * padding,
	                            height: bBox.height + 2 * padding,
	                            x: bBox.x - padding,
	                            y: bBox.y - padding
	                        };
	                    },
	
	                    /**
	                     * Apply the shadow to the box.
	                     * @ignore
	                     */
	                    shadow: function(b) {
	                        if (b) {
	                            updateBoxSize();
	                            if (box) {
	                                box.shadow(b);
	                            }
	                        }
	                        return wrapper;
	                    },
	
	                    /**
	                     * Destroy and release memory.
	                     * @ignore
	                     */
	                    destroy: function() {
	
	                        // Added by button implementation
	                        removeEvent(wrapper.element, 'mouseenter');
	                        removeEvent(wrapper.element, 'mouseleave');
	
	                        if (text) {
	                            text = text.destroy();
	                        }
	                        if (box) {
	                            box = box.destroy();
	                        }
	                        // Call base implementation to destroy the rest
	                        SVGElement.prototype.destroy.call(wrapper);
	
	                        // Release local pointers (#1298)
	                        wrapper = renderer = updateBoxSize = updateTextPadding = boxAttr = null;
	                    }
	                });
	            }
	        }); // end SVGRenderer
	
	
	        // general renderer
	        H.Renderer = SVGRenderer;
	
	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        /* eslint max-len: ["warn", 80, 4] */
	        var attr = H.attr,
	            createElement = H.createElement,
	            css = H.css,
	            defined = H.defined,
	            each = H.each,
	            extend = H.extend,
	            isFirefox = H.isFirefox,
	            isMS = H.isMS,
	            isWebKit = H.isWebKit,
	            pInt = H.pInt,
	            SVGElement = H.SVGElement,
	            SVGRenderer = H.SVGRenderer,
	            win = H.win,
	            wrap = H.wrap;
	
	        // Extend SvgElement for useHTML option
	        extend(SVGElement.prototype, /** @lends SVGElement.prototype */ {
	            /**
	             * Apply CSS to HTML elements. This is used in text within SVG rendering and
	             * by the VML renderer
	             */
	            htmlCss: function(styles) {
	                var wrapper = this,
	                    element = wrapper.element,
	                    textWidth = styles && element.tagName === 'SPAN' && styles.width;
	
	                if (textWidth) {
	                    delete styles.width;
	                    wrapper.textWidth = textWidth;
	                    wrapper.updateTransform();
	                }
	                if (styles && styles.textOverflow === 'ellipsis') {
	                    styles.whiteSpace = 'nowrap';
	                    styles.overflow = 'hidden';
	                }
	                wrapper.styles = extend(wrapper.styles, styles);
	                css(wrapper.element, styles);
	
	                return wrapper;
	            },
	
	            /**
	             * VML and useHTML method for calculating the bounding box based on offsets
	             * @param {Boolean} refresh Whether to force a fresh value from the DOM or
	             * to use the cached value.
	             *
	             * @return {Object} A hash containing values for x, y, width and height
	             */
	
	            htmlGetBBox: function() {
	                var wrapper = this,
	                    element = wrapper.element;
	
	                // faking getBBox in exported SVG in legacy IE (is this a duplicate of
	                // the fix for #1079?)
	                if (element.nodeName === 'text') {
	                    element.style.position = 'absolute';
	                }
	
	                return {
	                    x: element.offsetLeft,
	                    y: element.offsetTop,
	                    width: element.offsetWidth,
	                    height: element.offsetHeight
	                };
	            },
	
	            /**
	             * VML override private method to update elements based on internal
	             * properties based on SVG transform
	             */
	            htmlUpdateTransform: function() {
	                // aligning non added elements is expensive
	                if (!this.added) {
	                    this.alignOnAdd = true;
	                    return;
	                }
	
	                var wrapper = this,
	                    renderer = wrapper.renderer,
	                    elem = wrapper.element,
	                    translateX = wrapper.translateX || 0,
	                    translateY = wrapper.translateY || 0,
	                    x = wrapper.x || 0,
	                    y = wrapper.y || 0,
	                    align = wrapper.textAlign || 'left',
	                    alignCorrection = {
	                        left: 0,
	                        center: 0.5,
	                        right: 1
	                    }[align],
	                    styles = wrapper.styles;
	
	                // apply translate
	                css(elem, {
	                    marginLeft: translateX,
	                    marginTop: translateY
	                });
	
	
	                if (wrapper.shadows) { // used in labels/tooltip
	                    each(wrapper.shadows, function(shadow) {
	                        css(shadow, {
	                            marginLeft: translateX + 1,
	                            marginTop: translateY + 1
	                        });
	                    });
	                }
	
	
	                // apply inversion
	                if (wrapper.inverted) { // wrapper is a group
	                    each(elem.childNodes, function(child) {
	                        renderer.invertChild(child, elem);
	                    });
	                }
	
	                if (elem.tagName === 'SPAN') {
	
	                    var rotation = wrapper.rotation,
	                        baseline,
	                        textWidth = pInt(wrapper.textWidth),
	                        whiteSpace = styles && styles.whiteSpace,
	                        currentTextTransform = [
	                            rotation,
	                            align,
	                            elem.innerHTML,
	                            wrapper.textWidth,
	                            wrapper.textAlign
	                        ].join(',');
	
	                    // Do the calculations and DOM access only if properties changed
	                    if (currentTextTransform !== wrapper.cTT) {
	
	
	                        baseline = renderer.fontMetrics(elem.style.fontSize).b;
	
	                        // Renderer specific handling of span rotation
	                        if (defined(rotation)) {
	                            wrapper.setSpanRotation(
	                                rotation,
	                                alignCorrection,
	                                baseline
	                            );
	                        }
	
	                        // Reset multiline/ellipsis in order to read width (#4928,
	                        // #5417)
	                        css(elem, {
	                            width: '',
	                            whiteSpace: whiteSpace || 'nowrap'
	                        });
	
	                        // Update textWidth
	                        if (
	                            elem.offsetWidth > textWidth &&
	                            /[ \-]/.test(elem.textContent || elem.innerText)
	                        ) { // #983, #1254
	                            css(elem, {
	                                width: textWidth + 'px',
	                                display: 'block',
	                                whiteSpace: whiteSpace || 'normal' // #3331
	                            });
	                        }
	
	
	                        wrapper.getSpanCorrection(
	                            elem.offsetWidth,
	                            baseline,
	                            alignCorrection,
	                            rotation,
	                            align
	                        );
	                    }
	
	                    // apply position with correction
	                    css(elem, {
	                        left: (x + (wrapper.xCorr || 0)) + 'px',
	                        top: (y + (wrapper.yCorr || 0)) + 'px'
	                    });
	
	                    // Force reflow in webkit to apply the left and top on useHTML
	                    // element (#1249)
	                    if (isWebKit) {
	                        // Assigned to baseline for lint purpose
	                        baseline = elem.offsetHeight;
	                    }
	
	                    // record current text transform
	                    wrapper.cTT = currentTextTransform;
	                }
	            },
	
	            /**
	             * Set the rotation of an individual HTML span
	             */
	            setSpanRotation: function(rotation, alignCorrection, baseline) {
	                var rotationStyle = {},
	                    cssTransformKey =
	                    isMS ?
	                    '-ms-transform' :
	                    isWebKit ?
	                    '-webkit-transform' :
	                    isFirefox ?
	                    'MozTransform' :
	                    win.opera ?
	                    '-o-transform' :
	                    '';
	
	                rotationStyle[cssTransformKey] = rotationStyle.transform =
	                    'rotate(' + rotation + 'deg)';
	                rotationStyle[cssTransformKey + (isFirefox ? 'Origin' : '-origin')] =
	                    rotationStyle.transformOrigin =
	                    (alignCorrection * 100) + '% ' + baseline + 'px';
	                css(this.element, rotationStyle);
	            },
	
	            /**
	             * Get the correction in X and Y positioning as the element is rotated.
	             */
	            getSpanCorrection: function(width, baseline, alignCorrection) {
	                this.xCorr = -width * alignCorrection;
	                this.yCorr = -baseline;
	            }
	        });
	
	        // Extend SvgRenderer for useHTML option.
	        extend(SVGRenderer.prototype, /** @lends SVGRenderer.prototype */ {
	            /**
	             * Create HTML text node. This is used by the VML renderer as well as the
	             * SVG renderer through the useHTML option.
	             *
	             * @param {String} str
	             * @param {Number} x
	             * @param {Number} y
	             */
	            html: function(str, x, y) {
	                var wrapper = this.createElement('span'),
	                    element = wrapper.element,
	                    renderer = wrapper.renderer,
	                    isSVG = renderer.isSVG,
	                    addSetters = function(element, style) {
	                        // These properties are set as attributes on the SVG group, and
	                        // as identical CSS properties on the div. (#3542)
	                        each(['opacity', 'visibility'], function(prop) {
	                            wrap(element, prop + 'Setter', function(
	                                proceed,
	                                value,
	                                key,
	                                elem
	                            ) {
	                                proceed.call(this, value, key, elem);
	                                style[key] = value;
	                            });
	                        });
	                    };
	
	                // Text setter
	                wrapper.textSetter = function(value) {
	                    if (value !== element.innerHTML) {
	                        delete this.bBox;
	                    }
	                    element.innerHTML = this.textStr = value;
	                    wrapper.htmlUpdateTransform();
	                };
	
	                // Add setters for the element itself (#4938)
	                if (isSVG) { // #4938, only for HTML within SVG
	                    addSetters(wrapper, wrapper.element.style);
	                }
	
	                // Various setters which rely on update transform
	                wrapper.xSetter =
	                    wrapper.ySetter =
	                    wrapper.alignSetter =
	                    wrapper.rotationSetter =
	                    function(value, key) {
	                        if (key === 'align') {
	                            // Do not overwrite the SVGElement.align method. Same as VML.
	                            key = 'textAlign';
	                        }
	                        wrapper[key] = value;
	                        wrapper.htmlUpdateTransform();
	                    };
	
	                // Set the default attributes
	                wrapper
	                    .attr({
	                        text: str,
	                        x: Math.round(x),
	                        y: Math.round(y)
	                    })
	                    .css({
	
	                        fontFamily: this.style.fontFamily,
	                        fontSize: this.style.fontSize,
	
	                        position: 'absolute'
	                    });
	
	                // Keep the whiteSpace style outside the wrapper.styles collection
	                element.style.whiteSpace = 'nowrap';
	
	                // Use the HTML specific .css method
	                wrapper.css = wrapper.htmlCss;
	
	                // This is specific for HTML within SVG
	                if (isSVG) {
	                    wrapper.add = function(svgGroupWrapper) {
	
	                        var htmlGroup,
	                            container = renderer.box.parentNode,
	                            parentGroup,
	                            parents = [];
	
	                        this.parentGroup = svgGroupWrapper;
	
	                        // Create a mock group to hold the HTML elements
	                        if (svgGroupWrapper) {
	                            htmlGroup = svgGroupWrapper.div;
	                            if (!htmlGroup) {
	
	                                // Read the parent chain into an array and read from top
	                                // down
	                                parentGroup = svgGroupWrapper;
	                                while (parentGroup) {
	
	                                    parents.push(parentGroup);
	
	                                    // Move up to the next parent group
	                                    parentGroup = parentGroup.parentGroup;
	                                }
	
	                                // Ensure dynamically updating position when any parent
	                                // is translated
	                                each(parents.reverse(), function(parentGroup) {
	                                    var htmlGroupStyle,
	                                        cls = attr(parentGroup.element, 'class');
	
	                                    if (cls) {
	                                        cls = {
	                                            className: cls
	                                        };
	                                    } // else null
	
	                                    // Create a HTML div and append it to the parent div
	                                    // to emulate the SVG group structure
	                                    htmlGroup =
	                                        parentGroup.div =
	                                        parentGroup.div || createElement('div', cls, {
	                                            position: 'absolute',
	                                            left: (parentGroup.translateX || 0) + 'px',
	                                            top: (parentGroup.translateY || 0) + 'px',
	                                            display: parentGroup.display,
	                                            opacity: parentGroup.opacity, // #5075
	                                            pointerEvents: (
	                                                parentGroup.styles &&
	                                                parentGroup.styles.pointerEvents
	                                            ) // #5595
	
	                                            // the top group is appended to container
	                                        }, htmlGroup || container);
	
	                                    // Shortcut
	                                    htmlGroupStyle = htmlGroup.style;
	
	                                    // Set listeners to update the HTML div's position
	                                    // whenever the SVG group position is changed.
	                                    extend(parentGroup, {
	                                        classSetter: function(value) {
	                                            this.element.setAttribute('class', value);
	                                            htmlGroup.className = value;
	                                        },
	                                        on: function() {
	                                            if (parents[0].div) { // #6418
	                                                wrapper.on.apply({
	                                                        element: parents[0].div
	                                                    },
	                                                    arguments
	                                                );
	                                            }
	                                            return parentGroup;
	                                        },
	                                        translateXSetter: function(value, key) {
	                                            htmlGroupStyle.left = value + 'px';
	                                            parentGroup[key] = value;
	                                            parentGroup.doTransform = true;
	                                        },
	                                        translateYSetter: function(value, key) {
	                                            htmlGroupStyle.top = value + 'px';
	                                            parentGroup[key] = value;
	                                            parentGroup.doTransform = true;
	                                        }
	                                    });
	                                    addSetters(parentGroup, htmlGroupStyle);
	                                });
	
	                            }
	                        } else {
	                            htmlGroup = container;
	                        }
	
	                        htmlGroup.appendChild(element);
	
	                        // Shared with VML:
	                        wrapper.added = true;
	                        if (wrapper.alignOnAdd) {
	                            wrapper.htmlUpdateTransform();
	                        }
	
	                        return wrapper;
	                    };
	                }
	                return wrapper;
	            }
	        });
	
	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	
	        var VMLRenderer,
	            VMLRendererExtension,
	            VMLElement,
	
	            createElement = H.createElement,
	            css = H.css,
	            defined = H.defined,
	            deg2rad = H.deg2rad,
	            discardElement = H.discardElement,
	            doc = H.doc,
	            each = H.each,
	            erase = H.erase,
	            extend = H.extend,
	            extendClass = H.extendClass,
	            isArray = H.isArray,
	            isNumber = H.isNumber,
	            isObject = H.isObject,
	            merge = H.merge,
	            noop = H.noop,
	            pick = H.pick,
	            pInt = H.pInt,
	            svg = H.svg,
	            SVGElement = H.SVGElement,
	            SVGRenderer = H.SVGRenderer,
	            win = H.win;
	
	        /* ****************************************************************************
	         *                                                                            *
	         * START OF INTERNET EXPLORER <= 8 SPECIFIC CODE                              *
	         *                                                                            *
	         * For applications and websites that don't need IE support, like platform    *
	         * targeted mobile apps and web apps, this code can be removed.               *
	         *                                                                            *
	         *****************************************************************************/
	
	        /**
	         * @constructor
	         */
	        if (!svg) {
	
	            /**
	             * The VML element wrapper.
	             */
	            VMLElement = {
	
	                docMode8: doc && doc.documentMode === 8,
	
	                /**
	                 * Initialize a new VML element wrapper. It builds the markup as a string
	                 * to minimize DOM traffic.
	                 * @param {Object} renderer
	                 * @param {Object} nodeName
	                 */
	                init: function(renderer, nodeName) {
	                    var wrapper = this,
	                        markup = ['<', nodeName, ' filled="f" stroked="f"'],
	                        style = ['position: ', 'absolute', ';'],
	                        isDiv = nodeName === 'div';
	
	                    // divs and shapes need size
	                    if (nodeName === 'shape' || isDiv) {
	                        style.push('left:0;top:0;width:1px;height:1px;');
	                    }
	                    style.push('visibility: ', isDiv ? 'hidden' : 'visible');
	
	                    markup.push(' style="', style.join(''), '"/>');
	
	                    // create element with default attributes and style
	                    if (nodeName) {
	                        markup = isDiv || nodeName === 'span' || nodeName === 'img' ?
	                            markup.join('') :
	                            renderer.prepVML(markup);
	                        wrapper.element = createElement(markup);
	                    }
	
	                    wrapper.renderer = renderer;
	                },
	
	                /**
	                 * Add the node to the given parent
	                 * @param {Object} parent
	                 */
	                add: function(parent) {
	                    var wrapper = this,
	                        renderer = wrapper.renderer,
	                        element = wrapper.element,
	                        box = renderer.box,
	                        inverted = parent && parent.inverted,
	
	                        // get the parent node
	                        parentNode = parent ?
	                        parent.element || parent :
	                        box;
	
	                    if (parent) {
	                        this.parentGroup = parent;
	                    }
	
	                    // if the parent group is inverted, apply inversion on all children
	                    if (inverted) { // only on groups
	                        renderer.invertChild(element, parentNode);
	                    }
	
	                    // append it
	                    parentNode.appendChild(element);
	
	                    // align text after adding to be able to read offset
	                    wrapper.added = true;
	                    if (wrapper.alignOnAdd && !wrapper.deferUpdateTransform) {
	                        wrapper.updateTransform();
	                    }
	
	                    // fire an event for internal hooks
	                    if (wrapper.onAdd) {
	                        wrapper.onAdd();
	                    }
	
	                    // IE8 Standards can't set the class name before the element is appended
	                    if (this.className) {
	                        this.attr('class', this.className);
	                    }
	
	                    return wrapper;
	                },
	
	                /**
	                 * VML always uses htmlUpdateTransform
	                 */
	                updateTransform: SVGElement.prototype.htmlUpdateTransform,
	
	                /**
	                 * Set the rotation of a span with oldIE's filter
	                 */
	                setSpanRotation: function() {
	                    // Adjust for alignment and rotation. Rotation of useHTML content is not yet implemented
	                    // but it can probably be implemented for Firefox 3.5+ on user request. FF3.5+
	                    // has support for CSS3 transform. The getBBox method also needs to be updated
	                    // to compensate for the rotation, like it currently does for SVG.
	                    // Test case: http://jsfiddle.net/highcharts/Ybt44/
	
	                    var rotation = this.rotation,
	                        costheta = Math.cos(rotation * deg2rad),
	                        sintheta = Math.sin(rotation * deg2rad);
	
	                    css(this.element, {
	                        filter: rotation ? ['progid:DXImageTransform.Microsoft.Matrix(M11=', costheta,
	                            ', M12=', -sintheta, ', M21=', sintheta, ', M22=', costheta,
	                            ', sizingMethod=\'auto expand\')'
	                        ].join('') : 'none'
	                    });
	                },
	
	                /**
	                 * Get the positioning correction for the span after rotating.
	                 */
	                getSpanCorrection: function(width, baseline, alignCorrection, rotation, align) {
	
	                    var costheta = rotation ? Math.cos(rotation * deg2rad) : 1,
	                        sintheta = rotation ? Math.sin(rotation * deg2rad) : 0,
	                        height = pick(this.elemHeight, this.element.offsetHeight),
	                        quad,
	                        nonLeft = align && align !== 'left';
	
	                    // correct x and y
	                    this.xCorr = costheta < 0 && -width;
	                    this.yCorr = sintheta < 0 && -height;
	
	                    // correct for baseline and corners spilling out after rotation
	                    quad = costheta * sintheta < 0;
	                    this.xCorr += sintheta * baseline * (quad ? 1 - alignCorrection : alignCorrection);
	                    this.yCorr -= costheta * baseline * (rotation ? (quad ? alignCorrection : 1 - alignCorrection) : 1);
	                    // correct for the length/height of the text
	                    if (nonLeft) {
	                        this.xCorr -= width * alignCorrection * (costheta < 0 ? -1 : 1);
	                        if (rotation) {
	                            this.yCorr -= height * alignCorrection * (sintheta < 0 ? -1 : 1);
	                        }
	                        css(this.element, {
	                            textAlign: align
	                        });
	                    }
	                },
	
	                /**
	                 * Converts a subset of an SVG path definition to its VML counterpart. Takes an array
	                 * as the parameter and returns a string.
	                 */
	                pathToVML: function(value) {
	                    // convert paths
	                    var i = value.length,
	                        path = [];
	
	                    while (i--) {
	
	                        // Multiply by 10 to allow subpixel precision.
	                        // Substracting half a pixel seems to make the coordinates
	                        // align with SVG, but this hasn't been tested thoroughly
	                        if (isNumber(value[i])) {
	                            path[i] = Math.round(value[i] * 10) - 5;
	                        } else if (value[i] === 'Z') { // close the path
	                            path[i] = 'x';
	                        } else {
	                            path[i] = value[i];
	
	                            // When the start X and end X coordinates of an arc are too close,
	                            // they are rounded to the same value above. In this case, substract or
	                            // add 1 from the end X and Y positions. #186, #760, #1371, #1410.
	                            if (value.isArc && (value[i] === 'wa' || value[i] === 'at')) {
	                                // Start and end X
	                                if (path[i + 5] === path[i + 7]) {
	                                    path[i + 7] += value[i + 7] > value[i + 5] ? 1 : -1;
	                                }
	                                // Start and end Y
	                                if (path[i + 6] === path[i + 8]) {
	                                    path[i + 8] += value[i + 8] > value[i + 6] ? 1 : -1;
	                                }
	                            }
	                        }
	                    }
	
	
	                    // Loop up again to handle path shortcuts (#2132)
	                    /*while (i++ < path.length) {
	                    	if (path[i] === 'H') { // horizontal line to
	                    		path[i] = 'L';
	                    		path.splice(i + 2, 0, path[i - 1]);
	                    	} else if (path[i] === 'V') { // vertical line to
	                    		path[i] = 'L';
	                    		path.splice(i + 1, 0, path[i - 2]);
	                    	}
	                    }*/
	                    return path.join(' ') || 'x';
	                },
	
	                /**
	                 * Set the element's clipping to a predefined rectangle
	                 *
	                 * @param {String} id The id of the clip rectangle
	                 */
	                clip: function(clipRect) {
	                    var wrapper = this,
	                        clipMembers,
	                        cssRet;
	
	                    if (clipRect) {
	                        clipMembers = clipRect.members;
	                        erase(clipMembers, wrapper); // Ensure unique list of elements (#1258)
	                        clipMembers.push(wrapper);
	                        wrapper.destroyClip = function() {
	                            erase(clipMembers, wrapper);
	                        };
	                        cssRet = clipRect.getCSS(wrapper);
	
	                    } else {
	                        if (wrapper.destroyClip) {
	                            wrapper.destroyClip();
	                        }
	                        cssRet = {
	                            clip: wrapper.docMode8 ? 'inherit' : 'rect(auto)'
	                        }; // #1214
	                    }
	
	                    return wrapper.css(cssRet);
	
	                },
	
	                /**
	                 * Set styles for the element
	                 * @param {Object} styles
	                 */
	                css: SVGElement.prototype.htmlCss,
	
	                /**
	                 * Removes a child either by removeChild or move to garbageBin.
	                 * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.
	                 */
	                safeRemoveChild: function(element) {
	                    // discardElement will detach the node from its parent before attaching it
	                    // to the garbage bin. Therefore it is important that the node is attached and have parent.
	                    if (element.parentNode) {
	                        discardElement(element);
	                    }
	                },
	
	                /**
	                 * Extend element.destroy by removing it from the clip members array
	                 */
	                destroy: function() {
	                    if (this.destroyClip) {
	                        this.destroyClip();
	                    }
	
	                    return SVGElement.prototype.destroy.apply(this);
	                },
	
	                /**
	                 * Add an event listener. VML override for normalizing event parameters.
	                 * @param {String} eventType
	                 * @param {Function} handler
	                 */
	                on: function(eventType, handler) {
	                    // simplest possible event model for internal use
	                    this.element['on' + eventType] = function() {
	                        var evt = win.event;
	                        evt.target = evt.srcElement;
	                        handler(evt);
	                    };
	                    return this;
	                },
	
	                /**
	                 * In stacked columns, cut off the shadows so that they don't overlap
	                 */
	                cutOffPath: function(path, length) {
	
	                    var len;
	
	                    path = path.split(/[ ,]/); // The extra comma tricks the trailing comma remover in "gulp scripts" task
	                    len = path.length;
	
	                    if (len === 9 || len === 11) {
	                        path[len - 4] = path[len - 2] = pInt(path[len - 2]) - 10 * length;
	                    }
	                    return path.join(' ');
	                },
	
	                /**
	                 * Apply a drop shadow by copying elements and giving them different strokes
	                 * @param {Boolean|Object} shadowOptions
	                 */
	                shadow: function(shadowOptions, group, cutOff) {
	                    var shadows = [],
	                        i,
	                        element = this.element,
	                        renderer = this.renderer,
	                        shadow,
	                        elemStyle = element.style,
	                        markup,
	                        path = element.path,
	                        strokeWidth,
	                        modifiedPath,
	                        shadowWidth,
	                        shadowElementOpacity;
	
	                    // some times empty paths are not strings
	                    if (path && typeof path.value !== 'string') {
	                        path = 'x';
	                    }
	                    modifiedPath = path;
	
	                    if (shadowOptions) {
	                        shadowWidth = pick(shadowOptions.width, 3);
	                        shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;
	                        for (i = 1; i <= 3; i++) {
	
	                            strokeWidth = (shadowWidth * 2) + 1 - (2 * i);
	
	                            // Cut off shadows for stacked column items
	                            if (cutOff) {
	                                modifiedPath = this.cutOffPath(path.value, strokeWidth + 0.5);
	                            }
	
	                            markup = ['<shape isShadow="true" strokeweight="', strokeWidth,
	                                '" filled="false" path="', modifiedPath,
	                                '" coordsize="10 10" style="', element.style.cssText, '" />'
	                            ];
	
	                            shadow = createElement(renderer.prepVML(markup),
	                                null, {
	                                    left: pInt(elemStyle.left) + pick(shadowOptions.offsetX, 1),
	                                    top: pInt(elemStyle.top) + pick(shadowOptions.offsetY, 1)
	                                }
	                            );
	                            if (cutOff) {
	                                shadow.cutOff = strokeWidth + 1;
	                            }
	
	                            // apply the opacity
	                            markup = [
	                                '<stroke color="',
	                                shadowOptions.color || '#000000',
	                                '" opacity="', shadowElementOpacity * i, '"/>'
	                            ];
	                            createElement(renderer.prepVML(markup), null, null, shadow);
	
	
	                            // insert it
	                            if (group) {
	                                group.element.appendChild(shadow);
	                            } else {
	                                element.parentNode.insertBefore(shadow, element);
	                            }
	
	                            // record it
	                            shadows.push(shadow);
	
	                        }
	
	                        this.shadows = shadows;
	                    }
	                    return this;
	                },
	                updateShadows: noop, // Used in SVG only
	
	                setAttr: function(key, value) {
	                    if (this.docMode8) { // IE8 setAttribute bug
	                        this.element[key] = value;
	                    } else {
	                        this.element.setAttribute(key, value);
	                    }
	                },
	                classSetter: function(value) {
	                    // IE8 Standards mode has problems retrieving the className unless set like this.
	                    // IE8 Standards can't set the class name before the element is appended.
	                    (this.added ? this.element : this).className = value;
	                },
	                dashstyleSetter: function(value, key, element) {
	                    var strokeElem = element.getElementsByTagName('stroke')[0] ||
	                        createElement(this.renderer.prepVML(['<stroke/>']), null, null, element);
	                    strokeElem[key] = value || 'solid';
	                    this[key] = value;
	                    /* because changing stroke-width will change the dash length
					and cause an epileptic effect */
	                },
	                dSetter: function(value, key, element) {
	                    var i,
	                        shadows = this.shadows;
	                    value = value || [];
	                    this.d = value.join && value.join(' '); // used in getter for animation
	
	                    element.path = value = this.pathToVML(value);
	
	                    // update shadows
	                    if (shadows) {
	                        i = shadows.length;
	                        while (i--) {
	                            shadows[i].path = shadows[i].cutOff ? this.cutOffPath(value, shadows[i].cutOff) : value;
	                        }
	                    }
	                    this.setAttr(key, value);
	                },
	                fillSetter: function(value, key, element) {
	                    var nodeName = element.nodeName;
	                    if (nodeName === 'SPAN') { // text color
	                        element.style.color = value;
	                    } else if (nodeName !== 'IMG') { // #1336
	                        element.filled = value !== 'none';
	                        this.setAttr('fillcolor', this.renderer.color(value, element, key, this));
	                    }
	                },
	                'fill-opacitySetter': function(value, key, element) {
	                    createElement(
	                        this.renderer.prepVML(['<', key.split('-')[0], ' opacity="', value, '"/>']),
	                        null,
	                        null,
	                        element
	                    );
	                },
	                opacitySetter: noop, // Don't bother - animation is too slow and filters introduce artifacts
	                rotationSetter: function(value, key, element) {
	                    var style = element.style;
	                    this[key] = style[key] = value; // style is for #1873
	
	                    // Correction for the 1x1 size of the shape container. Used in gauge needles.
	                    style.left = -Math.round(Math.sin(value * deg2rad) + 1) + 'px';
	                    style.top = Math.round(Math.cos(value * deg2rad)) + 'px';
	                },
	                strokeSetter: function(value, key, element) {
	                    this.setAttr('strokecolor', this.renderer.color(value, element, key, this));
	                },
	                'stroke-widthSetter': function(value, key, element) {
	                    element.stroked = !!value; // VML "stroked" attribute
	                    this[key] = value; // used in getter, issue #113
	                    if (isNumber(value)) {
	                        value += 'px';
	                    }
	                    this.setAttr('strokeweight', value);
	                },
	                titleSetter: function(value, key) {
	                    this.setAttr(key, value);
	                },
	                visibilitySetter: function(value, key, element) {
	
	                    // Handle inherited visibility
	                    if (value === 'inherit') {
	                        value = 'visible';
	                    }
	
	                    // Let the shadow follow the main element
	                    if (this.shadows) {
	                        each(this.shadows, function(shadow) {
	                            shadow.style[key] = value;
	                        });
	                    }
	
	                    // Instead of toggling the visibility CSS property, move the div out of the viewport.
	                    // This works around #61 and #586
	                    if (element.nodeName === 'DIV') {
	                        value = value === 'hidden' ? '-999em' : 0;
	
	                        // In order to redraw, IE7 needs the div to be visible when tucked away
	                        // outside the viewport. So the visibility is actually opposite of
	                        // the expected value. This applies to the tooltip only.
	                        if (!this.docMode8) {
	                            element.style[key] = value ? 'visible' : 'hidden';
	                        }
	                        key = 'top';
	                    }
	                    element.style[key] = value;
	                },
	                xSetter: function(value, key, element) {
	                    this[key] = value; // used in getter
	
	                    if (key === 'x') {
	                        key = 'left';
	                    } else if (key === 'y') {
	                        key = 'top';
	                    }
	                    /* else {
	                    				value = Math.max(0, value); // don't set width or height below zero (#311)
	                    			}*/
	
	                    // clipping rectangle special
	                    if (this.updateClipping) {
	                        this[key] = value; // the key is now 'left' or 'top' for 'x' and 'y'
	                        this.updateClipping();
	                    } else {
	                        // normal
	                        element.style[key] = value;
	                    }
	                },
	                zIndexSetter: function(value, key, element) {
	                    element.style[key] = value;
	                }
	            };
	            VMLElement['stroke-opacitySetter'] = VMLElement['fill-opacitySetter'];
	            H.VMLElement = VMLElement = extendClass(SVGElement, VMLElement);
	
	            // Some shared setters
	            VMLElement.prototype.ySetter =
	                VMLElement.prototype.widthSetter =
	                VMLElement.prototype.heightSetter =
	                VMLElement.prototype.xSetter;
	
	
	            /**
	             * The VML renderer
	             */
	            VMLRendererExtension = { // inherit SVGRenderer
	
	                Element: VMLElement,
	                isIE8: win.navigator.userAgent.indexOf('MSIE 8.0') > -1,
	
	
	                /**
	                 * Initialize the VMLRenderer
	                 * @param {Object} container
	                 * @param {Number} width
	                 * @param {Number} height
	                 */
	                init: function(container, width, height) {
	                    var renderer = this,
	                        boxWrapper,
	                        box,
	                        css;
	
	                    renderer.alignedObjects = [];
	
	                    boxWrapper = renderer.createElement('div')
	                        .css({
	                            position: 'relative'
	                        });
	                    box = boxWrapper.element;
	                    container.appendChild(boxWrapper.element);
	
	
	                    // generate the containing box
	                    renderer.isVML = true;
	                    renderer.box = box;
	                    renderer.boxWrapper = boxWrapper;
	                    renderer.gradients = {};
	                    renderer.cache = {}; // Cache for numerical bounding boxes
	                    renderer.cacheKeys = [];
	                    renderer.imgCount = 0;
	
	
	                    renderer.setSize(width, height, false);
	
	                    // The only way to make IE6 and IE7 print is to use a global namespace. However,
	                    // with IE8 the only way to make the dynamic shapes visible in screen and print mode
	                    // seems to be to add the xmlns attribute and the behaviour style inline.
	                    if (!doc.namespaces.hcv) {
	
	                        doc.namespaces.add('hcv', 'urn:schemas-microsoft-com:vml');
	
	                        // Setup default CSS (#2153, #2368, #2384)
	                        css = 'hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke' +
	                            '{ behavior:url(#default#VML); display: inline-block; } ';
	                        try {
	                            doc.createStyleSheet().cssText = css;
	                        } catch (e) {
	                            doc.styleSheets[0].cssText += css;
	                        }
	
	                    }
	                },
	
	
	                /**
	                 * Detect whether the renderer is hidden. This happens when one of the parent elements
	                 * has display: none
	                 */
	                isHidden: function() {
	                    return !this.box.offsetWidth;
	                },
	
	                /**
	                 * Define a clipping rectangle. In VML it is accomplished by storing the values
	                 * for setting the CSS style to all associated members.
	                 *
	                 * @param {Number} x
	                 * @param {Number} y
	                 * @param {Number} width
	                 * @param {Number} height
	                 */
	                clipRect: function(x, y, width, height) {
	
	                    // create a dummy element
	                    var clipRect = this.createElement(),
	                        isObj = isObject(x);
	
	                    // mimic a rectangle with its style object for automatic updating in attr
	                    return extend(clipRect, {
	                        members: [],
	                        count: 0,
	                        left: (isObj ? x.x : x) + 1,
	                        top: (isObj ? x.y : y) + 1,
	                        width: (isObj ? x.width : width) - 1,
	                        height: (isObj ? x.height : height) - 1,
	                        getCSS: function(wrapper) {
	                            var element = wrapper.element,
	                                nodeName = element.nodeName,
	                                isShape = nodeName === 'shape',
	                                inverted = wrapper.inverted,
	                                rect = this,
	                                top = rect.top - (isShape ? element.offsetTop : 0),
	                                left = rect.left,
	                                right = left + rect.width,
	                                bottom = top + rect.height,
	                                ret = {
	                                    clip: 'rect(' +
	                                        Math.round(inverted ? left : top) + 'px,' +
	                                        Math.round(inverted ? bottom : right) + 'px,' +
	                                        Math.round(inverted ? right : bottom) + 'px,' +
	                                        Math.round(inverted ? top : left) + 'px)'
	                                };
	
	                            // issue 74 workaround
	                            if (!inverted && wrapper.docMode8 && nodeName === 'DIV') {
	                                extend(ret, {
	                                    width: right + 'px',
	                                    height: bottom + 'px'
	                                });
	                            }
	                            return ret;
	                        },
	
	                        // used in attr and animation to update the clipping of all members
	                        updateClipping: function() {
	                            each(clipRect.members, function(member) {
	                                // Member.element is falsy on deleted series, like in
	                                // stock/members/series-remove demo. Should be removed
	                                // from members, but this will do.
	                                if (member.element) {
	                                    member.css(clipRect.getCSS(member));
	                                }
	                            });
	                        }
	                    });
	
	                },
	
	
	                /**
	                 * Take a color and return it if it's a string, make it a gradient if it's a
	                 * gradient configuration object, and apply opacity.
	                 *
	                 * @param {Object} color The color or config object
	                 */
	                color: function(color, elem, prop, wrapper) {
	                    var renderer = this,
	                        colorObject,
	                        regexRgba = /^rgba/,
	                        markup,
	                        fillType,
	                        ret = 'none';
	
	                    // Check for linear or radial gradient
	                    if (color && color.linearGradient) {
	                        fillType = 'gradient';
	                    } else if (color && color.radialGradient) {
	                        fillType = 'pattern';
	                    }
	
	
	                    if (fillType) {
	
	                        var stopColor,
	                            stopOpacity,
	                            gradient = color.linearGradient || color.radialGradient,
	                            x1,
	                            y1,
	                            x2,
	                            y2,
	                            opacity1,
	                            opacity2,
	                            color1,
	                            color2,
	                            fillAttr = '',
	                            stops = color.stops,
	                            firstStop,
	                            lastStop,
	                            colors = [],
	                            addFillNode = function() {
	                                // Add the fill subnode. When colors attribute is used, the meanings of opacity and o:opacity2
	                                // are reversed.
	                                markup = ['<fill colors="' + colors.join(',') +
	                                    '" opacity="', opacity2, '" o:opacity2="',
	                                    opacity1, '" type="', fillType, '" ', fillAttr,
	                                    'focus="100%" method="any" />'
	                                ];
	                                createElement(renderer.prepVML(markup), null, null, elem);
	                            };
	
	                        // Extend from 0 to 1
	                        firstStop = stops[0];
	                        lastStop = stops[stops.length - 1];
	                        if (firstStop[0] > 0) {
	                            stops.unshift([
	                                0,
	                                firstStop[1]
	                            ]);
	                        }
	                        if (lastStop[0] < 1) {
	                            stops.push([
	                                1,
	                                lastStop[1]
	                            ]);
	                        }
	
	                        // Compute the stops
	                        each(stops, function(stop, i) {
	                            if (regexRgba.test(stop[1])) {
	                                colorObject = H.color(stop[1]);
	                                stopColor = colorObject.get('rgb');
	                                stopOpacity = colorObject.get('a');
	                            } else {
	                                stopColor = stop[1];
	                                stopOpacity = 1;
	                            }
	
	                            // Build the color attribute
	                            colors.push((stop[0] * 100) + '% ' + stopColor);
	
	                            // Only start and end opacities are allowed, so we use the first and the last
	                            if (!i) {
	                                opacity1 = stopOpacity;
	                                color2 = stopColor;
	                            } else {
	                                opacity2 = stopOpacity;
	                                color1 = stopColor;
	                            }
	                        });
	
	                        // Apply the gradient to fills only.
	                        if (prop === 'fill') {
	
	                            // Handle linear gradient angle
	                            if (fillType === 'gradient') {
	                                x1 = gradient.x1 || gradient[0] || 0;
	                                y1 = gradient.y1 || gradient[1] || 0;
	                                x2 = gradient.x2 || gradient[2] || 0;
	                                y2 = gradient.y2 || gradient[3] || 0;
	                                fillAttr = 'angle="' + (90 - Math.atan(
	                                    (y2 - y1) / // y vector
	                                    (x2 - x1) // x vector
	                                ) * 180 / Math.PI) + '"';
	
	                                addFillNode();
	
	                                // Radial (circular) gradient
	                            } else {
	
	                                var r = gradient.r,
	                                    sizex = r * 2,
	                                    sizey = r * 2,
	                                    cx = gradient.cx,
	                                    cy = gradient.cy,
	                                    radialReference = elem.radialReference,
	                                    bBox,
	                                    applyRadialGradient = function() {
	                                        if (radialReference) {
	                                            bBox = wrapper.getBBox();
	                                            cx += (radialReference[0] - bBox.x) / bBox.width - 0.5;
	                                            cy += (radialReference[1] - bBox.y) / bBox.height - 0.5;
	                                            sizex *= radialReference[2] / bBox.width;
	                                            sizey *= radialReference[2] / bBox.height;
	                                        }
	                                        fillAttr = 'src="' + H.getOptions().global.VMLRadialGradientURL + '" ' +
	                                            'size="' + sizex + ',' + sizey + '" ' +
	                                            'origin="0.5,0.5" ' +
	                                            'position="' + cx + ',' + cy + '" ' +
	                                            'color2="' + color2 + '" ';
	
	                                        addFillNode();
	                                    };
	
	                                // Apply radial gradient
	                                if (wrapper.added) {
	                                    applyRadialGradient();
	                                } else {
	                                    // We need to know the bounding box to get the size and position right
	                                    wrapper.onAdd = applyRadialGradient;
	                                }
	
	                                // The fill element's color attribute is broken in IE8 standards mode, so we
	                                // need to set the parent shape's fillcolor attribute instead.
	                                ret = color1;
	                            }
	
	                            // Gradients are not supported for VML stroke, return the first color. #722.
	                        } else {
	                            ret = stopColor;
	                        }
	
	                        // If the color is an rgba color, split it and add a fill node
	                        // to hold the opacity component
	                    } else if (regexRgba.test(color) && elem.tagName !== 'IMG') {
	
	                        colorObject = H.color(color);
	
	                        wrapper[prop + '-opacitySetter'](colorObject.get('a'), prop, elem);
	
	                        ret = colorObject.get('rgb');
	
	
	                    } else {
	                        var propNodes = elem.getElementsByTagName(prop); // 'stroke' or 'fill' node
	                        if (propNodes.length) {
	                            propNodes[0].opacity = 1;
	                            propNodes[0].type = 'solid';
	                        }
	                        ret = color;
	                    }
	
	                    return ret;
	                },
	
	                /**
	                 * Take a VML string and prepare it for either IE8 or IE6/IE7.
	                 * @param {Array} markup A string array of the VML markup to prepare
	                 */
	                prepVML: function(markup) {
	                    var vmlStyle = 'display:inline-block;behavior:url(#default#VML);',
	                        isIE8 = this.isIE8;
	
	                    markup = markup.join('');
	
	                    if (isIE8) { // add xmlns and style inline
	                        markup = markup.replace('/>', ' xmlns="urn:schemas-microsoft-com:vml" />');
	                        if (markup.indexOf('style="') === -1) {
	                            markup = markup.replace('/>', ' style="' + vmlStyle + '" />');
	                        } else {
	                            markup = markup.replace('style="', 'style="' + vmlStyle);
	                        }
	
	                    } else { // add namespace
	                        markup = markup.replace('<', '<hcv:');
	                    }
	
	                    return markup;
	                },
	
	                /**
	                 * Create rotated and aligned text
	                 * @param {String} str
	                 * @param {Number} x
	                 * @param {Number} y
	                 */
	                text: SVGRenderer.prototype.html,
	
	                /**
	                 * Create and return a path element
	                 * @param {Array} path
	                 */
	                path: function(path) {
	                    var attr = {
	                        // subpixel precision down to 0.1 (width and height = 1px)
	                        coordsize: '10 10'
	                    };
	                    if (isArray(path)) {
	                        attr.d = path;
	                    } else if (isObject(path)) { // attributes
	                        extend(attr, path);
	                    }
	                    // create the shape
	                    return this.createElement('shape').attr(attr);
	                },
	
	                /**
	                 * Create and return a circle element. In VML circles are implemented as
	                 * shapes, which is faster than v:oval
	                 * @param {Number} x
	                 * @param {Number} y
	                 * @param {Number} r
	                 */
	                circle: function(x, y, r) {
	                    var circle = this.symbol('circle');
	                    if (isObject(x)) {
	                        r = x.r;
	                        y = x.y;
	                        x = x.x;
	                    }
	                    circle.isCircle = true; // Causes x and y to mean center (#1682)
	                    circle.r = r;
	                    return circle.attr({
	                        x: x,
	                        y: y
	                    });
	                },
	
	                /**
	                 * Create a group using an outer div and an inner v:group to allow rotating
	                 * and flipping. A simple v:group would have problems with positioning
	                 * child HTML elements and CSS clip.
	                 *
	                 * @param {String} name The name of the group
	                 */
	                g: function(name) {
	                    var wrapper,
	                        attribs;
	
	                    // set the class name
	                    if (name) {
	                        attribs = {
	                            'className': 'highcharts-' + name,
	                            'class': 'highcharts-' + name
	                        };
	                    }
	
	                    // the div to hold HTML and clipping
	                    wrapper = this.createElement('div').attr(attribs);
	
	                    return wrapper;
	                },
	
	                /**
	                 * VML override to create a regular HTML image
	                 * @param {String} src
	                 * @param {Number} x
	                 * @param {Number} y
	                 * @param {Number} width
	                 * @param {Number} height
	                 */
	                image: function(src, x, y, width, height) {
	                    var obj = this.createElement('img')
	                        .attr({
	                            src: src
	                        });
	
	                    if (arguments.length > 1) {
	                        obj.attr({
	                            x: x,
	                            y: y,
	                            width: width,
	                            height: height
	                        });
	                    }
	                    return obj;
	                },
	
	                /**
	                 * For rectangles, VML uses a shape for rect to overcome bugs and rotation problems
	                 */
	                createElement: function(nodeName) {
	                    return nodeName === 'rect' ?
	                        this.symbol(nodeName) :
	                        SVGRenderer.prototype.createElement.call(this, nodeName);
	                },
	
	                /**
	                 * In the VML renderer, each child of an inverted div (group) is inverted
	                 * @param {Object} element
	                 * @param {Object} parentNode
	                 */
	                invertChild: function(element, parentNode) {
	                    var ren = this,
	                        parentStyle = parentNode.style,
	                        imgStyle = element.tagName === 'IMG' && element.style; // #1111
	
	                    css(element, {
	                        flip: 'x',
	                        left: pInt(parentStyle.width) - (imgStyle ? pInt(imgStyle.top) : 1),
	                        top: pInt(parentStyle.height) - (imgStyle ? pInt(imgStyle.left) : 1),
	                        rotation: -90
	                    });
	
	                    // Recursively invert child elements, needed for nested composite
	                    // shapes like box plots and error bars. #1680, #1806.
	                    each(element.childNodes, function(child) {
	                        ren.invertChild(child, element);
	                    });
	                },
	
	                /**
	                 * Symbol definitions that override the parent SVG renderer's symbols
	                 *
	                 */
	                symbols: {
	                    // VML specific arc function
	                    arc: function(x, y, w, h, options) {
	                        var start = options.start,
	                            end = options.end,
	                            radius = options.r || w || h,
	                            innerRadius = options.innerR,
	                            cosStart = Math.cos(start),
	                            sinStart = Math.sin(start),
	                            cosEnd = Math.cos(end),
	                            sinEnd = Math.sin(end),
	                            ret;
	
	                        if (end - start === 0) { // no angle, don't show it.
	                            return ['x'];
	                        }
	
	                        ret = [
	                            'wa', // clockwise arc to
	                            x - radius, // left
	                            y - radius, // top
	                            x + radius, // right
	                            y + radius, // bottom
	                            x + radius * cosStart, // start x
	                            y + radius * sinStart, // start y
	                            x + radius * cosEnd, // end x
	                            y + radius * sinEnd // end y
	                        ];
	
	                        if (options.open && !innerRadius) {
	                            ret.push(
	                                'e',
	                                'M',
	                                x, // - innerRadius,
	                                y // - innerRadius
	                            );
	                        }
	
	                        ret.push(
	                            'at', // anti clockwise arc to
	                            x - innerRadius, // left
	                            y - innerRadius, // top
	                            x + innerRadius, // right
	                            y + innerRadius, // bottom
	                            x + innerRadius * cosEnd, // start x
	                            y + innerRadius * sinEnd, // start y
	                            x + innerRadius * cosStart, // end x
	                            y + innerRadius * sinStart, // end y
	                            'x', // finish path
	                            'e' // close
	                        );
	
	                        ret.isArc = true;
	                        return ret;
	
	                    },
	                    // Add circle symbol path. This performs significantly faster than v:oval.
	                    circle: function(x, y, w, h, wrapper) {
	
	                        if (wrapper && defined(wrapper.r)) {
	                            w = h = 2 * wrapper.r;
	                        }
	
	                        // Center correction, #1682
	                        if (wrapper && wrapper.isCircle) {
	                            x -= w / 2;
	                            y -= h / 2;
	                        }
	
	                        // Return the path
	                        return [
	                            'wa', // clockwisearcto
	                            x, // left
	                            y, // top
	                            x + w, // right
	                            y + h, // bottom
	                            x + w, // start x
	                            y + h / 2, // start y
	                            x + w, // end x
	                            y + h / 2, // end y
	                            //'x', // finish path
	                            'e' // close
	                        ];
	                    },
	                    /**
	                     * Add rectangle symbol path which eases rotation and omits arcsize problems
	                     * compared to the built-in VML roundrect shape. When borders are not rounded,
	                     * use the simpler square path, else use the callout path without the arrow.
	                     */
	                    rect: function(x, y, w, h, options) {
	                        return SVGRenderer.prototype.symbols[!defined(options) || !options.r ? 'square' : 'callout'].call(0, x, y, w, h, options);
	                    }
	                }
	            };
	            H.VMLRenderer = VMLRenderer = function() {
	                this.init.apply(this, arguments);
	            };
	            VMLRenderer.prototype = merge(SVGRenderer.prototype, VMLRendererExtension);
	
	            // general renderer
	            H.Renderer = VMLRenderer;
	        }
	
	        // This method is used with exporting in old IE, when emulating SVG (see #2314)
	        SVGRenderer.prototype.measureSpanWidth = function(text, styles) {
	            var measuringSpan = doc.createElement('span'),
	                offsetWidth,
	                textNode = doc.createTextNode(text);
	
	            measuringSpan.appendChild(textNode);
	            css(measuringSpan, styles);
	            this.box.appendChild(measuringSpan);
	            offsetWidth = measuringSpan.offsetWidth;
	            discardElement(measuringSpan); // #2463
	            return offsetWidth;
	        };
	
	
	        /* ****************************************************************************
	         *                                                                            *
	         * END OF INTERNET EXPLORER <= 8 SPECIFIC CODE                                *
	         *                                                                            *
	         *****************************************************************************/
	
	
	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var correctFloat = H.correctFloat,
	            defined = H.defined,
	            destroyObjectProperties = H.destroyObjectProperties,
	            isNumber = H.isNumber,
	            merge = H.merge,
	            pick = H.pick,
	            deg2rad = H.deg2rad;
	
	        /**
	         * The Tick class
	         */
	        H.Tick = function(axis, pos, type, noLabel) {
	            this.axis = axis;
	            this.pos = pos;
	            this.type = type || '';
	            this.isNew = true;
	            this.isNewLabel = true;
	
	            if (!type && !noLabel) {
	                this.addLabel();
	            }
	        };
	
	        H.Tick.prototype = {
	            /**
	             * Write the tick label
	             */
	            addLabel: function() {
	                var tick = this,
	                    axis = tick.axis,
	                    options = axis.options,
	                    chart = axis.chart,
	                    categories = axis.categories,
	                    names = axis.names,
	                    pos = tick.pos,
	                    labelOptions = options.labels,
	                    str,
	                    tickPositions = axis.tickPositions,
	                    isFirst = pos === tickPositions[0],
	                    isLast = pos === tickPositions[tickPositions.length - 1],
	                    value = categories ?
	                    pick(categories[pos], names[pos], pos) :
	                    pos,
	                    label = tick.label,
	                    tickPositionInfo = tickPositions.info,
	                    dateTimeLabelFormat;
	
	                // Set the datetime label format. If a higher rank is set for this position, use that. If not,
	                // use the general format.
	                if (axis.isDatetimeAxis && tickPositionInfo) {
	                    dateTimeLabelFormat =
	                        options.dateTimeLabelFormats[
	                            tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName
	                        ];
	                }
	                // set properties for access in render method
	                tick.isFirst = isFirst;
	                tick.isLast = isLast;
	
	                // get the string
	                str = axis.labelFormatter.call({
	                    axis: axis,
	                    chart: chart,
	                    isFirst: isFirst,
	                    isLast: isLast,
	                    dateTimeLabelFormat: dateTimeLabelFormat,
	                    value: axis.isLog ? correctFloat(axis.lin2log(value)) : value,
	                    pos: pos
	                });
	
	                // prepare CSS
	                //css = width && { width: Math.max(1, Math.round(width - 2 * (labelOptions.padding || 10))) + 'px' };
	
	                // first call
	                if (!defined(label)) {
	
	                    tick.label = label =
	                        defined(str) && labelOptions.enabled ?
	                        chart.renderer.text(
	                            str,
	                            0,
	                            0,
	                            labelOptions.useHTML
	                        )
	
	                        // without position absolute, IE export sometimes is wrong
	                        .css(merge(labelOptions.style))
	
	                        .add(axis.labelGroup) :
	                        null;
	                    tick.labelLength = label && label.getBBox().width; // Un-rotated length
	                    tick.rotation = 0; // Base value to detect change for new calls to getBBox
	
	                    // update
	                } else if (label) {
	                    label.attr({
	                        text: str
	                    });
	                }
	            },
	
	            /**
	             * Get the offset height or width of the label
	             */
	            getLabelSize: function() {
	                return this.label ?
	                    this.label.getBBox()[this.axis.horiz ? 'height' : 'width'] :
	                    0;
	            },
	
	            /**
	             * Handle the label overflow by adjusting the labels to the left and right edge, or
	             * hide them if they collide into the neighbour label.
	             */
	            handleOverflow: function(xy) {
	                var axis = this.axis,
	                    pxPos = xy.x,
	                    chartWidth = axis.chart.chartWidth,
	                    spacing = axis.chart.spacing,
	                    leftBound = pick(axis.labelLeft, Math.min(axis.pos, spacing[3])),
	                    rightBound = pick(axis.labelRight, Math.max(axis.pos + axis.len, chartWidth - spacing[1])),
	                    label = this.label,
	                    rotation = this.rotation,
	                    factor = {
	                        left: 0,
	                        center: 0.5,
	                        right: 1
	                    }[axis.labelAlign],
	                    labelWidth = label.getBBox().width,
	                    slotWidth = axis.getSlotWidth(),
	                    modifiedSlotWidth = slotWidth,
	                    xCorrection = factor,
	                    goRight = 1,
	                    leftPos,
	                    rightPos,
	                    textWidth,
	                    css = {};
	
	                // Check if the label overshoots the chart spacing box. If it does, move it.
	                // If it now overshoots the slotWidth, add ellipsis.
	                if (!rotation) {
	                    leftPos = pxPos - factor * labelWidth;
	                    rightPos = pxPos + (1 - factor) * labelWidth;
	
	                    if (leftPos < leftBound) {
	                        modifiedSlotWidth = xy.x + modifiedSlotWidth * (1 - factor) - leftBound;
	                    } else if (rightPos > rightBound) {
	                        modifiedSlotWidth = rightBound - xy.x + modifiedSlotWidth * factor;
	                        goRight = -1;
	                    }
	
	                    modifiedSlotWidth = Math.min(slotWidth, modifiedSlotWidth); // #4177
	                    if (modifiedSlotWidth < slotWidth && axis.labelAlign === 'center') {
	                        xy.x += goRight * (slotWidth - modifiedSlotWidth - xCorrection *
	                            (slotWidth - Math.min(labelWidth, modifiedSlotWidth)));
	                    }
	                    // If the label width exceeds the available space, set a text width to be
	                    // picked up below. Also, if a width has been set before, we need to set a new
	                    // one because the reported labelWidth will be limited by the box (#3938).
	                    if (labelWidth > modifiedSlotWidth || (axis.autoRotation && (label.styles || {}).width)) {
	                        textWidth = modifiedSlotWidth;
	                    }
	
	                    // Add ellipsis to prevent rotated labels to be clipped against the edge of the chart
	                } else if (rotation < 0 && pxPos - factor * labelWidth < leftBound) {
	                    textWidth = Math.round(pxPos / Math.cos(rotation * deg2rad) - leftBound);
	                } else if (rotation > 0 && pxPos + factor * labelWidth > rightBound) {
	                    textWidth = Math.round((chartWidth - pxPos) / Math.cos(rotation * deg2rad));
	                }
	
	                if (textWidth) {
	                    css.width = textWidth;
	                    if (!(axis.options.labels.style || {}).textOverflow) {
	                        css.textOverflow = 'ellipsis';
	                    }
	                    label.css(css);
	                }
	            },
	
	            /**
	             * Get the x and y position for ticks and labels
	             */
	            getPosition: function(horiz, pos, tickmarkOffset, old) {
	                var axis = this.axis,
	                    chart = axis.chart,
	                    cHeight = (old && chart.oldChartHeight) || chart.chartHeight;
	
	                return {
	                    x: horiz ?
	                        axis.translate(pos + tickmarkOffset, null, null, old) + axis.transB : axis.left + axis.offset +
	                        (axis.opposite ?
	                            ((old && chart.oldChartWidth) || chart.chartWidth) - axis.right - axis.left :
	                            0
	                        ),
	
	                    y: horiz ?
	                        cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) : cHeight - axis.translate(pos + tickmarkOffset, null, null, old) - axis.transB
	                };
	
	            },
	
	            /**
	             * Get the x, y position of the tick label
	             */
	            getLabelPosition: function(x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {
	                var axis = this.axis,
	                    transA = axis.transA,
	                    reversed = axis.reversed,
	                    staggerLines = axis.staggerLines,
	                    rotCorr = axis.tickRotCorr || {
	                        x: 0,
	                        y: 0
	                    },
	                    yOffset = labelOptions.y,
	                    line;
	
	                if (!defined(yOffset)) {
	                    if (axis.side === 0) {
	                        yOffset = label.rotation ? -8 : -label.getBBox().height;
	                    } else if (axis.side === 2) {
	                        yOffset = rotCorr.y + 8;
	                    } else {
	                        // #3140, #3140
	                        yOffset = Math.cos(label.rotation * deg2rad) * (rotCorr.y - label.getBBox(false, 0).height / 2);
	                    }
	                }
	
	                x = x + labelOptions.x + rotCorr.x - (tickmarkOffset && horiz ?
	                    tickmarkOffset * transA * (reversed ? -1 : 1) : 0);
	                y = y + yOffset - (tickmarkOffset && !horiz ?
	                    tickmarkOffset * transA * (reversed ? 1 : -1) : 0);
	
	                // Correct for staggered labels
	                if (staggerLines) {
	                    line = (index / (step || 1) % staggerLines);
	                    if (axis.opposite) {
	                        line = staggerLines - line - 1;
	                    }
	                    y += line * (axis.labelOffset / staggerLines);
	                }
	
	                return {
	                    x: x,
	                    y: Math.round(y)
	                };
	            },
	
	            /**
	             * Extendible method to return the path of the marker
	             */
	            getMarkPath: function(x, y, tickLength, tickWidth, horiz, renderer) {
	                return renderer.crispLine([
	                    'M',
	                    x,
	                    y,
	                    'L',
	                    x + (horiz ? 0 : -tickLength),
	                    y + (horiz ? tickLength : 0)
	                ], tickWidth);
	            },
	
	            /**
	             * Renders the gridLine.
	             * @param  {Boolean} old         Whether or not the tick is old
	             * @param  {number} opacity      The opacity of the grid line
	             * @param  {number} reverseCrisp Modifier for avoiding overlapping 1 or -1
	             * @return {undefined}
	             */
	            renderGridLine: function(old, opacity, reverseCrisp) {
	                var tick = this,
	                    axis = tick.axis,
	                    options = axis.options,
	                    gridLine = tick.gridLine,
	                    gridLinePath,
	                    attribs = {},
	                    pos = tick.pos,
	                    type = tick.type,
	                    tickmarkOffset = axis.tickmarkOffset,
	                    renderer = axis.chart.renderer;
	
	
	                var gridPrefix = type ? type + 'Grid' : 'grid',
	                    gridLineWidth = options[gridPrefix + 'LineWidth'],
	                    gridLineColor = options[gridPrefix + 'LineColor'],
	                    dashStyle = options[gridPrefix + 'LineDashStyle'];
	
	
	                if (!gridLine) {
	
	                    attribs.stroke = gridLineColor;
	                    attribs['stroke-width'] = gridLineWidth;
	                    if (dashStyle) {
	                        attribs.dashstyle = dashStyle;
	                    }
	
	                    if (!type) {
	                        attribs.zIndex = 1;
	                    }
	                    if (old) {
	                        attribs.opacity = 0;
	                    }
	                    tick.gridLine = gridLine = renderer.path()
	                        .attr(attribs)
	                        .addClass(
	                            'highcharts-' + (type ? type + '-' : '') + 'grid-line'
	                        )
	                        .add(axis.gridGroup);
	                }
	
	                // If the parameter 'old' is set, the current call will be followed
	                // by another call, therefore do not do any animations this time
	                if (!old && gridLine) {
	                    gridLinePath = axis.getPlotLinePath(
	                        pos + tickmarkOffset,
	                        gridLine.strokeWidth() * reverseCrisp,
	                        old, true
	                    );
	                    if (gridLinePath) {
	                        gridLine[tick.isNew ? 'attr' : 'animate']({
	                            d: gridLinePath,
	                            opacity: opacity
	                        });
	                    }
	                }
	            },
	
	            /**
	             * Renders the tick mark.
	             * @param  {Object} xy           The position vector of the mark
	             * @param  {number} xy.x         The x position of the mark
	             * @param  {number} xy.y         The y position of the mark
	             * @param  {number} opacity      The opacity of the mark
	             * @param  {number} reverseCrisp Modifier for avoiding overlapping 1 or -1
	             * @return {undefined}
	             */
	            renderMark: function(xy, opacity, reverseCrisp) {
	                var tick = this,
	                    axis = tick.axis,
	                    options = axis.options,
	                    renderer = axis.chart.renderer,
	                    type = tick.type,
	                    tickPrefix = type ? type + 'Tick' : 'tick',
	                    tickSize = axis.tickSize(tickPrefix),
	                    mark = tick.mark,
	                    isNewMark = !mark,
	                    x = xy.x,
	                    y = xy.y;
	
	
	                var tickWidth = pick(
	                        options[tickPrefix + 'Width'], !type && axis.isXAxis ? 1 : 0
	                    ), // X axis defaults to 1
	                    tickColor = options[tickPrefix + 'Color'];
	
	
	                if (tickSize) {
	
	                    // negate the length
	                    if (axis.opposite) {
	                        tickSize[0] = -tickSize[0];
	                    }
	
	                    // First time, create it
	                    if (isNewMark) {
	                        tick.mark = mark = renderer.path()
	                            .addClass('highcharts-' + (type ? type + '-' : '') + 'tick')
	                            .add(axis.axisGroup);
	
	
	                        mark.attr({
	                            stroke: tickColor,
	                            'stroke-width': tickWidth
	                        });
	
	                    }
	                    mark[isNewMark ? 'attr' : 'animate']({
	                        d: tick.getMarkPath(
	                            x,
	                            y,
	                            tickSize[0],
	                            mark.strokeWidth() * reverseCrisp,
	                            axis.horiz,
	                            renderer),
	                        opacity: opacity
	                    });
	
	                }
	            },
	
	            /**
	             * Renders the tick label.
	             * Note: The label should already be created in init(), so it should only
	             * have to be moved into place.
	             * @param  {Object} xy      The position vector of the label
	             * @param  {number} xy.x    The x position of the label
	             * @param  {number} xy.y    The y position of the label
	             * @param  {Boolean} old    Whether or not the tick is old
	             * @param  {number} opacity The opacity of the label
	             * @param  {number} index   The index of the tick
	             * @return {undefined}
	             */
	            renderLabel: function(xy, old, opacity, index) {
	                var tick = this,
	                    axis = tick.axis,
	                    horiz = axis.horiz,
	                    options = axis.options,
	                    label = tick.label,
	                    labelOptions = options.labels,
	                    step = labelOptions.step,
	                    tickmarkOffset = axis.tickmarkOffset,
	                    show = true,
	                    x = xy.x,
	                    y = xy.y;
	                if (label && isNumber(x)) {
	                    label.xy = xy = tick.getLabelPosition(
	                        x,
	                        y,
	                        label,
	                        horiz,
	                        labelOptions,
	                        tickmarkOffset,
	                        index,
	                        step
	                    );
	
	                    // Apply show first and show last. If the tick is both first and
	                    // last, it is a single centered tick, in which case we show the
	                    // label anyway (#2100).
	                    if (
	                        (
	                            tick.isFirst &&
	                            !tick.isLast &&
	                            !pick(options.showFirstLabel, 1)
	                        ) ||
	                        (
	                            tick.isLast &&
	                            !tick.isFirst &&
	                            !pick(options.showLastLabel, 1)
	                        )
	                    ) {
	                        show = false;
	
	                        // Handle label overflow and show or hide accordingly
	                    } else if (horiz && !axis.isRadial && !labelOptions.step &&
	                        !labelOptions.rotation && !old && opacity !== 0) {
	                        tick.handleOverflow(xy);
	                    }
	
	                    // apply step
	                    if (step && index % step) {
	                        // show those indices dividable by step
	                        show = false;
	                    }
	
	                    // Set the new position, and show or hide
	                    if (show && isNumber(xy.y)) {
	                        xy.opacity = opacity;
	                        label[tick.isNewLabel ? 'attr' : 'animate'](xy);
	                        tick.isNewLabel = false;
	                    } else {
	                        label.attr('y', -9999); // #1338
	                        tick.isNewLabel = true;
	                    }
	                    tick.isNew = false;
	                }
	            },
	
	            /**
	             * Put everything in place
	             *
	             * @param index {Number}
	             * @param old {Boolean} Use old coordinates to prepare an animation into new
	             *                      position
	             */
	            render: function(index, old, opacity) {
	                var tick = this,
	                    axis = tick.axis,
	                    horiz = axis.horiz,
	                    pos = tick.pos,
	                    tickmarkOffset = axis.tickmarkOffset,
	                    xy = tick.getPosition(horiz, pos, tickmarkOffset, old),
	                    x = xy.x,
	                    y = xy.y,
	                    reverseCrisp = ((horiz && x === axis.pos + axis.len) ||
	                        (!horiz && y === axis.pos)) ? -1 : 1; // #1480, #1687
	
	                opacity = pick(opacity, 1);
	                this.isActive = true;
	
	                // Create the grid line
	                this.renderGridLine(old, opacity, reverseCrisp);
	
	                // create the tick mark
	                this.renderMark(xy, opacity, reverseCrisp);
	
	                // the label is created on init - now move it into place
	                this.renderLabel(xy, old, opacity, index);
	            },
	
	            /**
	             * Destructor for the tick prototype
	             */
	            destroy: function() {
	                destroyObjectProperties(this, this.axis);
	            }
	        };
	
	    }(Highcharts));
	    var Axis = (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	
	        var addEvent = H.addEvent,
	            animObject = H.animObject,
	            arrayMax = H.arrayMax,
	            arrayMin = H.arrayMin,
	            color = H.color,
	            correctFloat = H.correctFloat,
	            defaultOptions = H.defaultOptions,
	            defined = H.defined,
	            deg2rad = H.deg2rad,
	            destroyObjectProperties = H.destroyObjectProperties,
	            each = H.each,
	            extend = H.extend,
	            fireEvent = H.fireEvent,
	            format = H.format,
	            getMagnitude = H.getMagnitude,
	            grep = H.grep,
	            inArray = H.inArray,
	            isArray = H.isArray,
	            isNumber = H.isNumber,
	            isString = H.isString,
	            merge = H.merge,
	            normalizeTickInterval = H.normalizeTickInterval,
	            objectEach = H.objectEach,
	            pick = H.pick,
	            removeEvent = H.removeEvent,
	            splat = H.splat,
	            syncTimeout = H.syncTimeout,
	            Tick = H.Tick;
	
	        /**
	         * Create a new axis object. Called internally when instanciating a new chart or
	         * adding axes by {@link Highcharts.Chart#addAxis}.
	         *
	         * A chart can have from 0 axes (pie chart) to multiples. In a normal, single
	         * series cartesian chart, there is one X axis and one Y axis.
	         * 
	         * The X axis or axes are referenced by {@link Highcharts.Chart.xAxis}, which is
	         * an array of Axis objects. If there is only one axis, it can be referenced
	         * through `chart.xAxis[0]`, and multiple axes have increasing indices. The same
	         * pattern goes for Y axes.
	         * 
	         * If you need to get the axes from a series object, use the `series.xAxis` and
	         * `series.yAxis` properties. These are not arrays, as one series can only be
	         * associated to one X and one Y axis.
	         * 
	         * A third way to reference the axis programmatically is by `id`. Add an `id` in
	         * the axis configuration options, and get the axis by
	         * {@link Highcharts.Chart#get}.
	         * 
	         * Configuration options for the axes are given in options.xAxis and
	         * options.yAxis.
	         * 
	         * @class Highcharts.Axis
	         * @memberOf Highcharts
	         * @param {Highcharts.Chart} chart - The Chart instance to apply the axis on.
	         * @param {Object} options - Axis options
	         */
	        var Axis = function() {
	            this.init.apply(this, arguments);
	        };
	
	        H.extend(Axis.prototype, /** @lends Highcharts.Axis.prototype */ {
	
	            /**
	             * The X axis or category axis. Normally this is the horizontal axis,
	             * though if the chart is inverted this is the vertical axis. In case of
	             * multiple axes, the xAxis node is an array of configuration objects.
	             * 
	             * See [../class-reference/Highcharts.Axis](the Axis object) for
	             * programmatic access to the axis.
	             *
	             * @productdesc {highmaps}
	             * In Highmaps, the axis is hidden, but it is used behind the scenes to
	             * control features like zooming and panning. Zooming is in effect the same
	             * as setting the extremes of one of the exes.
	             * 
	             * @optionparent xAxis
	             */
	            defaultOptions: {
	                // allowDecimals: null,
	                // alternateGridColor: null,
	                // categories: [],
	
	                /**
	                 * For a datetime axis, the scale will automatically adjust to the
	                 * appropriate unit. This member gives the default string representations
	                 * used for each unit. For intermediate values, different units may
	                 * be used, for example the `day` unit can be used on midnight and
	                 * `hour` unit be used for intermediate values on the same axis. For
	                 * an overview of the replacement codes, see [dateFormat](#Highcharts.
	                 * dateFormat). Defaults to:
	                 * 
	                 * <pre>{
	                 * millisecond: '%H:%M:%S.%L',
	                 * second: '%H:%M:%S',
	                 * minute: '%H:%M',
	                 * hour: '%H:%M',
	                 * day: '%e. %b',
	                 * week: '%e. %b',
	                 * month: '%b \'%y',
	                 * year: '%Y'
	                 * }</pre>
	                 * 
	                 * @type {Object}
	                 * @sample {highcharts} highcharts/xaxis/datetimelabelformats/ Different day format on X axis
	                 * @sample {highstock} stock/xaxis/datetimelabelformats/ More information in x axis labels
	                 * @product highcharts highstock
	                 */
	                dateTimeLabelFormats: {
	
	                    /**
	                     */
	                    millisecond: '%H:%M:%S.%L',
	
	                    /**
	                     */
	                    second: '%H:%M:%S',
	
	                    /**
	                     */
	                    minute: '%H:%M',
	
	                    /**
	                     */
	                    hour: '%H:%M',
	
	                    /**
	                     */
	                    day: '%e. %b',
	
	                    /**
	                     */
	                    week: '%e. %b',
	
	                    /**
	                     */
	                    month: '%b \'%y',
	
	                    /**
	                     */
	                    year: '%Y'
	                },
	
	                /**
	                 * Whether to force the axis to end on a tick. Use this option with
	                 * the `maxPadding` option to control the axis end.
	                 * 
	                 * @type {Boolean}
	                 * @sample {highcharts} highcharts/chart/reflow-true/ True by default
	                 * @sample {highcharts} highcharts/yaxis/endontick/ False
	                 * @sample {highstock} stock/demo/basic-line/ True by default
	                 * @sample {highstock} stock/xaxis/endontick/ False
	                 * @default false
	                 * @since 1.2.0
	                 * @product highcharts highstock highmaps
	                 */
	                endOnTick: false,
	                // reversed: false,
	
	
	                /**
	                 * The axis labels show the number or category for each tick.
	                 *
	                 * @productdesc {highmaps}
	                 * X and Y axis labels are by default disabled in Highmaps, but the
	                 * functionality is inherited from Highcharts and used on `colorAxis`,
	                 * and can be enabled on X and Y axes too.
	                 */
	                labels: {
	
	                    /**
	                     * Enable or disable the axis labels.
	                     * 
	                     * @type {Boolean}
	                     * @sample {highcharts} highcharts/xaxis/labels-enabled/ X axis labels disabled
	                     * @sample {highstock} stock/xaxis/labels-enabled/ X axis labels disabled
	                     * @default {highstock} true
	                     * @default {highmaps} false
	                     * @product highcharts highstock highmaps
	                     */
	                    enabled: true,
	                    // rotation: 0,
	                    // align: 'center',
	                    // step: null,
	
	
	                    /**
	                     * CSS styles for the label. Use `whiteSpace: 'nowrap'` to prevent
	                     * wrapping of category labels. Use `textOverflow: 'none'` to prevent
	                     * ellipsis (dots).
	                     * 
	                     * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                     * style/style-by-css), the labels are styled with the `.highcharts-
	                     * axis-labels` class.
	                     * 
	                     * @type {CSSObject}
	                     * @sample {highcharts} highcharts/xaxis/labels-style/ Red X axis labels
	                     * @default { "color": "#666666", "cursor": "default", "fontSize": "11px" }
	                     * @product highcharts highstock highmaps
	                     */
	                    style: {
	
	                        /**
	                         */
	                        color: '#666666',
	
	                        /**
	                         */
	                        cursor: 'default',
	
	                        /**
	                         */
	                        fontSize: '11px'
	                    },
	
	
	                    /**
	                     * The x position offset of the label relative to the tick position
	                     * on the axis.
	                     * 
	                     * @type {Number}
	                     * @sample {highcharts} highcharts/xaxis/labels-x/ Y axis labels placed on grid lines
	                     * @default 0
	                     * @product highcharts highstock highmaps
	                     */
	                    x: 0
	                    //y: undefined
	                    /*formatter: function () {
	                    	return this.value;
	                    },*/
	                },
	                //linkedTo: null,
	                //max: undefined,
	                //min: undefined,
	
	                /**
	                 * Padding of the min value relative to the length of the axis. A
	                 * padding of 0.05 will make a 100px axis 5px longer. This is useful
	                 * when you don't want the lowest data value to appear on the edge
	                 * of the plot area. When the axis' `min` option is set or a min extreme
	                 * is set using `axis.setExtremes()`, the minPadding will be ignored.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/yaxis/minpadding/ Min padding of 0.2
	                 * @sample {highstock} stock/xaxis/minpadding-maxpadding/ Greater min- and maxPadding
	                 * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/ Add some padding
	                 * @default {highcharts} 0.01
	                 * @default {highstock} 0
	                 * @default {highmaps} 0
	                 * @since 1.2.0
	                 * @product highcharts highstock highmaps
	                 */
	                minPadding: 0.01,
	
	                /**
	                 * Padding of the max value relative to the length of the axis. A
	                 * padding of 0.05 will make a 100px axis 5px longer. This is useful
	                 * when you don't want the highest data value to appear on the edge
	                 * of the plot area. When the axis' `max` option is set or a max extreme
	                 * is set using `axis.setExtremes()`, the maxPadding will be ignored.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/yaxis/maxpadding/ Max padding of 0.25 on y axis
	                 * @sample {highstock} stock/xaxis/minpadding-maxpadding/ Greater min- and maxPadding
	                 * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/ Add some padding
	                 * @default {highcharts} 0.01
	                 * @default {highstock} 0
	                 * @default {highmaps} 0
	                 * @since 1.2.0
	                 * @product highcharts highstock highmaps
	                 */
	                maxPadding: 0.01,
	                //minRange: null,
	                //minorTickInterval: null,
	
	                /**
	                 * The pixel length of the minor tick marks.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/yaxis/minorticklength/ 10px on Y axis
	                 * @sample {highstock} stock/xaxis/minorticks/ 10px on Y axis
	                 * @default 2
	                 * @product highcharts highstock highmaps
	                 */
	                minorTickLength: 2,
	
	                /**
	                 * The position of the minor tick marks relative to the axis line.
	                 *  Can be one of `inside` and `outside`.
	                 * 
	                 * @validvalue ["inside", "outside"]
	                 * @type {String}
	                 * @sample {highcharts} highcharts/yaxis/minortickposition-outside/ Outside by default
	                 * @sample {highcharts} highcharts/yaxis/minortickposition-inside/ Inside
	                 * @sample {highstock} stock/xaxis/minorticks/ Inside
	                 * @default outside
	                 * @product highcharts highstock highmaps
	                 */
	                minorTickPosition: 'outside', // inside or outside
	                //opposite: false,
	                //offset: 0,
	                //plotBands: [{
	                //	events: {},
	                //	zIndex: 1,
	                //	labels: { align, x, verticalAlign, y, style, rotation, textAlign }
	                //}],
	                //plotLines: [{
	                //	events: {}
	                //  dashStyle: {}
	                //	zIndex:
	                //	labels: { align, x, verticalAlign, y, style, rotation, textAlign }
	                //}],
	                //reversed: false,
	                // showFirstLabel: true,
	                // showLastLabel: true,
	
	                /**
	                 * For datetime axes, this decides where to put the tick between weeks.
	                 *  0 = Sunday, 1 = Monday.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/xaxis/startofweek-monday/ Monday by default
	                 * @sample {highcharts} highcharts/xaxis/startofweek-sunday/ Sunday
	                 * @sample {highstock} stock/xaxis/startofweek-1 Monday by default
	                 * @sample {highstock} stock/xaxis/startofweek-0 Sunday
	                 * @default 1
	                 * @product highcharts highstock
	                 */
	                startOfWeek: 1,
	
	                /**
	                 * Whether to force the axis to start on a tick. Use this option with
	                 * the `minPadding` option to control the axis start.
	                 *
	                 * @productdesc {highstock}
	                 * In Highstock, `startOnTick` is always false when the navigator is
	                 * enabled, to prevent jumpy scrolling.
	                 * 
	                 * @type {Boolean}
	                 * @sample {highcharts} highcharts/xaxis/startontick-false/ False by default
	                 * @sample {highcharts} highcharts/xaxis/startontick-true/ True
	                 * @sample {highstock} stock/xaxis/endontick/ False for Y axis
	                 * @default false
	                 * @since 1.2.0
	                 */
	                startOnTick: false,
	                //tickInterval: null,
	
	                /**
	                 * The pixel length of the main tick marks.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/xaxis/ticklength/ 20 px tick length on the X axis
	                 * @sample {highstock} stock/xaxis/ticks/ Formatted ticks on X axis
	                 * @default 10
	                 * @product highcharts highstock highmaps
	                 */
	                tickLength: 10,
	
	                /**
	                 * For categorized axes only. If `on` the tick mark is placed in the
	                 * center of the category, if `between` the tick mark is placed between
	                 * categories. The default is `between` if the `tickInterval` is 1,
	                 *  else `on`.
	                 * 
	                 * @validvalue [null, "on", "between"]
	                 * @type {String}
	                 * @sample {highcharts} highcharts/xaxis/tickmarkplacement-between/ "between" by default
	                 * @sample {highcharts} highcharts/xaxis/tickmarkplacement-on/ "on"
	                 * @default null
	                 * @product highcharts
	                 */
	                tickmarkPlacement: 'between', // on or between
	
	                /**
	                 * If tickInterval is `null` this option sets the approximate pixel
	                 * interval of the tick marks. Not applicable to categorized axis.
	                 * 
	                 * 
	                 * The tick interval is also influenced by the [minTickInterval](#xAxis.
	                 * minTickInterval) option, that, by default prevents ticks from being
	                 * denser than the data points.
	                 * 
	                 * Defaults to `72` for the Y axis and `100` for the X axis.
	                 * 
	                 * @type {Number}
	                 * @see [tickInterval](#xAxis.tickInterval), [tickPositioner](#xAxis.tickPositioner),
	                 *  [tickPositions](#xAxis.tickPositions)-
	                 * @sample {highcharts} highcharts/xaxis/tickpixelinterval-50/ 50 px on X axis
	                 * @sample {highstock} stock/xaxis/tickpixelinterval/ 200 px on X axis
	                 * @product highcharts highstock highmaps
	                 */
	                tickPixelInterval: 100,
	
	                /**
	                 * The position of the major tick marks relative to the axis line.
	                 *  Can be one of `inside` and `outside`.
	                 * 
	                 * @validvalue ["inside", "outside"]
	                 * @type {String}
	                 * @sample {highcharts} highcharts/xaxis/tickposition-outside/ "outside" by default
	                 * @sample {highcharts} highcharts/xaxis/tickposition-inside/ "inside"
	                 * @sample {highstock} stock/xaxis/ticks/ Formatted ticks on X axis
	                 * @default {highcharts} outside
	                 * @default {highstock} "outside"
	                 * @default {highmaps} outside
	                 * @product highcharts highstock highmaps
	                 */
	                tickPosition: 'outside',
	
	                /**
	                 * The axis title, showing next to the axis line.
	                 *
	                 * @productdesc {highmaps}
	                 * In Highmaps, the axis is hidden by default, but adding an axis title
	                 * is still possible. X axis and Y axis titles will appear at the bottom
	                 * and left by default.
	                 */
	                title: {
	                    //text: null,
	
	                    /**
	                     * Alignment of the title relative to the axis values. Possible values
	                     * are "low", "middle" or "high".
	                     * 
	                     * @validvalue ["low", "middle", "high"]
	                     * @type {String}
	                     * @sample {highcharts} highcharts/xaxis/title-align-low/ "low"
	                     * @sample {highcharts} highcharts/xaxis/title-align-center/ "middle" by default
	                     * @sample {highcharts} highcharts/xaxis/title-align-high/ "high"
	                     * @sample {highcharts} highcharts/yaxis/title-offset/ Place the Y axis title on top of the axis
	                     * @sample {highstock} stock/xaxis/title-align/ Aligned to "high" value
	                     * @default {highcharts} middle
	                     * @default {highstock} "middle"
	                     * @default {highmaps} middle
	                     * @product highcharts highstock highmaps
	                     */
	                    align: 'middle', // low, middle or high
	                    //margin: 0 for horizontal, 10 for vertical axes,
	                    // reserveSpace: true,
	                    //rotation: 0,
	                    //side: 'outside',
	
	
	                    /**
	                     * CSS styles for the title. If the title text is longer than the
	                     * axis length, it will wrap to multiple lines by default. This can
	                     * be customized by setting `textOverflow: 'ellipsis'`, by 
	                     * setting a specific `width` or by setting `wordSpace: 'nowrap'`.
	                     * 
	                     * 
	                     * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                     * style/style-by-css), the stroke width is given in the
	                     * `.highcharts-axis-title` class.
	                     * 
	                     * @type {CSSObject}
	                     * @sample {highcharts} highcharts/xaxis/title-style/ Red
	                     * @sample {highcharts} highcharts/css/axis/ Styled mode
	                     * @default { "color": "#666666" }
	                     * @product highcharts highstock highmaps
	                     */
	                    style: {
	
	                        /**
	                         */
	                        color: '#666666'
	                    }
	
	                    //x: 0,
	                    //y: 0
	                },
	
	                /**
	                 * The type of axis. Can be one of `linear`, `logarithmic`, `datetime`
	                 * or `category`. In a datetime axis, the numbers are given in milliseconds,
	                 * and tick marks are placed on appropriate values like full hours
	                 * or days. In a category axis, the [point names](#series<line>.data.
	                 * name) of the chart's series are used for categories, if not a [categories](#xAxis.
	                 * categories) array is defined.
	                 * 
	                 * @validvalue ["linear", "logarithmic", "datetime", "category"]
	                 * @type {String}
	                 * @sample {highcharts} highcharts/xaxis/type-linear/ Linear
	                 * @sample {highcharts} highcharts/yaxis/type-log/ Logarithmic
	                 * @sample {highcharts} highcharts/yaxis/type-log-minorgrid/ Logarithmic with minor grid lines
	                 * @sample {highcharts} highcharts/xaxis/type-log-both/ Logarithmic on two axes
	                 * @sample {highcharts} highcharts/yaxis/type-log-negative/ Logarithmic with extension to emulate negative values
	                 * @default linear
	                 * @product highcharts
	                 */
	                type: 'linear', // linear, logarithmic or datetime
	                //visible: true
	
	
	                /**
	                 * Color of the minor, secondary grid lines.
	                 * 
	                 * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the stroke width is given in the `.highcharts-
	                 * minor-grid-line` class.
	                 * 
	                 * @type {Color}
	                 * @sample {highcharts} highcharts/yaxis/minorgridlinecolor/ Bright grey lines from Y axis
	                 * @sample {highcharts} highcharts/css/axis-grid/ Styled mode
	                 * @sample {highstock} stock/xaxis/minorgridlinecolor/ Bright grey lines from Y axis
	                 * @sample {highstock} highcharts/css/axis-grid/ Styled mode
	                 * @default #f2f2f2
	                 * @product highcharts highstock highmaps
	                 */
	                minorGridLineColor: '#f2f2f2',
	                // minorGridLineDashStyle: null,
	
	                /**
	                 * Width of the minor, secondary grid lines.
	                 * 
	                 * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the stroke width is given in the `.highcharts-
	                 * grid-line` class.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/yaxis/minorgridlinewidth/ 2px lines from Y axis
	                 * @sample {highcharts} highcharts/css/axis-grid/ Styled mode
	                 * @sample {highstock} stock/xaxis/minorgridlinewidth/ 2px lines from Y axis
	                 * @sample {highstock} highcharts/css/axis-grid/ Styled mode
	                 * @default 1
	                 * @product highcharts highstock highmaps
	                 */
	                minorGridLineWidth: 1,
	
	                /**
	                 * Color for the minor tick marks.
	                 * 
	                 * @type {Color}
	                 * @sample {highcharts} highcharts/yaxis/minortickcolor/ Black tick marks on Y axis
	                 * @sample {highstock} stock/xaxis/minorticks/ Black tick marks on Y axis
	                 * @default #999999
	                 * @product highcharts highstock highmaps
	                 */
	                minorTickColor: '#999999',
	                //minorTickWidth: 0,
	
	                /**
	                 * The color of the line marking the axis itself.
	                 * 
	                 * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the line stroke is given in the `.highcharts-
	                 * axis-line` or `.highcharts-xaxis-line` class.
	                 * 
	                 * @productdesc {highmaps}
	                 * In Highmaps, the axis line is hidden by default.
	                 * 
	                 * @type {Color}
	                 * @sample {highcharts} highcharts/yaxis/linecolor/ A red line on Y axis
	                 * @sample {highcharts} highcharts/css/axis/ Axes in styled mode
	                 * @sample {highstock} stock/xaxis/linecolor/ A red line on X axis
	                 * @sample {highstock} highcharts/css/axis/ Axes in styled mode
	                 * @default #ccd6eb
	                 * @product highcharts highstock highmaps
	                 */
	                lineColor: '#ccd6eb',
	
	                /**
	                 * The width of the line marking the axis itself.
	                 * 
	                 * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the stroke width is given in the `.highcharts-
	                 * axis-line` or `.highcharts-xaxis-line` class.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/yaxis/linecolor/ A 1px line on Y axis
	                 * @sample {highcharts} highcharts/css/axis/ Axes in styled mode
	                 * @sample {highstock} stock/xaxis/linewidth/ A 2px line on X axis
	                 * @sample {highstock} highcharts/css/axis/ Axes in styled mode
	                 * @default {highcharts} 1
	                 * @default {highstock} 1
	                 * @default {highmaps} 0
	                 * @product highcharts highstock highmaps
	                 */
	                lineWidth: 1,
	
	                /**
	                 * Color of the grid lines extending the ticks across the plot area.
	                 * 
	                 * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the stroke is given in the `.highcharts-grid-
	                 * line` class.
	                 *
	                 * @productdesc {highmaps}
	                 * In Highmaps, the grid lines are hidden by default.
	                 * 
	                 * @type {Color}
	                 * @sample {highcharts} highcharts/yaxis/gridlinecolor/ Green lines
	                 * @sample {highcharts} highcharts/css/axis-grid/ Styled mode
	                 * @sample {highstock} stock/xaxis/gridlinecolor/ Green lines
	                 * @sample {highstock} highcharts/css/axis-grid/ Styled mode
	                 * @default #e6e6e6
	                 * @product highcharts highstock highmaps
	                 */
	                gridLineColor: '#e6e6e6',
	                // gridLineDashStyle: 'solid',
	                // gridLineWidth: 0,
	
	                /**
	                 * Color for the main tick marks.
	                 * 
	                 * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                 * style/style-by-css), the stroke is given in the `.highcharts-tick`
	                 * class.
	                 * 
	                 * @type {Color}
	                 * @sample {highcharts} highcharts/xaxis/tickcolor/ Red ticks on X axis
	                 * @sample {highcharts} highcharts/css/axis-grid/ Styled mode
	                 * @sample {highstock} stock/xaxis/ticks/ Formatted ticks on X axis
	                 * @sample {highstock} highcharts/css/axis-grid/ Styled mode
	                 * @default #ccd6eb
	                 * @product highcharts highstock highmaps
	                 */
	                tickColor: '#ccd6eb'
	                // tickWidth: 1
	
	            },
	
	            /**
	             * This option set extends the defaultOptions for Y axes.
	             * @extends xAxis
	             * @optionparent yAxis
	             */
	            defaultYAxisOptions: {
	
	                /**
	                 * Whether to force the axis to end on a tick. Use this option with
	                 * the `maxPadding` option to control the axis end.
	                 *
	                 * @productdesc {highstock}
	                 * In Highstock, `endOnTick` is always false when the navigator is
	                 * enabled, to prevent jumpy scrolling.
	                 * 
	                 * @type {Boolean}
	                 * @sample {highcharts} highcharts/chart/reflow-true/ True by default
	                 * @sample {highcharts} highcharts/yaxis/endontick-false/ False
	                 * @sample {highcharts} highcharts/yaxis/endontick-log-false/ False
	                 * @sample {highstock} stock/demo/basic-line/ True by default
	                 * @sample {highstock} stock/xaxis/endontick/ False
	                 * @default true
	                 * @since 1.2.0
	                 * @product highcharts highstock
	                 */
	                endOnTick: true,
	
	                /**
	                 */
	                tickPixelInterval: 72,
	
	                /**
	                 * Whether to show the last tick label. Defaults to `true` on cartesian
	                 * charts, and `false` on polar charts.
	                 * 
	                 * @type {Boolean}
	                 * @sample {highcharts} highcharts/xaxis/showlastlabel-true/ Set to true on X axis
	                 * @sample {highstock} stock/xaxis/showfirstlabel/ Labels below plot lines on Y axis
	                 * @default false
	                 * @product highcharts highstock
	                 */
	                showLastLabel: true,
	
	                /**
	                 * @extends xAxis.labels
	                 * @product highcharts highstock highmaps
	                 */
	                labels: {
	
	                    /**
	                     * The x position offset of the label relative to the tick position
	                     * on the axis. Defaults to -15 for left axis, 15 for right axis.
	                     * 
	                     * @type {Number}
	                     * @sample {highcharts} highcharts/xaxis/labels-x/ Y axis labels placed on grid lines
	                     * @default 0
	                     * @product highcharts highstock highmaps
	                     */
	                    x: -8
	                },
	
	                /**
	                 * Padding of the max value relative to the length of the axis. A
	                 * padding of 0.05 will make a 100px axis 5px longer. This is useful
	                 * when you don't want the highest data value to appear on the edge
	                 * of the plot area. When the axis' `max` option is set or a max extreme
	                 * is set using `axis.setExtremes()`, the maxPadding will be ignored.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/yaxis/maxpadding-02/ Max padding of 0.2
	                 * @sample {highstock} stock/xaxis/minpadding-maxpadding/ Greater min- and maxPadding
	                 * @default 0.05
	                 * @since 1.2.0
	                 * @product highcharts highstock
	                 */
	                maxPadding: 0.05,
	
	                /**
	                 * Padding of the min value relative to the length of the axis. A
	                 * padding of 0.05 will make a 100px axis 5px longer. This is useful
	                 * when you don't want the lowest data value to appear on the edge
	                 * of the plot area. When the axis' `min` option is set or a max extreme
	                 * is set using `axis.setExtremes()`, the maxPadding will be ignored.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/yaxis/minpadding/ Min padding of 0.2
	                 * @sample {highstock} stock/xaxis/minpadding-maxpadding/ Greater min- and maxPadding
	                 * @default 0.05
	                 * @since 1.2.0
	                 * @product highcharts highstock
	                 */
	                minPadding: 0.05,
	
	                /**
	                 * Whether to force the axis to start on a tick. Use this option with
	                 * the `maxPadding` option to control the axis start.
	                 * 
	                 * @type {Boolean}
	                 * @sample {highcharts} highcharts/xaxis/startontick-false/ False by default
	                 * @sample {highcharts} highcharts/xaxis/startontick-true/ True
	                 * @sample {highstock} stock/xaxis/endontick/ False for Y axis
	                 * @default true
	                 * @since 1.2.0
	                 * @product highcharts highstock
	                 */
	                startOnTick: true,
	
	                /**
	                 * @extends xAxis.title
	                 * @product highcharts highstock highmaps
	                 */
	                title: {
	
	                    /**
	                     * The rotation of the text in degrees. 0 is horizontal, 270 is vertical
	                     * reading from bottom to top.
	                     * 
	                     * @type {Number}
	                     * @sample {highcharts} highcharts/yaxis/title-offset/ Horizontal
	                     * @default 270
	                     * @product highcharts highstock highmaps
	                     */
	                    rotation: 270,
	
	                    /**
	                     * The actual text of the axis title. Horizontal texts can contain
	                     * HTML, but rotated texts are painted using vector techniques and
	                     * must be clean text. The Y axis title is disabled by setting the
	                     * `text` option to `null`.
	                     * 
	                     * @type {String}
	                     * @sample {highcharts} highcharts/xaxis/title-text/ Custom HTML
	                     * @default Values
	                     * @product highcharts
	                     */
	                    text: 'Values'
	                },
	
	                /**
	                 * The stack labels show the total value for each bar in a stacked
	                 * column or bar chart. The label will be placed on top of positive
	                 * columns and below negative columns. In case of an inverted column
	                 * chart or a bar chart the label is placed to the right of positive
	                 * bars and to the left of negative bars.
	                 * 
	                 * @product highcharts
	                 */
	                stackLabels: {
	
	                    /**
	                     * Allow the stack labels to overlap.
	                     * 
	                     * @type {Boolean}
	                     * @sample {highcharts} highcharts/yaxis/stacklabels-allowoverlap-false/
	                     *         Default false
	                     * @since 5.0.13
	                     * @product highcharts
	                     */
	                    allowOverlap: false,
	
	                    /**
	                     * Enable or disable the stack total labels.
	                     * 
	                     * @type {Boolean}
	                     * @sample {highcharts} highcharts/yaxis/stacklabels-enabled/ Enabled stack total labels
	                     * @since 2.1.5
	                     * @product highcharts
	                     */
	                    enabled: false,
	                    //align: dynamic,
	                    //y: dynamic,
	                    //x: dynamic,
	                    //verticalAlign: dynamic,
	                    //textAlign: dynamic,
	                    //rotation: 0,
	
	                    /**
	                     * Callback JavaScript function to format the label. The value is
	                     * given by `this.total`. Defaults to:
	                     * 
	                     * <pre>function() {
	                     * return this.total;
	                     * }</pre>
	                     * 
	                     * @type {Function}
	                     * @sample {highcharts} highcharts/yaxis/stacklabels-formatter/ Added units to stack total value
	                     * @since 2.1.5
	                     * @product highcharts
	                     */
	                    formatter: function() {
	                        return H.numberFormat(this.total, -1);
	                    },
	
	
	                    /**
	                     * CSS styles for the label.
	                     * 
	                     * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                     * style/style-by-css), the styles are set in the `.highcharts-stack-
	                     * label` class.
	                     * 
	                     * @type {CSSObject}
	                     * @sample {highcharts} highcharts/yaxis/stacklabels-style/ Red stack total labels
	                     * @default { "color": "#000000", "fontSize": "11px", "fontWeight": "bold", "textShadow": "1px 1px contrast, -1px -1px contrast, -1px 1px contrast, 1px -1px contrast" }
	                     * @since 2.1.5
	                     * @product highcharts
	                     */
	                    style: {
	
	                        /**
	                         */
	                        fontSize: '11px',
	
	                        /**
	                         */
	                        fontWeight: 'bold',
	
	                        /**
	                         */
	                        color: '#000000',
	
	                        /**
	                         */
	                        textOutline: '1px contrast'
	                    }
	
	                },
	
	
	                /**
	                 * The width of the grid lines extending the ticks across the plot
	                 * area.
	                 * 
	                 * @productdesc {highmaps}
	                 * In Highmaps, the grid lines are hidden by default.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/yaxis/gridlinewidth/ 2px lines
	                 * @sample {highstock} stock/xaxis/gridlinewidth/ 2px lines
	                 * @default 1
	                 * @product highcharts highstock
	                 */
	                gridLineWidth: 1,
	
	                /**
	                 * The width of the line marking the axis itself.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/yaxis/linecolor/ A 1px line on Y axis
	                 * @sample {highstock} stock/xaxis/linewidth/ A 2px line on X axis
	                 * @default 0
	                 * @product highcharts highstock
	                 */
	                lineWidth: 0
	                // tickWidth: 0
	
	            },
	
	            /**
	             * These options extend the defaultOptions for left axes.
	             * 
	             * @private
	             * @type {Object}
	             */
	            defaultLeftAxisOptions: {
	                labels: {
	                    x: -15
	                },
	                title: {
	                    rotation: 270
	                }
	            },
	
	            /**
	             * These options extend the defaultOptions for right axes.
	             *
	             * @private
	             * @type {Object}
	             */
	            defaultRightAxisOptions: {
	                labels: {
	                    x: 15
	                },
	                title: {
	                    rotation: 90
	                }
	            },
	
	            /**
	             * These options extend the defaultOptions for bottom axes.
	             *
	             * @private
	             * @type {Object}
	             */
	            defaultBottomAxisOptions: {
	                labels: {
	                    autoRotation: [-45],
	                    x: 0
	                    // overflow: undefined,
	                    // staggerLines: null
	                },
	                title: {
	                    rotation: 0
	                }
	            },
	            /**
	             * These options extend the defaultOptions for top axes.
	             *
	             * @private
	             * @type {Object}
	             */
	            defaultTopAxisOptions: {
	                labels: {
	                    autoRotation: [-45],
	                    x: 0
	                    // overflow: undefined
	                    // staggerLines: null
	                },
	                title: {
	                    rotation: 0
	                }
	            },
	
	            /**
	             * Overrideable function to initialize the axis. 
	             *
	             * @see {@link Axis}
	             */
	            init: function(chart, userOptions) {
	
	
	                var isXAxis = userOptions.isX,
	                    axis = this;
	
	
	                /**
	                 * The Chart that the axis belongs to.
	                 *
	                 * @name chart
	                 * @memberOf Axis
	                 * @type {Chart}
	                 */
	                axis.chart = chart;
	
	                /**
	                 * Whether the axis is horizontal.
	                 *
	                 * @name horiz
	                 * @memberOf Axis
	                 * @type {Boolean}
	                 */
	                axis.horiz = chart.inverted && !axis.isZAxis ? !isXAxis : isXAxis;
	
	                // Flag, isXAxis
	                axis.isXAxis = isXAxis;
	
	                /**
	                 * The collection where the axis belongs, for example `xAxis`, `yAxis`
	                 * or `colorAxis`. Corresponds to properties on Chart, for example
	                 * {@link Chart.xAxis}.
	                 *
	                 * @name coll
	                 * @memberOf Axis
	                 * @type {String}
	                 */
	                axis.coll = axis.coll || (isXAxis ? 'xAxis' : 'yAxis');
	
	
	                axis.opposite = userOptions.opposite; // needed in setOptions
	
	                /**
	                 * The side on which the axis is rendered. 0 is top, 1 is right, 2 is
	                 * bottom and 3 is left.
	                 *
	                 * @name side
	                 * @memberOf Axis
	                 * @type {Number}
	                 */
	                axis.side = userOptions.side || (axis.horiz ?
	                    (axis.opposite ? 0 : 2) : // top : bottom
	                    (axis.opposite ? 1 : 3)); // right : left
	
	                axis.setOptions(userOptions);
	
	
	                var options = this.options,
	                    type = options.type,
	                    isDatetimeAxis = type === 'datetime';
	
	                axis.labelFormatter = options.labels.formatter ||
	                    axis.defaultLabelFormatter; // can be overwritten by dynamic format
	
	
	                // Flag, stagger lines or not
	                axis.userOptions = userOptions;
	
	                //axis.axisTitleMargin = undefined,// = options.title.margin,
	                axis.minPixelPadding = 0;
	
	
	                /**
	                 * Whether the axis is reversed. Based on the `axis.reversed`,
	                 * option, but inverted charts have reversed xAxis by default.
	                 *
	                 * @name reversed
	                 * @memberOf Axis
	                 * @type {Boolean}
	                 */
	                axis.reversed = options.reversed;
	                axis.visible = options.visible !== false;
	                axis.zoomEnabled = options.zoomEnabled !== false;
	
	                // Initial categories
	                axis.hasNames = type === 'category' || options.categories === true;
	                axis.categories = options.categories || axis.hasNames;
	                axis.names = axis.names || []; // Preserve on update (#3830)
	
	                // Elements
	                //axis.axisGroup = undefined;
	                //axis.gridGroup = undefined;
	                //axis.axisTitle = undefined;
	                //axis.axisLine = undefined;
	
	                // Placeholder for plotlines and plotbands groups
	                axis.plotLinesAndBandsGroups = {};
	
	                // Shorthand types
	                axis.isLog = type === 'logarithmic';
	                axis.isDatetimeAxis = isDatetimeAxis;
	                axis.positiveValuesOnly = axis.isLog && !axis.allowNegativeLog;
	
	                // Flag, if axis is linked to another axis
	                axis.isLinked = defined(options.linkedTo);
	                // Linked axis.
	                //axis.linkedParent = undefined;
	
	                // Major ticks
	                axis.ticks = {};
	                axis.labelEdge = [];
	                // Minor ticks
	                axis.minorTicks = {};
	
	                // List of plotLines/Bands
	                axis.plotLinesAndBands = [];
	
	                // Alternate bands
	                axis.alternateBands = {};
	
	                // Axis metrics
	                //axis.left = undefined;
	                //axis.top = undefined;
	                //axis.width = undefined;
	                //axis.height = undefined;
	                //axis.bottom = undefined;
	                //axis.right = undefined;
	                //axis.transA = undefined;
	                //axis.transB = undefined;
	                //axis.oldTransA = undefined;
	                axis.len = 0;
	                //axis.oldMin = undefined;
	                //axis.oldMax = undefined;
	                //axis.oldUserMin = undefined;
	                //axis.oldUserMax = undefined;
	                //axis.oldAxisLength = undefined;
	                axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;
	                axis.range = options.range;
	                axis.offset = options.offset || 0;
	
	
	                // Dictionary for stacks
	                axis.stacks = {};
	                axis.oldStacks = {};
	                axis.stacksTouched = 0;
	
	                // Min and max in the data
	                //axis.dataMin = undefined,
	                //axis.dataMax = undefined,
	
	                /**
	                 * The maximum value of the axis. In a logarithmic axis, this is the
	                 * logarithm of the real value, and the real value can be obtained from
	                 * {@link Axis#getExtremes}.
	                 *
	                 * @name max
	                 * @memberOf Axis
	                 * @type {Number}
	                 */
	                axis.max = null;
	                /**
	                 * The minimum value of the axis. In a logarithmic axis, this is the
	                 * logarithm of the real value, and the real value can be obtained from
	                 * {@link Axis#getExtremes}.
	                 *
	                 * @name min
	                 * @memberOf Axis
	                 * @type {Number}
	                 */
	                axis.min = null;
	
	                // User set min and max
	                //axis.userMin = undefined,
	                //axis.userMax = undefined,
	
	                /**
	                 * The processed crosshair options.
	                 *
	                 * @name crosshair
	                 * @memberOf Axis
	                 * @type {AxisCrosshairOptions}
	                 */
	                axis.crosshair = pick(
	                    options.crosshair,
	                    splat(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1],
	                    false
	                );
	
	                var events = axis.options.events;
	
	                // Register. Don't add it again on Axis.update().
	                if (inArray(axis, chart.axes) === -1) { // 
	                    if (isXAxis) { // #2713
	                        chart.axes.splice(chart.xAxis.length, 0, axis);
	                    } else {
	                        chart.axes.push(axis);
	                    }
	
	                    chart[axis.coll].push(axis);
	                }
	
	                /**
	                 * All series associated to the axis.
	                 *
	                 * @name series
	                 * @memberOf Axis
	                 * @type {Array.<Series>}
	                 */
	                axis.series = axis.series || []; // populated by Series
	
	                // Reversed axis
	                if (
	                    chart.inverted &&
	                    !axis.isZAxis &&
	                    isXAxis &&
	                    axis.reversed === undefined
	                ) {
	                    axis.reversed = true;
	                }
	
	                // register event listeners
	                objectEach(events, function(event, eventType) {
	                    addEvent(axis, eventType, event);
	                });
	
	                // extend logarithmic axis
	                axis.lin2log = options.linearToLogConverter || axis.lin2log;
	                if (axis.isLog) {
	                    axis.val2lin = axis.log2lin;
	                    axis.lin2val = axis.lin2log;
	                }
	            },
	
	            /**
	             * Merge and set options.
	             *
	             * @private
	             */
	            setOptions: function(userOptions) {
	                this.options = merge(
	                    this.defaultOptions,
	                    this.coll === 'yAxis' && this.defaultYAxisOptions, [
	                        this.defaultTopAxisOptions,
	                        this.defaultRightAxisOptions,
	                        this.defaultBottomAxisOptions,
	                        this.defaultLeftAxisOptions
	                    ][this.side],
	                    merge(
	                        defaultOptions[this.coll], // if set in setOptions (#1053)
	                        userOptions
	                    )
	                );
	            },
	
	            /**
	             * The default label formatter. The context is a special config object for
	             * the label. In apps, use the {@link
	             * https://api.highcharts.com/highcharts/xAxis.labels.formatter|
	             * labels.formatter} instead except when a modification is needed.
	             *
	             * @private
	             */
	            defaultLabelFormatter: function() {
	                var axis = this.axis,
	                    value = this.value,
	                    categories = axis.categories,
	                    dateTimeLabelFormat = this.dateTimeLabelFormat,
	                    lang = defaultOptions.lang,
	                    numericSymbols = lang.numericSymbols,
	                    numSymMagnitude = lang.numericSymbolMagnitude || 1000,
	                    i = numericSymbols && numericSymbols.length,
	                    multi,
	                    ret,
	                    formatOption = axis.options.labels.format,
	
	                    // make sure the same symbol is added for all labels on a linear
	                    // axis
	                    numericSymbolDetector = axis.isLog ?
	                    Math.abs(value) :
	                    axis.tickInterval;
	
	                if (formatOption) {
	                    ret = format(formatOption, this);
	
	                } else if (categories) {
	                    ret = value;
	
	                } else if (dateTimeLabelFormat) { // datetime axis
	                    ret = H.dateFormat(dateTimeLabelFormat, value);
	
	                } else if (i && numericSymbolDetector >= 1000) {
	                    // Decide whether we should add a numeric symbol like k (thousands)
	                    // or M (millions). If we are to enable this in tooltip or other
	                    // places as well, we can move this logic to the numberFormatter and
	                    // enable it by a parameter.
	                    while (i-- && ret === undefined) {
	                        multi = Math.pow(numSymMagnitude, i + 1);
	                        if (
	                            numericSymbolDetector >= multi &&
	                            (value * 10) % multi === 0 &&
	                            numericSymbols[i] !== null &&
	                            value !== 0
	                        ) { // #5480
	                            ret = H.numberFormat(value / multi, -1) + numericSymbols[i];
	                        }
	                    }
	                }
	
	                if (ret === undefined) {
	                    if (Math.abs(value) >= 10000) { // add thousands separators
	                        ret = H.numberFormat(value, -1);
	                    } else { // small numbers
	                        ret = H.numberFormat(value, -1, undefined, ''); // #2466
	                    }
	                }
	
	                return ret;
	            },
	
	            /**
	             * Get the minimum and maximum for the series of each axis. The function
	             * analyzes the axis series and updates `this.dataMin` and `this.dataMax`.
	             *
	             * @private
	             */
	            getSeriesExtremes: function() {
	                var axis = this,
	                    chart = axis.chart;
	                axis.hasVisibleSeries = false;
	
	                // Reset properties in case we're redrawing (#3353)
	                axis.dataMin = axis.dataMax = axis.threshold = null;
	                axis.softThreshold = !axis.isXAxis;
	
	                if (axis.buildStacks) {
	                    axis.buildStacks();
	                }
	
	                // loop through this axis' series
	                each(axis.series, function(series) {
	
	                    if (series.visible || !chart.options.chart.ignoreHiddenSeries) {
	
	                        var seriesOptions = series.options,
	                            xData,
	                            threshold = seriesOptions.threshold,
	                            seriesDataMin,
	                            seriesDataMax;
	
	                        axis.hasVisibleSeries = true;
	
	                        // Validate threshold in logarithmic axes
	                        if (axis.positiveValuesOnly && threshold <= 0) {
	                            threshold = null;
	                        }
	
	                        // Get dataMin and dataMax for X axes
	                        if (axis.isXAxis) {
	                            xData = series.xData;
	                            if (xData.length) {
	                                // If xData contains values which is not numbers, then
	                                // filter them out. To prevent performance hit, we only
	                                // do this after we have already found seriesDataMin
	                                // because in most cases all data is valid. #5234.
	                                seriesDataMin = arrayMin(xData);
	                                if (!isNumber(seriesDataMin) &&
	                                    !(seriesDataMin instanceof Date) // #5010
	                                ) {
	                                    xData = grep(xData, function(x) {
	                                        return isNumber(x);
	                                    });
	                                    seriesDataMin = arrayMin(xData); // Do it again with valid data
	                                }
	
	                                axis.dataMin = Math.min(
	                                    pick(axis.dataMin, xData[0]),
	                                    seriesDataMin
	                                );
	                                axis.dataMax = Math.max(
	                                    pick(axis.dataMax, xData[0]),
	                                    arrayMax(xData)
	                                );
	
	                            }
	
	                            // Get dataMin and dataMax for Y axes, as well as handle
	                            // stacking and processed data
	                        } else {
	
	                            // Get this particular series extremes
	                            series.getExtremes();
	                            seriesDataMax = series.dataMax;
	                            seriesDataMin = series.dataMin;
	
	                            // Get the dataMin and dataMax so far. If percentage is
	                            // used, the min and max are always 0 and 100. If
	                            // seriesDataMin and seriesDataMax is null, then series
	                            // doesn't have active y data, we continue with nulls
	                            if (defined(seriesDataMin) && defined(seriesDataMax)) {
	                                axis.dataMin = Math.min(
	                                    pick(axis.dataMin, seriesDataMin),
	                                    seriesDataMin
	                                );
	                                axis.dataMax = Math.max(
	                                    pick(axis.dataMax, seriesDataMax),
	                                    seriesDataMax
	                                );
	                            }
	
	                            // Adjust to threshold
	                            if (defined(threshold)) {
	                                axis.threshold = threshold;
	                            }
	                            // If any series has a hard threshold, it takes precedence
	                            if (!seriesOptions.softThreshold ||
	                                axis.positiveValuesOnly
	                            ) {
	                                axis.softThreshold = false;
	                            }
	                        }
	                    }
	                });
	            },
	
	            /**
	             * Translate from axis value to pixel position on the chart, or back. Use
	             * the `toPixels` and `toValue` functions in applications.
	             *
	             * @private
	             */
	            translate: function(val, backwards, cvsCoord, old, handleLog, pointPlacement) {
	                var axis = this.linkedParent || this, // #1417
	                    sign = 1,
	                    cvsOffset = 0,
	                    localA = old ? axis.oldTransA : axis.transA,
	                    localMin = old ? axis.oldMin : axis.min,
	                    returnValue,
	                    minPixelPadding = axis.minPixelPadding,
	                    doPostTranslate = (axis.isOrdinal || axis.isBroken || (axis.isLog && handleLog)) && axis.lin2val;
	
	                if (!localA) {
	                    localA = axis.transA;
	                }
	
	                // In vertical axes, the canvas coordinates start from 0 at the top like in
	                // SVG.
	                if (cvsCoord) {
	                    sign *= -1; // canvas coordinates inverts the value
	                    cvsOffset = axis.len;
	                }
	
	                // Handle reversed axis
	                if (axis.reversed) {
	                    sign *= -1;
	                    cvsOffset -= sign * (axis.sector || axis.len);
	                }
	
	                // From pixels to value
	                if (backwards) { // reverse translation
	
	                    val = val * sign + cvsOffset;
	                    val -= minPixelPadding;
	                    returnValue = val / localA + localMin; // from chart pixel to value
	                    if (doPostTranslate) { // log and ordinal axes
	                        returnValue = axis.lin2val(returnValue);
	                    }
	
	                    // From value to pixels
	                } else {
	                    if (doPostTranslate) { // log and ordinal axes
	                        val = axis.val2lin(val);
	                    }
	                    returnValue = sign * (val - localMin) * localA + cvsOffset +
	                        (sign * minPixelPadding) +
	                        (isNumber(pointPlacement) ? localA * pointPlacement : 0);
	                }
	
	                return returnValue;
	            },
	
	            /**
	             * Translate a value in terms of axis units into pixels within the chart.
	             * 
	             * @param  {Number} value
	             *         A value in terms of axis units.
	             * @param  {Boolean} paneCoordinates
	             *         Whether to return the pixel coordinate relative to the chart or
	             *         just the axis/pane itself.
	             * @return {Number} Pixel position of the value on the chart or axis.
	             */
	            toPixels: function(value, paneCoordinates) {
	                return this.translate(value, false, !this.horiz, null, true) +
	                    (paneCoordinates ? 0 : this.pos);
	            },
	
	            /**
	             * Translate a pixel position along the axis to a value in terms of axis
	             * units.
	             * @param  {Number} pixel
	             *         The pixel value coordinate.
	             * @param  {Boolean} paneCoordiantes
	             *         Whether the input pixel is relative to the chart or just the
	             *         axis/pane itself.
	             * @return {Number} The axis value.
	             */
	            toValue: function(pixel, paneCoordinates) {
	                return this.translate(
	                    pixel - (paneCoordinates ? 0 : this.pos),
	                    true, !this.horiz,
	                    null,
	                    true
	                );
	            },
	
	            /**
	             * Create the path for a plot line that goes from the given value on
	             * this axis, across the plot to the opposite side. Also used internally for
	             * grid lines and crosshairs.
	             * 
	             * @param  {Number} value
	             *         Axis value.
	             * @param  {Number} [lineWidth=1]
	             *         Used for calculation crisp line coordinates.
	             * @param  {Boolean} [old=false]
	             *         Use old coordinates (for resizing and rescaling).
	             * @param  {Boolean} [force=false]
	             *         If `false`, the function will return null when it falls outside
	             *         the axis bounds.
	             * @param  {Number} [translatedValue]
	             *         If given, return the plot line path of a pixel position on the
	             *         axis.
	             *
	             * @return {Array.<String|Number>}
	             *         The SVG path definition for the plot line.
	             */
	            getPlotLinePath: function(value, lineWidth, old, force, translatedValue) {
	                var axis = this,
	                    chart = axis.chart,
	                    axisLeft = axis.left,
	                    axisTop = axis.top,
	                    x1,
	                    y1,
	                    x2,
	                    y2,
	                    cHeight = (old && chart.oldChartHeight) || chart.chartHeight,
	                    cWidth = (old && chart.oldChartWidth) || chart.chartWidth,
	                    skip,
	                    transB = axis.transB,
	                    /**
	                     * Check if x is between a and b. If not, either move to a/b or skip,
	                     * depending on the force parameter.
	                     */
	                    between = function(x, a, b) {
	                        if (x < a || x > b) {
	                            if (force) {
	                                x = Math.min(Math.max(a, x), b);
	                            } else {
	                                skip = true;
	                            }
	                        }
	                        return x;
	                    };
	
	                translatedValue = pick(translatedValue, axis.translate(value, null, null, old));
	                x1 = x2 = Math.round(translatedValue + transB);
	                y1 = y2 = Math.round(cHeight - translatedValue - transB);
	                if (!isNumber(translatedValue)) { // no min or max
	                    skip = true;
	
	                } else if (axis.horiz) {
	                    y1 = axisTop;
	                    y2 = cHeight - axis.bottom;
	                    x1 = x2 = between(x1, axisLeft, axisLeft + axis.width);
	                } else {
	                    x1 = axisLeft;
	                    x2 = cWidth - axis.right;
	                    y1 = y2 = between(y1, axisTop, axisTop + axis.height);
	                }
	                return skip && !force ?
	                    null :
	                    chart.renderer.crispLine(['M', x1, y1, 'L', x2, y2], lineWidth || 1);
	            },
	
	            /**
	             * Internal function to et the tick positions of a linear axis to round
	             * values like whole tens or every five.
	             *
	             * @param  {Number} tickInterval
	             *         The normalized tick interval
	             * @param  {Number} min
	             *         Axis minimum.
	             * @param  {Number} max
	             *         Axis maximum.
	             *
	             * @return {Array.<Number>}
	             *         An array of axis values where ticks should be placed.
	             */
	            getLinearTickPositions: function(tickInterval, min, max) {
	                var pos,
	                    lastPos,
	                    roundedMin = correctFloat(Math.floor(min / tickInterval) * tickInterval),
	                    roundedMax = correctFloat(Math.ceil(max / tickInterval) * tickInterval),
	                    tickPositions = [];
	
	                // For single points, add a tick regardless of the relative position
	                // (#2662, #6274)
	                if (this.single) {
	                    return [min];
	                }
	
	                // Populate the intermediate values
	                pos = roundedMin;
	                while (pos <= roundedMax) {
	
	                    // Place the tick on the rounded value
	                    tickPositions.push(pos);
	
	                    // Always add the raw tickInterval, not the corrected one.
	                    pos = correctFloat(pos + tickInterval);
	
	                    // If the interval is not big enough in the current min - max range to actually increase
	                    // the loop variable, we need to break out to prevent endless loop. Issue #619
	                    if (pos === lastPos) {
	                        break;
	                    }
	
	                    // Record the last value
	                    lastPos = pos;
	                }
	                return tickPositions;
	            },
	
	            /**
	             * Internal function to return the minor tick positions. For logarithmic
	             * axes, the same logic as for major ticks is reused.
	             *
	             * @return {Array.<Number>}
	             *         An array of axis values where ticks should be placed.
	             */
	            getMinorTickPositions: function() {
	                var axis = this,
	                    options = axis.options,
	                    tickPositions = axis.tickPositions,
	                    minorTickInterval = axis.minorTickInterval,
	                    minorTickPositions = [],
	                    pos,
	                    pointRangePadding = axis.pointRangePadding || 0,
	                    min = axis.min - pointRangePadding, // #1498
	                    max = axis.max + pointRangePadding, // #1498
	                    range = max - min;
	
	                // If minor ticks get too dense, they are hard to read, and may cause long running script. So we don't draw them.
	                if (range && range / minorTickInterval < axis.len / 3) { // #3875
	
	                    if (axis.isLog) {
	                        // For each interval in the major ticks, compute the minor ticks
	                        // separately.
	                        each(this.paddedTicks, function(pos, i, paddedTicks) {
	                            if (i) {
	                                minorTickPositions.push.apply(
	                                    minorTickPositions,
	                                    axis.getLogTickPositions(
	                                        minorTickInterval,
	                                        paddedTicks[i - 1],
	                                        paddedTicks[i],
	                                        true
	                                    )
	                                );
	                            }
	                        });
	
	                    } else if (axis.isDatetimeAxis && options.minorTickInterval === 'auto') { // #1314
	                        minorTickPositions = minorTickPositions.concat(
	                            axis.getTimeTicks(
	                                axis.normalizeTimeTickInterval(minorTickInterval),
	                                min,
	                                max,
	                                options.startOfWeek
	                            )
	                        );
	                    } else {
	                        for (
	                            pos = min + (tickPositions[0] - min) % minorTickInterval; pos <= max; pos += minorTickInterval
	                        ) {
	                            // Very, very, tight grid lines (#5771)
	                            if (pos === minorTickPositions[0]) {
	                                break;
	                            }
	                            minorTickPositions.push(pos);
	                        }
	                    }
	                }
	
	                if (minorTickPositions.length !== 0) {
	                    axis.trimTicks(minorTickPositions); // #3652 #3743 #1498 #6330
	                }
	                return minorTickPositions;
	            },
	
	            /**
	             * Adjust the min and max for the minimum range. Keep in mind that the series data is
	             * not yet processed, so we don't have information on data cropping and grouping, or
	             * updated axis.pointRange or series.pointRange. The data can't be processed until
	             * we have finally established min and max.
	             *
	             * @private
	             */
	            adjustForMinRange: function() {
	                var axis = this,
	                    options = axis.options,
	                    min = axis.min,
	                    max = axis.max,
	                    zoomOffset,
	                    spaceAvailable,
	                    closestDataRange,
	                    i,
	                    distance,
	                    xData,
	                    loopLength,
	                    minArgs,
	                    maxArgs,
	                    minRange;
	
	                // Set the automatic minimum range based on the closest point distance
	                if (axis.isXAxis && axis.minRange === undefined && !axis.isLog) {
	
	                    if (defined(options.min) || defined(options.max)) {
	                        axis.minRange = null; // don't do this again
	
	                    } else {
	
	                        // Find the closest distance between raw data points, as opposed to
	                        // closestPointRange that applies to processed points (cropped and grouped)
	                        each(axis.series, function(series) {
	                            xData = series.xData;
	                            loopLength = series.xIncrement ? 1 : xData.length - 1;
	                            for (i = loopLength; i > 0; i--) {
	                                distance = xData[i] - xData[i - 1];
	                                if (closestDataRange === undefined || distance < closestDataRange) {
	                                    closestDataRange = distance;
	                                }
	                            }
	                        });
	                        axis.minRange = Math.min(closestDataRange * 5, axis.dataMax - axis.dataMin);
	                    }
	                }
	
	                // if minRange is exceeded, adjust
	                if (max - min < axis.minRange) {
	
	                    spaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange;
	                    minRange = axis.minRange;
	                    zoomOffset = (minRange - max + min) / 2;
	
	                    // if min and max options have been set, don't go beyond it
	                    minArgs = [min - zoomOffset, pick(options.min, min - zoomOffset)];
	                    if (spaceAvailable) { // if space is available, stay within the data range
	                        minArgs[2] = axis.isLog ? axis.log2lin(axis.dataMin) : axis.dataMin;
	                    }
	                    min = arrayMax(minArgs);
	
	                    maxArgs = [min + minRange, pick(options.max, min + minRange)];
	                    if (spaceAvailable) { // if space is availabe, stay within the data range
	                        maxArgs[2] = axis.isLog ? axis.log2lin(axis.dataMax) : axis.dataMax;
	                    }
	
	                    max = arrayMin(maxArgs);
	
	                    // now if the max is adjusted, adjust the min back
	                    if (max - min < minRange) {
	                        minArgs[0] = max - minRange;
	                        minArgs[1] = pick(options.min, max - minRange);
	                        min = arrayMax(minArgs);
	                    }
	                }
	
	                // Record modified extremes
	                axis.min = min;
	                axis.max = max;
	            },
	
	            /**
	             * Find the closestPointRange across all series.
	             *
	             * @private
	             */
	            getClosest: function() {
	                var ret;
	
	                if (this.categories) {
	                    ret = 1;
	                } else {
	                    each(this.series, function(series) {
	                        var seriesClosest = series.closestPointRange,
	                            visible = series.visible ||
	                            !series.chart.options.chart.ignoreHiddenSeries;
	
	                        if (!series.noSharedTooltip &&
	                            defined(seriesClosest) &&
	                            visible
	                        ) {
	                            ret = defined(ret) ?
	                                Math.min(ret, seriesClosest) :
	                                seriesClosest;
	                        }
	                    });
	                }
	                return ret;
	            },
	
	            /**
	             * When a point name is given and no x, search for the name in the existing
	             * categories, or if categories aren't provided, search names or create a
	             * new category (#2522).
	             *
	             * @private
	             *
	             * @param  {Point}
	             *         The point to inspect.
	             *
	             * @return {Number}
	             *         The X value that the point is given.
	             */
	            nameToX: function(point) {
	                var explicitCategories = isArray(this.categories),
	                    names = explicitCategories ? this.categories : this.names,
	                    nameX = point.options.x,
	                    x;
	
	                point.series.requireSorting = false;
	
	                if (!defined(nameX)) {
	                    nameX = this.options.uniqueNames === false ?
	                        point.series.autoIncrement() :
	                        inArray(point.name, names);
	                }
	                if (nameX === -1) { // The name is not found in currenct categories
	                    if (!explicitCategories) {
	                        x = names.length;
	                    }
	                } else {
	                    x = nameX;
	                }
	
	                // Write the last point's name to the names array
	                if (x !== undefined) {
	                    this.names[x] = point.name;
	                }
	
	                return x;
	            },
	
	            /**
	             * When changes have been done to series data, update the axis.names.
	             *
	             * @private
	             */
	            updateNames: function() {
	                var axis = this;
	
	                if (this.names.length > 0) {
	                    this.names.length = 0;
	                    this.minRange = this.userMinRange; // Reset
	                    each(this.series || [], function(series) {
	
	                        // Reset incrementer (#5928)
	                        series.xIncrement = null;
	
	                        // When adding a series, points are not yet generated
	                        if (!series.points || series.isDirtyData) {
	                            series.processData();
	                            series.generatePoints();
	                        }
	
	                        each(series.points, function(point, i) {
	                            var x;
	                            if (point.options) {
	                                x = axis.nameToX(point);
	                                if (x !== undefined && x !== point.x) {
	                                    point.x = x;
	                                    series.xData[i] = x;
	                                }
	                            }
	                        });
	                    });
	                }
	            },
	
	            /**
	             * Update translation information.
	             *
	             * @private
	             */
	            setAxisTranslation: function(saveOld) {
	                var axis = this,
	                    range = axis.max - axis.min,
	                    pointRange = axis.axisPointRange || 0,
	                    closestPointRange,
	                    minPointOffset = 0,
	                    pointRangePadding = 0,
	                    linkedParent = axis.linkedParent,
	                    ordinalCorrection,
	                    hasCategories = !!axis.categories,
	                    transA = axis.transA,
	                    isXAxis = axis.isXAxis;
	
	                // Adjust translation for padding. Y axis with categories need to go through the same (#1784).
	                if (isXAxis || hasCategories || pointRange) {
	
	                    // Get the closest points
	                    closestPointRange = axis.getClosest();
	
	                    if (linkedParent) {
	                        minPointOffset = linkedParent.minPointOffset;
	                        pointRangePadding = linkedParent.pointRangePadding;
	                    } else {
	                        each(axis.series, function(series) {
	                            var seriesPointRange = hasCategories ?
	                                1 :
	                                (isXAxis ?
	                                    pick(series.options.pointRange, closestPointRange, 0) :
	                                    (axis.axisPointRange || 0)), // #2806
	                                pointPlacement = series.options.pointPlacement;
	
	                            pointRange = Math.max(pointRange, seriesPointRange);
	
	                            if (!axis.single) {
	                                // minPointOffset is the value padding to the left of the axis in order to make
	                                // room for points with a pointRange, typically columns. When the pointPlacement option
	                                // is 'between' or 'on', this padding does not apply.
	                                minPointOffset = Math.max(
	                                    minPointOffset,
	                                    isString(pointPlacement) ? 0 : seriesPointRange / 2
	                                );
	
	                                // Determine the total padding needed to the length of the axis to make room for the
	                                // pointRange. If the series' pointPlacement is 'on', no padding is added.
	                                pointRangePadding = Math.max(
	                                    pointRangePadding,
	                                    pointPlacement === 'on' ? 0 : seriesPointRange
	                                );
	                            }
	                        });
	                    }
	
	                    // Record minPointOffset and pointRangePadding
	                    ordinalCorrection = axis.ordinalSlope && closestPointRange ? axis.ordinalSlope / closestPointRange : 1; // #988, #1853
	                    axis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;
	                    axis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection;
	
	                    // pointRange means the width reserved for each point, like in a column chart
	                    axis.pointRange = Math.min(pointRange, range);
	
	                    // closestPointRange means the closest distance between points. In columns
	                    // it is mostly equal to pointRange, but in lines pointRange is 0 while closestPointRange
	                    // is some other value
	                    if (isXAxis) {
	                        axis.closestPointRange = closestPointRange;
	                    }
	                }
	
	                // Secondary values
	                if (saveOld) {
	                    axis.oldTransA = transA;
	                }
	                axis.translationSlope = axis.transA = transA =
	                    axis.options.staticScale ||
	                    axis.len / ((range + pointRangePadding) || 1);
	                axis.transB = axis.horiz ? axis.left : axis.bottom; // translation addend
	                axis.minPixelPadding = transA * minPointOffset;
	            },
	
	            minFromRange: function() {
	                return this.max - this.range;
	            },
	
	            /**
	             * Set the tick positions to round values and optionally extend the extremes
	             * to the nearest tick.
	             *
	             * @private
	             */
	            setTickInterval: function(secondPass) {
	                var axis = this,
	                    chart = axis.chart,
	                    options = axis.options,
	                    isLog = axis.isLog,
	                    log2lin = axis.log2lin,
	                    isDatetimeAxis = axis.isDatetimeAxis,
	                    isXAxis = axis.isXAxis,
	                    isLinked = axis.isLinked,
	                    maxPadding = options.maxPadding,
	                    minPadding = options.minPadding,
	                    length,
	                    linkedParentExtremes,
	                    tickIntervalOption = options.tickInterval,
	                    minTickInterval,
	                    tickPixelIntervalOption = options.tickPixelInterval,
	                    categories = axis.categories,
	                    threshold = axis.threshold,
	                    softThreshold = axis.softThreshold,
	                    thresholdMin,
	                    thresholdMax,
	                    hardMin,
	                    hardMax;
	
	                if (!isDatetimeAxis && !categories && !isLinked) {
	                    this.getTickAmount();
	                }
	
	                // Min or max set either by zooming/setExtremes or initial options
	                hardMin = pick(axis.userMin, options.min);
	                hardMax = pick(axis.userMax, options.max);
	
	                // Linked axis gets the extremes from the parent axis
	                if (isLinked) {
	                    axis.linkedParent = chart[axis.coll][options.linkedTo];
	                    linkedParentExtremes = axis.linkedParent.getExtremes();
	                    axis.min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);
	                    axis.max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);
	                    if (options.type !== axis.linkedParent.options.type) {
	                        H.error(11, 1); // Can't link axes of different type
	                    }
	
	                    // Initial min and max from the extreme data values
	                } else {
	
	                    // Adjust to hard threshold
	                    if (!softThreshold && defined(threshold)) {
	                        if (axis.dataMin >= threshold) {
	                            thresholdMin = threshold;
	                            minPadding = 0;
	                        } else if (axis.dataMax <= threshold) {
	                            thresholdMax = threshold;
	                            maxPadding = 0;
	                        }
	                    }
	
	                    axis.min = pick(hardMin, thresholdMin, axis.dataMin);
	                    axis.max = pick(hardMax, thresholdMax, axis.dataMax);
	
	                }
	
	                if (isLog) {
	                    if (
	                        axis.positiveValuesOnly &&
	                        !secondPass &&
	                        Math.min(axis.min, pick(axis.dataMin, axis.min)) <= 0
	                    ) { // #978
	                        H.error(10, 1); // Can't plot negative values on log axis
	                    }
	                    // The correctFloat cures #934, float errors on full tens. But it
	                    // was too aggressive for #4360 because of conversion back to lin,
	                    // therefore use precision 15.
	                    axis.min = correctFloat(log2lin(axis.min), 15);
	                    axis.max = correctFloat(log2lin(axis.max), 15);
	                }
	
	                // handle zoomed range
	                if (axis.range && defined(axis.max)) {
	                    axis.userMin = axis.min = hardMin = Math.max(axis.dataMin, axis.minFromRange()); // #618, #6773
	                    axis.userMax = hardMax = axis.max;
	
	                    axis.range = null; // don't use it when running setExtremes
	                }
	
	                // Hook for Highstock Scroller. Consider combining with beforePadding.
	                fireEvent(axis, 'foundExtremes');
	
	                // Hook for adjusting this.min and this.max. Used by bubble series.
	                if (axis.beforePadding) {
	                    axis.beforePadding();
	                }
	
	                // adjust min and max for the minimum range
	                axis.adjustForMinRange();
	
	                // Pad the values to get clear of the chart's edges. To avoid tickInterval taking the padding
	                // into account, we do this after computing tick interval (#1337).
	                if (!categories && !axis.axisPointRange && !axis.usePercentage && !isLinked && defined(axis.min) && defined(axis.max)) {
	                    length = axis.max - axis.min;
	                    if (length) {
	                        if (!defined(hardMin) && minPadding) {
	                            axis.min -= length * minPadding;
	                        }
	                        if (!defined(hardMax) && maxPadding) {
	                            axis.max += length * maxPadding;
	                        }
	                    }
	                }
	
	                // Handle options for floor, ceiling, softMin and softMax (#6359)
	                if (isNumber(options.softMin)) {
	                    axis.min = Math.min(axis.min, options.softMin);
	                }
	                if (isNumber(options.softMax)) {
	                    axis.max = Math.max(axis.max, options.softMax);
	                }
	                if (isNumber(options.floor)) {
	                    axis.min = Math.max(axis.min, options.floor);
	                }
	                if (isNumber(options.ceiling)) {
	                    axis.max = Math.min(axis.max, options.ceiling);
	                }
	
	
	                // When the threshold is soft, adjust the extreme value only if
	                // the data extreme and the padded extreme land on either side of the threshold. For example,
	                // a series of [0, 1, 2, 3] would make the yAxis add a tick for -1 because of the
	                // default minPadding and startOnTick options. This is prevented by the softThreshold
	                // option.
	                if (softThreshold && defined(axis.dataMin)) {
	                    threshold = threshold || 0;
	                    if (!defined(hardMin) && axis.min < threshold && axis.dataMin >= threshold) {
	                        axis.min = threshold;
	                    } else if (!defined(hardMax) && axis.max > threshold && axis.dataMax <= threshold) {
	                        axis.max = threshold;
	                    }
	                }
	
	
	                // get tickInterval
	                if (axis.min === axis.max || axis.min === undefined || axis.max === undefined) {
	                    axis.tickInterval = 1;
	                } else if (isLinked && !tickIntervalOption &&
	                    tickPixelIntervalOption === axis.linkedParent.options.tickPixelInterval) {
	                    axis.tickInterval = tickIntervalOption = axis.linkedParent.tickInterval;
	                } else {
	                    axis.tickInterval = pick(
	                        tickIntervalOption,
	                        this.tickAmount ? ((axis.max - axis.min) / Math.max(this.tickAmount - 1, 1)) : undefined,
	                        categories ? // for categoried axis, 1 is default, for linear axis use tickPix
	                        1 :
	                        // don't let it be more than the data range
	                        (axis.max - axis.min) * tickPixelIntervalOption / Math.max(axis.len, tickPixelIntervalOption)
	                    );
	                }
	
	                // Now we're finished detecting min and max, crop and group series data. This
	                // is in turn needed in order to find tick positions in ordinal axes.
	                if (isXAxis && !secondPass) {
	                    each(axis.series, function(series) {
	                        series.processData(axis.min !== axis.oldMin || axis.max !== axis.oldMax);
	                    });
	                }
	
	                // set the translation factor used in translate function
	                axis.setAxisTranslation(true);
	
	                // hook for ordinal axes and radial axes
	                if (axis.beforeSetTickPositions) {
	                    axis.beforeSetTickPositions();
	                }
	
	                // hook for extensions, used in Highstock ordinal axes
	                if (axis.postProcessTickInterval) {
	                    axis.tickInterval = axis.postProcessTickInterval(axis.tickInterval);
	                }
	
	                // In column-like charts, don't cramp in more ticks than there are points (#1943, #4184)
	                if (axis.pointRange && !tickIntervalOption) {
	                    axis.tickInterval = Math.max(axis.pointRange, axis.tickInterval);
	                }
	
	                // Before normalizing the tick interval, handle minimum tick interval. This applies only if tickInterval is not defined.
	                minTickInterval = pick(options.minTickInterval, axis.isDatetimeAxis && axis.closestPointRange);
	                if (!tickIntervalOption && axis.tickInterval < minTickInterval) {
	                    axis.tickInterval = minTickInterval;
	                }
	
	                // for linear axes, get magnitude and normalize the interval
	                if (!isDatetimeAxis && !isLog && !tickIntervalOption) {
	                    axis.tickInterval = normalizeTickInterval(
	                        axis.tickInterval,
	                        null,
	                        getMagnitude(axis.tickInterval),
	                        // If the tick interval is between 0.5 and 5 and the axis max is in the order of
	                        // thousands, chances are we are dealing with years. Don't allow decimals. #3363.
	                        pick(options.allowDecimals, !(axis.tickInterval > 0.5 && axis.tickInterval < 5 && axis.max > 1000 && axis.max < 9999)), !!this.tickAmount
	                    );
	                }
	
	                // Prevent ticks from getting so close that we can't draw the labels
	                if (!this.tickAmount) {
	                    axis.tickInterval = axis.unsquish();
	                }
	
	                this.setTickPositions();
	            },
	
	            /**
	             * Now we have computed the normalized tickInterval, get the tick positions
	             */
	            setTickPositions: function() {
	
	                var options = this.options,
	                    tickPositions,
	                    tickPositionsOption = options.tickPositions,
	                    tickPositioner = options.tickPositioner,
	                    startOnTick = options.startOnTick,
	                    endOnTick = options.endOnTick;
	
	                // Set the tickmarkOffset
	                this.tickmarkOffset = (this.categories && options.tickmarkPlacement === 'between' &&
	                    this.tickInterval === 1) ? 0.5 : 0; // #3202
	
	
	                // get minorTickInterval
	                this.minorTickInterval = options.minorTickInterval === 'auto' && this.tickInterval ?
	                    this.tickInterval / 5 : options.minorTickInterval;
	
	                // When there is only one point, or all points have the same value on
	                // this axis, then min and max are equal and tickPositions.length is 0
	                // or 1. In this case, add some padding in order to center the point,
	                // but leave it with one tick. #1337.
	                this.single =
	                    this.min === this.max &&
	                    defined(this.min) &&
	                    !this.tickAmount &&
	                    (
	                        // Data is on integer (#6563)
	                        parseInt(this.min, 10) === this.min ||
	
	                        // Between integers and decimals are not allowed (#6274)
	                        options.allowDecimals !== false
	                    );
	
	                // Find the tick positions
	                this.tickPositions = tickPositions = tickPositionsOption && tickPositionsOption.slice(); // Work on a copy (#1565)
	                if (!tickPositions) {
	
	                    if (this.isDatetimeAxis) {
	                        tickPositions = this.getTimeTicks(
	                            this.normalizeTimeTickInterval(
	                                this.tickInterval,
	                                options.units
	                            ),
	                            this.min,
	                            this.max,
	                            options.startOfWeek,
	                            this.ordinalPositions,
	                            this.closestPointRange,
	                            true
	                        );
	                    } else if (this.isLog) {
	                        tickPositions = this.getLogTickPositions(
	                            this.tickInterval,
	                            this.min,
	                            this.max
	                        );
	                    } else {
	                        tickPositions = this.getLinearTickPositions(
	                            this.tickInterval,
	                            this.min,
	                            this.max
	                        );
	                    }
	
	                    // Too dense ticks, keep only the first and last (#4477)
	                    if (tickPositions.length > this.len) {
	                        tickPositions = [tickPositions[0], tickPositions.pop()];
	                    }
	
	                    this.tickPositions = tickPositions;
	
	                    // Run the tick positioner callback, that allows modifying auto tick positions.
	                    if (tickPositioner) {
	                        tickPositioner = tickPositioner.apply(this, [this.min, this.max]);
	                        if (tickPositioner) {
	                            this.tickPositions = tickPositions = tickPositioner;
	                        }
	                    }
	
	                }
	
	                // Reset min/max or remove extremes based on start/end on tick
	                this.paddedTicks = tickPositions.slice(0); // Used for logarithmic minor
	                this.trimTicks(tickPositions, startOnTick, endOnTick);
	                if (!this.isLinked) {
	
	                    // Substract half a unit (#2619, #2846, #2515, #3390),
	                    // but not in case of multiple ticks (#6897)
	                    if (this.single && tickPositions.length < 2) {
	                        this.min -= 0.5;
	                        this.max += 0.5;
	                    }
	                    if (!tickPositionsOption && !tickPositioner) {
	                        this.adjustTickAmount();
	                    }
	                }
	            },
	
	            /**
	             * Handle startOnTick and endOnTick by either adapting to padding min/max or
	             * rounded min/max. Also handle single data points.
	             *
	             * @private
	             */
	            trimTicks: function(tickPositions, startOnTick, endOnTick) {
	                var roundedMin = tickPositions[0],
	                    roundedMax = tickPositions[tickPositions.length - 1],
	                    minPointOffset = this.minPointOffset || 0;
	
	                if (!this.isLinked) {
	                    if (startOnTick && roundedMin !== -Infinity) { // #6502
	                        this.min = roundedMin;
	                    } else {
	                        while (this.min - minPointOffset > tickPositions[0]) {
	                            tickPositions.shift();
	                        }
	                    }
	
	                    if (endOnTick) {
	                        this.max = roundedMax;
	                    } else {
	                        while (this.max + minPointOffset < tickPositions[tickPositions.length - 1]) {
	                            tickPositions.pop();
	                        }
	                    }
	
	                    // If no tick are left, set one tick in the middle (#3195)
	                    if (tickPositions.length === 0 && defined(roundedMin)) {
	                        tickPositions.push((roundedMax + roundedMin) / 2);
	                    }
	                }
	            },
	
	            /**
	             * Check if there are multiple axes in the same pane.
	             *
	             * @private
	             * @return {Boolean}
	             *         True if there are other axes.
	             */
	            alignToOthers: function() {
	                var others = {}, // Whether there is another axis to pair with this one
	                    hasOther,
	                    options = this.options;
	
	                if (
	                    // Only if alignTicks is true
	                    this.chart.options.chart.alignTicks !== false &&
	                    options.alignTicks !== false &&
	
	                    // Don't try to align ticks on a log axis, they are not evenly
	                    // spaced (#6021)
	                    !this.isLog
	                ) {
	                    each(this.chart[this.coll], function(axis) {
	                        var otherOptions = axis.options,
	                            horiz = axis.horiz,
	                            key = [
	                                horiz ? otherOptions.left : otherOptions.top,
	                                otherOptions.width,
	                                otherOptions.height,
	                                otherOptions.pane
	                            ].join(',');
	
	
	                        if (axis.series.length) { // #4442
	                            if (others[key]) {
	                                hasOther = true; // #4201
	                            } else {
	                                others[key] = 1;
	                            }
	                        }
	                    });
	                }
	                return hasOther;
	            },
	
	            /**
	             * Find the max ticks of either the x and y axis collection, and record it
	             * in `this.tickAmount`.
	             *
	             * @private
	             */
	            getTickAmount: function() {
	                var options = this.options,
	                    tickAmount = options.tickAmount,
	                    tickPixelInterval = options.tickPixelInterval;
	
	                if (!defined(options.tickInterval) && this.len < tickPixelInterval && !this.isRadial &&
	                    !this.isLog && options.startOnTick && options.endOnTick) {
	                    tickAmount = 2;
	                }
	
	                if (!tickAmount && this.alignToOthers()) {
	                    // Add 1 because 4 tick intervals require 5 ticks (including first and last)
	                    tickAmount = Math.ceil(this.len / tickPixelInterval) + 1;
	                }
	
	                // For tick amounts of 2 and 3, compute five ticks and remove the intermediate ones. This
	                // prevents the axis from adding ticks that are too far away from the data extremes.
	                if (tickAmount < 4) {
	                    this.finalTickAmt = tickAmount;
	                    tickAmount = 5;
	                }
	
	                this.tickAmount = tickAmount;
	            },
	
	            /**
	             * When using multiple axes, adjust the number of ticks to match the highest
	             * number of ticks in that group.
	             *
	             * @private
	             */
	            adjustTickAmount: function() {
	                var tickInterval = this.tickInterval,
	                    tickPositions = this.tickPositions,
	                    tickAmount = this.tickAmount,
	                    finalTickAmt = this.finalTickAmt,
	                    currentTickAmount = tickPositions && tickPositions.length,
	                    i,
	                    len;
	
	                if (currentTickAmount < tickAmount) {
	                    while (tickPositions.length < tickAmount) {
	                        tickPositions.push(correctFloat(
	                            tickPositions[tickPositions.length - 1] + tickInterval
	                        ));
	                    }
	                    this.transA *= (currentTickAmount - 1) / (tickAmount - 1);
	                    this.max = tickPositions[tickPositions.length - 1];
	
	                    // We have too many ticks, run second pass to try to reduce ticks
	                } else if (currentTickAmount > tickAmount) {
	                    this.tickInterval *= 2;
	                    this.setTickPositions();
	                }
	
	                // The finalTickAmt property is set in getTickAmount
	                if (defined(finalTickAmt)) {
	                    i = len = tickPositions.length;
	                    while (i--) {
	                        if (
	                            (finalTickAmt === 3 && i % 2 === 1) || // Remove every other tick
	                            (finalTickAmt <= 2 && i > 0 && i < len - 1) // Remove all but first and last
	                        ) {
	                            tickPositions.splice(i, 1);
	                        }
	                    }
	                    this.finalTickAmt = undefined;
	                }
	            },
	
	            /**
	             * Set the scale based on data min and max, user set min and max or options.
	             * 
	             * @private
	             */
	            setScale: function() {
	                var axis = this,
	                    isDirtyData,
	                    isDirtyAxisLength;
	
	                axis.oldMin = axis.min;
	                axis.oldMax = axis.max;
	                axis.oldAxisLength = axis.len;
	
	                // set the new axisLength
	                axis.setAxisSize();
	                //axisLength = horiz ? axisWidth : axisHeight;
	                isDirtyAxisLength = axis.len !== axis.oldAxisLength;
	
	                // is there new data?
	                each(axis.series, function(series) {
	                    if (series.isDirtyData || series.isDirty ||
	                        series.xAxis.isDirty) { // when x axis is dirty, we need new data extremes for y as well
	                        isDirtyData = true;
	                    }
	                });
	
	                // do we really need to go through all this?
	                if (isDirtyAxisLength || isDirtyData || axis.isLinked || axis.forceRedraw ||
	                    axis.userMin !== axis.oldUserMin || axis.userMax !== axis.oldUserMax || axis.alignToOthers()) {
	
	                    if (axis.resetStacks) {
	                        axis.resetStacks();
	                    }
	
	                    axis.forceRedraw = false;
	
	                    // get data extremes if needed
	                    axis.getSeriesExtremes();
	
	                    // get fixed positions based on tickInterval
	                    axis.setTickInterval();
	
	                    // record old values to decide whether a rescale is necessary later on (#540)
	                    axis.oldUserMin = axis.userMin;
	                    axis.oldUserMax = axis.userMax;
	
	                    // Mark as dirty if it is not already set to dirty and extremes have changed. #595.
	                    if (!axis.isDirty) {
	                        axis.isDirty = isDirtyAxisLength || axis.min !== axis.oldMin || axis.max !== axis.oldMax;
	                    }
	                } else if (axis.cleanStacks) {
	                    axis.cleanStacks();
	                }
	            },
	
	            /**
	             * Set the minimum and maximum of the axes after render time. If the
	             * `startOnTick` and `endOnTick` options are true, the minimum and maximum
	             * values are rounded off to the nearest tick. To prevent this, these
	             * options can be set to false before calling setExtremes. Also, setExtremes
	             * will not allow a range lower than the `minRange` option, which by default
	             * is the range of five points.
	             * 
	             * @param  {Number} [newMin]
	             *         The new minimum value.
	             * @param  {Number} [newMax]
	             *         The new maximum value.
	             * @param  {Boolean} [redraw=true]
	             *         Whether to redraw the chart or wait for an explicit call to 
	             *         {@link Highcharts.Chart#redraw}
	             * @param  {AnimationOptions} [animation=true]
	             *         Enable or modify animations.
	             * @param  {Object} [eventArguments]
	             *         Arguments to be accessed in event handler.
	             *
	             * @sample highcharts/members/axis-setextremes/
	             *         Set extremes from a button
	             * @sample highcharts/members/axis-setextremes-datetime/
	             *         Set extremes on a datetime axis
	             * @sample highcharts/members/axis-setextremes-off-ticks/
	             *         Set extremes off ticks
	             * @sample stock/members/axis-setextremes/
	             *         Set extremes in Highstock
	             * @sample maps/members/axis-setextremes/
	             *         Set extremes in Highmaps
	             */
	            setExtremes: function(newMin, newMax, redraw, animation, eventArguments) {
	                var axis = this,
	                    chart = axis.chart;
	
	                redraw = pick(redraw, true); // defaults to true
	
	                each(axis.series, function(serie) {
	                    delete serie.kdTree;
	                });
	
	                // Extend the arguments with min and max
	                eventArguments = extend(eventArguments, {
	                    min: newMin,
	                    max: newMax
	                });
	
	                // Fire the event
	                fireEvent(axis, 'setExtremes', eventArguments, function() { // the default event handler
	
	                    axis.userMin = newMin;
	                    axis.userMax = newMax;
	                    axis.eventArgs = eventArguments;
	
	                    if (redraw) {
	                        chart.redraw(animation);
	                    }
	                });
	            },
	
	            /**
	             * Overridable method for zooming chart. Pulled out in a separate method to
	             * allow overriding in stock charts.
	             *
	             * @private
	             */
	            zoom: function(newMin, newMax) {
	                var dataMin = this.dataMin,
	                    dataMax = this.dataMax,
	                    options = this.options,
	                    min = Math.min(dataMin, pick(options.min, dataMin)),
	                    max = Math.max(dataMax, pick(options.max, dataMax));
	
	                if (newMin !== this.min || newMax !== this.max) { // #5790
	
	                    // Prevent pinch zooming out of range. Check for defined is for #1946. #1734.
	                    if (!this.allowZoomOutside) {
	                        // #6014, sometimes newMax will be smaller than min (or newMin will be larger than max).
	                        if (defined(dataMin)) {
	                            if (newMin < min) {
	                                newMin = min;
	                            }
	                            if (newMin > max) {
	                                newMin = max;
	                            }
	                        }
	                        if (defined(dataMax)) {
	                            if (newMax < min) {
	                                newMax = min;
	                            }
	                            if (newMax > max) {
	                                newMax = max;
	                            }
	                        }
	                    }
	
	                    // In full view, displaying the reset zoom button is not required
	                    this.displayBtn = newMin !== undefined || newMax !== undefined;
	
	                    // Do it
	                    this.setExtremes(
	                        newMin,
	                        newMax,
	                        false,
	                        undefined, {
	                            trigger: 'zoom'
	                        }
	                    );
	                }
	
	                return true;
	            },
	
	            /**
	             * Update the axis metrics.
	             *
	             * @private
	             */
	            setAxisSize: function() {
	                var chart = this.chart,
	                    options = this.options,
	                    offsets = options.offsets || [0, 0, 0, 0], // top / right / bottom / left
	                    horiz = this.horiz,
	
	                    // Check for percentage based input values. Rounding fixes problems
	                    // with column overflow and plot line filtering (#4898, #4899)
	                    width = this.width = Math.round(H.relativeLength(
	                        pick(
	                            options.width,
	                            chart.plotWidth - offsets[3] + offsets[1]
	                        ),
	                        chart.plotWidth
	                    )),
	                    height = this.height = Math.round(H.relativeLength(
	                        pick(
	                            options.height,
	                            chart.plotHeight - offsets[0] + offsets[2]
	                        ),
	                        chart.plotHeight
	                    )),
	                    top = this.top = Math.round(H.relativeLength(
	                        pick(options.top, chart.plotTop + offsets[0]),
	                        chart.plotHeight,
	                        chart.plotTop
	                    )),
	                    left = this.left = Math.round(H.relativeLength(
	                        pick(options.left, chart.plotLeft + offsets[3]),
	                        chart.plotWidth,
	                        chart.plotLeft
	                    ));
	
	                // Expose basic values to use in Series object and navigator
	                this.bottom = chart.chartHeight - height - top;
	                this.right = chart.chartWidth - width - left;
	
	                // Direction agnostic properties
	                this.len = Math.max(horiz ? width : height, 0); // Math.max fixes #905
	                this.pos = horiz ? left : top; // distance from SVG origin
	            },
	
	            /**
	             * The returned object literal from the {@link Highcharts.Axis#getExtremes}
	             * function. 
	             * @typedef {Object} Extremes
	             * @property {Number} dataMax
	             *         The maximum value of the axis' associated series.
	             * @property {Number} dataMin
	             *         The minimum value of the axis' associated series.
	             * @property {Number} max
	             *         The maximum axis value, either automatic or set manually. If the
	             *         `max` option is not set, `maxPadding` is 0 and `endOnTick` is
	             *         false, this value will be the same as `dataMax`.
	             * @property {Number} min
	             *         The minimum axis value, either automatic or set manually. If the
	             *         `min` option is not set, `minPadding` is 0 and `startOnTick` is
	             *         false, this value will be the same as `dataMin`.
	             */
	            /**
	             * Get the current extremes for the axis.
	             *
	             * @returns {Extremes}
	             * An object containing extremes information.
	             * 
	             * @sample  members/axis-getextremes/
	             *          Report extremes by click on a button
	             * @sample  maps/members/axis-getextremes/
	             *          Get extremes in Highmaps
	             */
	            getExtremes: function() {
	                var axis = this,
	                    isLog = axis.isLog,
	                    lin2log = axis.lin2log;
	
	                return {
	                    min: isLog ? correctFloat(lin2log(axis.min)) : axis.min,
	                    max: isLog ? correctFloat(lin2log(axis.max)) : axis.max,
	                    dataMin: axis.dataMin,
	                    dataMax: axis.dataMax,
	                    userMin: axis.userMin,
	                    userMax: axis.userMax
	                };
	            },
	
	            /**
	             * Get the zero plane either based on zero or on the min or max value.
	             * Used in bar and area plots.
	             *
	             * @param  {Number} threshold
	             *         The threshold in axis values.
	             *
	             * @return {Number}
	             *         The translated threshold position in terms of pixels, and
	             *         corrected to stay within the axis bounds.
	             */
	            getThreshold: function(threshold) {
	                var axis = this,
	                    isLog = axis.isLog,
	                    lin2log = axis.lin2log,
	                    realMin = isLog ? lin2log(axis.min) : axis.min,
	                    realMax = isLog ? lin2log(axis.max) : axis.max;
	
	                if (threshold === null) {
	                    threshold = realMin;
	                } else if (realMin > threshold) {
	                    threshold = realMin;
	                } else if (realMax < threshold) {
	                    threshold = realMax;
	                }
	
	                return axis.translate(threshold, 0, 1, 0, 1);
	            },
	
	            /**
	             * Compute auto alignment for the axis label based on which side the axis is
	             * on and the given rotation for the label.
	             *
	             * @param  {Number} rotation
	             *         The rotation in degrees as set by either the `rotation` or 
	             *         `autoRotation` options.
	             * @private
	             */
	            autoLabelAlign: function(rotation) {
	                var ret,
	                    angle = (pick(rotation, 0) - (this.side * 90) + 720) % 360;
	
	                if (angle > 15 && angle < 165) {
	                    ret = 'right';
	                } else if (angle > 195 && angle < 345) {
	                    ret = 'left';
	                } else {
	                    ret = 'center';
	                }
	                return ret;
	            },
	
	            /**
	             * Get the tick length and width for the axis based on axis options.
	             *
	             * @private
	             * 
	             * @param  {String} prefix
	             *         'tick' or 'minorTick'
	             * @return {Array.<Number>}
	             *         An array of tickLength and tickWidth
	             */
	            tickSize: function(prefix) {
	                var options = this.options,
	                    tickLength = options[prefix + 'Length'],
	                    tickWidth = pick(options[prefix + 'Width'], prefix === 'tick' && this.isXAxis ? 1 : 0); // X axis defaults to 1
	
	                if (tickWidth && tickLength) {
	                    // Negate the length
	                    if (options[prefix + 'Position'] === 'inside') {
	                        tickLength = -tickLength;
	                    }
	                    return [tickLength, tickWidth];
	                }
	
	            },
	
	            /**
	             * Return the size of the labels.
	             *
	             * @private
	             */
	            labelMetrics: function() {
	                var index = this.tickPositions && this.tickPositions[0] || 0;
	                return this.chart.renderer.fontMetrics(
	                    this.options.labels.style && this.options.labels.style.fontSize,
	                    this.ticks[index] && this.ticks[index].label
	                );
	            },
	
	            /**
	             * Prevent the ticks from getting so close we can't draw the labels. On a
	             * horizontal axis, this is handled by rotating the labels, removing ticks
	             * and adding ellipsis. On a vertical axis remove ticks and add ellipsis.
	             *
	             * @private
	             */
	            unsquish: function() {
	                var labelOptions = this.options.labels,
	                    horiz = this.horiz,
	                    tickInterval = this.tickInterval,
	                    newTickInterval = tickInterval,
	                    slotSize = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / tickInterval),
	                    rotation,
	                    rotationOption = labelOptions.rotation,
	                    labelMetrics = this.labelMetrics(),
	                    step,
	                    bestScore = Number.MAX_VALUE,
	                    autoRotation,
	                    // Return the multiple of tickInterval that is needed to avoid collision
	                    getStep = function(spaceNeeded) {
	                        var step = spaceNeeded / (slotSize || 1);
	                        step = step > 1 ? Math.ceil(step) : 1;
	                        return step * tickInterval;
	                    };
	
	                if (horiz) {
	                    autoRotation = !labelOptions.staggerLines && !labelOptions.step && ( // #3971
	                        defined(rotationOption) ? [rotationOption] :
	                        slotSize < pick(labelOptions.autoRotationLimit, 80) && labelOptions.autoRotation
	                    );
	
	                    if (autoRotation) {
	
	                        // Loop over the given autoRotation options, and determine which gives the best score. The
	                        // best score is that with the lowest number of steps and a rotation closest to horizontal.
	                        each(autoRotation, function(rot) {
	                            var score;
	
	                            if (rot === rotationOption || (rot && rot >= -90 && rot <= 90)) { // #3891
	
	                                step = getStep(Math.abs(labelMetrics.h / Math.sin(deg2rad * rot)));
	
	                                score = step + Math.abs(rot / 360);
	
	                                if (score < bestScore) {
	                                    bestScore = score;
	                                    rotation = rot;
	                                    newTickInterval = step;
	                                }
	                            }
	                        });
	                    }
	
	                } else if (!labelOptions.step) { // #4411
	                    newTickInterval = getStep(labelMetrics.h);
	                }
	
	                this.autoRotation = autoRotation;
	                this.labelRotation = pick(rotation, rotationOption);
	
	                return newTickInterval;
	            },
	
	            /**
	             * Get the general slot width for labels/categories on this axis. This may
	             * change between the pre-render (from Axis.getOffset) and the final tick
	             * rendering and placement.
	             *
	             * @private
	             * @return {Number}
	             *         The pixel width allocated to each axis label.
	             */
	            getSlotWidth: function() {
	                // #5086, #1580, #1931
	                var chart = this.chart,
	                    horiz = this.horiz,
	                    labelOptions = this.options.labels,
	                    slotCount = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),
	                    marginLeft = chart.margin[3];
	
	                return (
	                    horiz &&
	                    (labelOptions.step || 0) < 2 &&
	                    !labelOptions.rotation && // #4415
	                    ((this.staggerLines || 1) * this.len) / slotCount
	                ) || (!horiz && (
	                    (marginLeft && (marginLeft - chart.spacing[3])) ||
	                    chart.chartWidth * 0.33
	                ));
	
	            },
	
	            /**
	             * Render the axis labels and determine whether ellipsis or rotation need
	             * to be applied.
	             *
	             * @private
	             */
	            renderUnsquish: function() {
	                var chart = this.chart,
	                    renderer = chart.renderer,
	                    tickPositions = this.tickPositions,
	                    ticks = this.ticks,
	                    labelOptions = this.options.labels,
	                    horiz = this.horiz,
	                    slotWidth = this.getSlotWidth(),
	                    innerWidth = Math.max(1, Math.round(slotWidth - 2 * (labelOptions.padding || 5))),
	                    attr = {},
	                    labelMetrics = this.labelMetrics(),
	                    textOverflowOption = labelOptions.style && labelOptions.style.textOverflow,
	                    css,
	                    maxLabelLength = 0,
	                    label,
	                    i,
	                    pos;
	
	                // Set rotation option unless it is "auto", like in gauges
	                if (!isString(labelOptions.rotation)) {
	                    attr.rotation = labelOptions.rotation || 0; // #4443
	                }
	
	                // Get the longest label length
	                each(tickPositions, function(tick) {
	                    tick = ticks[tick];
	                    if (tick && tick.labelLength > maxLabelLength) {
	                        maxLabelLength = tick.labelLength;
	                    }
	                });
	                this.maxLabelLength = maxLabelLength;
	
	
	                // Handle auto rotation on horizontal axis
	                if (this.autoRotation) {
	
	                    // Apply rotation only if the label is too wide for the slot, and
	                    // the label is wider than its height.
	                    if (maxLabelLength > innerWidth && maxLabelLength > labelMetrics.h) {
	                        attr.rotation = this.labelRotation;
	                    } else {
	                        this.labelRotation = 0;
	                    }
	
	                    // Handle word-wrap or ellipsis on vertical axis
	                } else if (slotWidth) {
	                    // For word-wrap or ellipsis
	                    css = {
	                        width: innerWidth + 'px'
	                    };
	
	                    if (!textOverflowOption) {
	                        css.textOverflow = 'clip';
	
	                        // On vertical axis, only allow word wrap if there is room for more lines.
	                        i = tickPositions.length;
	                        while (!horiz && i--) {
	                            pos = tickPositions[i];
	                            label = ticks[pos].label;
	                            if (label) {
	                                // Reset ellipsis in order to get the correct bounding box (#4070)
	                                if (label.styles && label.styles.textOverflow === 'ellipsis') {
	                                    label.css({
	                                        textOverflow: 'clip'
	                                    });
	
	                                    // Set the correct width in order to read the bounding box height (#4678, #5034)
	                                } else if (ticks[pos].labelLength > slotWidth) {
	                                    label.css({
	                                        width: slotWidth + 'px'
	                                    });
	                                }
	
	                                if (label.getBBox().height > this.len / tickPositions.length - (labelMetrics.h - labelMetrics.f)) {
	                                    label.specCss = {
	                                        textOverflow: 'ellipsis'
	                                    };
	                                }
	                            }
	                        }
	                    }
	                }
	
	
	                // Add ellipsis if the label length is significantly longer than ideal
	                if (attr.rotation) {
	                    css = {
	                        width: (maxLabelLength > chart.chartHeight * 0.5 ? chart.chartHeight * 0.33 : chart.chartHeight) + 'px'
	                    };
	                    if (!textOverflowOption) {
	                        css.textOverflow = 'ellipsis';
	                    }
	                }
	
	                // Set the explicit or automatic label alignment
	                this.labelAlign = labelOptions.align || this.autoLabelAlign(this.labelRotation);
	                if (this.labelAlign) {
	                    attr.align = this.labelAlign;
	                }
	
	                // Apply general and specific CSS
	                each(tickPositions, function(pos) {
	                    var tick = ticks[pos],
	                        label = tick && tick.label;
	                    if (label) {
	                        label.attr(attr); // This needs to go before the CSS in old IE (#4502)
	                        if (css) {
	                            label.css(merge(css, label.specCss));
	                        }
	                        delete label.specCss;
	                        tick.rotation = attr.rotation;
	                    }
	                });
	
	                // Note: Why is this not part of getLabelPosition?
	                this.tickRotCorr = renderer.rotCorr(labelMetrics.b, this.labelRotation || 0, this.side !== 0);
	            },
	
	            /**
	             * Return true if the axis has associated data.
	             *
	             * @return {Boolean}
	             *         True if the axis has associated visible series and those series
	             *         have either valid data points or explicit `min` and `max`
	             *         settings.
	             */
	            hasData: function() {
	                return (
	                    this.hasVisibleSeries ||
	                    (defined(this.min) && defined(this.max) && !!this.tickPositions)
	                );
	            },
	
	            /**
	             * Adds the title defined in axis.options.title.
	             * @param {Boolean} display - whether or not to display the title
	             */
	            addTitle: function(display) {
	                var axis = this,
	                    renderer = axis.chart.renderer,
	                    horiz = axis.horiz,
	                    opposite = axis.opposite,
	                    options = axis.options,
	                    axisTitleOptions = options.title,
	                    textAlign;
	
	                if (!axis.axisTitle) {
	                    textAlign = axisTitleOptions.textAlign;
	                    if (!textAlign) {
	                        textAlign = (horiz ? {
	                            low: 'left',
	                            middle: 'center',
	                            high: 'right'
	                        } : {
	                            low: opposite ? 'right' : 'left',
	                            middle: 'center',
	                            high: opposite ? 'left' : 'right'
	                        })[axisTitleOptions.align];
	                    }
	                    axis.axisTitle = renderer.text(
	                            axisTitleOptions.text,
	                            0,
	                            0,
	                            axisTitleOptions.useHTML
	                        )
	                        .attr({
	                            zIndex: 7,
	                            rotation: axisTitleOptions.rotation || 0,
	                            align: textAlign
	                        })
	                        .addClass('highcharts-axis-title')
	
	                        .css(axisTitleOptions.style)
	
	                        .add(axis.axisGroup);
	                    axis.axisTitle.isNew = true;
	                }
	
	                // Max width defaults to the length of the axis
	
	                if (!axisTitleOptions.style.width && !axis.isRadial) {
	
	                    axis.axisTitle.css({
	                        width: axis.len
	                    });
	
	                }
	
	
	
	                // hide or show the title depending on whether showEmpty is set
	                axis.axisTitle[display ? 'show' : 'hide'](true);
	            },
	
	            /**
	             * Generates a tick for initial positioning.
	             *
	             * @private
	             * @param  {number} pos
	             *         The tick position in axis values.
	             * @param  {number} i
	             *         The index of the tick in {@link Axis.tickPositions}.
	             */
	            generateTick: function(pos) {
	                var ticks = this.ticks;
	
	                if (!ticks[pos]) {
	                    ticks[pos] = new Tick(this, pos);
	                } else {
	                    ticks[pos].addLabel(); // update labels depending on tick interval
	                }
	            },
	
	            /**
	             * Render the tick labels to a preliminary position to get their sizes.
	             *
	             * @private
	             */
	            getOffset: function() {
	                var axis = this,
	                    chart = axis.chart,
	                    renderer = chart.renderer,
	                    options = axis.options,
	                    tickPositions = axis.tickPositions,
	                    ticks = axis.ticks,
	                    horiz = axis.horiz,
	                    side = axis.side,
	                    invertedSide = chart.inverted && !axis.isZAxis ? [1, 0, 3, 2][side] : side,
	                    hasData,
	                    showAxis,
	                    titleOffset = 0,
	                    titleOffsetOption,
	                    titleMargin = 0,
	                    axisTitleOptions = options.title,
	                    labelOptions = options.labels,
	                    labelOffset = 0, // reset
	                    labelOffsetPadded,
	                    axisOffset = chart.axisOffset,
	                    clipOffset = chart.clipOffset,
	                    clip,
	                    directionFactor = [-1, 1, 1, -1][side],
	                    className = options.className,
	                    axisParent = axis.axisParent, // Used in color axis
	                    lineHeightCorrection,
	                    tickSize = this.tickSize('tick');
	
	                // For reuse in Axis.render
	                hasData = axis.hasData();
	                axis.showAxis = showAxis = hasData || pick(options.showEmpty, true);
	
	                // Set/reset staggerLines
	                axis.staggerLines = axis.horiz && labelOptions.staggerLines;
	
	                // Create the axisGroup and gridGroup elements on first iteration
	                if (!axis.axisGroup) {
	                    axis.gridGroup = renderer.g('grid')
	                        .attr({
	                            zIndex: options.gridZIndex || 1
	                        })
	                        .addClass('highcharts-' + this.coll.toLowerCase() + '-grid ' + (className || ''))
	                        .add(axisParent);
	                    axis.axisGroup = renderer.g('axis')
	                        .attr({
	                            zIndex: options.zIndex || 2
	                        })
	                        .addClass('highcharts-' + this.coll.toLowerCase() + ' ' + (className || ''))
	                        .add(axisParent);
	                    axis.labelGroup = renderer.g('axis-labels')
	                        .attr({
	                            zIndex: labelOptions.zIndex || 7
	                        })
	                        .addClass('highcharts-' + axis.coll.toLowerCase() + '-labels ' + (className || ''))
	                        .add(axisParent);
	                }
	
	                if (hasData || axis.isLinked) {
	
	                    // Generate ticks
	                    each(tickPositions, function(pos, i) {
	                        // i is not used here, but may be used in overrides
	                        axis.generateTick(pos, i);
	                    });
	
	                    axis.renderUnsquish();
	
	
	                    // Left side must be align: right and right side must have align: left for labels
	                    if (labelOptions.reserveSpace !== false && (side === 0 || side === 2 || {
	                            1: 'left',
	                            3: 'right'
	                        }[side] === axis.labelAlign || axis.labelAlign === 'center')) {
	                        each(tickPositions, function(pos) {
	
	                            // get the highest offset
	                            labelOffset = Math.max(
	                                ticks[pos].getLabelSize(),
	                                labelOffset
	                            );
	                        });
	                    }
	
	                    if (axis.staggerLines) {
	                        labelOffset *= axis.staggerLines;
	                        axis.labelOffset = labelOffset * (axis.opposite ? -1 : 1);
	                    }
	
	
	                } else { // doesn't have data
	                    objectEach(ticks, function(tick, n) {
	                        tick.destroy();
	                        delete ticks[n];
	                    });
	                }
	
	                if (axisTitleOptions && axisTitleOptions.text && axisTitleOptions.enabled !== false) {
	                    axis.addTitle(showAxis);
	
	                    if (showAxis && axisTitleOptions.reserveSpace !== false) {
	                        axis.titleOffset = titleOffset =
	                            axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];
	                        titleOffsetOption = axisTitleOptions.offset;
	                        titleMargin = defined(titleOffsetOption) ? 0 : pick(axisTitleOptions.margin, horiz ? 5 : 10);
	                    }
	                }
	
	                // Render the axis line
	                axis.renderLine();
	
	                // handle automatic or user set offset
	                axis.offset = directionFactor * pick(options.offset, axisOffset[side]);
	
	                axis.tickRotCorr = axis.tickRotCorr || {
	                    x: 0,
	                    y: 0
	                }; // polar
	                if (side === 0) {
	                    lineHeightCorrection = -axis.labelMetrics().h;
	                } else if (side === 2) {
	                    lineHeightCorrection = axis.tickRotCorr.y;
	                } else {
	                    lineHeightCorrection = 0;
	                }
	
	                // Find the padded label offset
	                labelOffsetPadded = Math.abs(labelOffset) + titleMargin;
	                if (labelOffset) {
	                    labelOffsetPadded -= lineHeightCorrection;
	                    labelOffsetPadded += directionFactor * (horiz ? pick(labelOptions.y, axis.tickRotCorr.y + directionFactor * 8) : labelOptions.x);
	                }
	                axis.axisTitleMargin = pick(titleOffsetOption, labelOffsetPadded);
	
	                axisOffset[side] = Math.max(
	                    axisOffset[side],
	                    axis.axisTitleMargin + titleOffset + directionFactor * axis.offset,
	                    labelOffsetPadded, // #3027
	                    hasData && tickPositions.length && tickSize ?
	                    tickSize[0] + directionFactor * axis.offset :
	                    0 // #4866
	                );
	
	                // Decide the clipping needed to keep the graph inside the plot area and
	                // axis lines
	                clip = Math.floor(axis.axisLine.strokeWidth() / 2) * 2; // #4308, #4371
	                if (options.offset > 0) {
	                    clip -= options.offset * 2;
	                }
	                clipOffset[invertedSide] = Math.max(
	                    clipOffset[invertedSide] || clip,
	                    clip
	                );
	            },
	
	            /**
	             * Internal function to get the path for the axis line. Extended for polar
	             * charts.
	             *
	             * @param  {Number} lineWidth
	             *         The line width in pixels.
	             * @return {Array}
	             *         The SVG path definition in array form.
	             */
	            getLinePath: function(lineWidth) {
	                var chart = this.chart,
	                    opposite = this.opposite,
	                    offset = this.offset,
	                    horiz = this.horiz,
	                    lineLeft = this.left + (opposite ? this.width : 0) + offset,
	                    lineTop = chart.chartHeight - this.bottom -
	                    (opposite ? this.height : 0) + offset;
	
	                if (opposite) {
	                    lineWidth *= -1; // crispify the other way - #1480, #1687
	                }
	
	                return chart.renderer
	                    .crispLine([
	                        'M',
	                        horiz ?
	                        this.left :
	                        lineLeft,
	                        horiz ?
	                        lineTop :
	                        this.top,
	                        'L',
	                        horiz ?
	                        chart.chartWidth - this.right :
	                        lineLeft,
	                        horiz ?
	                        lineTop :
	                        chart.chartHeight - this.bottom
	                    ], lineWidth);
	            },
	
	            /**
	             * Render the axis line. Called internally when rendering and redrawing the
	             * axis.
	             */
	            renderLine: function() {
	                if (!this.axisLine) {
	                    this.axisLine = this.chart.renderer.path()
	                        .addClass('highcharts-axis-line')
	                        .add(this.axisGroup);
	
	
	                    this.axisLine.attr({
	                        stroke: this.options.lineColor,
	                        'stroke-width': this.options.lineWidth,
	                        zIndex: 7
	                    });
	
	                }
	            },
	
	            /**
	             * Position the axis title.
	             *
	             * @private
	             *
	             * @return {Object}
	             *         X and Y positions for the title.
	             */
	            getTitlePosition: function() {
	                // compute anchor points for each of the title align options
	                var horiz = this.horiz,
	                    axisLeft = this.left,
	                    axisTop = this.top,
	                    axisLength = this.len,
	                    axisTitleOptions = this.options.title,
	                    margin = horiz ? axisLeft : axisTop,
	                    opposite = this.opposite,
	                    offset = this.offset,
	                    xOption = axisTitleOptions.x || 0,
	                    yOption = axisTitleOptions.y || 0,
	                    axisTitle = this.axisTitle,
	                    fontMetrics = this.chart.renderer.fontMetrics(
	                        axisTitleOptions.style && axisTitleOptions.style.fontSize,
	                        axisTitle
	                    ),
	                    // The part of a multiline text that is below the baseline of the
	                    // first line. Subtract 1 to preserve pixel-perfectness from the 
	                    // old behaviour (v5.0.12), where only one line was allowed.
	                    textHeightOvershoot = Math.max(
	                        axisTitle.getBBox(null, 0).height - fontMetrics.h - 1,
	                        0
	                    ),
	
	                    // the position in the length direction of the axis
	                    alongAxis = {
	                        low: margin + (horiz ? 0 : axisLength),
	                        middle: margin + axisLength / 2,
	                        high: margin + (horiz ? axisLength : 0)
	                    }[axisTitleOptions.align],
	
	                    // the position in the perpendicular direction of the axis
	                    offAxis = (horiz ? axisTop + this.height : axisLeft) +
	                    (horiz ? 1 : -1) * // horizontal axis reverses the margin
	                    (opposite ? -1 : 1) * // so does opposite axes
	                    this.axisTitleMargin + [-textHeightOvershoot, // top
	                        textHeightOvershoot, // right
	                        fontMetrics.f, // bottom
	                        -textHeightOvershoot // left
	                    ][this.side];
	
	
	                return {
	                    x: horiz ?
	                        alongAxis + xOption : offAxis + (opposite ? this.width : 0) + offset + xOption,
	                    y: horiz ?
	                        offAxis + yOption - (opposite ? this.height : 0) + offset : alongAxis + yOption
	                };
	            },
	
	            /**
	             * Render a minor tick into the given position. If a minor tick already 
	             * exists in this position, move it.
	             * 
	             * @param  {number} pos
	             *         The position in axis values.
	             */
	            renderMinorTick: function(pos) {
	                var slideInTicks = this.chart.hasRendered && isNumber(this.oldMin),
	                    minorTicks = this.minorTicks;
	
	                if (!minorTicks[pos]) {
	                    minorTicks[pos] = new Tick(this, pos, 'minor');
	                }
	
	                // Render new ticks in old position
	                if (slideInTicks && minorTicks[pos].isNew) {
	                    minorTicks[pos].render(null, true);
	                }
	
	                minorTicks[pos].render(null, false, 1);
	            },
	
	            /**
	             * Render a major tick into the given position. If a tick already exists
	             * in this position, move it.
	             * 
	             * @param  {number} pos
	             *         The position in axis values.
	             * @param  {number} i
	             *         The tick index.
	             */
	            renderTick: function(pos, i) {
	                var isLinked = this.isLinked,
	                    ticks = this.ticks,
	                    slideInTicks = this.chart.hasRendered && isNumber(this.oldMin);
	
	                // Linked axes need an extra check to find out if
	                if (!isLinked || (pos >= this.min && pos <= this.max)) {
	
	                    if (!ticks[pos]) {
	                        ticks[pos] = new Tick(this, pos);
	                    }
	
	                    // render new ticks in old position
	                    if (slideInTicks && ticks[pos].isNew) {
	                        ticks[pos].render(i, true, 0.1);
	                    }
	
	                    ticks[pos].render(i);
	                }
	            },
	
	            /**
	             * Render the axis.
	             *
	             * @private
	             */
	            render: function() {
	                var axis = this,
	                    chart = axis.chart,
	                    renderer = chart.renderer,
	                    options = axis.options,
	                    isLog = axis.isLog,
	                    lin2log = axis.lin2log,
	                    isLinked = axis.isLinked,
	                    tickPositions = axis.tickPositions,
	                    axisTitle = axis.axisTitle,
	                    ticks = axis.ticks,
	                    minorTicks = axis.minorTicks,
	                    alternateBands = axis.alternateBands,
	                    stackLabelOptions = options.stackLabels,
	                    alternateGridColor = options.alternateGridColor,
	                    tickmarkOffset = axis.tickmarkOffset,
	                    axisLine = axis.axisLine,
	                    showAxis = axis.showAxis,
	                    animation = animObject(renderer.globalAnimation),
	                    from,
	                    to;
	
	                // Reset
	                axis.labelEdge.length = 0;
	                //axis.justifyToPlot = overflow === 'justify';
	                axis.overlap = false;
	
	                // Mark all elements inActive before we go over and mark the active ones
	                each([ticks, minorTicks, alternateBands], function(coll) {
	                    objectEach(coll, function(tick) {
	                        tick.isActive = false;
	                    });
	                });
	
	                // If the series has data draw the ticks. Else only the line and title
	                if (axis.hasData() || isLinked) {
	
	                    // minor ticks
	                    if (axis.minorTickInterval && !axis.categories) {
	                        each(axis.getMinorTickPositions(), function(pos) {
	                            axis.renderMinorTick(pos);
	                        });
	                    }
	
	                    // Major ticks. Pull out the first item and render it last so that
	                    // we can get the position of the neighbour label. #808.
	                    if (tickPositions.length) { // #1300
	                        each(tickPositions, function(pos, i) {
	                            axis.renderTick(pos, i);
	                        });
	                        // In a categorized axis, the tick marks are displayed between labels. So
	                        // we need to add a tick mark and grid line at the left edge of the X axis.
	                        if (tickmarkOffset && (axis.min === 0 || axis.single)) {
	                            if (!ticks[-1]) {
	                                ticks[-1] = new Tick(axis, -1, null, true);
	                            }
	                            ticks[-1].render(-1);
	                        }
	
	                    }
	
	                    // alternate grid color
	                    if (alternateGridColor) {
	                        each(tickPositions, function(pos, i) {
	                            to = tickPositions[i + 1] !== undefined ? tickPositions[i + 1] + tickmarkOffset : axis.max - tickmarkOffset;
	                            if (i % 2 === 0 && pos < axis.max && to <= axis.max + (chart.polar ? -tickmarkOffset : tickmarkOffset)) { // #2248, #4660
	                                if (!alternateBands[pos]) {
	                                    alternateBands[pos] = new H.PlotLineOrBand(axis);
	                                }
	                                from = pos + tickmarkOffset; // #949
	                                alternateBands[pos].options = {
	                                    from: isLog ? lin2log(from) : from,
	                                    to: isLog ? lin2log(to) : to,
	                                    color: alternateGridColor
	                                };
	                                alternateBands[pos].render();
	                                alternateBands[pos].isActive = true;
	                            }
	                        });
	                    }
	
	                    // custom plot lines and bands
	                    if (!axis._addedPlotLB) { // only first time
	                        each((options.plotLines || []).concat(options.plotBands || []), function(plotLineOptions) {
	                            axis.addPlotBandOrLine(plotLineOptions);
	                        });
	                        axis._addedPlotLB = true;
	                    }
	
	                } // end if hasData
	
	                // Remove inactive ticks
	                each([ticks, minorTicks, alternateBands], function(coll) {
	                    var i,
	                        forDestruction = [],
	                        delay = animation.duration,
	                        destroyInactiveItems = function() {
	                            i = forDestruction.length;
	                            while (i--) {
	                                // When resizing rapidly, the same items may be destroyed in different timeouts,
	                                // or the may be reactivated
	                                if (coll[forDestruction[i]] && !coll[forDestruction[i]].isActive) {
	                                    coll[forDestruction[i]].destroy();
	                                    delete coll[forDestruction[i]];
	                                }
	                            }
	
	                        };
	
	                    objectEach(coll, function(tick, pos) {
	                        if (!tick.isActive) {
	                            // Render to zero opacity
	                            tick.render(pos, false, 0);
	                            tick.isActive = false;
	                            forDestruction.push(pos);
	                        }
	                    });
	
	                    // When the objects are finished fading out, destroy them
	                    syncTimeout(
	                        destroyInactiveItems,
	                        coll === alternateBands || !chart.hasRendered || !delay ? 0 : delay
	                    );
	                });
	
	                // Set the axis line path
	                if (axisLine) {
	                    axisLine[axisLine.isPlaced ? 'animate' : 'attr']({
	                        d: this.getLinePath(axisLine.strokeWidth())
	                    });
	                    axisLine.isPlaced = true;
	
	                    // Show or hide the line depending on options.showEmpty
	                    axisLine[showAxis ? 'show' : 'hide'](true);
	                }
	
	                if (axisTitle && showAxis) {
	                    var titleXy = axis.getTitlePosition();
	                    if (isNumber(titleXy.y)) {
	                        axisTitle[axisTitle.isNew ? 'attr' : 'animate'](titleXy);
	                        axisTitle.isNew = false;
	                    } else {
	                        axisTitle.attr('y', -9999);
	                        axisTitle.isNew = true;
	                    }
	                }
	
	                // Stacked totals:
	                if (stackLabelOptions && stackLabelOptions.enabled) {
	                    axis.renderStackTotals();
	                }
	                // End stacked totals
	
	                axis.isDirty = false;
	            },
	
	            /**
	             * Redraw the axis to reflect changes in the data or axis extremes. Called
	             * internally from {@link Chart#redraw}.
	             *
	             * @private
	             */
	            redraw: function() {
	
	                if (this.visible) {
	                    // render the axis
	                    this.render();
	
	                    // move plot lines and bands
	                    each(this.plotLinesAndBands, function(plotLine) {
	                        plotLine.render();
	                    });
	                }
	
	                // mark associated series as dirty and ready for redraw
	                each(this.series, function(series) {
	                    series.isDirty = true;
	                });
	
	            },
	
	            // Properties to survive after destroy, needed for Axis.update (#4317,
	            // #5773, #5881).
	            keepProps: ['extKey', 'hcEvents', 'names', 'series', 'userMax', 'userMin'],
	
	            /**
	             * Destroys an Axis instance. See {@link Axis#remove} for the API endpoint
	             * to fully remove the axis.
	             *
	             * @private
	             * @param  {Boolean} keepEvents
	             *         Whether to preserve events, used internally in Axis.update.
	             */
	            destroy: function(keepEvents) {
	                var axis = this,
	                    stacks = axis.stacks,
	                    plotLinesAndBands = axis.plotLinesAndBands,
	                    plotGroup,
	                    i;
	
	                // Remove the events
	                if (!keepEvents) {
	                    removeEvent(axis);
	                }
	
	                // Destroy each stack total
	                objectEach(stacks, function(stack, stackKey) {
	                    destroyObjectProperties(stack);
	
	                    stacks[stackKey] = null;
	                });
	
	                // Destroy collections
	                each([axis.ticks, axis.minorTicks, axis.alternateBands], function(coll) {
	                    destroyObjectProperties(coll);
	                });
	                if (plotLinesAndBands) {
	                    i = plotLinesAndBands.length;
	                    while (i--) { // #1975
	                        plotLinesAndBands[i].destroy();
	                    }
	                }
	
	                // Destroy local variables
	                each(['stackTotalGroup', 'axisLine', 'axisTitle', 'axisGroup', 'gridGroup', 'labelGroup', 'cross'], function(prop) {
	                    if (axis[prop]) {
	                        axis[prop] = axis[prop].destroy();
	                    }
	                });
	
	                // Destroy each generated group for plotlines and plotbands
	                for (plotGroup in axis.plotLinesAndBandsGroups) {
	                    axis.plotLinesAndBandsGroups[plotGroup] = axis.plotLinesAndBandsGroups[plotGroup].destroy();
	                }
	
	                // Delete all properties and fall back to the prototype.
	                objectEach(axis, function(val, key) {
	                    if (inArray(key, axis.keepProps) === -1) {
	                        delete axis[key];
	                    }
	                });
	            },
	
	            /**
	             * Internal function to draw a crosshair.
	             *
	             * @param  {PointerEvent} [e]
	             *         The event arguments from the modified pointer event, extended 
	             *         with `chartX` and `chartY`
	             * @param  {Point} [point]
	             *         The Point object if the crosshair snaps to points.
	             */
	            drawCrosshair: function(e, point) {
	
	                var path,
	                    options = this.crosshair,
	                    snap = pick(options.snap, true),
	                    pos,
	                    categorized,
	                    graphic = this.cross;
	
	                // Use last available event when updating non-snapped crosshairs without
	                // mouse interaction (#5287)
	                if (!e) {
	                    e = this.cross && this.cross.e;
	                }
	
	                if (
	                    // Disabled in options
	                    !this.crosshair ||
	                    // Snap
	                    ((defined(point) || !snap) === false)
	                ) {
	                    this.hideCrosshair();
	                } else {
	
	                    // Get the path
	                    if (!snap) {
	                        pos = e && (this.horiz ? e.chartX - this.pos : this.len - e.chartY + this.pos);
	                    } else if (defined(point)) {
	                        pos = this.isXAxis ? point.plotX : this.len - point.plotY; // #3834
	                    }
	
	                    if (defined(pos)) {
	                        path = this.getPlotLinePath(
	                            // First argument, value, only used on radial
	                            point && (this.isXAxis ? point.x : pick(point.stackY, point.y)),
	                            null,
	                            null,
	                            null,
	                            pos // Translated position
	                        ) || null; // #3189
	                    }
	
	                    if (!defined(path)) {
	                        this.hideCrosshair();
	                        return;
	                    }
	
	                    categorized = this.categories && !this.isRadial;
	
	                    // Draw the cross
	                    if (!graphic) {
	                        this.cross = graphic = this.chart.renderer
	                            .path()
	                            .addClass('highcharts-crosshair highcharts-crosshair-' +
	                                (categorized ? 'category ' : 'thin ') + options.className)
	                            .attr({
	                                zIndex: pick(options.zIndex, 2)
	                            })
	                            .add();
	
	
	                        // Presentational attributes
	                        graphic.attr({
	                            'stroke': options.color || (categorized ? color('#ccd6eb').setOpacity(0.25).get() : '#cccccc'),
	                            'stroke-width': pick(options.width, 1)
	                        });
	                        if (options.dashStyle) {
	                            graphic.attr({
	                                dashstyle: options.dashStyle
	                            });
	                        }
	
	
	                    }
	
	                    graphic.show().attr({
	                        d: path
	                    });
	
	                    if (categorized && !options.width) {
	                        graphic.attr({
	                            'stroke-width': this.transA
	                        });
	                    }
	                    this.cross.e = e;
	                }
	            },
	
	            /**
	             *	Hide the crosshair if visible.
	             */
	            hideCrosshair: function() {
	                if (this.cross) {
	                    this.cross.hide();
	                }
	            }
	        }); // end Axis
	
	        H.Axis = Axis;
	        return Axis;
	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var Axis = H.Axis,
	            getMagnitude = H.getMagnitude,
	            map = H.map,
	            normalizeTickInterval = H.normalizeTickInterval,
	            pick = H.pick;
	        /**
	         * Methods defined on the Axis prototype
	         */
	
	        /**
	         * Set the tick positions of a logarithmic axis
	         */
	        Axis.prototype.getLogTickPositions = function(interval, min, max, minor) {
	            var axis = this,
	                options = axis.options,
	                axisLength = axis.len,
	                lin2log = axis.lin2log,
	                log2lin = axis.log2lin,
	                // Since we use this method for both major and minor ticks,
	                // use a local variable and return the result
	                positions = [];
	
	            // Reset
	            if (!minor) {
	                axis._minorAutoInterval = null;
	            }
	
	            // First case: All ticks fall on whole logarithms: 1, 10, 100 etc.
	            if (interval >= 0.5) {
	                interval = Math.round(interval);
	                positions = axis.getLinearTickPositions(interval, min, max);
	
	                // Second case: We need intermediary ticks. For example
	                // 1, 2, 4, 6, 8, 10, 20, 40 etc.
	            } else if (interval >= 0.08) {
	                var roundedMin = Math.floor(min),
	                    intermediate,
	                    i,
	                    j,
	                    len,
	                    pos,
	                    lastPos,
	                    break2;
	
	                if (interval > 0.3) {
	                    intermediate = [1, 2, 4];
	                } else if (interval > 0.15) { // 0.2 equals five minor ticks per 1, 10, 100 etc
	                    intermediate = [1, 2, 4, 6, 8];
	                } else { // 0.1 equals ten minor ticks per 1, 10, 100 etc
	                    intermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9];
	                }
	
	                for (i = roundedMin; i < max + 1 && !break2; i++) {
	                    len = intermediate.length;
	                    for (j = 0; j < len && !break2; j++) {
	                        pos = log2lin(lin2log(i) * intermediate[j]);
	                        if (pos > min && (!minor || lastPos <= max) && lastPos !== undefined) { // #1670, lastPos is #3113
	                            positions.push(lastPos);
	                        }
	
	                        if (lastPos > max) {
	                            break2 = true;
	                        }
	                        lastPos = pos;
	                    }
	                }
	
	                // Third case: We are so deep in between whole logarithmic values that
	                // we might as well handle the tick positions like a linear axis. For
	                // example 1.01, 1.02, 1.03, 1.04.
	            } else {
	                var realMin = lin2log(min),
	                    realMax = lin2log(max),
	                    tickIntervalOption = options[minor ? 'minorTickInterval' : 'tickInterval'],
	                    filteredTickIntervalOption = tickIntervalOption === 'auto' ? null : tickIntervalOption,
	                    tickPixelIntervalOption = options.tickPixelInterval / (minor ? 5 : 1),
	                    totalPixelLength = minor ? axisLength / axis.tickPositions.length : axisLength;
	
	                interval = pick(
	                    filteredTickIntervalOption,
	                    axis._minorAutoInterval,
	                    (realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1)
	                );
	
	                interval = normalizeTickInterval(
	                    interval,
	                    null,
	                    getMagnitude(interval)
	                );
	
	                positions = map(axis.getLinearTickPositions(
	                    interval,
	                    realMin,
	                    realMax
	                ), log2lin);
	
	                if (!minor) {
	                    axis._minorAutoInterval = interval / 5;
	                }
	            }
	
	            // Set the axis-level tickInterval variable
	            if (!minor) {
	                axis.tickInterval = interval;
	            }
	            return positions;
	        };
	
	        Axis.prototype.log2lin = function(num) {
	            return Math.log(num) / Math.LN10;
	        };
	
	        Axis.prototype.lin2log = function(num) {
	            return Math.pow(10, num);
	        };
	
	    }(Highcharts));
	    (function(H, Axis) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var arrayMax = H.arrayMax,
	            arrayMin = H.arrayMin,
	            defined = H.defined,
	            destroyObjectProperties = H.destroyObjectProperties,
	            each = H.each,
	            erase = H.erase,
	            merge = H.merge,
	            pick = H.pick;
	        /*
	         * The object wrapper for plot lines and plot bands
	         * @param {Object} options
	         */
	        H.PlotLineOrBand = function(axis, options) {
	            this.axis = axis;
	
	            if (options) {
	                this.options = options;
	                this.id = options.id;
	            }
	        };
	
	        H.PlotLineOrBand.prototype = {
	
	            /**
	             * Render the plot line or plot band. If it is already existing,
	             * move it.
	             */
	            render: function() {
	                var plotLine = this,
	                    axis = plotLine.axis,
	                    horiz = axis.horiz,
	                    options = plotLine.options,
	                    optionsLabel = options.label,
	                    label = plotLine.label,
	                    to = options.to,
	                    from = options.from,
	                    value = options.value,
	                    isBand = defined(from) && defined(to),
	                    isLine = defined(value),
	                    svgElem = plotLine.svgElem,
	                    isNew = !svgElem,
	                    path = [],
	                    color = options.color,
	                    zIndex = pick(options.zIndex, 0),
	                    events = options.events,
	                    attribs = {
	                        'class': 'highcharts-plot-' + (isBand ? 'band ' : 'line ') + (options.className || '')
	                    },
	                    groupAttribs = {},
	                    renderer = axis.chart.renderer,
	                    groupName = isBand ? 'bands' : 'lines',
	                    group,
	                    log2lin = axis.log2lin;
	
	                // logarithmic conversion
	                if (axis.isLog) {
	                    from = log2lin(from);
	                    to = log2lin(to);
	                    value = log2lin(value);
	                }
	
	
	                // Set the presentational attributes
	                if (isLine) {
	                    attribs = {
	                        stroke: color,
	                        'stroke-width': options.width
	                    };
	                    if (options.dashStyle) {
	                        attribs.dashstyle = options.dashStyle;
	                    }
	
	                } else if (isBand) { // plot band
	                    if (color) {
	                        attribs.fill = color;
	                    }
	                    if (options.borderWidth) {
	                        attribs.stroke = options.borderColor;
	                        attribs['stroke-width'] = options.borderWidth;
	                    }
	                }
	
	
	                // Grouping and zIndex
	                groupAttribs.zIndex = zIndex;
	                groupName += '-' + zIndex;
	
	                group = axis.plotLinesAndBandsGroups[groupName];
	                if (!group) {
	                    axis.plotLinesAndBandsGroups[groupName] = group = renderer.g('plot-' + groupName)
	                        .attr(groupAttribs).add();
	                }
	
	                // Create the path
	                if (isNew) {
	                    plotLine.svgElem = svgElem =
	                        renderer
	                        .path()
	                        .attr(attribs).add(group);
	                }
	
	
	                // Set the path or return
	                if (isLine) {
	                    path = axis.getPlotLinePath(value, svgElem.strokeWidth());
	                } else if (isBand) { // plot band
	                    path = axis.getPlotBandPath(from, to, options);
	                } else {
	                    return;
	                }
	
	
	                // common for lines and bands
	                if (isNew && path && path.length) {
	                    svgElem.attr({
	                        d: path
	                    });
	
	                    // events
	                    if (events) {
	                        H.objectEach(events, function(event, eventType) {
	                            svgElem.on(eventType, function(e) {
	                                events[eventType].apply(plotLine, [e]);
	                            });
	                        });
	                    }
	                } else if (svgElem) {
	                    if (path) {
	                        svgElem.show();
	                        svgElem.animate({
	                            d: path
	                        });
	                    } else {
	                        svgElem.hide();
	                        if (label) {
	                            plotLine.label = label = label.destroy();
	                        }
	                    }
	                }
	
	                // the plot band/line label
	                if (optionsLabel && defined(optionsLabel.text) && path && path.length &&
	                    axis.width > 0 && axis.height > 0 && !path.flat) {
	                    // apply defaults
	                    optionsLabel = merge({
	                        align: horiz && isBand && 'center',
	                        x: horiz ? !isBand && 4 : 10,
	                        verticalAlign: !horiz && isBand && 'middle',
	                        y: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,
	                        rotation: horiz && !isBand && 90
	                    }, optionsLabel);
	
	                    this.renderLabel(optionsLabel, path, isBand, zIndex);
	
	                } else if (label) { // move out of sight
	                    label.hide();
	                }
	
	                // chainable
	                return plotLine;
	            },
	
	            /**
	             * Render and align label for plot line or band.
	             */
	            renderLabel: function(optionsLabel, path, isBand, zIndex) {
	                var plotLine = this,
	                    label = plotLine.label,
	                    renderer = plotLine.axis.chart.renderer,
	                    attribs,
	                    xs,
	                    ys,
	                    x,
	                    y;
	
	                // add the SVG element
	                if (!label) {
	                    attribs = {
	                        align: optionsLabel.textAlign || optionsLabel.align,
	                        rotation: optionsLabel.rotation,
	                        'class': 'highcharts-plot-' + (isBand ? 'band' : 'line') + '-label ' + (optionsLabel.className || '')
	                    };
	
	                    attribs.zIndex = zIndex;
	
	                    plotLine.label = label = renderer.text(
	                            optionsLabel.text,
	                            0,
	                            0,
	                            optionsLabel.useHTML
	                        )
	                        .attr(attribs)
	                        .add();
	
	
	                    label.css(optionsLabel.style);
	
	                }
	
	                // get the bounding box and align the label
	                // #3000 changed to better handle choice between plotband or plotline
	                xs = [path[1], path[4], (isBand ? path[6] : path[1])];
	                ys = [path[2], path[5], (isBand ? path[7] : path[2])];
	                x = arrayMin(xs);
	                y = arrayMin(ys);
	
	                label.align(optionsLabel, false, {
	                    x: x,
	                    y: y,
	                    width: arrayMax(xs) - x,
	                    height: arrayMax(ys) - y
	                });
	                label.show();
	            },
	
	            /**
	             * Remove the plot line or band
	             */
	            destroy: function() {
	                // remove it from the lookup
	                erase(this.axis.plotLinesAndBands, this);
	
	                delete this.axis;
	                destroyObjectProperties(this);
	            }
	        };
	
	        /**
	         * Object with members for extending the Axis prototype
	         * @todo Extend directly instead of adding object to Highcharts first
	         */
	
	        H.extend(Axis.prototype, /** @lends Highcharts.Axis.prototype */ {
	
	            /**
	             * Internal function to create the SVG path definition for a plot band.
	             *
	             * @param  {Number} from
	             *         The axis value to start from.
	             * @param  {Number} to
	             *         The axis value to end on.
	             *
	             * @return {Array.<String|Number>}
	             *         The SVG path definition in array form.
	             */
	            getPlotBandPath: function(from, to) {
	                var toPath = this.getPlotLinePath(to, null, null, true),
	                    path = this.getPlotLinePath(from, null, null, true),
	                    // #4964 check if chart is inverted or plotband is on yAxis 
	                    horiz = this.horiz,
	                    plus = 1,
	                    outside =
	                    (from < this.min && to < this.min) ||
	                    (from > this.max && to > this.max);
	
	                if (path && toPath) {
	
	                    // Flat paths don't need labels (#3836)
	                    if (outside) {
	                        path.flat = path.toString() === toPath.toString();
	                        plus = 0;
	                    }
	
	                    // Add 1 pixel, when coordinates are the same
	                    path.push(
	                        horiz && toPath[4] === path[4] ? toPath[4] + plus : toPath[4], !horiz && toPath[5] === path[5] ? toPath[5] + plus : toPath[5],
	                        horiz && toPath[1] === path[1] ? toPath[1] + plus : toPath[1], !horiz && toPath[2] === path[2] ? toPath[2] + plus : toPath[2]
	                    );
	                } else { // outside the axis area
	                    path = null;
	                }
	
	                return path;
	            },
	
	            /**
	             * Add a plot band after render time.
	             *
	             * @param  {AxisPlotBandsOptions} options
	             *         A configuration object for the plot band, as defined in {@link
	             *         https://api.highcharts.com/highcharts/xAxis.plotBands|
	             *         xAxis.plotBands}.
	             * @return {Object}
	             *         The added plot band.
	             * @sample highcharts/members/axis-addplotband/
	             *         Toggle the plot band from a button
	             */
	            addPlotBand: function(options) {
	                return this.addPlotBandOrLine(options, 'plotBands');
	            },
	
	            /**
	             * Add a plot line after render time.
	             * 
	             * @param  {AxisPlotLinesOptions} options
	             *         A configuration object for the plot line, as defined in {@link
	             *         https://api.highcharts.com/highcharts/xAxis.plotLines|
	             *         xAxis.plotLines}.
	             * @return {Object}
	             *         The added plot line.
	             * @sample highcharts/members/axis-addplotline/
	             *         Toggle the plot line from a button
	             */
	            addPlotLine: function(options) {
	                return this.addPlotBandOrLine(options, 'plotLines');
	            },
	
	            /**
	             * Add a plot band or plot line after render time. Called from addPlotBand
	             * and addPlotLine internally.
	             *
	             * @private
	             * @param  options {AxisPlotLinesOptions|AxisPlotBandsOptions}
	             *         The plotBand or plotLine configuration object.
	             */
	            addPlotBandOrLine: function(options, coll) {
	                var obj = new H.PlotLineOrBand(this, options).render(),
	                    userOptions = this.userOptions;
	
	                if (obj) { // #2189
	                    // Add it to the user options for exporting and Axis.update
	                    if (coll) {
	                        userOptions[coll] = userOptions[coll] || [];
	                        userOptions[coll].push(options);
	                    }
	                    this.plotLinesAndBands.push(obj);
	                }
	
	                return obj;
	            },
	
	            /**
	             * Remove a plot band or plot line from the chart by id. Called internally
	             * from `removePlotBand` and `removePlotLine`.
	             *
	             * @private
	             * @param {String} id
	             */
	            removePlotBandOrLine: function(id) {
	                var plotLinesAndBands = this.plotLinesAndBands,
	                    options = this.options,
	                    userOptions = this.userOptions,
	                    i = plotLinesAndBands.length;
	                while (i--) {
	                    if (plotLinesAndBands[i].id === id) {
	                        plotLinesAndBands[i].destroy();
	                    }
	                }
	                each([
	                    options.plotLines || [],
	                    userOptions.plotLines || [],
	                    options.plotBands || [],
	                    userOptions.plotBands || []
	                ], function(arr) {
	                    i = arr.length;
	                    while (i--) {
	                        if (arr[i].id === id) {
	                            erase(arr, arr[i]);
	                        }
	                    }
	                });
	            },
	
	            /**
	             * Remove a plot band by its id.
	             * 
	             * @param  {String} id
	             *         The plot band's `id` as given in the original configuration
	             *         object or in the `addPlotBand` option.
	             * @sample highcharts/members/axis-removeplotband/
	             *         Remove plot band by id
	             * @sample highcharts/members/axis-addplotband/
	             *         Toggle the plot band from a button
	             */
	            removePlotBand: function(id) {
	                this.removePlotBandOrLine(id);
	            },
	
	            /**
	             * Remove a plot line by its id.
	             * @param  {String} id
	             *         The plot line's `id` as given in the original configuration
	             *         object or in the `addPlotLine` option.
	             * @sample highcharts/xaxis/plotlines-id/
	             *         Remove plot line by id
	             * @sample highcharts/members/axis-addplotline/
	             *         Toggle the plot line from a button
	             */
	            removePlotLine: function(id) {
	                this.removePlotBandOrLine(id);
	            }
	        });
	
	    }(Highcharts, Axis));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var dateFormat = H.dateFormat,
	            each = H.each,
	            extend = H.extend,
	            format = H.format,
	            isNumber = H.isNumber,
	            map = H.map,
	            merge = H.merge,
	            pick = H.pick,
	            splat = H.splat,
	            syncTimeout = H.syncTimeout,
	            timeUnits = H.timeUnits;
	        /**
	         * The tooltip object
	         * @param {Object} chart The chart instance
	         * @param {Object} options Tooltip options
	         */
	        H.Tooltip = function() {
	            this.init.apply(this, arguments);
	        };
	
	        H.Tooltip.prototype = {
	
	            init: function(chart, options) {
	
	                // Save the chart and options
	                this.chart = chart;
	                this.options = options;
	
	                // Keep track of the current series
	                //this.currentSeries = undefined;
	
	                // List of crosshairs
	                this.crosshairs = [];
	
	                // Current values of x and y when animating
	                this.now = {
	                    x: 0,
	                    y: 0
	                };
	
	                // The tooltip is initially hidden
	                this.isHidden = true;
	
	
	
	                // Public property for getting the shared state.
	                this.split = options.split && !chart.inverted;
	                this.shared = options.shared || this.split;
	
	            },
	
	            /**
	             * Destroy the single tooltips in a split tooltip.
	             * If the tooltip is active then it is not destroyed, unless forced to.
	             * @param  {boolean} force Force destroy all tooltips.
	             * @return {undefined}
	             */
	            cleanSplit: function(force) {
	                each(this.chart.series, function(series) {
	                    var tt = series && series.tt;
	                    if (tt) {
	                        if (!tt.isActive || force) {
	                            series.tt = tt.destroy();
	                        } else {
	                            tt.isActive = false;
	                        }
	                    }
	                });
	            },
	
	
	
	
	            /**
	             * Create the Tooltip label element if it doesn't exist, then return the
	             * label.
	             */
	            getLabel: function() {
	
	                var renderer = this.chart.renderer,
	                    options = this.options;
	
	                if (!this.label) {
	                    // Create the label
	                    if (this.split) {
	                        this.label = renderer.g('tooltip');
	                    } else {
	                        this.label = renderer.label(
	                                '',
	                                0,
	                                0,
	                                options.shape || 'callout',
	                                null,
	                                null,
	                                options.useHTML,
	                                null,
	                                'tooltip'
	                            )
	                            .attr({
	                                padding: options.padding,
	                                r: options.borderRadius
	                            });
	
	
	                        this.label
	                            .attr({
	                                'fill': options.backgroundColor,
	                                'stroke-width': options.borderWidth
	                            })
	                            // #2301, #2657
	                            .css(options.style)
	                            .shadow(options.shadow);
	
	                    }
	
	
	
	                    this.label
	                        .attr({
	                            zIndex: 8
	                        })
	                        .add();
	                }
	                return this.label;
	            },
	
	            update: function(options) {
	                this.destroy();
	                // Update user options (#6218)
	                merge(true, this.chart.options.tooltip.userOptions, options);
	                this.init(this.chart, merge(true, this.options, options));
	            },
	
	            /**
	             * Destroy the tooltip and its elements.
	             */
	            destroy: function() {
	                // Destroy and clear local variables
	                if (this.label) {
	                    this.label = this.label.destroy();
	                }
	                if (this.split && this.tt) {
	                    this.cleanSplit(this.chart, true);
	                    this.tt = this.tt.destroy();
	                }
	                clearTimeout(this.hideTimer);
	                clearTimeout(this.tooltipTimeout);
	            },
	
	            /**
	             * Provide a soft movement for the tooltip
	             *
	             * @param {Number} x
	             * @param {Number} y
	             * @private
	             */
	            move: function(x, y, anchorX, anchorY) {
	                var tooltip = this,
	                    now = tooltip.now,
	                    animate = tooltip.options.animation !== false && !tooltip.isHidden &&
	                    // When we get close to the target position, abort animation and land on the right place (#3056)
	                    (Math.abs(x - now.x) > 1 || Math.abs(y - now.y) > 1),
	                    skipAnchor = tooltip.followPointer || tooltip.len > 1;
	
	                // Get intermediate values for animation
	                extend(now, {
	                    x: animate ? (2 * now.x + x) / 3 : x,
	                    y: animate ? (now.y + y) / 2 : y,
	                    anchorX: skipAnchor ? undefined : animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,
	                    anchorY: skipAnchor ? undefined : animate ? (now.anchorY + anchorY) / 2 : anchorY
	                });
	
	                // Move to the intermediate value
	                tooltip.getLabel().attr(now);
	
	
	                // Run on next tick of the mouse tracker
	                if (animate) {
	
	                    // Never allow two timeouts
	                    clearTimeout(this.tooltipTimeout);
	
	                    // Set the fixed interval ticking for the smooth tooltip
	                    this.tooltipTimeout = setTimeout(function() {
	                        // The interval function may still be running during destroy,
	                        // so check that the chart is really there before calling.
	                        if (tooltip) {
	                            tooltip.move(x, y, anchorX, anchorY);
	                        }
	                    }, 32);
	
	                }
	            },
	
	            /**
	             * Hide the tooltip
	             */
	            hide: function(delay) {
	                var tooltip = this;
	                clearTimeout(this.hideTimer); // disallow duplicate timers (#1728, #1766)
	                delay = pick(delay, this.options.hideDelay, 500);
	                if (!this.isHidden) {
	                    this.hideTimer = syncTimeout(function() {
	                        tooltip.getLabel()[delay ? 'fadeOut' : 'hide']();
	                        tooltip.isHidden = true;
	                    }, delay);
	                }
	            },
	
	            /**
	             * Extendable method to get the anchor position of the tooltip
	             * from a point or set of points
	             */
	            getAnchor: function(points, mouseEvent) {
	                var ret,
	                    chart = this.chart,
	                    inverted = chart.inverted,
	                    plotTop = chart.plotTop,
	                    plotLeft = chart.plotLeft,
	                    plotX = 0,
	                    plotY = 0,
	                    yAxis,
	                    xAxis;
	
	                points = splat(points);
	
	                // Pie uses a special tooltipPos
	                ret = points[0].tooltipPos;
	
	                // When tooltip follows mouse, relate the position to the mouse
	                if (this.followPointer && mouseEvent) {
	                    if (mouseEvent.chartX === undefined) {
	                        mouseEvent = chart.pointer.normalize(mouseEvent);
	                    }
	                    ret = [
	                        mouseEvent.chartX - chart.plotLeft,
	                        mouseEvent.chartY - plotTop
	                    ];
	                }
	                // When shared, use the average position
	                if (!ret) {
	                    each(points, function(point) {
	                        yAxis = point.series.yAxis;
	                        xAxis = point.series.xAxis;
	                        plotX += point.plotX + (!inverted && xAxis ? xAxis.left - plotLeft : 0);
	                        plotY += (point.plotLow ? (point.plotLow + point.plotHigh) / 2 : point.plotY) +
	                            (!inverted && yAxis ? yAxis.top - plotTop : 0); // #1151
	                    });
	
	                    plotX /= points.length;
	                    plotY /= points.length;
	
	                    ret = [
	                        inverted ? chart.plotWidth - plotY : plotX,
	                        this.shared && !inverted && points.length > 1 && mouseEvent ?
	                        mouseEvent.chartY - plotTop : // place shared tooltip next to the mouse (#424)
	                        inverted ? chart.plotHeight - plotX : plotY
	                    ];
	                }
	
	                return map(ret, Math.round);
	            },
	
	            /**
	             * Place the tooltip in a chart without spilling over
	             * and not covering the point it self.
	             */
	            getPosition: function(boxWidth, boxHeight, point) {
	
	                var chart = this.chart,
	                    distance = this.distance,
	                    ret = {},
	                    h = point.h || 0, // #4117
	                    swapped,
	                    first = ['y', chart.chartHeight, boxHeight,
	                        point.plotY + chart.plotTop, chart.plotTop,
	                        chart.plotTop + chart.plotHeight
	                    ],
	                    second = ['x', chart.chartWidth, boxWidth,
	                        point.plotX + chart.plotLeft, chart.plotLeft,
	                        chart.plotLeft + chart.plotWidth
	                    ],
	                    // The far side is right or bottom
	                    preferFarSide = !this.followPointer && pick(point.ttBelow, !chart.inverted === !!point.negative), // #4984
	                    /**
	                     * Handle the preferred dimension. When the preferred dimension is tooltip
	                     * on top or bottom of the point, it will look for space there.
	                     */
	                    firstDimension = function(dim, outerSize, innerSize, point, min, max) {
	                        var roomLeft = innerSize < point - distance,
	                            roomRight = point + distance + innerSize < outerSize,
	                            alignedLeft = point - distance - innerSize,
	                            alignedRight = point + distance;
	
	                        if (preferFarSide && roomRight) {
	                            ret[dim] = alignedRight;
	                        } else if (!preferFarSide && roomLeft) {
	                            ret[dim] = alignedLeft;
	                        } else if (roomLeft) {
	                            ret[dim] = Math.min(max - innerSize, alignedLeft - h < 0 ? alignedLeft : alignedLeft - h);
	                        } else if (roomRight) {
	                            ret[dim] = Math.max(
	                                min,
	                                alignedRight + h + innerSize > outerSize ?
	                                alignedRight :
	                                alignedRight + h
	                            );
	                        } else {
	                            return false;
	                        }
	                    },
	                    /**
	                     * Handle the secondary dimension. If the preferred dimension is tooltip
	                     * on top or bottom of the point, the second dimension is to align the tooltip
	                     * above the point, trying to align center but allowing left or right
	                     * align within the chart box.
	                     */
	                    secondDimension = function(dim, outerSize, innerSize, point) {
	                        var retVal;
	
	                        // Too close to the edge, return false and swap dimensions
	                        if (point < distance || point > outerSize - distance) {
	                            retVal = false;
	                            // Align left/top
	                        } else if (point < innerSize / 2) {
	                            ret[dim] = 1;
	                            // Align right/bottom
	                        } else if (point > outerSize - innerSize / 2) {
	                            ret[dim] = outerSize - innerSize - 2;
	                            // Align center
	                        } else {
	                            ret[dim] = point - innerSize / 2;
	                        }
	                        return retVal;
	                    },
	                    /**
	                     * Swap the dimensions
	                     */
	                    swap = function(count) {
	                        var temp = first;
	                        first = second;
	                        second = temp;
	                        swapped = count;
	                    },
	                    run = function() {
	                        if (firstDimension.apply(0, first) !== false) {
	                            if (secondDimension.apply(0, second) === false && !swapped) {
	                                swap(true);
	                                run();
	                            }
	                        } else if (!swapped) {
	                            swap(true);
	                            run();
	                        } else {
	                            ret.x = ret.y = 0;
	                        }
	                    };
	
	                // Under these conditions, prefer the tooltip on the side of the point
	                if (chart.inverted || this.len > 1) {
	                    swap();
	                }
	                run();
	
	                return ret;
	
	            },
	
	            /**
	             * In case no user defined formatter is given, this will be used. Note that the context
	             * here is an object holding point, series, x, y etc.
	             *
	             * @returns {String|Array<String>}
	             */
	            defaultFormatter: function(tooltip) {
	                var items = this.points || splat(this),
	                    s;
	
	                // Build the header
	                s = [tooltip.tooltipFooterHeaderFormatter(items[0])];
	
	                // build the values
	                s = s.concat(tooltip.bodyFormatter(items));
	
	                // footer
	                s.push(tooltip.tooltipFooterHeaderFormatter(items[0], true));
	
	                return s;
	            },
	
	            /**
	             * Refresh the tooltip's text and position.
	             * @param {Object|Array} pointOrPoints Rither a point or an array of points
	             */
	            refresh: function(pointOrPoints, mouseEvent) {
	                var tooltip = this,
	                    label,
	                    options = tooltip.options,
	                    x,
	                    y,
	                    point = pointOrPoints,
	                    anchor,
	                    textConfig = {},
	                    text,
	                    pointConfig = [],
	                    formatter = options.formatter || tooltip.defaultFormatter,
	                    shared = tooltip.shared,
	                    currentSeries;
	
	                if (!options.enabled) {
	                    return;
	                }
	
	                clearTimeout(this.hideTimer);
	
	                // get the reference point coordinates (pie charts use tooltipPos)
	                tooltip.followPointer = splat(point)[0].series.tooltipOptions.followPointer;
	                anchor = tooltip.getAnchor(point, mouseEvent);
	                x = anchor[0];
	                y = anchor[1];
	
	                // shared tooltip, array is sent over
	                if (shared && !(point.series && point.series.noSharedTooltip)) {
	                    each(point, function(item) {
	                        item.setState('hover');
	
	                        pointConfig.push(item.getLabelConfig());
	                    });
	
	                    textConfig = {
	                        x: point[0].category,
	                        y: point[0].y
	                    };
	                    textConfig.points = pointConfig;
	                    point = point[0];
	
	                    // single point tooltip
	                } else {
	                    textConfig = point.getLabelConfig();
	                }
	                this.len = pointConfig.length; // #6128
	                text = formatter.call(textConfig, tooltip);
	
	                // register the current series
	                currentSeries = point.series;
	                this.distance = pick(currentSeries.tooltipOptions.distance, 16);
	
	                // update the inner HTML
	                if (text === false) {
	                    this.hide();
	                } else {
	
	                    label = tooltip.getLabel();
	
	                    // show it
	                    if (tooltip.isHidden) {
	                        label.attr({
	                            opacity: 1
	                        }).show();
	                    }
	
	                    // update text
	                    if (tooltip.split) {
	                        this.renderSplit(text, pointOrPoints);
	                    } else {
	
	                        // Prevent the tooltip from flowing over the chart box (#6659)
	
	                        if (!options.style.width) {
	
	                            label.css({
	                                width: this.chart.spacingBox.width
	                            });
	
	                        }
	
	
	                        label.attr({
	                            text: text && text.join ? text.join('') : text
	                        });
	
	                        // Set the stroke color of the box to reflect the point
	                        label.removeClass(/highcharts-color-[\d]+/g)
	                            .addClass('highcharts-color-' + pick(point.colorIndex, currentSeries.colorIndex));
	
	
	                        label.attr({
	                            stroke: options.borderColor || point.color || currentSeries.color || '#666666'
	                        });
	
	
	                        tooltip.updatePosition({
	                            plotX: x,
	                            plotY: y,
	                            negative: point.negative,
	                            ttBelow: point.ttBelow,
	                            h: anchor[2] || 0
	                        });
	                    }
	
	                    this.isHidden = false;
	                }
	            },
	
	            /**
	             * Render the split tooltip. Loops over each point's text and adds
	             * a label next to the point, then uses the distribute function to 
	             * find best non-overlapping positions.
	             */
	            renderSplit: function(labels, points) {
	                var tooltip = this,
	                    boxes = [],
	                    chart = this.chart,
	                    ren = chart.renderer,
	                    rightAligned = true,
	                    options = this.options,
	                    headerHeight = 0,
	                    tooltipLabel = this.getLabel();
	
	                // Create the individual labels for header and points, ignore footer
	                each(labels.slice(0, points.length + 1), function(str, i) {
	                    if (str !== false) {
	                        var point = points[i - 1] ||
	                            // Item 0 is the header. Instead of this, we could also
	                            // use the crosshair label
	                            {
	                                isHeader: true,
	                                plotX: points[0].plotX
	                            },
	                            owner = point.series || tooltip,
	                            tt = owner.tt,
	                            series = point.series || {},
	                            colorClass = 'highcharts-color-' + pick(
	                                point.colorIndex,
	                                series.colorIndex,
	                                'none'
	                            ),
	                            target,
	                            x,
	                            bBox,
	                            boxWidth;
	
	                        // Store the tooltip referance on the series
	                        if (!tt) {
	                            owner.tt = tt = ren.label(null, null, null, 'callout')
	                                .addClass('highcharts-tooltip-box ' + colorClass)
	                                .attr({
	                                    'padding': options.padding,
	                                    'r': options.borderRadius,
	
	                                    'fill': options.backgroundColor,
	                                    'stroke': (
	                                        options.borderColor ||
	                                        point.color ||
	                                        series.color ||
	                                        '#333333'
	                                    ),
	                                    'stroke-width': options.borderWidth
	
	                                })
	                                .add(tooltipLabel);
	                        }
	
	                        tt.isActive = true;
	                        tt.attr({
	                            text: str
	                        });
	
	                        tt.css(options.style)
	                            .shadow(options.shadow);
	
	
	                        // Get X position now, so we can move all to the other side in
	                        // case of overflow
	                        bBox = tt.getBBox();
	                        boxWidth = bBox.width + tt.strokeWidth();
	                        if (point.isHeader) {
	                            headerHeight = bBox.height;
	                            x = Math.max(
	                                0, // No left overflow
	                                Math.min(
	                                    point.plotX + chart.plotLeft - boxWidth / 2,
	                                    // No right overflow (#5794)
	                                    chart.chartWidth - boxWidth
	                                )
	                            );
	                        } else {
	                            x = point.plotX + chart.plotLeft -
	                                pick(options.distance, 16) - boxWidth;
	                        }
	
	
	                        // If overflow left, we don't use this x in the next loop
	                        if (x < 0) {
	                            rightAligned = false;
	                        }
	
	                        // Prepare for distribution
	                        target = (point.series && point.series.yAxis &&
	                            point.series.yAxis.pos) + (point.plotY || 0);
	                        target -= chart.plotTop;
	                        boxes.push({
	                            target: point.isHeader ?
	                                chart.plotHeight + headerHeight : target,
	                            rank: point.isHeader ? 1 : 0,
	                            size: owner.tt.getBBox().height + 1,
	                            point: point,
	                            x: x,
	                            tt: tt
	                        });
	                    }
	                });
	
	                // Clean previous run (for missing points)
	                this.cleanSplit();
	
	                // Distribute and put in place
	                H.distribute(boxes, chart.plotHeight + headerHeight);
	                each(boxes, function(box) {
	                    var point = box.point,
	                        series = point.series;
	
	                    // Put the label in place
	                    box.tt.attr({
	                        visibility: box.pos === undefined ? 'hidden' : 'inherit',
	                        x: (rightAligned || point.isHeader ?
	                            box.x :
	                            point.plotX + chart.plotLeft + pick(options.distance, 16)),
	                        y: box.pos + chart.plotTop,
	                        anchorX: point.isHeader ?
	                            point.plotX + chart.plotLeft : point.plotX + series.xAxis.pos,
	                        anchorY: point.isHeader ?
	                            box.pos + chart.plotTop - 15 : point.plotY + series.yAxis.pos
	                    });
	                });
	            },
	
	            /**
	             * Find the new position and perform the move
	             */
	            updatePosition: function(point) {
	                var chart = this.chart,
	                    label = this.getLabel(),
	                    pos = (this.options.positioner || this.getPosition).call(
	                        this,
	                        label.width,
	                        label.height,
	                        point
	                    );
	
	                // do the move
	                this.move(
	                    Math.round(pos.x),
	                    Math.round(pos.y || 0), // can be undefined (#3977) 
	                    point.plotX + chart.plotLeft,
	                    point.plotY + chart.plotTop
	                );
	            },
	
	            /**
	             * Get the optimal date format for a point, based on a range.
	             * @param  {number} range - The time range
	             * @param  {number|Date} date - The date of the point in question
	             * @param  {number} startOfWeek - An integer representing the first day of
	             * the week, where 0 is Sunday
	             * @param  {Object} dateTimeLabelFormats - A map of time units to formats
	             * @return {string} - the optimal date format for a point
	             */
	            getDateFormat: function(range, date, startOfWeek, dateTimeLabelFormats) {
	                var dateStr = dateFormat('%m-%d %H:%M:%S.%L', date),
	                    format,
	                    n,
	                    blank = '01-01 00:00:00.000',
	                    strpos = {
	                        millisecond: 15,
	                        second: 12,
	                        minute: 9,
	                        hour: 6,
	                        day: 3
	                    },
	                    lastN = 'millisecond'; // for sub-millisecond data, #4223
	                for (n in timeUnits) {
	
	                    // If the range is exactly one week and we're looking at a Sunday/Monday, go for the week format
	                    if (range === timeUnits.week && +dateFormat('%w', date) === startOfWeek &&
	                        dateStr.substr(6) === blank.substr(6)) {
	                        n = 'week';
	                        break;
	                    }
	
	                    // The first format that is too great for the range
	                    if (timeUnits[n] > range) {
	                        n = lastN;
	                        break;
	                    }
	
	                    // If the point is placed every day at 23:59, we need to show
	                    // the minutes as well. #2637.
	                    if (strpos[n] && dateStr.substr(strpos[n]) !== blank.substr(strpos[n])) {
	                        break;
	                    }
	
	                    // Weeks are outside the hierarchy, only apply them on Mondays/Sundays like in the first condition
	                    if (n !== 'week') {
	                        lastN = n;
	                    }
	                }
	
	                if (n) {
	                    format = dateTimeLabelFormats[n];
	                }
	
	                return format;
	            },
	
	            /**
	             * Get the best X date format based on the closest point range on the axis.
	             */
	            getXDateFormat: function(point, options, xAxis) {
	                var xDateFormat,
	                    dateTimeLabelFormats = options.dateTimeLabelFormats,
	                    closestPointRange = xAxis && xAxis.closestPointRange;
	
	                if (closestPointRange) {
	                    xDateFormat = this.getDateFormat(
	                        closestPointRange,
	                        point.x,
	                        xAxis.options.startOfWeek,
	                        dateTimeLabelFormats
	                    );
	                } else {
	                    xDateFormat = dateTimeLabelFormats.day;
	                }
	
	                return xDateFormat || dateTimeLabelFormats.year; // #2546, 2581
	            },
	
	            /**
	             * Format the footer/header of the tooltip
	             * #3397: abstraction to enable formatting of footer and header
	             */
	            tooltipFooterHeaderFormatter: function(labelConfig, isFooter) {
	                var footOrHead = isFooter ? 'footer' : 'header',
	                    series = labelConfig.series,
	                    tooltipOptions = series.tooltipOptions,
	                    xDateFormat = tooltipOptions.xDateFormat,
	                    xAxis = series.xAxis,
	                    isDateTime = xAxis && xAxis.options.type === 'datetime' && isNumber(labelConfig.key),
	                    formatString = tooltipOptions[footOrHead + 'Format'];
	
	                // Guess the best date format based on the closest point distance (#568, #3418)
	                if (isDateTime && !xDateFormat) {
	                    xDateFormat = this.getXDateFormat(labelConfig, tooltipOptions, xAxis);
	                }
	
	                // Insert the footer date format if any
	                if (isDateTime && xDateFormat) {
	                    formatString = formatString.replace('{point.key}', '{point.key:' + xDateFormat + '}');
	                }
	
	                return format(formatString, {
	                    point: labelConfig,
	                    series: series
	                });
	            },
	
	            /**
	             * Build the body (lines) of the tooltip by iterating over the items and returning one entry for each item,
	             * abstracting this functionality allows to easily overwrite and extend it.
	             */
	            bodyFormatter: function(items) {
	                return map(items, function(item) {
	                    var tooltipOptions = item.series.tooltipOptions;
	                    return (tooltipOptions.pointFormatter || item.point.tooltipFormatter)
	                        .call(item.point, tooltipOptions.pointFormat);
	                });
	            }
	
	        };
	
	    }(Highcharts));
	    (function(Highcharts) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var H = Highcharts,
	            addEvent = H.addEvent,
	            attr = H.attr,
	            charts = H.charts,
	            color = H.color,
	            css = H.css,
	            defined = H.defined,
	            each = H.each,
	            extend = H.extend,
	            find = H.find,
	            fireEvent = H.fireEvent,
	            isObject = H.isObject,
	            offset = H.offset,
	            pick = H.pick,
	            removeEvent = H.removeEvent,
	            splat = H.splat,
	            Tooltip = H.Tooltip,
	            win = H.win;
	
	        /**
	         * The mouse and touch tracker object. Each {@link Chart} item has one
	         * assosiated Pointer item that can be accessed from the  {@link Chart.pointer}
	         * property.
	         *
	         * @class
	         * @param  {Chart} chart
	         *         The Chart instance.
	         * @param  {Options} options
	         *         The root options object. The pointer uses options from the chart and
	         *         tooltip structures.
	         */
	        Highcharts.Pointer = function(chart, options) {
	            this.init(chart, options);
	        };
	
	        Highcharts.Pointer.prototype = {
	            /**
	             * Initialize the Pointer.
	             *
	             * @private
	             */
	            init: function(chart, options) {
	
	                // Store references
	                this.options = options;
	                this.chart = chart;
	
	                // Do we need to handle click on a touch device?
	                this.runChartClick = options.chart.events && !!options.chart.events.click;
	
	                this.pinchDown = [];
	                this.lastValidTouch = {};
	
	                if (Tooltip) {
	                    chart.tooltip = new Tooltip(chart, options.tooltip);
	                    this.followTouchMove = pick(options.tooltip.followTouchMove, true);
	                }
	
	                this.setDOMEvents();
	            },
	
	            /**
	             * Resolve the zoomType option, this is reset on all touch start and mouse
	             * down events.
	             *
	             * @private
	             */
	            zoomOption: function(e) {
	                var chart = this.chart,
	                    options = chart.options.chart,
	                    zoomType = options.zoomType || '',
	                    inverted = chart.inverted,
	                    zoomX,
	                    zoomY;
	
	                // Look for the pinchType option
	                if (/touch/.test(e.type)) {
	                    zoomType = pick(options.pinchType, zoomType);
	                }
	
	                this.zoomX = zoomX = /x/.test(zoomType);
	                this.zoomY = zoomY = /y/.test(zoomType);
	                this.zoomHor = (zoomX && !inverted) || (zoomY && inverted);
	                this.zoomVert = (zoomY && !inverted) || (zoomX && inverted);
	                this.hasZoom = zoomX || zoomY;
	            },
	
	            /**
	             * @typedef  {Object} PointerEvent
	             *           A native browser mouse or touch event, extended with position
	             *           information relative to the {@link Chart.container}.
	             * @property {Number} chartX
	             *           The X coordinate of the pointer interaction relative to the
	             *           chart.
	             * @property {Number} chartY
	             *           The Y coordinate of the pointer interaction relative to the 
	             *           chart.
	             * 
	             */
	            /**
	             * Takes a browser event object and extends it with custom Highcharts
	             * properties `chartX` and `chartY` in order to work on the internal 
	             * coordinate system.
	             * 
	             * @param  {Object} e
	             *         The event object in standard browsers.
	             *
	             * @return {PointerEvent}
	             *         A browser event with extended properties `chartX` and `chartY`.
	             */
	            normalize: function(e, chartPosition) {
	                var chartX,
	                    chartY,
	                    ePos;
	
	                // IE normalizing
	                e = e || win.event;
	                if (!e.target) {
	                    e.target = e.srcElement;
	                }
	
	                // iOS (#2757)
	                ePos = e.touches ? (e.touches.length ? e.touches.item(0) : e.changedTouches[0]) : e;
	
	                // Get mouse position
	                if (!chartPosition) {
	                    this.chartPosition = chartPosition = offset(this.chart.container);
	                }
	
	                // chartX and chartY
	                if (ePos.pageX === undefined) { // IE < 9. #886.
	                    chartX = Math.max(e.x, e.clientX - chartPosition.left); // #2005, #2129: the second case is 
	                    // for IE10 quirks mode within framesets
	                    chartY = e.y;
	                } else {
	                    chartX = ePos.pageX - chartPosition.left;
	                    chartY = ePos.pageY - chartPosition.top;
	                }
	
	                return extend(e, {
	                    chartX: Math.round(chartX),
	                    chartY: Math.round(chartY)
	                });
	            },
	
	            /**
	             * Get the click position in terms of axis values.
	             *
	             * @param  {PointerEvent} e
	             *         A pointer event, extended with `chartX` and `chartY`
	             *         properties.
	             */
	            getCoordinates: function(e) {
	                var coordinates = {
	                    xAxis: [],
	                    yAxis: []
	                };
	
	                each(this.chart.axes, function(axis) {
	                    coordinates[axis.isXAxis ? 'xAxis' : 'yAxis'].push({
	                        axis: axis,
	                        value: axis.toValue(e[axis.horiz ? 'chartX' : 'chartY'])
	                    });
	                });
	                return coordinates;
	            },
	            /**
	             * Finds the closest point to a set of coordinates, using the k-d-tree
	             * algorithm.
	             *
	             * @param  {Array.<Series>} series
	             *         All the series to search in.
	             * @param  {boolean} shared
	             *         Whether it is a shared tooltip or not.
	             * @param  {object} coordinates
	             *         Chart coordinates of the pointer.
	             * @param  {number} coordinates.chartX
	             * @param  {number} coordinates.chartY
	             *
	             * @return {Point|undefined} The point closest to given coordinates.
	             */
	            findNearestKDPoint: function(series, shared, coordinates) {
	                var closest,
	                    sort = function(p1, p2) {
	                        var isCloserX = p1.distX - p2.distX,
	                            isCloser = p1.dist - p2.dist,
	                            isAbove =
	                            (p2.series.group && p2.series.group.zIndex) -
	                            (p1.series.group && p1.series.group.zIndex),
	                            result;
	
	                        // We have two points which are not in the same place on xAxis
	                        // and shared tooltip:
	                        if (isCloserX !== 0 && shared) { // #5721
	                            result = isCloserX;
	                            // Points are not exactly in the same place on x/yAxis:
	                        } else if (isCloser !== 0) {
	                            result = isCloser;
	                            // The same xAxis and yAxis position, sort by z-index:
	                        } else if (isAbove !== 0) {
	                            result = isAbove;
	                            // The same zIndex, sort by array index:
	                        } else {
	                            result = p1.series.index > p2.series.index ? -1 : 1;
	                        }
	                        return result;
	                    };
	                each(series, function(s) {
	                    var noSharedTooltip = s.noSharedTooltip && shared,
	                        compareX = (!noSharedTooltip &&
	                            s.options.findNearestPointBy.indexOf('y') < 0
	                        ),
	                        point = s.searchPoint(
	                            coordinates,
	                            compareX
	                        );
	                    if (
	                        // Check that we actually found a point on the series.
	                        isObject(point, true) &&
	                        // Use the new point if it is closer.
	                        (!isObject(closest, true) || (sort(closest, point) > 0))
	                    ) {
	                        closest = point;
	                    }
	                });
	                return closest;
	            },
	            getPointFromEvent: function(e) {
	                var target = e.target,
	                    point;
	
	                while (target && !point) {
	                    point = target.point;
	                    target = target.parentNode;
	                }
	                return point;
	            },
	
	            getChartCoordinatesFromPoint: function(point, inverted) {
	                var series = point.series,
	                    xAxis = series.xAxis,
	                    yAxis = series.yAxis;
	
	                if (xAxis && yAxis) {
	                    return inverted ? {
	                        chartX: xAxis.len + xAxis.pos - point.clientX,
	                        chartY: yAxis.len + yAxis.pos - point.plotY
	                    } : {
	                        chartX: point.clientX + xAxis.pos,
	                        chartY: point.plotY + yAxis.pos
	                    };
	                }
	            },
	
	            /**
	             * Calculates what is the current hovered point/points and series.
	             *
	             * @private
	             *
	             * @param  {undefined|Point} existingHoverPoint
	             *         The point currrently beeing hovered.
	             * @param  {undefined|Series} existingHoverSeries
	             *         The series currently beeing hovered.
	             * @param  {Array.<Series>} series
	             *         All the series in the chart.
	             * @param  {boolean} isDirectTouch
	             *         Is the pointer directly hovering the point.
	             * @param  {boolean} shared
	             *         Whether it is a shared tooltip or not.
	             * @param  {object} coordinates
	             *         Chart coordinates of the pointer.
	             * @param  {number} coordinates.chartX
	             * @param  {number} coordinates.chartY
	             * 
	             * @return {object}
	             *         Object containing resulting hover data.
	             */
	            getHoverData: function(
	                existingHoverPoint,
	                existingHoverSeries,
	                series,
	                isDirectTouch,
	                shared,
	                coordinates
	            ) {
	                var hoverPoint,
	                    hoverPoints = [],
	                    hoverSeries = existingHoverSeries,
	                    useExisting = !!(isDirectTouch && existingHoverPoint),
	                    notSticky = hoverSeries && !hoverSeries.stickyTracking,
	                    filter = function(s) {
	                        return (
	                            s.visible &&
	                            !(!shared && s.directTouch) && // #3821
	                            pick(s.options.enableMouseTracking, true)
	                        );
	                    },
	                    // Which series to look in for the hover point
	                    searchSeries = notSticky ?
	                    // Only search on hovered series if it has stickyTracking false
	                    [hoverSeries] :
	                    // Filter what series to look in.
	                    H.grep(series, function(s) {
	                        return filter(s) && s.stickyTracking;
	                    });
	
	                // Use existing hovered point or find the one closest to coordinates.
	                hoverPoint = useExisting ?
	                    existingHoverPoint :
	                    this.findNearestKDPoint(searchSeries, shared, coordinates);
	
	                // Assign hover series
	                hoverSeries = hoverPoint && hoverPoint.series;
	
	                // If we have a hoverPoint, assign hoverPoints.
	                if (hoverPoint) {
	                    // When tooltip is shared, it displays more than one point
	                    if (shared && !hoverSeries.noSharedTooltip) {
	                        searchSeries = H.grep(series, function(s) {
	                            return filter(s) && !s.noSharedTooltip;
	                        });
	
	                        // Get all points with the same x value as the hoverPoint
	                        each(searchSeries, function(s) {
	                            var point = find(s.points, function(p) {
	                                return p.x === hoverPoint.x;
	                            });
	                            if (isObject(point) && !point.isNull) {
	                                hoverPoints.push(point);
	                            }
	                        });
	                    } else {
	                        hoverPoints.push(hoverPoint);
	                    }
	                }
	
	                return {
	                    hoverPoint: hoverPoint,
	                    hoverSeries: hoverSeries,
	                    hoverPoints: hoverPoints
	                };
	            },
	            /**
	             * With line type charts with a single tracker, get the point closest to the
	             * mouse. Run Point.onMouseOver and display tooltip for the point or points.
	             *
	             * @private
	             */
	            runPointActions: function(e, p) {
	                var pointer = this,
	                    chart = pointer.chart,
	                    series = chart.series,
	                    tooltip = chart.tooltip,
	                    shared = tooltip ? tooltip.shared : false,
	                    hoverPoint = p || chart.hoverPoint,
	                    hoverSeries = hoverPoint && hoverPoint.series || chart.hoverSeries,
	                    // onMouseOver or already hovering a series with directTouch
	                    isDirectTouch = !!p || (
	                        (hoverSeries && hoverSeries.directTouch) &&
	                        pointer.isDirectTouch
	                    ),
	                    hoverData = this.getHoverData(
	                        hoverPoint,
	                        hoverSeries,
	                        series,
	                        isDirectTouch,
	                        shared,
	                        e
	                    ),
	                    useSharedTooltip,
	                    followPointer,
	                    anchor,
	                    points;
	                // Update variables from hoverData.
	                hoverPoint = hoverData.hoverPoint;
	                points = hoverData.hoverPoints;
	                hoverSeries = hoverData.hoverSeries;
	                followPointer = hoverSeries && hoverSeries.tooltipOptions.followPointer;
	                useSharedTooltip = shared && hoverSeries && !hoverSeries.noSharedTooltip;
	
	                // Refresh tooltip for kdpoint if new hover point or tooltip was hidden
	                // #3926, #4200
	                if (
	                    hoverPoint &&
	                    // !(hoverSeries && hoverSeries.directTouch) &&
	                    (hoverPoint !== chart.hoverPoint || (tooltip && tooltip.isHidden))
	                ) {
	                    each(chart.hoverPoints || [], function(p) {
	                        if (H.inArray(p, points) === -1) {
	                            p.setState();
	                        }
	                    });
	                    // Do mouseover on all points (#3919, #3985, #4410, #5622)
	                    each(points || [], function(p) {
	                        p.setState('hover');
	                    });
	                    // set normal state to previous series
	                    if (chart.hoverSeries !== hoverSeries) {
	                        hoverSeries.onMouseOver();
	                    }
	
	                    // If tracking is on series in stead of on each point, 
	                    // fire mouseOver on hover point. // #4448
	                    if (chart.hoverPoint) {
	                        chart.hoverPoint.firePointEvent('mouseOut');
	                    }
	                    hoverPoint.firePointEvent('mouseOver');
	                    chart.hoverPoints = points;
	                    chart.hoverPoint = hoverPoint;
	                    // Draw tooltip if necessary
	                    if (tooltip) {
	                        tooltip.refresh(useSharedTooltip ? points : hoverPoint, e);
	                    }
	                    // Update positions (regardless of kdpoint or hoverPoint)
	                } else if (followPointer && tooltip && !tooltip.isHidden) {
	                    anchor = tooltip.getAnchor([{}], e);
	                    tooltip.updatePosition({
	                        plotX: anchor[0],
	                        plotY: anchor[1]
	                    });
	                }
	
	                // Start the event listener to pick up the tooltip and crosshairs
	                if (!pointer.unDocMouseMove) {
	                    pointer.unDocMouseMove = addEvent(
	                        chart.container.ownerDocument,
	                        'mousemove',
	                        function(e) {
	                            var chart = charts[H.hoverChartIndex];
	                            if (chart) {
	                                chart.pointer.onDocumentMouseMove(e);
	                            }
	                        }
	                    );
	                }
	
	                // Issues related to crosshair #4927, #5269 #5066, #5658
	                each(chart.axes, function drawAxisCrosshair(axis) {
	                    var snap = pick(axis.crosshair.snap, true),
	                        point = !snap ?
	                        undefined :
	                        H.find(points, function(p) {
	                            return p.series[axis.coll] === axis;
	                        });
	
	                    // Axis has snapping crosshairs, and one of the hover points belongs
	                    // to axis. Always call drawCrosshair when it is not snap.
	                    if (point || !snap) {
	                        axis.drawCrosshair(e, point);
	                        // Axis has snapping crosshairs, but no hover point belongs to axis
	                    } else {
	                        axis.hideCrosshair();
	                    }
	                });
	            },
	
	            /**
	             * Reset the tracking by hiding the tooltip, the hover series state and the
	             * hover point
	             *
	             * @param allowMove {Boolean}
	             *        Instead of destroying the tooltip altogether, allow moving it if
	             *        possible.
	             */
	            reset: function(allowMove, delay) {
	                var pointer = this,
	                    chart = pointer.chart,
	                    hoverSeries = chart.hoverSeries,
	                    hoverPoint = chart.hoverPoint,
	                    hoverPoints = chart.hoverPoints,
	                    tooltip = chart.tooltip,
	                    tooltipPoints = tooltip && tooltip.shared ? hoverPoints : hoverPoint;
	
	                // Check if the points have moved outside the plot area (#1003, #4736, #5101)
	                if (allowMove && tooltipPoints) {
	                    each(splat(tooltipPoints), function(point) {
	                        if (point.series.isCartesian && point.plotX === undefined) {
	                            allowMove = false;
	                        }
	                    });
	                }
	
	                // Just move the tooltip, #349
	                if (allowMove) {
	                    if (tooltip && tooltipPoints) {
	                        tooltip.refresh(tooltipPoints);
	                        if (hoverPoint) { // #2500
	                            hoverPoint.setState(hoverPoint.state, true);
	                            each(chart.axes, function(axis) {
	                                if (axis.crosshair) {
	                                    axis.drawCrosshair(null, hoverPoint);
	                                }
	                            });
	                        }
	                    }
	
	                    // Full reset
	                } else {
	
	                    if (hoverPoint) {
	                        hoverPoint.onMouseOut();
	                    }
	
	                    if (hoverPoints) {
	                        each(hoverPoints, function(point) {
	                            point.setState();
	                        });
	                    }
	
	                    if (hoverSeries) {
	                        hoverSeries.onMouseOut();
	                    }
	
	                    if (tooltip) {
	                        tooltip.hide(delay);
	                    }
	
	                    if (pointer.unDocMouseMove) {
	                        pointer.unDocMouseMove = pointer.unDocMouseMove();
	                    }
	
	                    // Remove crosshairs
	                    each(chart.axes, function(axis) {
	                        axis.hideCrosshair();
	                    });
	
	                    pointer.hoverX = chart.hoverPoints = chart.hoverPoint = null;
	                }
	            },
	
	            /**
	             * Scale series groups to a certain scale and translation.
	             *
	             * @private
	             */
	            scaleGroups: function(attribs, clip) {
	
	                var chart = this.chart,
	                    seriesAttribs;
	
	                // Scale each series
	                each(chart.series, function(series) {
	                    seriesAttribs = attribs || series.getPlotBox(); // #1701
	                    if (series.xAxis && series.xAxis.zoomEnabled && series.group) {
	                        series.group.attr(seriesAttribs);
	                        if (series.markerGroup) {
	                            series.markerGroup.attr(seriesAttribs);
	                            series.markerGroup.clip(clip ? chart.clipRect : null);
	                        }
	                        if (series.dataLabelsGroup) {
	                            series.dataLabelsGroup.attr(seriesAttribs);
	                        }
	                    }
	                });
	
	                // Clip
	                chart.clipRect.attr(clip || chart.clipBox);
	            },
	
	            /**
	             * Start a drag operation.
	             *
	             * @private
	             */
	            dragStart: function(e) {
	                var chart = this.chart;
	
	                // Record the start position
	                chart.mouseIsDown = e.type;
	                chart.cancelClick = false;
	                chart.mouseDownX = this.mouseDownX = e.chartX;
	                chart.mouseDownY = this.mouseDownY = e.chartY;
	            },
	
	            /**
	             * Perform a drag operation in response to a mousemove event while the mouse
	             * is down.
	             *
	             * @private
	             */
	            drag: function(e) {
	
	                var chart = this.chart,
	                    chartOptions = chart.options.chart,
	                    chartX = e.chartX,
	                    chartY = e.chartY,
	                    zoomHor = this.zoomHor,
	                    zoomVert = this.zoomVert,
	                    plotLeft = chart.plotLeft,
	                    plotTop = chart.plotTop,
	                    plotWidth = chart.plotWidth,
	                    plotHeight = chart.plotHeight,
	                    clickedInside,
	                    size,
	                    selectionMarker = this.selectionMarker,
	                    mouseDownX = this.mouseDownX,
	                    mouseDownY = this.mouseDownY,
	                    panKey = chartOptions.panKey && e[chartOptions.panKey + 'Key'];
	
	                // If the device supports both touch and mouse (like IE11), and we are touch-dragging
	                // inside the plot area, don't handle the mouse event. #4339.
	                if (selectionMarker && selectionMarker.touch) {
	                    return;
	                }
	
	                // If the mouse is outside the plot area, adjust to cooordinates
	                // inside to prevent the selection marker from going outside
	                if (chartX < plotLeft) {
	                    chartX = plotLeft;
	                } else if (chartX > plotLeft + plotWidth) {
	                    chartX = plotLeft + plotWidth;
	                }
	
	                if (chartY < plotTop) {
	                    chartY = plotTop;
	                } else if (chartY > plotTop + plotHeight) {
	                    chartY = plotTop + plotHeight;
	                }
	
	                // determine if the mouse has moved more than 10px
	                this.hasDragged = Math.sqrt(
	                    Math.pow(mouseDownX - chartX, 2) +
	                    Math.pow(mouseDownY - chartY, 2)
	                );
	
	                if (this.hasDragged > 10) {
	                    clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop);
	
	                    // make a selection
	                    if (chart.hasCartesianSeries && (this.zoomX || this.zoomY) && clickedInside && !panKey) {
	                        if (!selectionMarker) {
	                            this.selectionMarker = selectionMarker = chart.renderer.rect(
	                                    plotLeft,
	                                    plotTop,
	                                    zoomHor ? 1 : plotWidth,
	                                    zoomVert ? 1 : plotHeight,
	                                    0
	                                )
	                                .attr({
	
	                                    fill: chartOptions.selectionMarkerFill || color('#335cad').setOpacity(0.25).get(),
	
	                                    'class': 'highcharts-selection-marker',
	                                    'zIndex': 7
	                                })
	                                .add();
	                        }
	                    }
	
	                    // adjust the width of the selection marker
	                    if (selectionMarker && zoomHor) {
	                        size = chartX - mouseDownX;
	                        selectionMarker.attr({
	                            width: Math.abs(size),
	                            x: (size > 0 ? 0 : size) + mouseDownX
	                        });
	                    }
	                    // adjust the height of the selection marker
	                    if (selectionMarker && zoomVert) {
	                        size = chartY - mouseDownY;
	                        selectionMarker.attr({
	                            height: Math.abs(size),
	                            y: (size > 0 ? 0 : size) + mouseDownY
	                        });
	                    }
	
	                    // panning
	                    if (clickedInside && !selectionMarker && chartOptions.panning) {
	                        chart.pan(e, chartOptions.panning);
	                    }
	                }
	            },
	
	            /**
	             * On mouse up or touch end across the entire document, drop the selection.
	             *
	             * @private
	             */
	            drop: function(e) {
	                var pointer = this,
	                    chart = this.chart,
	                    hasPinched = this.hasPinched;
	
	                if (this.selectionMarker) {
	                    var selectionData = {
	                            originalEvent: e, // #4890
	                            xAxis: [],
	                            yAxis: []
	                        },
	                        selectionBox = this.selectionMarker,
	                        selectionLeft = selectionBox.attr ? selectionBox.attr('x') : selectionBox.x,
	                        selectionTop = selectionBox.attr ? selectionBox.attr('y') : selectionBox.y,
	                        selectionWidth = selectionBox.attr ? selectionBox.attr('width') : selectionBox.width,
	                        selectionHeight = selectionBox.attr ? selectionBox.attr('height') : selectionBox.height,
	                        runZoom;
	
	                    // a selection has been made
	                    if (this.hasDragged || hasPinched) {
	
	                        // record each axis' min and max
	                        each(chart.axes, function(axis) {
	                            if (axis.zoomEnabled && defined(axis.min) && (hasPinched || pointer[{
	                                    xAxis: 'zoomX',
	                                    yAxis: 'zoomY'
	                                }[axis.coll]])) { // #859, #3569
	                                var horiz = axis.horiz,
	                                    minPixelPadding = e.type === 'touchend' ? axis.minPixelPadding : 0, // #1207, #3075
	                                    selectionMin = axis.toValue((horiz ? selectionLeft : selectionTop) + minPixelPadding),
	                                    selectionMax = axis.toValue((horiz ? selectionLeft + selectionWidth : selectionTop + selectionHeight) - minPixelPadding);
	
	                                selectionData[axis.coll].push({
	                                    axis: axis,
	                                    min: Math.min(selectionMin, selectionMax), // for reversed axes
	                                    max: Math.max(selectionMin, selectionMax)
	                                });
	                                runZoom = true;
	                            }
	                        });
	                        if (runZoom) {
	                            fireEvent(chart, 'selection', selectionData, function(args) {
	                                chart.zoom(extend(args, hasPinched ? {
	                                    animation: false
	                                } : null));
	                            });
	                        }
	
	                    }
	                    this.selectionMarker = this.selectionMarker.destroy();
	
	                    // Reset scaling preview
	                    if (hasPinched) {
	                        this.scaleGroups();
	                    }
	                }
	
	                // Reset all
	                if (chart) { // it may be destroyed on mouse up - #877
	                    css(chart.container, {
	                        cursor: chart._cursor
	                    });
	                    chart.cancelClick = this.hasDragged > 10; // #370
	                    chart.mouseIsDown = this.hasDragged = this.hasPinched = false;
	                    this.pinchDown = [];
	                }
	            },
	
	            onContainerMouseDown: function(e) {
	
	                e = this.normalize(e);
	
	                this.zoomOption(e);
	
	                // issue #295, dragging not always working in Firefox
	                if (e.preventDefault) {
	                    e.preventDefault();
	                }
	
	                this.dragStart(e);
	            },
	
	
	
	            onDocumentMouseUp: function(e) {
	                if (charts[H.hoverChartIndex]) {
	                    charts[H.hoverChartIndex].pointer.drop(e);
	                }
	            },
	
	            /**
	             * Special handler for mouse move that will hide the tooltip when the mouse
	             * leaves the plotarea. Issue #149 workaround. The mouseleave event does not
	             * always fire.
	             *
	             * @private
	             */
	            onDocumentMouseMove: function(e) {
	                var chart = this.chart,
	                    chartPosition = this.chartPosition;
	
	                e = this.normalize(e, chartPosition);
	
	                // If we're outside, hide the tooltip
	                if (chartPosition && !this.inClass(e.target, 'highcharts-tracker') &&
	                    !chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {
	                    this.reset();
	                }
	            },
	
	            /**
	             * When mouse leaves the container, hide the tooltip.
	             *
	             * @private
	             */
	            onContainerMouseLeave: function(e) {
	                var chart = charts[H.hoverChartIndex];
	                if (chart && (e.relatedTarget || e.toElement)) { // #4886, MS Touch end fires mouseleave but with no related target
	                    chart.pointer.reset();
	                    chart.pointer.chartPosition = null; // also reset the chart position, used in #149 fix
	                }
	            },
	
	            // The mousemove, touchmove and touchstart event handler
	            onContainerMouseMove: function(e) {
	
	                var chart = this.chart;
	
	                if (!defined(H.hoverChartIndex) || !charts[H.hoverChartIndex] || !charts[H.hoverChartIndex].mouseIsDown) {
	                    H.hoverChartIndex = chart.index;
	                }
	
	                e = this.normalize(e);
	                e.returnValue = false; // #2251, #3224
	
	                if (chart.mouseIsDown === 'mousedown') {
	                    this.drag(e);
	                }
	
	                // Show the tooltip and run mouse over events (#977)
	                if ((this.inClass(e.target, 'highcharts-tracker') ||
	                        chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) && !chart.openMenu) {
	                    this.runPointActions(e);
	                }
	            },
	
	            /**
	             * Utility to detect whether an element has, or has a parent with, a specific
	             * class name. Used on detection of tracker objects and on deciding whether
	             * hovering the tooltip should cause the active series to mouse out.
	             *
	             * @param  {SVGDOMElement|HTMLDOMElement} element
	             *         The element to investigate.
	             * @param  {String} className
	             *         The class name to look for.
	             *
	             * @return {Boolean}
	             *         True if either the element or one of its parents has the given
	             *         class name.
	             */
	            inClass: function(element, className) {
	                var elemClassName;
	                while (element) {
	                    elemClassName = attr(element, 'class');
	                    if (elemClassName) {
	                        if (elemClassName.indexOf(className) !== -1) {
	                            return true;
	                        }
	                        if (elemClassName.indexOf('highcharts-container') !== -1) {
	                            return false;
	                        }
	                    }
	                    element = element.parentNode;
	                }
	            },
	
	            onTrackerMouseOut: function(e) {
	                var series = this.chart.hoverSeries,
	                    relatedTarget = e.relatedTarget || e.toElement;
	                this.isDirectTouch = false;
	                if (series && relatedTarget && !series.stickyTracking &&
	                    !this.inClass(relatedTarget, 'highcharts-tooltip') &&
	                    (!this.inClass(relatedTarget, 'highcharts-series-' + series.index) || // #2499, #4465
	                        !this.inClass(relatedTarget, 'highcharts-tracker') // #5553
	                    )
	                ) {
	                    series.onMouseOut();
	                }
	            },
	
	            onContainerClick: function(e) {
	                var chart = this.chart,
	                    hoverPoint = chart.hoverPoint,
	                    plotLeft = chart.plotLeft,
	                    plotTop = chart.plotTop;
	
	                e = this.normalize(e);
	
	                if (!chart.cancelClick) {
	
	                    // On tracker click, fire the series and point events. #783, #1583
	                    if (hoverPoint && this.inClass(e.target, 'highcharts-tracker')) {
	
	                        // the series click event
	                        fireEvent(hoverPoint.series, 'click', extend(e, {
	                            point: hoverPoint
	                        }));
	
	                        // the point click event
	                        if (chart.hoverPoint) { // it may be destroyed (#1844)
	                            hoverPoint.firePointEvent('click', e);
	                        }
	
	                        // When clicking outside a tracker, fire a chart event
	                    } else {
	                        extend(e, this.getCoordinates(e));
	
	                        // fire a click event in the chart
	                        if (chart.isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {
	                            fireEvent(chart, 'click', e);
	                        }
	                    }
	
	
	                }
	            },
	
	            /**
	             * Set the JS DOM events on the container and document. This method should contain
	             * a one-to-one assignment between methods and their handlers. Any advanced logic should
	             * be moved to the handler reflecting the event's name.
	             *
	             * @private
	             */
	            setDOMEvents: function() {
	
	                var pointer = this,
	                    container = pointer.chart.container,
	                    ownerDoc = container.ownerDocument;
	
	                container.onmousedown = function(e) {
	                    pointer.onContainerMouseDown(e);
	                };
	                container.onmousemove = function(e) {
	                    pointer.onContainerMouseMove(e);
	                };
	                container.onclick = function(e) {
	                    pointer.onContainerClick(e);
	                };
	                addEvent(container, 'mouseleave', pointer.onContainerMouseLeave);
	                if (H.chartCount === 1) {
	                    addEvent(
	                        ownerDoc,
	                        'mouseup',
	                        pointer.onDocumentMouseUp
	                    );
	                }
	                if (H.hasTouch) {
	                    container.ontouchstart = function(e) {
	                        pointer.onContainerTouchStart(e);
	                    };
	                    container.ontouchmove = function(e) {
	                        pointer.onContainerTouchMove(e);
	                    };
	                    if (H.chartCount === 1) {
	                        addEvent(
	                            ownerDoc,
	                            'touchend',
	                            pointer.onDocumentTouchEnd
	                        );
	                    }
	                }
	
	            },
	
	            /**
	             * Destroys the Pointer object and disconnects DOM events.
	             */
	            destroy: function() {
	                var pointer = this,
	                    ownerDoc = this.chart.container.ownerDocument;
	
	                if (pointer.unDocMouseMove) {
	                    pointer.unDocMouseMove();
	                }
	
	                removeEvent(
	                    pointer.chart.container,
	                    'mouseleave',
	                    pointer.onContainerMouseLeave
	                );
	                if (!H.chartCount) {
	                    removeEvent(ownerDoc, 'mouseup', pointer.onDocumentMouseUp);
	                    if (H.hasTouch) {
	                        removeEvent(ownerDoc, 'touchend', pointer.onDocumentTouchEnd);
	                    }
	                }
	
	                // memory and CPU leak
	                clearInterval(pointer.tooltipTimeout);
	
	                H.objectEach(pointer, function(val, prop) {
	                    pointer[prop] = null;
	                });
	            }
	        };
	
	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var charts = H.charts,
	            each = H.each,
	            extend = H.extend,
	            map = H.map,
	            noop = H.noop,
	            pick = H.pick,
	            Pointer = H.Pointer;
	
	        /* Support for touch devices */
	        extend(Pointer.prototype, /** @lends Pointer.prototype */ {
	
	            /**
	             * Run translation operations
	             */
	            pinchTranslate: function(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch) {
	                if (this.zoomHor) {
	                    this.pinchTranslateDirection(true, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
	                }
	                if (this.zoomVert) {
	                    this.pinchTranslateDirection(false, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
	                }
	            },
	
	            /**
	             * Run translation operations for each direction (horizontal and vertical) independently
	             */
	            pinchTranslateDirection: function(horiz, pinchDown, touches, transform,
	                selectionMarker, clip, lastValidTouch, forcedScale) {
	                var chart = this.chart,
	                    xy = horiz ? 'x' : 'y',
	                    XY = horiz ? 'X' : 'Y',
	                    sChartXY = 'chart' + XY,
	                    wh = horiz ? 'width' : 'height',
	                    plotLeftTop = chart['plot' + (horiz ? 'Left' : 'Top')],
	                    selectionWH,
	                    selectionXY,
	                    clipXY,
	                    scale = forcedScale || 1,
	                    inverted = chart.inverted,
	                    bounds = chart.bounds[horiz ? 'h' : 'v'],
	                    singleTouch = pinchDown.length === 1,
	                    touch0Start = pinchDown[0][sChartXY],
	                    touch0Now = touches[0][sChartXY],
	                    touch1Start = !singleTouch && pinchDown[1][sChartXY],
	                    touch1Now = !singleTouch && touches[1][sChartXY],
	                    outOfBounds,
	                    transformScale,
	                    scaleKey,
	                    setScale = function() {
	                        // Don't zoom if fingers are too close on this axis
	                        if (!singleTouch && Math.abs(touch0Start - touch1Start) > 20) {
	                            scale = forcedScale || Math.abs(touch0Now - touch1Now) / Math.abs(touch0Start - touch1Start);
	                        }
	
	                        clipXY = ((plotLeftTop - touch0Now) / scale) + touch0Start;
	                        selectionWH = chart['plot' + (horiz ? 'Width' : 'Height')] / scale;
	                    };
	
	                // Set the scale, first pass
	                setScale();
	
	                selectionXY = clipXY; // the clip position (x or y) is altered if out of bounds, the selection position is not
	
	                // Out of bounds
	                if (selectionXY < bounds.min) {
	                    selectionXY = bounds.min;
	                    outOfBounds = true;
	                } else if (selectionXY + selectionWH > bounds.max) {
	                    selectionXY = bounds.max - selectionWH;
	                    outOfBounds = true;
	                }
	
	                // Is the chart dragged off its bounds, determined by dataMin and dataMax?
	                if (outOfBounds) {
	
	                    // Modify the touchNow position in order to create an elastic drag movement. This indicates
	                    // to the user that the chart is responsive but can't be dragged further.
	                    touch0Now -= 0.8 * (touch0Now - lastValidTouch[xy][0]);
	                    if (!singleTouch) {
	                        touch1Now -= 0.8 * (touch1Now - lastValidTouch[xy][1]);
	                    }
	
	                    // Set the scale, second pass to adapt to the modified touchNow positions
	                    setScale();
	
	                } else {
	                    lastValidTouch[xy] = [touch0Now, touch1Now];
	                }
	
	                // Set geometry for clipping, selection and transformation
	                if (!inverted) {
	                    clip[xy] = clipXY - plotLeftTop;
	                    clip[wh] = selectionWH;
	                }
	                scaleKey = inverted ? (horiz ? 'scaleY' : 'scaleX') : 'scale' + XY;
	                transformScale = inverted ? 1 / scale : scale;
	
	                selectionMarker[wh] = selectionWH;
	                selectionMarker[xy] = selectionXY;
	                transform[scaleKey] = scale;
	                transform['translate' + XY] = (transformScale * plotLeftTop) + (touch0Now - (transformScale * touch0Start));
	            },
	
	            /**
	             * Handle touch events with two touches
	             */
	            pinch: function(e) {
	
	                var self = this,
	                    chart = self.chart,
	                    pinchDown = self.pinchDown,
	                    touches = e.touches,
	                    touchesLength = touches.length,
	                    lastValidTouch = self.lastValidTouch,
	                    hasZoom = self.hasZoom,
	                    selectionMarker = self.selectionMarker,
	                    transform = {},
	                    fireClickEvent = touchesLength === 1 && ((self.inClass(e.target, 'highcharts-tracker') &&
	                        chart.runTrackerClick) || self.runChartClick),
	                    clip = {};
	
	                // Don't initiate panning until the user has pinched. This prevents us from
	                // blocking page scrolling as users scroll down a long page (#4210).
	                if (touchesLength > 1) {
	                    self.initiated = true;
	                }
	
	                // On touch devices, only proceed to trigger click if a handler is defined
	                if (hasZoom && self.initiated && !fireClickEvent) {
	                    e.preventDefault();
	                }
	
	                // Normalize each touch
	                map(touches, function(e) {
	                    return self.normalize(e);
	                });
	
	                // Register the touch start position
	                if (e.type === 'touchstart') {
	                    each(touches, function(e, i) {
	                        pinchDown[i] = {
	                            chartX: e.chartX,
	                            chartY: e.chartY
	                        };
	                    });
	                    lastValidTouch.x = [pinchDown[0].chartX, pinchDown[1] && pinchDown[1].chartX];
	                    lastValidTouch.y = [pinchDown[0].chartY, pinchDown[1] && pinchDown[1].chartY];
	
	                    // Identify the data bounds in pixels
	                    each(chart.axes, function(axis) {
	                        if (axis.zoomEnabled) {
	                            var bounds = chart.bounds[axis.horiz ? 'h' : 'v'],
	                                minPixelPadding = axis.minPixelPadding,
	                                min = axis.toPixels(pick(axis.options.min, axis.dataMin)),
	                                max = axis.toPixels(pick(axis.options.max, axis.dataMax)),
	                                absMin = Math.min(min, max),
	                                absMax = Math.max(min, max);
	
	                            // Store the bounds for use in the touchmove handler
	                            bounds.min = Math.min(axis.pos, absMin - minPixelPadding);
	                            bounds.max = Math.max(axis.pos + axis.len, absMax + minPixelPadding);
	                        }
	                    });
	                    self.res = true; // reset on next move
	
	                    // Optionally move the tooltip on touchmove
	                } else if (self.followTouchMove && touchesLength === 1) {
	                    this.runPointActions(self.normalize(e));
	
	                    // Event type is touchmove, handle panning and pinching
	                } else if (pinchDown.length) { // can be 0 when releasing, if touchend fires first
	
	
	                    // Set the marker
	                    if (!selectionMarker) {
	                        self.selectionMarker = selectionMarker = extend({
	                            destroy: noop,
	                            touch: true
	                        }, chart.plotBox);
	                    }
	
	                    self.pinchTranslate(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
	
	                    self.hasPinched = hasZoom;
	
	                    // Scale and translate the groups to provide visual feedback during pinching
	                    self.scaleGroups(transform, clip);
	
	                    if (self.res) {
	                        self.res = false;
	                        this.reset(false, 0);
	                    }
	                }
	            },
	
	            /**
	             * General touch handler shared by touchstart and touchmove.
	             */
	            touch: function(e, start) {
	                var chart = this.chart,
	                    hasMoved,
	                    pinchDown,
	                    isInside;
	
	                if (chart.index !== H.hoverChartIndex) {
	                    this.onContainerMouseLeave({
	                        relatedTarget: true
	                    });
	                }
	                H.hoverChartIndex = chart.index;
	
	                if (e.touches.length === 1) {
	
	                    e = this.normalize(e);
	
	                    isInside = chart.isInsidePlot(
	                        e.chartX - chart.plotLeft,
	                        e.chartY - chart.plotTop
	                    );
	                    if (isInside && !chart.openMenu) {
	
	                        // Run mouse events and display tooltip etc
	                        if (start) {
	                            this.runPointActions(e);
	                        }
	
	                        // Android fires touchmove events after the touchstart even if the
	                        // finger hasn't moved, or moved only a pixel or two. In iOS however,
	                        // the touchmove doesn't fire unless the finger moves more than ~4px.
	                        // So we emulate this behaviour in Android by checking how much it
	                        // moved, and cancelling on small distances. #3450.
	                        if (e.type === 'touchmove') {
	                            pinchDown = this.pinchDown;
	                            hasMoved = pinchDown[0] ? Math.sqrt( // #5266
	                                Math.pow(pinchDown[0].chartX - e.chartX, 2) +
	                                Math.pow(pinchDown[0].chartY - e.chartY, 2)
	                            ) >= 4 : false;
	                        }
	
	                        if (pick(hasMoved, true)) {
	                            this.pinch(e);
	                        }
	
	                    } else if (start) {
	                        // Hide the tooltip on touching outside the plot area (#1203)
	                        this.reset();
	                    }
	
	                } else if (e.touches.length === 2) {
	                    this.pinch(e);
	                }
	            },
	
	            onContainerTouchStart: function(e) {
	                this.zoomOption(e);
	                this.touch(e, true);
	            },
	
	            onContainerTouchMove: function(e) {
	                this.touch(e);
	            },
	
	            onDocumentTouchEnd: function(e) {
	                if (charts[H.hoverChartIndex]) {
	                    charts[H.hoverChartIndex].pointer.drop(e);
	                }
	            }
	
	        });
	
	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var addEvent = H.addEvent,
	            charts = H.charts,
	            css = H.css,
	            doc = H.doc,
	            extend = H.extend,
	            hasTouch = H.hasTouch,
	            noop = H.noop,
	            Pointer = H.Pointer,
	            removeEvent = H.removeEvent,
	            win = H.win,
	            wrap = H.wrap;
	
	        if (!hasTouch && (win.PointerEvent || win.MSPointerEvent)) {
	
	            // The touches object keeps track of the points being touched at all times
	            var touches = {},
	                hasPointerEvent = !!win.PointerEvent,
	                getWebkitTouches = function() {
	                    var fake = [];
	                    fake.item = function(i) {
	                        return this[i];
	                    };
	                    H.objectEach(touches, function(touch) {
	                        fake.push({
	                            pageX: touch.pageX,
	                            pageY: touch.pageY,
	                            target: touch.target
	                        });
	                    });
	                    return fake;
	                },
	                translateMSPointer = function(e, method, wktype, func) {
	                    var p;
	                    if ((e.pointerType === 'touch' || e.pointerType === e.MSPOINTER_TYPE_TOUCH) && charts[H.hoverChartIndex]) {
	                        func(e);
	                        p = charts[H.hoverChartIndex].pointer;
	                        p[method]({
	                            type: wktype,
	                            target: e.currentTarget,
	                            preventDefault: noop,
	                            touches: getWebkitTouches()
	                        });
	                    }
	                };
	
	            /**
	             * Extend the Pointer prototype with methods for each event handler and more
	             */
	            extend(Pointer.prototype, /** @lends Pointer.prototype */ {
	                onContainerPointerDown: function(e) {
	                    translateMSPointer(e, 'onContainerTouchStart', 'touchstart', function(e) {
	                        touches[e.pointerId] = {
	                            pageX: e.pageX,
	                            pageY: e.pageY,
	                            target: e.currentTarget
	                        };
	                    });
	                },
	                onContainerPointerMove: function(e) {
	                    translateMSPointer(e, 'onContainerTouchMove', 'touchmove', function(e) {
	                        touches[e.pointerId] = {
	                            pageX: e.pageX,
	                            pageY: e.pageY
	                        };
	                        if (!touches[e.pointerId].target) {
	                            touches[e.pointerId].target = e.currentTarget;
	                        }
	                    });
	                },
	                onDocumentPointerUp: function(e) {
	                    translateMSPointer(e, 'onDocumentTouchEnd', 'touchend', function(e) {
	                        delete touches[e.pointerId];
	                    });
	                },
	
	                /**
	                 * Add or remove the MS Pointer specific events
	                 */
	                batchMSEvents: function(fn) {
	                    fn(this.chart.container, hasPointerEvent ? 'pointerdown' : 'MSPointerDown', this.onContainerPointerDown);
	                    fn(this.chart.container, hasPointerEvent ? 'pointermove' : 'MSPointerMove', this.onContainerPointerMove);
	                    fn(doc, hasPointerEvent ? 'pointerup' : 'MSPointerUp', this.onDocumentPointerUp);
	                }
	            });
	
	            // Disable default IE actions for pinch and such on chart element
	            wrap(Pointer.prototype, 'init', function(proceed, chart, options) {
	                proceed.call(this, chart, options);
	                if (this.hasZoom) { // #4014
	                    css(chart.container, {
	                        '-ms-touch-action': 'none',
	                        'touch-action': 'none'
	                    });
	                }
	            });
	
	            // Add IE specific touch events to chart
	            wrap(Pointer.prototype, 'setDOMEvents', function(proceed) {
	                proceed.apply(this);
	                if (this.hasZoom || this.followTouchMove) {
	                    this.batchMSEvents(addEvent);
	                }
	            });
	            // Destroy MS events also
	            wrap(Pointer.prototype, 'destroy', function(proceed) {
	                this.batchMSEvents(removeEvent);
	                proceed.call(this);
	            });
	        }
	
	    }(Highcharts));
	    (function(Highcharts) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var H = Highcharts,
	
	            addEvent = H.addEvent,
	            css = H.css,
	            discardElement = H.discardElement,
	            defined = H.defined,
	            each = H.each,
	            isFirefox = H.isFirefox,
	            marginNames = H.marginNames,
	            merge = H.merge,
	            pick = H.pick,
	            setAnimation = H.setAnimation,
	            stableSort = H.stableSort,
	            win = H.win,
	            wrap = H.wrap;
	
	        /**
	         * The overview of the chart's series. The legend object is instanciated
	         * internally in the chart constructor, and available from `chart.legend`. Each
	         * chart has only one legend.
	         * 
	         * @class
	         */
	        Highcharts.Legend = function(chart, options) {
	            this.init(chart, options);
	        };
	
	        Highcharts.Legend.prototype = {
	
	            /**
	             * Initialize the legend.
	             *
	             * @private
	             */
	            init: function(chart, options) {
	
	                this.chart = chart;
	
	                this.setOptions(options);
	
	                if (options.enabled) {
	
	                    // Render it
	                    this.render();
	
	                    // move checkboxes
	                    addEvent(this.chart, 'endResize', function() {
	                        this.legend.positionCheckboxes();
	                    });
	                }
	            },
	
	            setOptions: function(options) {
	
	                var padding = pick(options.padding, 8);
	
	                this.options = options;
	
	
	                this.itemStyle = options.itemStyle;
	                this.itemHiddenStyle = merge(this.itemStyle, options.itemHiddenStyle);
	
	                this.itemMarginTop = options.itemMarginTop || 0;
	                this.padding = padding;
	                this.initialItemY = padding - 5; // 5 is pixels above the text
	                this.maxItemWidth = 0;
	                this.itemHeight = 0;
	                this.symbolWidth = pick(options.symbolWidth, 16);
	                this.pages = [];
	
	            },
	
	            /**
	             * Update the legend with new options. Equivalent to running `chart.update`
	             * with a legend configuration option.
	             * @param  {LegendOptions} options
	             *         Legend options.
	             * @param  {Boolean} [redraw=true]
	             *         Whether to redraw the chart.
	             *
	             * @sample highcharts/legend/legend-update/
	             *         Legend update
	             */
	            update: function(options, redraw) {
	                var chart = this.chart;
	
	                this.setOptions(merge(true, this.options, options));
	                this.destroy();
	                chart.isDirtyLegend = chart.isDirtyBox = true;
	                if (pick(redraw, true)) {
	                    chart.redraw();
	                }
	            },
	
	            /**
	             * Set the colors for the legend item.
	             *
	             * @private
	             * @param  {Series|Point} item
	             *         A Series or Point instance
	             * @param  {Boolean} visible
	             *         Dimmed or colored
	             */
	            colorizeItem: function(item, visible) {
	                item.legendGroup[visible ? 'removeClass' : 'addClass'](
	                    'highcharts-legend-item-hidden'
	                );
	
	
	                var legend = this,
	                    options = legend.options,
	                    legendItem = item.legendItem,
	                    legendLine = item.legendLine,
	                    legendSymbol = item.legendSymbol,
	                    hiddenColor = legend.itemHiddenStyle.color,
	                    textColor = visible ? options.itemStyle.color : hiddenColor,
	                    symbolColor = visible ? (item.color || hiddenColor) : hiddenColor,
	                    markerOptions = item.options && item.options.marker,
	                    symbolAttr = {
	                        fill: symbolColor
	                    };
	
	                if (legendItem) {
	                    legendItem.css({
	                        fill: textColor,
	                        color: textColor // #1553, oldIE
	                    });
	                }
	                if (legendLine) {
	                    legendLine.attr({
	                        stroke: symbolColor
	                    });
	                }
	
	                if (legendSymbol) {
	
	                    // Apply marker options
	                    if (markerOptions && legendSymbol.isMarker) { // #585
	                        symbolAttr = item.pointAttribs();
	                        if (!visible) {
	                            symbolAttr.stroke = symbolAttr.fill = hiddenColor; // #6769
	                        }
	                    }
	
	                    legendSymbol.attr(symbolAttr);
	                }
	
	            },
	
	            /**
	             * Position the legend item.
	             *
	             * @private
	             * @param {Series|Point} item
	             *        The item to position
	             */
	            positionItem: function(item) {
	                var legend = this,
	                    options = legend.options,
	                    symbolPadding = options.symbolPadding,
	                    ltr = !options.rtl,
	                    legendItemPos = item._legendItemPos,
	                    itemX = legendItemPos[0],
	                    itemY = legendItemPos[1],
	                    checkbox = item.checkbox,
	                    legendGroup = item.legendGroup;
	
	                if (legendGroup && legendGroup.element) {
	                    legendGroup.translate(
	                        ltr ?
	                        itemX :
	                        legend.legendWidth - itemX - 2 * symbolPadding - 4,
	                        itemY
	                    );
	                }
	
	                if (checkbox) {
	                    checkbox.x = itemX;
	                    checkbox.y = itemY;
	                }
	            },
	
	            /**
	             * Destroy a single legend item, used internally on removing series items.
	             * 
	             * @param {Series|Point} item
	             *        The item to remove
	             */
	            destroyItem: function(item) {
	                var checkbox = item.checkbox;
	
	                // destroy SVG elements
	                each(
	                    ['legendItem', 'legendLine', 'legendSymbol', 'legendGroup'],
	                    function(key) {
	                        if (item[key]) {
	                            item[key] = item[key].destroy();
	                        }
	                    }
	                );
	
	                if (checkbox) {
	                    discardElement(item.checkbox);
	                }
	            },
	
	            /**
	             * Destroy the legend. Used internally. To reflow objects, `chart.redraw`
	             * must be called after destruction.
	             */
	            destroy: function() {
	                function destroyItems(key) {
	                    if (this[key]) {
	                        this[key] = this[key].destroy();
	                    }
	                }
	
	                // Destroy items
	                each(this.getAllItems(), function(item) {
	                    each(['legendItem', 'legendGroup'], destroyItems, item);
	                });
	
	                // Destroy legend elements
	                each([
	                    'clipRect',
	                    'up',
	                    'down',
	                    'pager',
	                    'nav',
	                    'box',
	                    'title',
	                    'group'
	                ], destroyItems, this);
	                this.display = null; // Reset in .render on update.
	            },
	
	            /**
	             * Position the checkboxes after the width is determined.
	             *
	             * @private
	             */
	            positionCheckboxes: function(scrollOffset) {
	                var alignAttr = this.group && this.group.alignAttr,
	                    translateY,
	                    clipHeight = this.clipHeight || this.legendHeight,
	                    titleHeight = this.titleHeight;
	
	                if (alignAttr) {
	                    translateY = alignAttr.translateY;
	                    each(this.allItems, function(item) {
	                        var checkbox = item.checkbox,
	                            top;
	
	                        if (checkbox) {
	                            top = translateY + titleHeight + checkbox.y +
	                                (scrollOffset || 0) + 3;
	                            css(checkbox, {
	                                left: (alignAttr.translateX + item.checkboxOffset +
	                                    checkbox.x - 20) + 'px',
	                                top: top + 'px',
	                                display: top > translateY - 6 && top < translateY +
	                                    clipHeight - 6 ? '' : 'none'
	                            });
	                        }
	                    });
	                }
	            },
	
	            /**
	             * Render the legend title on top of the legend.
	             *
	             * @private
	             */
	            renderTitle: function() {
	                var options = this.options,
	                    padding = this.padding,
	                    titleOptions = options.title,
	                    titleHeight = 0,
	                    bBox;
	
	                if (titleOptions.text) {
	                    if (!this.title) {
	                        this.title = this.chart.renderer.label(
	                                titleOptions.text,
	                                padding - 3,
	                                padding - 4,
	                                null,
	                                null,
	                                null,
	                                options.useHTML,
	                                null,
	                                'legend-title'
	                            )
	                            .attr({
	                                zIndex: 1
	                            })
	
	                            .css(titleOptions.style)
	
	                            .add(this.group);
	                    }
	                    bBox = this.title.getBBox();
	                    titleHeight = bBox.height;
	                    this.offsetWidth = bBox.width; // #1717
	                    this.contentGroup.attr({
	                        translateY: titleHeight
	                    });
	                }
	                this.titleHeight = titleHeight;
	            },
	
	            /**
	             * Set the legend item text.
	             *
	             * @param  {Series|Point} item
	             *         The item for which to update the text in the legend.
	             */
	            setText: function(item) {
	                var options = this.options;
	                item.legendItem.attr({
	                    text: options.labelFormat ?
	                        H.format(options.labelFormat, item) : options.labelFormatter.call(item)
	                });
	            },
	
	            /**
	             * Render a single specific legend item. Called internally from the `render`
	             * function.
	             *
	             * @private
	             * @param {Series|Point} item
	             *        The item to render.
	             */
	            renderItem: function(item) {
	                var legend = this,
	                    chart = legend.chart,
	                    renderer = chart.renderer,
	                    options = legend.options,
	                    horizontal = options.layout === 'horizontal',
	                    symbolWidth = legend.symbolWidth,
	                    symbolPadding = options.symbolPadding,
	
	                    itemStyle = legend.itemStyle,
	                    itemHiddenStyle = legend.itemHiddenStyle,
	
	                    padding = legend.padding,
	                    itemDistance = horizontal ? pick(options.itemDistance, 20) : 0,
	                    ltr = !options.rtl,
	                    itemHeight,
	                    widthOption = options.width,
	                    itemMarginBottom = options.itemMarginBottom || 0,
	                    itemMarginTop = legend.itemMarginTop,
	                    bBox,
	                    itemWidth,
	                    li = item.legendItem,
	                    isSeries = !item.series,
	                    series = !isSeries && item.series.drawLegendSymbol ?
	                    item.series :
	                    item,
	                    seriesOptions = series.options,
	                    showCheckbox = legend.createCheckboxForItem &&
	                    seriesOptions &&
	                    seriesOptions.showCheckbox,
	                    // full width minus text width
	                    itemExtraWidth = symbolWidth + symbolPadding + itemDistance +
	                    (showCheckbox ? 20 : 0),
	                    useHTML = options.useHTML,
	                    fontSize = 12,
	                    itemClassName = item.options.className;
	
	                if (!li) { // generate it once, later move it
	
	                    // Generate the group box, a group to hold the symbol and text. Text
	                    // is to be appended in Legend class.
	                    item.legendGroup = renderer.g('legend-item')
	                        .addClass(
	                            'highcharts-' + series.type + '-series ' +
	                            'highcharts-color-' + item.colorIndex +
	                            (itemClassName ? ' ' + itemClassName : '') +
	                            (isSeries ? ' highcharts-series-' + item.index : '')
	                        )
	                        .attr({
	                            zIndex: 1
	                        })
	                        .add(legend.scrollGroup);
	
	                    // Generate the list item text and add it to the group
	                    item.legendItem = li = renderer.text(
	                            '',
	                            ltr ? symbolWidth + symbolPadding : -symbolPadding,
	                            legend.baseline || 0,
	                            useHTML
	                        )
	
	                        // merge to prevent modifying original (#1021)
	                        .css(merge(item.visible ? itemStyle : itemHiddenStyle))
	
	                        .attr({
	                            align: ltr ? 'left' : 'right',
	                            zIndex: 2
	                        })
	                        .add(item.legendGroup);
	
	                    // Get the baseline for the first item - the font size is equal for
	                    // all
	                    if (!legend.baseline) {
	
	                        fontSize = itemStyle.fontSize;
	
	                        legend.fontMetrics = renderer.fontMetrics(
	                            fontSize,
	                            li
	                        );
	                        legend.baseline = legend.fontMetrics.f + 3 + itemMarginTop;
	                        li.attr('y', legend.baseline);
	                    }
	
	                    // Draw the legend symbol inside the group box
	                    legend.symbolHeight = options.symbolHeight || legend.fontMetrics.f;
	                    series.drawLegendSymbol(legend, item);
	
	                    if (legend.setItemEvents) {
	                        legend.setItemEvents(item, li, useHTML);
	                    }
	
	                    // add the HTML checkbox on top
	                    if (showCheckbox) {
	                        legend.createCheckboxForItem(item);
	                    }
	                }
	
	                // Colorize the items
	                legend.colorizeItem(item, item.visible);
	
	                // Take care of max width and text overflow (#6659)
	
	                if (!itemStyle.width) {
	
	                    li.css({
	                        width: (
	                            options.itemWidth ||
	                            options.width ||
	                            chart.spacingBox.width
	                        ) - itemExtraWidth
	                    });
	
	                }
	
	
	                // Always update the text
	                legend.setText(item);
	
	                // calculate the positions for the next line
	                bBox = li.getBBox();
	
	                itemWidth = item.checkboxOffset =
	                    options.itemWidth ||
	                    item.legendItemWidth ||
	                    bBox.width + itemExtraWidth;
	                legend.itemHeight = itemHeight = Math.round(
	                    item.legendItemHeight || bBox.height || legend.symbolHeight
	                );
	
	                // If the item exceeds the width, start a new line
	                if (
	                    horizontal &&
	                    legend.itemX - padding + itemWidth > (
	                        widthOption || (
	                            chart.spacingBox.width - 2 * padding - options.x
	                        )
	                    )
	                ) {
	                    legend.itemX = padding;
	                    legend.itemY += itemMarginTop + legend.lastLineHeight +
	                        itemMarginBottom;
	                    legend.lastLineHeight = 0; // reset for next line (#915, #3976)
	                }
	
	                // If the item exceeds the height, start a new column
	                /*if (!horizontal && legend.itemY + options.y +
	                		itemHeight > chart.chartHeight - spacingTop - spacingBottom) {
	                	legend.itemY = legend.initialItemY;
	                	legend.itemX += legend.maxItemWidth;
	                	legend.maxItemWidth = 0;
	                }*/
	
	                // Set the edge positions
	                legend.maxItemWidth = Math.max(legend.maxItemWidth, itemWidth);
	                legend.lastItemY = itemMarginTop + legend.itemY + itemMarginBottom;
	                legend.lastLineHeight = Math.max( // #915
	                    itemHeight,
	                    legend.lastLineHeight
	                );
	
	                // cache the position of the newly generated or reordered items
	                item._legendItemPos = [legend.itemX, legend.itemY];
	
	                // advance
	                if (horizontal) {
	                    legend.itemX += itemWidth;
	
	                } else {
	                    legend.itemY += itemMarginTop + itemHeight + itemMarginBottom;
	                    legend.lastLineHeight = itemHeight;
	                }
	
	                // the width of the widest item
	                legend.offsetWidth = widthOption || Math.max(
	                    (
	                        horizontal ? legend.itemX - padding - (item.checkbox ?
	                            // decrease by itemDistance only when no checkbox #4853
	                            0 :
	                            itemDistance
	                        ) : itemWidth
	                    ) + padding,
	                    legend.offsetWidth
	                );
	            },
	
	            /**
	             * Get all items, which is one item per series for most series and one
	             * item per point for pie series and its derivatives.
	             *
	             * @return {Array.<Series|Point>}
	             *         The current items in the legend.
	             */
	            getAllItems: function() {
	                var allItems = [];
	                each(this.chart.series, function(series) {
	                    var seriesOptions = series && series.options;
	
	                    // Handle showInLegend. If the series is linked to another series,
	                    // defaults to false.
	                    if (series && pick(
	                            seriesOptions.showInLegend, !defined(seriesOptions.linkedTo) ? undefined : false, true
	                        )) {
	
	                        // Use points or series for the legend item depending on
	                        // legendType
	                        allItems = allItems.concat(
	                            series.legendItems ||
	                            (
	                                seriesOptions.legendType === 'point' ?
	                                series.data :
	                                series
	                            )
	                        );
	                    }
	                });
	                return allItems;
	            },
	
	            /**
	             * Adjust the chart margins by reserving space for the legend on only one
	             * side of the chart. If the position is set to a corner, top or bottom is
	             * reserved for horizontal legends and left or right for vertical ones.
	             *
	             * @private
	             */
	            adjustMargins: function(margin, spacing) {
	                var chart = this.chart,
	                    options = this.options,
	                    // Use the first letter of each alignment option in order to detect
	                    // the side. (#4189 - use charAt(x) notation instead of [x] for IE7)
	                    alignment = options.align.charAt(0) +
	                    options.verticalAlign.charAt(0) +
	                    options.layout.charAt(0);
	
	                if (!options.floating) {
	
	                    each([
	                        /(lth|ct|rth)/,
	                        /(rtv|rm|rbv)/,
	                        /(rbh|cb|lbh)/,
	                        /(lbv|lm|ltv)/
	                    ], function(alignments, side) {
	                        if (alignments.test(alignment) && !defined(margin[side])) {
	                            // Now we have detected on which side of the chart we should
	                            // reserve space for the legend
	                            chart[marginNames[side]] = Math.max(
	                                chart[marginNames[side]],
	                                (
	                                    chart.legend[
	                                        (side + 1) % 2 ? 'legendHeight' : 'legendWidth'
	                                    ] + [1, -1, -1, 1][side] * options[
	                                        (side % 2) ? 'x' : 'y'
	                                    ] +
	                                    pick(options.margin, 12) +
	                                    spacing[side]
	                                )
	                            );
	                        }
	                    });
	                }
	            },
	
	            /**
	             * Render the legend. This method can be called both before and after
	             * `chart.render`. If called after, it will only rearrange items instead
	             * of creating new ones. Called internally on initial render and after
	             * redraws.
	             */
	            render: function() {
	                var legend = this,
	                    chart = legend.chart,
	                    renderer = chart.renderer,
	                    legendGroup = legend.group,
	                    allItems,
	                    display,
	                    legendWidth,
	                    legendHeight,
	                    box = legend.box,
	                    options = legend.options,
	                    padding = legend.padding;
	
	                legend.itemX = padding;
	                legend.itemY = legend.initialItemY;
	                legend.offsetWidth = 0;
	                legend.lastItemY = 0;
	
	                if (!legendGroup) {
	                    legend.group = legendGroup = renderer.g('legend')
	                        .attr({
	                            zIndex: 7
	                        })
	                        .add();
	                    legend.contentGroup = renderer.g()
	                        .attr({
	                            zIndex: 1
	                        }) // above background
	                        .add(legendGroup);
	                    legend.scrollGroup = renderer.g()
	                        .add(legend.contentGroup);
	                }
	
	                legend.renderTitle();
	
	                // add each series or point
	                allItems = legend.getAllItems();
	
	                // sort by legendIndex
	                stableSort(allItems, function(a, b) {
	                    return ((a.options && a.options.legendIndex) || 0) -
	                        ((b.options && b.options.legendIndex) || 0);
	                });
	
	                // reversed legend
	                if (options.reversed) {
	                    allItems.reverse();
	                }
	
	                legend.allItems = allItems;
	                legend.display = display = !!allItems.length;
	
	                // render the items
	                legend.lastLineHeight = 0;
	                each(allItems, function(item) {
	                    legend.renderItem(item);
	                });
	
	                // Get the box
	                legendWidth = (options.width || legend.offsetWidth) + padding;
	                legendHeight = legend.lastItemY + legend.lastLineHeight +
	                    legend.titleHeight;
	                legendHeight = legend.handleOverflow(legendHeight);
	                legendHeight += padding;
	
	                // Draw the border and/or background
	                if (!box) {
	                    legend.box = box = renderer.rect()
	                        .addClass('highcharts-legend-box')
	                        .attr({
	                            r: options.borderRadius
	                        })
	                        .add(legendGroup);
	                    box.isNew = true;
	                }
	
	
	                // Presentational
	                box
	                    .attr({
	                        stroke: options.borderColor,
	                        'stroke-width': options.borderWidth || 0,
	                        fill: options.backgroundColor || 'none'
	                    })
	                    .shadow(options.shadow);
	
	
	                if (legendWidth > 0 && legendHeight > 0) {
	                    box[box.isNew ? 'attr' : 'animate'](
	                        box.crisp({
	                            x: 0,
	                            y: 0,
	                            width: legendWidth,
	                            height: legendHeight
	                        }, box.strokeWidth())
	                    );
	                    box.isNew = false;
	                }
	
	                // hide the border if no items
	                box[display ? 'show' : 'hide']();
	
	
	
	                legend.legendWidth = legendWidth;
	                legend.legendHeight = legendHeight;
	
	                // Now that the legend width and height are established, put the items
	                // in the final position
	                each(allItems, function(item) {
	                    legend.positionItem(item);
	                });
	
	                // 1.x compatibility: positioning based on style
	                /*var props = ['left', 'right', 'top', 'bottom'],
	                	prop,
	                	i = 4;
	                while (i--) {
	                	prop = props[i];
	                	if (options.style[prop] && options.style[prop] !== 'auto') {
	                		options[i < 2 ? 'align' : 'verticalAlign'] = prop;
	                		options[i < 2 ? 'x' : 'y'] = 
	                			pInt(options.style[prop]) * (i % 2 ? -1 : 1);
	                	}
	                }*/
	
	                if (display) {
	                    legendGroup.align(merge(options, {
	                        width: legendWidth,
	                        height: legendHeight
	                    }), true, 'spacingBox');
	                }
	
	                if (!chart.isResizing) {
	                    this.positionCheckboxes();
	                }
	            },
	
	            /**
	             * Set up the overflow handling by adding navigation with up and down arrows
	             * below the legend.
	             *
	             * @private
	             */
	            handleOverflow: function(legendHeight) {
	                var legend = this,
	                    chart = this.chart,
	                    renderer = chart.renderer,
	                    options = this.options,
	                    optionsY = options.y,
	                    alignTop = options.verticalAlign === 'top',
	                    padding = this.padding,
	                    spaceHeight = chart.spacingBox.height +
	                    (alignTop ? -optionsY : optionsY) - padding,
	                    maxHeight = options.maxHeight,
	                    clipHeight,
	                    clipRect = this.clipRect,
	                    navOptions = options.navigation,
	                    animation = pick(navOptions.animation, true),
	                    arrowSize = navOptions.arrowSize || 12,
	                    nav = this.nav,
	                    pages = this.pages,
	                    lastY,
	                    allItems = this.allItems,
	                    clipToHeight = function(height) {
	                        if (typeof height === 'number') {
	                            clipRect.attr({
	                                height: height
	                            });
	                        } else if (clipRect) { // Reset (#5912)
	                            legend.clipRect = clipRect.destroy();
	                            legend.contentGroup.clip();
	                        }
	
	                        // useHTML
	                        if (legend.contentGroup.div) {
	                            legend.contentGroup.div.style.clip = height ?
	                                'rect(' + padding + 'px,9999px,' +
	                                (padding + height) + 'px,0)' :
	                                'auto';
	                        }
	                    };
	
	
	                // Adjust the height
	                if (
	                    options.layout === 'horizontal' &&
	                    options.verticalAlign !== 'middle' &&
	                    !options.floating
	                ) {
	                    spaceHeight /= 2;
	                }
	                if (maxHeight) {
	                    spaceHeight = Math.min(spaceHeight, maxHeight);
	                }
	
	                // Reset the legend height and adjust the clipping rectangle
	                pages.length = 0;
	                if (legendHeight > spaceHeight && navOptions.enabled !== false) {
	
	                    this.clipHeight = clipHeight =
	                        Math.max(spaceHeight - 20 - this.titleHeight - padding, 0);
	                    this.currentPage = pick(this.currentPage, 1);
	                    this.fullHeight = legendHeight;
	
	                    // Fill pages with Y positions so that the top of each a legend item
	                    // defines the scroll top for each page (#2098)
	                    each(allItems, function(item, i) {
	                        var y = item._legendItemPos[1],
	                            h = Math.round(item.legendItem.getBBox().height),
	                            len = pages.length;
	
	                        if (!len || (y - pages[len - 1] > clipHeight &&
	                                (lastY || y) !== pages[len - 1])) {
	                            pages.push(lastY || y);
	                            len++;
	                        }
	
	                        if (i === allItems.length - 1 &&
	                            y + h - pages[len - 1] > clipHeight) {
	                            pages.push(y);
	                        }
	                        if (y !== lastY) {
	                            lastY = y;
	                        }
	                    });
	
	                    // Only apply clipping if needed. Clipping causes blurred legend in
	                    // PDF export (#1787)
	                    if (!clipRect) {
	                        clipRect = legend.clipRect =
	                            renderer.clipRect(0, padding, 9999, 0);
	                        legend.contentGroup.clip(clipRect);
	                    }
	
	                    clipToHeight(clipHeight);
	
	                    // Add navigation elements
	                    if (!nav) {
	                        this.nav = nav = renderer.g()
	                            .attr({
	                                zIndex: 1
	                            })
	                            .add(this.group);
	
	                        this.up = renderer
	                            .symbol(
	                                'triangle',
	                                0,
	                                0,
	                                arrowSize,
	                                arrowSize
	                            )
	                            .on('click', function() {
	                                legend.scroll(-1, animation);
	                            })
	                            .add(nav);
	
	                        this.pager = renderer.text('', 15, 10)
	                            .addClass('highcharts-legend-navigation')
	
	                            .css(navOptions.style)
	
	                            .add(nav);
	
	                        this.down = renderer
	                            .symbol(
	                                'triangle-down',
	                                0,
	                                0,
	                                arrowSize,
	                                arrowSize
	                            )
	                            .on('click', function() {
	                                legend.scroll(1, animation);
	                            })
	                            .add(nav);
	                    }
	
	                    // Set initial position
	                    legend.scroll(0);
	
	                    legendHeight = spaceHeight;
	
	                    // Reset
	                } else if (nav) {
	                    clipToHeight();
	                    this.nav = nav.destroy(); // #6322
	                    this.scrollGroup.attr({
	                        translateY: 1
	                    });
	                    this.clipHeight = 0; // #1379
	                }
	
	                return legendHeight;
	            },
	
	            /**
	             * Scroll the legend by a number of pages.
	             * @param  {Number} scrollBy
	             *         The number of pages to scroll.
	             * @param  {AnimationOptions} animation
	             *         Whether and how to apply animation.
	             */
	            scroll: function(scrollBy, animation) {
	                var pages = this.pages,
	                    pageCount = pages.length,
	                    currentPage = this.currentPage + scrollBy,
	                    clipHeight = this.clipHeight,
	                    navOptions = this.options.navigation,
	                    pager = this.pager,
	                    padding = this.padding,
	                    scrollOffset;
	
	                // When resizing while looking at the last page
	                if (currentPage > pageCount) {
	                    currentPage = pageCount;
	                }
	
	                if (currentPage > 0) {
	
	                    if (animation !== undefined) {
	                        setAnimation(animation, this.chart);
	                    }
	
	                    this.nav.attr({
	                        translateX: padding,
	                        translateY: clipHeight + this.padding + 7 + this.titleHeight,
	                        visibility: 'visible'
	                    });
	                    this.up.attr({
	                        'class': currentPage === 1 ?
	                            'highcharts-legend-nav-inactive' : 'highcharts-legend-nav-active'
	                    });
	                    pager.attr({
	                        text: currentPage + '/' + pageCount
	                    });
	                    this.down.attr({
	                        'x': 18 + this.pager.getBBox().width, // adjust to text width
	                        'class': currentPage === pageCount ?
	                            'highcharts-legend-nav-inactive' : 'highcharts-legend-nav-active'
	                    });
	
	
	                    this.up
	                        .attr({
	                            fill: currentPage === 1 ?
	                                navOptions.inactiveColor : navOptions.activeColor
	                        })
	                        .css({
	                            cursor: currentPage === 1 ? 'default' : 'pointer'
	                        });
	                    this.down
	                        .attr({
	                            fill: currentPage === pageCount ?
	                                navOptions.inactiveColor : navOptions.activeColor
	                        })
	                        .css({
	                            cursor: currentPage === pageCount ? 'default' : 'pointer'
	                        });
	
	
	                    scrollOffset = -pages[currentPage - 1] + this.initialItemY;
	
	                    this.scrollGroup.animate({
	                        translateY: scrollOffset
	                    });
	
	                    this.currentPage = currentPage;
	                    this.positionCheckboxes(scrollOffset);
	                }
	
	            }
	
	        };
	
	        /*
	         * LegendSymbolMixin
	         */
	
	        H.LegendSymbolMixin = {
	
	            /**
	             * Get the series' symbol in the legend
	             *
	             * @param {Object} legend The legend object
	             * @param {Object} item The series (this) or point
	             */
	            drawRectangle: function(legend, item) {
	                var options = legend.options,
	                    symbolHeight = legend.symbolHeight,
	                    square = options.squareSymbol,
	                    symbolWidth = square ? symbolHeight : legend.symbolWidth;
	
	                item.legendSymbol = this.chart.renderer.rect(
	                        square ? (legend.symbolWidth - symbolHeight) / 2 : 0,
	                        legend.baseline - symbolHeight + 1, // #3988
	                        symbolWidth,
	                        symbolHeight,
	                        pick(legend.options.symbolRadius, symbolHeight / 2)
	                    )
	                    .addClass('highcharts-point')
	                    .attr({
	                        zIndex: 3
	                    }).add(item.legendGroup);
	
	            },
	
	            /**
	             * Get the series' symbol in the legend. This method should be overridable
	             * to create custom symbols through
	             * Highcharts.seriesTypes[type].prototype.drawLegendSymbols.
	             *
	             * @param {Object} legend The legend object
	             */
	            drawLineMarker: function(legend) {
	
	                var options = this.options,
	                    markerOptions = options.marker,
	                    radius,
	                    legendSymbol,
	                    symbolWidth = legend.symbolWidth,
	                    symbolHeight = legend.symbolHeight,
	                    generalRadius = symbolHeight / 2,
	                    renderer = this.chart.renderer,
	                    legendItemGroup = this.legendGroup,
	                    verticalCenter = legend.baseline -
	                    Math.round(legend.fontMetrics.b * 0.3),
	                    attr = {};
	
	                // Draw the line
	
	                attr = {
	                    'stroke-width': options.lineWidth || 0
	                };
	                if (options.dashStyle) {
	                    attr.dashstyle = options.dashStyle;
	                }
	
	
	                this.legendLine = renderer.path([
	                        'M',
	                        0,
	                        verticalCenter,
	                        'L',
	                        symbolWidth,
	                        verticalCenter
	                    ])
	                    .addClass('highcharts-graph')
	                    .attr(attr)
	                    .add(legendItemGroup);
	
	                // Draw the marker
	                if (markerOptions && markerOptions.enabled !== false) {
	
	                    // Do not allow the marker to be larger than the symbolHeight
	                    radius = Math.min(
	                        pick(markerOptions.radius, generalRadius),
	                        generalRadius
	                    );
	
	                    // Restrict symbol markers size
	                    if (this.symbol.indexOf('url') === 0) {
	                        markerOptions = merge(markerOptions, {
	                            width: symbolHeight,
	                            height: symbolHeight
	                        });
	                        radius = 0;
	                    }
	
	                    this.legendSymbol = legendSymbol = renderer.symbol(
	                            this.symbol,
	                            (symbolWidth / 2) - radius,
	                            verticalCenter - radius,
	                            2 * radius,
	                            2 * radius,
	                            markerOptions
	                        )
	                        .addClass('highcharts-point')
	                        .add(legendItemGroup);
	                    legendSymbol.isMarker = true;
	                }
	            }
	        };
	
	        // Workaround for #2030, horizontal legend items not displaying in IE11 Preview,
	        // and for #2580, a similar drawing flaw in Firefox 26.
	        // Explore if there's a general cause for this. The problem may be related
	        // to nested group elements, as the legend item texts are within 4 group
	        // elements.
	        if (/Trident\/7\.0/.test(win.navigator.userAgent) || isFirefox) {
	            wrap(Highcharts.Legend.prototype, 'positionItem', function(proceed, item) {
	                var legend = this,
	                    // If chart destroyed in sync, this is undefined (#2030)
	                    runPositionItem = function() {
	                        if (item._legendItemPos) {
	                            proceed.call(legend, item);
	                        }
	                    };
	
	                // Do it now, for export and to get checkbox placement
	                runPositionItem();
	
	                // Do it after to work around the core issue
	                setTimeout(runPositionItem);
	            });
	        }
	
	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var addEvent = H.addEvent,
	            animate = H.animate,
	            animObject = H.animObject,
	            attr = H.attr,
	            doc = H.doc,
	            Axis = H.Axis, // @todo add as requirement
	            createElement = H.createElement,
	            defaultOptions = H.defaultOptions,
	            discardElement = H.discardElement,
	            charts = H.charts,
	            css = H.css,
	            defined = H.defined,
	            each = H.each,
	            extend = H.extend,
	            find = H.find,
	            fireEvent = H.fireEvent,
	            getStyle = H.getStyle,
	            grep = H.grep,
	            isNumber = H.isNumber,
	            isObject = H.isObject,
	            isString = H.isString,
	            Legend = H.Legend, // @todo add as requirement
	            marginNames = H.marginNames,
	            merge = H.merge,
	            objectEach = H.objectEach,
	            Pointer = H.Pointer, // @todo add as requirement
	            pick = H.pick,
	            pInt = H.pInt,
	            removeEvent = H.removeEvent,
	            seriesTypes = H.seriesTypes,
	            splat = H.splat,
	            svg = H.svg,
	            syncTimeout = H.syncTimeout,
	            win = H.win,
	            Renderer = H.Renderer;
	        /**
	         * The Chart class. The recommended constructor is {@link Highcharts#chart}.
	         * @class Highcharts.Chart
	         * @param  {String|HTMLDOMElement} renderTo
	         *         The DOM element to render to, or its id.
	         * @param  {Options} options
	         *         The chart options structure.
	         * @param  {Function} [callback]
	         *         Function to run when the chart has loaded and and all external images
	         *         are loaded. Defining a {@link
	         *         https://api.highcharts.com/highcharts/chart.events.load|chart.event.load}
	         *         handler is equivalent.
	         *
	         * @example
	         * var chart = Highcharts.chart('container', {
	         * 	   title: {
	         * 	   	   text: 'My chart'
	         * 	   },
	         * 	   series: [{
	         * 	       data: [1, 3, 2, 4]
	         * 	   }]
	         * })
	         */
	        var Chart = H.Chart = function() {
	            this.getArgs.apply(this, arguments);
	        };
	
	        /**
	         * Factory function for basic charts. 
	         *
	         * @function #chart
	         * @memberOf Highcharts
	         * @param  {String|HTMLDOMElement} renderTo - The DOM element to render to, or
	         * its id.
	         * @param  {Options} options - The chart options structure.
	         * @param  {Function} [callback] - Function to run when the chart has loaded and
	         * and all external images are loaded. Defining a {@link
	         * https://api.highcharts.com/highcharts/chart.events.load|chart.event.load}
	         * handler is equivalent.
	         * @return {Highcharts.Chart} - Returns the Chart object.
	         *
	         * @example
	         * // Render a chart in to div#container
	         * var chart = Highcharts.chart('container', {
	         *     title: {
	         *         text: 'My chart'
	         *     },
	         *     series: [{
	         *         data: [1, 3, 2, 4]
	         *     }]
	         * });
	         */
	        H.chart = function(a, b, c) {
	            return new Chart(a, b, c);
	        };
	
	        extend(Chart.prototype, /** @lends Highcharts.Chart.prototype */ {
	
	            // Hook for adding callbacks in modules
	            callbacks: [],
	
	            /**
	             * Handle the arguments passed to the constructor.
	             *
	             * @private
	             * @returns {Array} Arguments without renderTo
	             */
	            getArgs: function() {
	                var args = [].slice.call(arguments);
	
	                // Remove the optional first argument, renderTo, and
	                // set it on this.
	                if (isString(args[0]) || args[0].nodeName) {
	                    this.renderTo = args.shift();
	                }
	                this.init(args[0], args[1]);
	            },
	
	            /**
	             * Overridable function that initializes the chart. The constructor's
	             * arguments are passed on directly.
	             */
	            init: function(userOptions, callback) {
	
	                // Handle regular options
	                var options,
	                    type,
	                    seriesOptions = userOptions.series, // skip merging data points to increase performance
	                    userPlotOptions = userOptions.plotOptions || {};
	
	                userOptions.series = null;
	                options = merge(defaultOptions, userOptions); // do the merge
	
	                // Override (by copy of user options) or clear tooltip options
	                // in chart.options.plotOptions (#6218)
	                for (type in options.plotOptions) {
	                    options.plotOptions[type].tooltip = (
	                        userPlotOptions[type] &&
	                        merge(userPlotOptions[type].tooltip) // override by copy
	                    ) || undefined; // or clear
	                }
	                // User options have higher priority than default options (#6218).
	                // In case of exporting: path is changed
	                options.tooltip.userOptions = (userOptions.chart &&
	                        userOptions.chart.forExport && userOptions.tooltip.userOptions) ||
	                    userOptions.tooltip;
	
	                options.series = userOptions.series = seriesOptions; // set back the series data
	                this.userOptions = userOptions;
	
	                var optionsChart = options.chart;
	
	                var chartEvents = optionsChart.events;
	
	                this.margin = [];
	                this.spacing = [];
	
	                //this.runChartClick = chartEvents && !!chartEvents.click;
	                this.bounds = {
	                    h: {},
	                    v: {}
	                }; // Pixel data bounds for touch zoom
	
	                this.callback = callback;
	                this.isResizing = 0;
	
	                /**
	                 * The options structure for the chart. It contains members for the sub
	                 * elements like series, legend, tooltip etc.
	                 *
	                 * @memberof Highcharts.Chart
	                 * @name options
	                 * @type {Options}
	                 */
	                this.options = options;
	                /**
	                 * All the axes in the chart.
	                 *
	                 * @memberof Highcharts.Chart
	                 * @name axes
	                 * @see  Highcharts.Chart.xAxis
	                 * @see  Highcharts.Chart.yAxis
	                 * @type {Array.<Highcharts.Axis>}
	                 */
	                this.axes = [];
	
	                /**
	                 * All the current series in the chart.
	                 *
	                 * @memberof Highcharts.Chart
	                 * @name series
	                 * @type {Array.<Highcharts.Series>}
	                 */
	                this.series = [];
	
	                /**
	                 * The chart title. The title has an `update` method that allows
	                 * modifying the options directly or indirectly via `chart.update`.
	                 *
	                 * @memberof Highcharts.Chart
	                 * @name title
	                 * @type Object
	                 *
	                 * @sample highcharts/members/title-update/
	                 *         Updating titles
	                 */
	
	                /**
	                 * The chart subtitle. The subtitle has an `update` method that allows
	                 * modifying the options directly or indirectly via `chart.update`.
	                 *
	                 * @memberof Highcharts.Chart
	                 * @name subtitle
	                 * @type Object
	                 */
	
	
	
	                this.hasCartesianSeries = optionsChart.showAxes;
	                //this.axisOffset = undefined;
	                //this.inverted = undefined;
	                //this.loadingShown = undefined;
	                //this.container = undefined;
	                //this.chartWidth = undefined;
	                //this.chartHeight = undefined;
	                //this.marginRight = undefined;
	                //this.marginBottom = undefined;
	                //this.containerWidth = undefined;
	                //this.containerHeight = undefined;
	                //this.oldChartWidth = undefined;
	                //this.oldChartHeight = undefined;
	
	                //this.renderTo = undefined;
	
	                //this.spacingBox = undefined
	
	                //this.legend = undefined;
	
	                // Elements
	                //this.chartBackground = undefined;
	                //this.plotBackground = undefined;
	                //this.plotBGImage = undefined;
	                //this.plotBorder = undefined;
	                //this.loadingDiv = undefined;
	                //this.loadingSpan = undefined;
	
	                var chart = this;
	
	                // Add the chart to the global lookup
	                chart.index = charts.length;
	
	                charts.push(chart);
	                H.chartCount++;
	
	                // Chart event handlers
	                if (chartEvents) {
	                    objectEach(chartEvents, function(event, eventType) {
	                        addEvent(chart, eventType, event);
	                    });
	                }
	
	                /**
	                 * A collection of the X axes in the chart.
	                 * @type {Array.<Highcharts.Axis>}
	                 * @name xAxis
	                 * @memberOf Highcharts.Chart
	                 */
	                chart.xAxis = [];
	                /**
	                 * A collection of the Y axes in the chart.
	                 * @type {Array.<Highcharts.Axis>}
	                 * @name yAxis
	                 * @memberOf Highcharts.Chart
	                 */
	                chart.yAxis = [];
	
	                chart.pointCount = chart.colorCounter = chart.symbolCounter = 0;
	
	                chart.firstRender();
	            },
	
	            /**
	             * Internal function to unitialize an individual series.
	             *
	             * @private
	             */
	            initSeries: function(options) {
	                var chart = this,
	                    optionsChart = chart.options.chart,
	                    type = options.type || optionsChart.type || optionsChart.defaultSeriesType,
	                    series,
	                    Constr = seriesTypes[type];
	
	                // No such series type
	                if (!Constr) {
	                    H.error(17, true);
	                }
	
	                series = new Constr();
	                series.init(this, options);
	                return series;
	            },
	
	            /**
	             * Order all series above a given index. When series are added and ordered
	             * by configuration, only the last series is handled (#248, #1123, #2456,
	             * #6112). This function is called on series initialization and destroy.
	             *
	             * @private
	             *
	             * @param  {number} fromIndex
	             *         If this is given, only the series above this index are handled.
	             */
	            orderSeries: function(fromIndex) {
	                var series = this.series,
	                    i = fromIndex || 0;
	                for (; i < series.length; i++) {
	                    if (series[i]) {
	                        series[i].index = i;
	                        series[i].name = series[i].name ||
	                            'Series ' + (series[i].index + 1);
	                    }
	                }
	            },
	
	            /**
	             * Check whether a given point is within the plot area.
	             *
	             * @param  {Number} plotX
	             *         Pixel x relative to the plot area.
	             * @param  {Number} plotY
	             *         Pixel y relative to the plot area.
	             * @param  {Boolean} inverted
	             *         Whether the chart is inverted.
	             *
	             * @return {Boolean}
	             *         Returns true if the given point is inside the plot area.
	             */
	            isInsidePlot: function(plotX, plotY, inverted) {
	                var x = inverted ? plotY : plotX,
	                    y = inverted ? plotX : plotY;
	
	                return x >= 0 &&
	                    x <= this.plotWidth &&
	                    y >= 0 &&
	                    y <= this.plotHeight;
	            },
	
	            /**
	             * Redraw the chart after changes have been done to the data, axis extremes
	             * chart size or chart elements. All methods for updating axes, series or
	             * points have a parameter for redrawing the chart. This is `true` by
	             * default. But in many cases you want to do more than one operation on the
	             * chart before redrawing, for example add a number of points. In those
	             * cases it is a waste of resources to redraw the chart for each new point
	             * added. So you add the points and call `chart.redraw()` after.
	             *
	             * @param  {AnimationOptions} animation
	             *         If or how to apply animation to the redraw.
	             */
	            redraw: function(animation) {
	                var chart = this,
	                    axes = chart.axes,
	                    series = chart.series,
	                    pointer = chart.pointer,
	                    legend = chart.legend,
	                    redrawLegend = chart.isDirtyLegend,
	                    hasStackedSeries,
	                    hasDirtyStacks,
	                    hasCartesianSeries = chart.hasCartesianSeries,
	                    isDirtyBox = chart.isDirtyBox,
	                    i,
	                    serie,
	                    renderer = chart.renderer,
	                    isHiddenChart = renderer.isHidden(),
	                    afterRedraw = [];
	
	                // Handle responsive rules, not only on resize (#6130)
	                if (chart.setResponsive) {
	                    chart.setResponsive(false);
	                }
	
	                H.setAnimation(animation, chart);
	
	                if (isHiddenChart) {
	                    chart.temporaryDisplay();
	                }
	
	                // Adjust title layout (reflow multiline text)
	                chart.layOutTitles();
	
	                // link stacked series
	                i = series.length;
	                while (i--) {
	                    serie = series[i];
	
	                    if (serie.options.stacking) {
	                        hasStackedSeries = true;
	
	                        if (serie.isDirty) {
	                            hasDirtyStacks = true;
	                            break;
	                        }
	                    }
	                }
	                if (hasDirtyStacks) { // mark others as dirty
	                    i = series.length;
	                    while (i--) {
	                        serie = series[i];
	                        if (serie.options.stacking) {
	                            serie.isDirty = true;
	                        }
	                    }
	                }
	
	                // Handle updated data in the series
	                each(series, function(serie) {
	                    if (serie.isDirty) {
	                        if (serie.options.legendType === 'point') {
	                            if (serie.updateTotals) {
	                                serie.updateTotals();
	                            }
	                            redrawLegend = true;
	                        }
	                    }
	                    if (serie.isDirtyData) {
	                        fireEvent(serie, 'updatedData');
	                    }
	                });
	
	                // handle added or removed series
	                if (redrawLegend && legend.options.enabled) { // series or pie points are added or removed
	                    // draw legend graphics
	                    legend.render();
	
	                    chart.isDirtyLegend = false;
	                }
	
	                // reset stacks
	                if (hasStackedSeries) {
	                    chart.getStacks();
	                }
	
	
	                if (hasCartesianSeries) {
	                    // set axes scales
	                    each(axes, function(axis) {
	                        axis.updateNames();
	                        axis.setScale();
	                    });
	                }
	
	                chart.getMargins(); // #3098
	
	                if (hasCartesianSeries) {
	                    // If one axis is dirty, all axes must be redrawn (#792, #2169)
	                    each(axes, function(axis) {
	                        if (axis.isDirty) {
	                            isDirtyBox = true;
	                        }
	                    });
	
	                    // redraw axes
	                    each(axes, function(axis) {
	
	                        // Fire 'afterSetExtremes' only if extremes are set
	                        var key = axis.min + ',' + axis.max;
	                        if (axis.extKey !== key) { // #821, #4452
	                            axis.extKey = key;
	                            afterRedraw.push(function() { // prevent a recursive call to chart.redraw() (#1119)
	                                fireEvent(axis, 'afterSetExtremes', extend(axis.eventArgs, axis.getExtremes())); // #747, #751
	                                delete axis.eventArgs;
	                            });
	                        }
	                        if (isDirtyBox || hasStackedSeries) {
	                            axis.redraw();
	                        }
	                    });
	                }
	
	                // the plot areas size has changed
	                if (isDirtyBox) {
	                    chart.drawChartBox();
	                }
	
	                // Fire an event before redrawing series, used by the boost module to
	                // clear previous series renderings.
	                fireEvent(chart, 'predraw');
	
	                // redraw affected series
	                each(series, function(serie) {
	                    if ((isDirtyBox || serie.isDirty) && serie.visible) {
	                        serie.redraw();
	                    }
	                    // Set it here, otherwise we will have unlimited 'updatedData' calls
	                    // for a hidden series after setData(). Fixes #6012
	                    serie.isDirtyData = false;
	                });
	
	                // move tooltip or reset
	                if (pointer) {
	                    pointer.reset(true);
	                }
	
	                // redraw if canvas
	                renderer.draw();
	
	                // Fire the events
	                fireEvent(chart, 'redraw');
	                fireEvent(chart, 'render');
	
	                if (isHiddenChart) {
	                    chart.temporaryDisplay(true);
	                }
	
	                // Fire callbacks that are put on hold until after the redraw
	                each(afterRedraw, function(callback) {
	                    callback.call();
	                });
	            },
	
	            /**
	             * Get an axis, series or point object by `id` as given in the configuration
	             * options. Returns `undefined` if no item is found.
	             * @param id {String} The id as given in the configuration options.
	             * @return {Highcharts.Axis|Highcharts.Series|Highcharts.Point|undefined}
	             *         The retrieved item.
	             * @sample highcharts/plotoptions/series-id/
	             *         Get series by id
	             */
	            get: function(id) {
	
	                var ret,
	                    series = this.series,
	                    i;
	
	                function itemById(item) {
	                    return item.id === id || (item.options && item.options.id === id);
	                }
	
	                ret =
	                    // Search axes
	                    find(this.axes, itemById) ||
	
	                    // Search series
	                    find(this.series, itemById);
	
	                // Search points
	                for (i = 0; !ret && i < series.length; i++) {
	                    ret = find(series[i].points || [], itemById);
	                }
	
	                return ret;
	            },
	
	            /**
	             * Create the Axis instances based on the config options.
	             *
	             * @private
	             */
	            getAxes: function() {
	                var chart = this,
	                    options = this.options,
	                    xAxisOptions = options.xAxis = splat(options.xAxis || {}),
	                    yAxisOptions = options.yAxis = splat(options.yAxis || {}),
	                    optionsArray;
	
	                // make sure the options are arrays and add some members
	                each(xAxisOptions, function(axis, i) {
	                    axis.index = i;
	                    axis.isX = true;
	                });
	
	                each(yAxisOptions, function(axis, i) {
	                    axis.index = i;
	                });
	
	                // concatenate all axis options into one array
	                optionsArray = xAxisOptions.concat(yAxisOptions);
	
	                each(optionsArray, function(axisOptions) {
	                    new Axis(chart, axisOptions); // eslint-disable-line no-new
	                });
	            },
	
	
	            /**
	             * Returns an array of all currently selected points in the chart. Points
	             * can be selected by clicking or programmatically by the {@link
	             * Highcharts.Point#select} function.
	             *
	             * @return {Array.<Highcharts.Point>}
	             *         The currently selected points.
	             *
	             * @sample highcharts/plotoptions/series-allowpointselect-line/
	             *         Get selected points
	             */
	            getSelectedPoints: function() {
	                var points = [];
	                each(this.series, function(serie) {
	                    // series.data - for points outside of viewed range (#6445)
	                    points = points.concat(grep(serie.data || [], function(point) {
	                        return point.selected;
	                    }));
	                });
	                return points;
	            },
	
	            /**
	             * Returns an array of all currently selected series in the chart. Series
	             * can be selected either programmatically by the {@link
	             * Highcharts.Series#select} function or by checking the checkbox next to
	             * the legend item if {@link
	             * https://api.highcharts.com/highcharts/plotOptions.series.showCheckbox|
	             * series.showCheckBox} is true.
	             * 
	             * @return {Array.<Highcharts.Series>}
	             *         The currently selected series.
	             *
	             * @sample highcharts/members/chart-getselectedseries/
	             *         Get selected series
	             */
	            getSelectedSeries: function() {
	                return grep(this.series, function(serie) {
	                    return serie.selected;
	                });
	            },
	
	            /**
	             * Set a new title or subtitle for the chart.
	             *
	             * @param  titleOptions {TitleOptions}
	             *         New title options. The title text itself is set by the
	             *         `titleOptions.text` property.
	             * @param  subtitleOptions {SubtitleOptions}
	             *         New subtitle options. The subtitle text itself is set by the
	             *         `subtitleOptions.text` property.
	             * @param  redraw {Boolean}
	             *         Whether to redraw the chart or wait for a later call to 
	             *         `chart.redraw()`.
	             *
	             * @sample highcharts/members/chart-settitle/ Set title text and styles
	             *
	             */
	            setTitle: function(titleOptions, subtitleOptions, redraw) {
	                var chart = this,
	                    options = chart.options,
	                    chartTitleOptions,
	                    chartSubtitleOptions;
	
	                chartTitleOptions = options.title = merge(
	
	                    // Default styles
	                    {
	                        style: {
	                            color: '#333333',
	                            fontSize: options.isStock ? '16px' : '18px' // #2944
	                        }
	                    },
	
	                    options.title,
	                    titleOptions
	                );
	                chartSubtitleOptions = options.subtitle = merge(
	
	                    // Default styles
	                    {
	                        style: {
	                            color: '#666666'
	                        }
	                    },
	
	                    options.subtitle,
	                    subtitleOptions
	                );
	
	                // add title and subtitle
	                each([
	                    ['title', titleOptions, chartTitleOptions],
	                    ['subtitle', subtitleOptions, chartSubtitleOptions]
	                ], function(arr, i) {
	                    var name = arr[0],
	                        title = chart[name],
	                        titleOptions = arr[1],
	                        chartTitleOptions = arr[2];
	
	                    if (title && titleOptions) {
	                        chart[name] = title = title.destroy(); // remove old
	                    }
	
	                    if (chartTitleOptions && chartTitleOptions.text && !title) {
	                        chart[name] = chart.renderer.text(
	                                chartTitleOptions.text,
	                                0,
	                                0,
	                                chartTitleOptions.useHTML
	                            )
	                            .attr({
	                                align: chartTitleOptions.align,
	                                'class': 'highcharts-' + name,
	                                zIndex: chartTitleOptions.zIndex || 4
	                            })
	                            .add();
	
	                        // Update methods, shortcut to Chart.setTitle
	                        chart[name].update = function(o) {
	                            chart.setTitle(!i && o, i && o);
	                        };
	
	
	                        // Presentational
	                        chart[name].css(chartTitleOptions.style);
	
	
	                    }
	                });
	                chart.layOutTitles(redraw);
	            },
	
	            /**
	             * Internal function to lay out the chart titles and cache the full offset
	             * height for use in `getMargins`. The result is stored in 
	             * `this.titleOffset`.
	             *
	             * @private
	             */
	            layOutTitles: function(redraw) {
	                var titleOffset = 0,
	                    requiresDirtyBox,
	                    renderer = this.renderer,
	                    spacingBox = this.spacingBox;
	
	                // Lay out the title and the subtitle respectively
	                each(['title', 'subtitle'], function(key) {
	                    var title = this[key],
	                        titleOptions = this.options[key],
	                        offset = key === 'title' ? -3 :
	                        // Floating subtitle (#6574)
	                        titleOptions.verticalAlign ? 0 : titleOffset + 2,
	                        titleSize;
	
	                    if (title) {
	
	                        titleSize = titleOptions.style.fontSize;
	
	                        titleSize = renderer.fontMetrics(titleSize, title).b;
	
	                        title
	                            .css({
	                                width: (titleOptions.width ||
	                                    spacingBox.width + titleOptions.widthAdjust) + 'px'
	                            })
	                            .align(extend({
	                                y: offset + titleSize
	                            }, titleOptions), false, 'spacingBox');
	
	                        if (!titleOptions.floating && !titleOptions.verticalAlign) {
	                            titleOffset = Math.ceil(
	                                titleOffset +
	                                // Skip the cache for HTML (#3481)
	                                title.getBBox(titleOptions.useHTML).height
	                            );
	                        }
	                    }
	                }, this);
	
	                requiresDirtyBox = this.titleOffset !== titleOffset;
	                this.titleOffset = titleOffset; // used in getMargins
	
	                if (!this.isDirtyBox && requiresDirtyBox) {
	                    this.isDirtyBox = requiresDirtyBox;
	                    // Redraw if necessary (#2719, #2744)
	                    if (this.hasRendered && pick(redraw, true) && this.isDirtyBox) {
	                        this.redraw();
	                    }
	                }
	            },
	
	            /**
	             * Internal function to get the chart width and height according to options
	             * and container size. Sets {@link Chart.chartWidth} and {@link
	             * Chart.chartHeight}.
	             */
	            getChartSize: function() {
	                var chart = this,
	                    optionsChart = chart.options.chart,
	                    widthOption = optionsChart.width,
	                    heightOption = optionsChart.height,
	                    renderTo = chart.renderTo;
	
	                // Get inner width and height
	                if (!defined(widthOption)) {
	                    chart.containerWidth = getStyle(renderTo, 'width');
	                }
	                if (!defined(heightOption)) {
	                    chart.containerHeight = getStyle(renderTo, 'height');
	                }
	
	                /**
	                 * The current pixel width of the chart.
	                 *
	                 * @name chartWidth
	                 * @memberOf Chart
	                 * @type {Number}
	                 */
	                chart.chartWidth = Math.max( // #1393
	                    0,
	                    widthOption || chart.containerWidth || 600 // #1460
	                );
	                /**
	                 * The current pixel height of the chart.
	                 *
	                 * @name chartHeight
	                 * @memberOf Chart
	                 * @type {Number}
	                 */
	                chart.chartHeight = Math.max(
	                    0,
	                    H.relativeLength(
	                        heightOption,
	                        chart.chartWidth
	                    ) || chart.containerHeight || 400
	                );
	            },
	
	            /**
	             * If the renderTo element has no offsetWidth, most likely one or more of
	             * its parents are hidden. Loop up the DOM tree to temporarily display the
	             * parents, then save the original display properties, and when the true
	             * size is retrieved, reset them. Used on first render and on redraws.
	             *
	             * @private
	             * 
	             * @param  {Boolean} revert
	             *         Revert to the saved original styles.
	             */
	            temporaryDisplay: function(revert) {
	                var node = this.renderTo,
	                    tempStyle;
	                if (!revert) {
	                    while (node && node.style) {
	
	                        // When rendering to a detached node, it needs to be temporarily
	                        // attached in order to read styling and bounding boxes (#5783).
	                        if (!doc.body.contains(node)) {
	                            node.hcOrigDetached = true;
	                            doc.body.appendChild(node);
	                        }
	                        if (
	                            getStyle(node, 'display', false) === 'none' ||
	                            node.hcOricDetached
	                        ) {
	                            node.hcOrigStyle = {
	                                display: node.style.display,
	                                height: node.style.height,
	                                overflow: node.style.overflow
	                            };
	                            tempStyle = {
	                                display: 'block',
	                                overflow: 'hidden'
	                            };
	                            if (node !== this.renderTo) {
	                                tempStyle.height = 0;
	                            }
	
	                            H.css(node, tempStyle);
	
	                            // If it still doesn't have an offset width after setting
	                            // display to block, it probably has an !important priority
	                            // #2631, 6803
	                            if (!node.offsetWidth) {
	                                node.style.setProperty('display', 'block', 'important');
	                            }
	                        }
	                        node = node.parentNode;
	
	                        if (node === doc.body) {
	                            break;
	                        }
	                    }
	                } else {
	                    while (node && node.style) {
	                        if (node.hcOrigStyle) {
	                            H.css(node, node.hcOrigStyle);
	                            delete node.hcOrigStyle;
	                        }
	                        if (node.hcOrigDetached) {
	                            doc.body.removeChild(node);
	                            node.hcOrigDetached = false;
	                        }
	                        node = node.parentNode;
	                    }
	                }
	            },
	
	            /**
	             * Set the {@link Chart.container|chart container's} class name, in
	             * addition to `highcharts-container`. 
	             */
	            setClassName: function(className) {
	                this.container.className = 'highcharts-container ' + (className || '');
	            },
	
	            /**
	             * Get the containing element, determine the size and create the inner
	             * container div to hold the chart.
	             *
	             * @private
	             */
	            getContainer: function() {
	                var chart = this,
	                    container,
	                    options = chart.options,
	                    optionsChart = options.chart,
	                    chartWidth,
	                    chartHeight,
	                    renderTo = chart.renderTo,
	                    indexAttrName = 'data-highcharts-chart',
	                    oldChartIndex,
	                    Ren,
	                    containerId = H.uniqueKey(),
	                    containerStyle,
	                    key;
	
	                if (!renderTo) {
	                    chart.renderTo = renderTo = optionsChart.renderTo;
	                }
	
	                if (isString(renderTo)) {
	                    chart.renderTo = renderTo = doc.getElementById(renderTo);
	                }
	
	                // Display an error if the renderTo is wrong
	                if (!renderTo) {
	                    H.error(13, true);
	                }
	
	                // If the container already holds a chart, destroy it. The check for
	                // hasRendered is there because web pages that are saved to disk from
	                // the browser, will preserve the data-highcharts-chart attribute and
	                // the SVG contents, but not an interactive chart. So in this case,
	                // charts[oldChartIndex] will point to the wrong chart if any (#2609).
	                oldChartIndex = pInt(attr(renderTo, indexAttrName));
	                if (
	                    isNumber(oldChartIndex) &&
	                    charts[oldChartIndex] &&
	                    charts[oldChartIndex].hasRendered
	                ) {
	                    charts[oldChartIndex].destroy();
	                }
	
	                // Make a reference to the chart from the div
	                attr(renderTo, indexAttrName, chart.index);
	
	                // remove previous chart
	                renderTo.innerHTML = '';
	
	                // If the container doesn't have an offsetWidth, it has or is a child of
	                // a node that has display:none. We need to temporarily move it out to a
	                // visible state to determine the size, else the legend and tooltips
	                // won't render properly. The skipClone option is used in sparklines as
	                // a micro optimization, saving about 1-2 ms each chart.
	                if (!optionsChart.skipClone && !renderTo.offsetWidth) {
	                    chart.temporaryDisplay();
	                }
	
	                // get the width and height
	                chart.getChartSize();
	                chartWidth = chart.chartWidth;
	                chartHeight = chart.chartHeight;
	
	                // Create the inner container
	
	                containerStyle = extend({
	                    position: 'relative',
	                    overflow: 'hidden', // needed for context menu (avoid scrollbars)
	                    // and content overflow in IE
	                    width: chartWidth + 'px',
	                    height: chartHeight + 'px',
	                    textAlign: 'left',
	                    lineHeight: 'normal', // #427
	                    zIndex: 0, // #1072
	                    '-webkit-tap-highlight-color': 'rgba(0,0,0,0)'
	                }, optionsChart.style);
	
	
	                /**
	                 * The containing HTML element of the chart. The container is
	                 * dynamically inserted into the element given as the `renderTo`
	                 * parameterin the {@link Highcharts#chart} constructor.
	                 *
	                 * @memberOf Highcharts.Chart
	                 * @type {HTMLDOMElement}
	                 */
	                container = createElement(
	                    'div', {
	                        id: containerId
	                    },
	                    containerStyle,
	                    renderTo
	                );
	                chart.container = container;
	
	                // cache the cursor (#1650)
	                chart._cursor = container.style.cursor;
	
	                // Initialize the renderer
	                Ren = H[optionsChart.renderer] || Renderer;
	                /**
	                 * The renderer instance of the chart. Each chart instance has only one
	                 * associated renderer.
	                 * @type {SVGRenderer}
	                 * @name renderer
	                 * @memberOf Chart
	                 */
	                chart.renderer = new Ren(
	                    container,
	                    chartWidth,
	                    chartHeight,
	                    null,
	                    optionsChart.forExport,
	                    options.exporting && options.exporting.allowHTML
	                );
	
	
	                chart.setClassName(optionsChart.className);
	
	                chart.renderer.setStyle(optionsChart.style);
	
	
	                // Add a reference to the charts index
	                chart.renderer.chartIndex = chart.index;
	            },
	
	            /**
	             * Calculate margins by rendering axis labels in a preliminary position.
	             * Title, subtitle and legend have already been rendered at this stage, but
	             * will be moved into their final positions.
	             *
	             * @private
	             */
	            getMargins: function(skipAxes) {
	                var chart = this,
	                    spacing = chart.spacing,
	                    margin = chart.margin,
	                    titleOffset = chart.titleOffset;
	
	                chart.resetMargins();
	
	                // Adjust for title and subtitle
	                if (titleOffset && !defined(margin[0])) {
	                    chart.plotTop = Math.max(
	                        chart.plotTop,
	                        titleOffset + chart.options.title.margin + spacing[0]
	                    );
	                }
	
	                // Adjust for legend
	                if (chart.legend.display) {
	                    chart.legend.adjustMargins(margin, spacing);
	                }
	
	                // adjust for scroller
	                if (chart.extraMargin) {
	                    chart[chart.extraMargin.type] =
	                        (chart[chart.extraMargin.type] || 0) + chart.extraMargin.value;
	                }
	                if (chart.extraTopMargin) {
	                    chart.plotTop += chart.extraTopMargin;
	                }
	                if (!skipAxes) {
	                    this.getAxisMargins();
	                }
	            },
	
	            getAxisMargins: function() {
	
	                var chart = this,
	                    // [top, right, bottom, left]
	                    axisOffset = chart.axisOffset = [0, 0, 0, 0],
	                    margin = chart.margin;
	
	                // pre-render axes to get labels offset width
	                if (chart.hasCartesianSeries) {
	                    each(chart.axes, function(axis) {
	                        if (axis.visible) {
	                            axis.getOffset();
	                        }
	                    });
	                }
	
	                // Add the axis offsets
	                each(marginNames, function(m, side) {
	                    if (!defined(margin[side])) {
	                        chart[m] += axisOffset[side];
	                    }
	                });
	
	                chart.setChartSize();
	
	            },
	
	            /**
	             * Reflows the chart to its container. By default, the chart reflows
	             * automatically to its container following a `window.resize` event, as per
	             * the {@link https://api.highcharts/highcharts/chart.reflow|chart.reflow}
	             * option. However, there are no reliable events for div resize, so if the
	             * container is resized without a window resize event, this must be called
	             * explicitly.
	             *
	             * @param  {Object} e
	             *         Event arguments. Used primarily when the function is called
	             *         internally as a response to window resize.
	             *
	             * @sample highcharts/members/chart-reflow/
	             *         Resize div and reflow
	             * @sample highcharts/chart/events-container/
	             *         Pop up and reflow
	             */
	            reflow: function(e) {
	                var chart = this,
	                    optionsChart = chart.options.chart,
	                    renderTo = chart.renderTo,
	                    hasUserSize = (
	                        defined(optionsChart.width) &&
	                        defined(optionsChart.height)
	                    ),
	                    width = optionsChart.width || getStyle(renderTo, 'width'),
	                    height = optionsChart.height || getStyle(renderTo, 'height'),
	                    target = e ? e.target : win;
	
	                // Width and height checks for display:none. Target is doc in IE8 and
	                // Opera, win in Firefox, Chrome and IE9.
	                if (!hasUserSize &&
	                    !chart.isPrinting &&
	                    width &&
	                    height &&
	                    (target === win || target === doc)
	                ) {
	                    if (
	                        width !== chart.containerWidth ||
	                        height !== chart.containerHeight
	                    ) {
	                        clearTimeout(chart.reflowTimeout);
	                        // When called from window.resize, e is set, else it's called
	                        // directly (#2224)
	                        chart.reflowTimeout = syncTimeout(function() {
	                            // Set size, it may have been destroyed in the meantime
	                            // (#1257)
	                            if (chart.container) {
	                                chart.setSize(undefined, undefined, false);
	                            }
	                        }, e ? 100 : 0);
	                    }
	                    chart.containerWidth = width;
	                    chart.containerHeight = height;
	                }
	            },
	
	            /**
	             * Add the event handlers necessary for auto resizing, depending on the 
	             * `chart.events.reflow` option.
	             *
	             * @private
	             */
	            initReflow: function() {
	                var chart = this,
	                    unbind;
	
	                unbind = addEvent(win, 'resize', function(e) {
	                    chart.reflow(e);
	                });
	                addEvent(chart, 'destroy', unbind);
	
	                // The following will add listeners to re-fit the chart before and after
	                // printing (#2284). However it only works in WebKit. Should have worked
	                // in Firefox, but not supported in IE.
	                /*
	                if (win.matchMedia) {
	                	win.matchMedia('print').addListener(function reflow() {
	                		chart.reflow();
	                	});
	                }
	                */
	            },
	
	            /**
	             * Resize the chart to a given width and height. In order to set the width
	             * only, the height argument may be skipped. To set the height only, pass
	             * `undefined for the width.
	             * @param  {Number|undefined|null} [width]
	             *         The new pixel width of the chart. Since v4.2.6, the argument can
	             *         be `undefined` in order to preserve the current value (when
	             *         setting height only), or `null` to adapt to the width of the
	             *         containing element.
	             * @param  {Number|undefined|null} [height]
	             *         The new pixel height of the chart. Since v4.2.6, the argument can
	             *         be `undefined` in order to preserve the current value, or `null`
	             *         in order to adapt to the height of the containing element.
	             * @param  {AnimationOptions} [animation=true]
	             *         Whether and how to apply animation.
	             *
	             * @sample highcharts/members/chart-setsize-button/
	             *         Test resizing from buttons
	             * @sample highcharts/members/chart-setsize-jquery-resizable/
	             *         Add a jQuery UI resizable
	             * @sample stock/members/chart-setsize/
	             *         Highstock with UI resizable
	             */
	            setSize: function(width, height, animation) {
	                var chart = this,
	                    renderer = chart.renderer,
	                    globalAnimation;
	
	                // Handle the isResizing counter
	                chart.isResizing += 1;
	
	                // set the animation for the current process
	                H.setAnimation(animation, chart);
	
	                chart.oldChartHeight = chart.chartHeight;
	                chart.oldChartWidth = chart.chartWidth;
	                if (width !== undefined) {
	                    chart.options.chart.width = width;
	                }
	                if (height !== undefined) {
	                    chart.options.chart.height = height;
	                }
	                chart.getChartSize();
	
	                // Resize the container with the global animation applied if enabled
	                // (#2503)
	
	                globalAnimation = renderer.globalAnimation;
	                (globalAnimation ? animate : css)(chart.container, {
	                    width: chart.chartWidth + 'px',
	                    height: chart.chartHeight + 'px'
	                }, globalAnimation);
	
	
	                chart.setChartSize(true);
	                renderer.setSize(chart.chartWidth, chart.chartHeight, animation);
	
	                // handle axes
	                each(chart.axes, function(axis) {
	                    axis.isDirty = true;
	                    axis.setScale();
	                });
	
	                chart.isDirtyLegend = true; // force legend redraw
	                chart.isDirtyBox = true; // force redraw of plot and chart border
	
	                chart.layOutTitles(); // #2857
	                chart.getMargins();
	
	                chart.redraw(animation);
	
	
	                chart.oldChartHeight = null;
	                fireEvent(chart, 'resize');
	
	                // Fire endResize and set isResizing back. If animation is disabled,
	                // fire without delay
	                syncTimeout(function() {
	                    if (chart) {
	                        fireEvent(chart, 'endResize', null, function() {
	                            chart.isResizing -= 1;
	                        });
	                    }
	                }, animObject(globalAnimation).duration);
	            },
	
	            /**
	             * Set the public chart properties. This is done before and after the
	             * pre-render to determine margin sizes.
	             *
	             * @private
	             */
	            setChartSize: function(skipAxes) {
	                var chart = this,
	                    inverted = chart.inverted,
	                    renderer = chart.renderer,
	                    chartWidth = chart.chartWidth,
	                    chartHeight = chart.chartHeight,
	                    optionsChart = chart.options.chart,
	                    spacing = chart.spacing,
	                    clipOffset = chart.clipOffset,
	                    clipX,
	                    clipY,
	                    plotLeft,
	                    plotTop,
	                    plotWidth,
	                    plotHeight,
	                    plotBorderWidth;
	
	                function clipOffsetSide(side) {
	                    var offset = clipOffset[side] || 0;
	                    return Math.max(plotBorderWidth || offset, offset) / 2;
	                }
	
	                /**
	                 * The current left position of the plot area in pixels.
	                 *
	                 * @name plotLeft
	                 * @memberOf Chart
	                 * @type {Number}
	                 */
	                chart.plotLeft = plotLeft = Math.round(chart.plotLeft);
	
	                /**
	                 * The current top position of the plot area in pixels.
	                 *
	                 * @name plotTop
	                 * @memberOf Chart
	                 * @type {Number}
	                 */
	                chart.plotTop = plotTop = Math.round(chart.plotTop);
	
	                /**
	                 * The current width of the plot area in pixels.
	                 *
	                 * @name plotWidth
	                 * @memberOf Chart
	                 * @type {Number}
	                 */
	                chart.plotWidth = plotWidth = Math.max(
	                    0,
	                    Math.round(chartWidth - plotLeft - chart.marginRight)
	                );
	
	                /**
	                 * The current height of the plot area in pixels.
	                 *
	                 * @name plotHeight
	                 * @memberOf Chart
	                 * @type {Number}
	                 */
	                chart.plotHeight = plotHeight = Math.max(
	                    0,
	                    Math.round(chartHeight - plotTop - chart.marginBottom)
	                );
	
	                chart.plotSizeX = inverted ? plotHeight : plotWidth;
	                chart.plotSizeY = inverted ? plotWidth : plotHeight;
	
	                chart.plotBorderWidth = optionsChart.plotBorderWidth || 0;
	
	                // Set boxes used for alignment
	                chart.spacingBox = renderer.spacingBox = {
	                    x: spacing[3],
	                    y: spacing[0],
	                    width: chartWidth - spacing[3] - spacing[1],
	                    height: chartHeight - spacing[0] - spacing[2]
	                };
	                chart.plotBox = renderer.plotBox = {
	                    x: plotLeft,
	                    y: plotTop,
	                    width: plotWidth,
	                    height: plotHeight
	                };
	
	                plotBorderWidth = 2 * Math.floor(chart.plotBorderWidth / 2);
	                clipX = Math.ceil(clipOffsetSide(3));
	                clipY = Math.ceil(clipOffsetSide(0));
	                chart.clipBox = {
	                    x: clipX,
	                    y: clipY,
	                    width: Math.floor(
	                        chart.plotSizeX -
	                        clipOffsetSide(1) -
	                        clipX
	                    ),
	                    height: Math.max(
	                        0,
	                        Math.floor(
	                            chart.plotSizeY -
	                            clipOffsetSide(2) -
	                            clipY
	                        )
	                    )
	                };
	
	                if (!skipAxes) {
	                    each(chart.axes, function(axis) {
	                        axis.setAxisSize();
	                        axis.setAxisTranslation();
	                    });
	                }
	            },
	
	            /**
	             * Initial margins before auto size margins are applied.
	             *
	             * @private
	             */
	            resetMargins: function() {
	                var chart = this,
	                    chartOptions = chart.options.chart;
	
	                // Create margin and spacing array
	                each(['margin', 'spacing'], function splashArrays(target) {
	                    var value = chartOptions[target],
	                        values = isObject(value) ? value : [value, value, value, value];
	
	                    each(['Top', 'Right', 'Bottom', 'Left'], function(sideName, side) {
	                        chart[target][side] = pick(
	                            chartOptions[target + sideName],
	                            values[side]
	                        );
	                    });
	                });
	
	                // Set margin names like chart.plotTop, chart.plotLeft,
	                // chart.marginRight, chart.marginBottom.
	                each(marginNames, function(m, side) {
	                    chart[m] = pick(chart.margin[side], chart.spacing[side]);
	                });
	                chart.axisOffset = [0, 0, 0, 0]; // top, right, bottom, left
	                chart.clipOffset = [];
	            },
	
	            /**
	             * Internal function to draw or redraw the borders and backgrounds for chart
	             * and plot area.
	             *
	             * @private
	             */
	            drawChartBox: function() {
	                var chart = this,
	                    optionsChart = chart.options.chart,
	                    renderer = chart.renderer,
	                    chartWidth = chart.chartWidth,
	                    chartHeight = chart.chartHeight,
	                    chartBackground = chart.chartBackground,
	                    plotBackground = chart.plotBackground,
	                    plotBorder = chart.plotBorder,
	                    chartBorderWidth,
	
	                    plotBGImage = chart.plotBGImage,
	                    chartBackgroundColor = optionsChart.backgroundColor,
	                    plotBackgroundColor = optionsChart.plotBackgroundColor,
	                    plotBackgroundImage = optionsChart.plotBackgroundImage,
	
	                    mgn,
	                    bgAttr,
	                    plotLeft = chart.plotLeft,
	                    plotTop = chart.plotTop,
	                    plotWidth = chart.plotWidth,
	                    plotHeight = chart.plotHeight,
	                    plotBox = chart.plotBox,
	                    clipRect = chart.clipRect,
	                    clipBox = chart.clipBox,
	                    verb = 'animate';
	
	                // Chart area
	                if (!chartBackground) {
	                    chart.chartBackground = chartBackground = renderer.rect()
	                        .addClass('highcharts-background')
	                        .add();
	                    verb = 'attr';
	                }
	
	
	                // Presentational
	                chartBorderWidth = optionsChart.borderWidth || 0;
	                mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);
	
	                bgAttr = {
	                    fill: chartBackgroundColor || 'none'
	                };
	
	                if (chartBorderWidth || chartBackground['stroke-width']) { // #980
	                    bgAttr.stroke = optionsChart.borderColor;
	                    bgAttr['stroke-width'] = chartBorderWidth;
	                }
	                chartBackground
	                    .attr(bgAttr)
	                    .shadow(optionsChart.shadow);
	
	                chartBackground[verb]({
	                    x: mgn / 2,
	                    y: mgn / 2,
	                    width: chartWidth - mgn - chartBorderWidth % 2,
	                    height: chartHeight - mgn - chartBorderWidth % 2,
	                    r: optionsChart.borderRadius
	                });
	
	                // Plot background
	                verb = 'animate';
	                if (!plotBackground) {
	                    verb = 'attr';
	                    chart.plotBackground = plotBackground = renderer.rect()
	                        .addClass('highcharts-plot-background')
	                        .add();
	                }
	                plotBackground[verb](plotBox);
	
	
	                // Presentational attributes for the background
	                plotBackground
	                    .attr({
	                        fill: plotBackgroundColor || 'none'
	                    })
	                    .shadow(optionsChart.plotShadow);
	
	                // Create the background image
	                if (plotBackgroundImage) {
	                    if (!plotBGImage) {
	                        chart.plotBGImage = renderer.image(
	                            plotBackgroundImage,
	                            plotLeft,
	                            plotTop,
	                            plotWidth,
	                            plotHeight
	                        ).add();
	                    } else {
	                        plotBGImage.animate(plotBox);
	                    }
	                }
	
	
	                // Plot clip
	                if (!clipRect) {
	                    chart.clipRect = renderer.clipRect(clipBox);
	                } else {
	                    clipRect.animate({
	                        width: clipBox.width,
	                        height: clipBox.height
	                    });
	                }
	
	                // Plot area border
	                verb = 'animate';
	                if (!plotBorder) {
	                    verb = 'attr';
	                    chart.plotBorder = plotBorder = renderer.rect()
	                        .addClass('highcharts-plot-border')
	                        .attr({
	                            zIndex: 1 // Above the grid
	                        })
	                        .add();
	                }
	
	
	                // Presentational
	                plotBorder.attr({
	                    stroke: optionsChart.plotBorderColor,
	                    'stroke-width': optionsChart.plotBorderWidth || 0,
	                    fill: 'none'
	                });
	
	
	                plotBorder[verb](plotBorder.crisp({
	                    x: plotLeft,
	                    y: plotTop,
	                    width: plotWidth,
	                    height: plotHeight
	                }, -plotBorder.strokeWidth())); //#3282 plotBorder should be negative;
	
	                // reset
	                chart.isDirtyBox = false;
	            },
	
	            /**
	             * Detect whether a certain chart property is needed based on inspecting its
	             * options and series. This mainly applies to the chart.inverted property,
	             * and in extensions to the chart.angular and chart.polar properties.
	             *
	             * @private
	             */
	            propFromSeries: function() {
	                var chart = this,
	                    optionsChart = chart.options.chart,
	                    klass,
	                    seriesOptions = chart.options.series,
	                    i,
	                    value;
	
	
	                each(['inverted', 'angular', 'polar'], function(key) {
	
	                    // The default series type's class
	                    klass = seriesTypes[optionsChart.type ||
	                        optionsChart.defaultSeriesType];
	
	                    // Get the value from available chart-wide properties
	                    value =
	                        optionsChart[key] || // It is set in the options
	                        (klass && klass.prototype[key]); // The default series class
	                    // requires it
	
	                    // 4. Check if any the chart's series require it
	                    i = seriesOptions && seriesOptions.length;
	                    while (!value && i--) {
	                        klass = seriesTypes[seriesOptions[i].type];
	                        if (klass && klass.prototype[key]) {
	                            value = true;
	                        }
	                    }
	
	                    // Set the chart property
	                    chart[key] = value;
	                });
	
	            },
	
	            /**
	             * Internal function to link two or more series together, based on the 
	             * `linkedTo` option. This is done from `Chart.render`, and after
	             * `Chart.addSeries` and `Series.remove`.
	             *
	             * @private
	             */
	            linkSeries: function() {
	                var chart = this,
	                    chartSeries = chart.series;
	
	                // Reset links
	                each(chartSeries, function(series) {
	                    series.linkedSeries.length = 0;
	                });
	
	                // Apply new links
	                each(chartSeries, function(series) {
	                    var linkedTo = series.options.linkedTo;
	                    if (isString(linkedTo)) {
	                        if (linkedTo === ':previous') {
	                            linkedTo = chart.series[series.index - 1];
	                        } else {
	                            linkedTo = chart.get(linkedTo);
	                        }
	                        // #3341 avoid mutual linking
	                        if (linkedTo && linkedTo.linkedParent !== series) {
	                            linkedTo.linkedSeries.push(series);
	                            series.linkedParent = linkedTo;
	                            series.visible = pick(
	                                series.options.visible,
	                                linkedTo.options.visible,
	                                series.visible
	                            ); // #3879
	                        }
	                    }
	                });
	            },
	
	            /**
	             * Render series for the chart.
	             *
	             * @private
	             */
	            renderSeries: function() {
	                each(this.series, function(serie) {
	                    serie.translate();
	                    serie.render();
	                });
	            },
	
	            /**
	             * Render labels for the chart.
	             *
	             * @private
	             */
	            renderLabels: function() {
	                var chart = this,
	                    labels = chart.options.labels;
	                if (labels.items) {
	                    each(labels.items, function(label) {
	                        var style = extend(labels.style, label.style),
	                            x = pInt(style.left) + chart.plotLeft,
	                            y = pInt(style.top) + chart.plotTop + 12;
	
	                        // delete to prevent rewriting in IE
	                        delete style.left;
	                        delete style.top;
	
	                        chart.renderer.text(
	                                label.html,
	                                x,
	                                y
	                            )
	                            .attr({
	                                zIndex: 2
	                            })
	                            .css(style)
	                            .add();
	
	                    });
	                }
	            },
	
	            /**
	             * Render all graphics for the chart. Runs internally on initialization.
	             *
	             * @private
	             */
	            render: function() {
	                var chart = this,
	                    axes = chart.axes,
	                    renderer = chart.renderer,
	                    options = chart.options,
	                    tempWidth,
	                    tempHeight,
	                    redoHorizontal,
	                    redoVertical;
	
	                // Title
	                chart.setTitle();
	
	
	                // Legend
	                chart.legend = new Legend(chart, options.legend);
	
	                // Get stacks
	                if (chart.getStacks) {
	                    chart.getStacks();
	                }
	
	                // Get chart margins
	                chart.getMargins(true);
	                chart.setChartSize();
	
	                // Record preliminary dimensions for later comparison
	                tempWidth = chart.plotWidth;
	                tempHeight = chart.plotHeight = chart.plotHeight - 21; // 21 is the most common correction for X axis labels
	
	                // Get margins by pre-rendering axes
	                each(axes, function(axis) {
	                    axis.setScale();
	                });
	                chart.getAxisMargins();
	
	                // If the plot area size has changed significantly, calculate tick positions again
	                redoHorizontal = tempWidth / chart.plotWidth > 1.1;
	                redoVertical = tempHeight / chart.plotHeight > 1.05; // Height is more sensitive
	
	                if (redoHorizontal || redoVertical) {
	
	                    each(axes, function(axis) {
	                        if ((axis.horiz && redoHorizontal) || (!axis.horiz && redoVertical)) {
	                            axis.setTickInterval(true); // update to reflect the new margins
	                        }
	                    });
	                    chart.getMargins(); // second pass to check for new labels
	                }
	
	                // Draw the borders and backgrounds
	                chart.drawChartBox();
	
	
	                // Axes
	                if (chart.hasCartesianSeries) {
	                    each(axes, function(axis) {
	                        if (axis.visible) {
	                            axis.render();
	                        }
	                    });
	                }
	
	                // The series
	                if (!chart.seriesGroup) {
	                    chart.seriesGroup = renderer.g('series-group')
	                        .attr({
	                            zIndex: 3
	                        })
	                        .add();
	                }
	                chart.renderSeries();
	
	                // Labels
	                chart.renderLabels();
	
	                // Credits
	                chart.addCredits();
	
	                // Handle responsiveness
	                if (chart.setResponsive) {
	                    chart.setResponsive();
	                }
	
	                // Set flag
	                chart.hasRendered = true;
	
	            },
	
	            /**
	             * Set a new credits label for the chart.
	             *
	             * @param  {CreditOptions} options
	             *         A configuration object for the new credits.
	             * @sample highcharts/credits/credits-update/ Add and update credits
	             */
	            addCredits: function(credits) {
	                var chart = this;
	
	                credits = merge(true, this.options.credits, credits);
	                if (credits.enabled && !this.credits) {
	
	                    /**
	                     * The chart's credits label. The label has an `update` method that
	                     * allows setting new options as per the {@link
	                     * https://api.highcharts.com/highcharts/credits|
	                     * credits options set}.
	                     *
	                     * @memberof Highcharts.Chart
	                     * @name credits
	                     * @type {Highcharts.SVGElement}
	                     */
	                    this.credits = this.renderer.text(
	                            credits.text + (this.mapCredits || ''),
	                            0,
	                            0
	                        )
	                        .addClass('highcharts-credits')
	                        .on('click', function() {
	                            if (credits.href) {
	                                win.location.href = credits.href;
	                            }
	                        })
	                        .attr({
	                            align: credits.position.align,
	                            zIndex: 8
	                        })
	
	                        .css(credits.style)
	
	                        .add()
	                        .align(credits.position);
	
	                    // Dynamically update
	                    this.credits.update = function(options) {
	                        chart.credits = chart.credits.destroy();
	                        chart.addCredits(options);
	                    };
	                }
	            },
	
	            /**
	             * Remove the chart and purge memory. This method is called internally
	             * before adding a second chart into the same container, as well as on
	             * window unload to prevent leaks.
	             *
	             * @sample highcharts/members/chart-destroy/
	             *         Destroy the chart from a button
	             * @sample stock/members/chart-destroy/
	             *         Destroy with Highstock
	             */
	            destroy: function() {
	                var chart = this,
	                    axes = chart.axes,
	                    series = chart.series,
	                    container = chart.container,
	                    i,
	                    parentNode = container && container.parentNode;
	
	                // fire the chart.destoy event
	                fireEvent(chart, 'destroy');
	
	                // Delete the chart from charts lookup array
	                if (chart.renderer.forExport) {
	                    H.erase(charts, chart); // #6569
	                } else {
	                    charts[chart.index] = undefined;
	                }
	                H.chartCount--;
	                chart.renderTo.removeAttribute('data-highcharts-chart');
	
	                // remove events
	                removeEvent(chart);
	
	                // ==== Destroy collections:
	                // Destroy axes
	                i = axes.length;
	                while (i--) {
	                    axes[i] = axes[i].destroy();
	                }
	
	                // Destroy scroller & scroller series before destroying base series
	                if (this.scroller && this.scroller.destroy) {
	                    this.scroller.destroy();
	                }
	
	                // Destroy each series
	                i = series.length;
	                while (i--) {
	                    series[i] = series[i].destroy();
	                }
	
	                // ==== Destroy chart properties:
	                each([
	                    'title', 'subtitle', 'chartBackground', 'plotBackground',
	                    'plotBGImage', 'plotBorder', 'seriesGroup', 'clipRect', 'credits',
	                    'pointer', 'rangeSelector', 'legend', 'resetZoomButton', 'tooltip',
	                    'renderer'
	                ], function(name) {
	                    var prop = chart[name];
	
	                    if (prop && prop.destroy) {
	                        chart[name] = prop.destroy();
	                    }
	                });
	
	                // remove container and all SVG
	                if (container) { // can break in IE when destroyed before finished loading
	                    container.innerHTML = '';
	                    removeEvent(container);
	                    if (parentNode) {
	                        discardElement(container);
	                    }
	
	                }
	
	                // clean it all up
	                objectEach(chart, function(val, key) {
	                    delete chart[key];
	                });
	
	            },
	
	
	            /**
	             * VML namespaces can't be added until after complete. Listening
	             * for Perini's doScroll hack is not enough.
	             *
	             * @private
	             */
	            isReadyToRender: function() {
	                var chart = this;
	
	                // Note: win == win.top is required
	                if ((!svg && (win == win.top && doc.readyState !== 'complete'))) { // eslint-disable-line eqeqeq
	                    doc.attachEvent('onreadystatechange', function() {
	                        doc.detachEvent('onreadystatechange', chart.firstRender);
	                        if (doc.readyState === 'complete') {
	                            chart.firstRender();
	                        }
	                    });
	                    return false;
	                }
	                return true;
	            },
	
	            /**
	             * Prepare for first rendering after all data are loaded.
	             *
	             * @private
	             */
	            firstRender: function() {
	                var chart = this,
	                    options = chart.options;
	
	                // Check whether the chart is ready to render
	                if (!chart.isReadyToRender()) {
	                    return;
	                }
	
	                // Create the container
	                chart.getContainer();
	
	                // Run an early event after the container and renderer are established
	                fireEvent(chart, 'init');
	
	
	                chart.resetMargins();
	                chart.setChartSize();
	
	                // Set the common chart properties (mainly invert) from the given series
	                chart.propFromSeries();
	
	                // get axes
	                chart.getAxes();
	
	                // Initialize the series
	                each(options.series || [], function(serieOptions) {
	                    chart.initSeries(serieOptions);
	                });
	
	                chart.linkSeries();
	
	                // Run an event after axes and series are initialized, but before render. At this stage,
	                // the series data is indexed and cached in the xData and yData arrays, so we can access
	                // those before rendering. Used in Highstock.
	                fireEvent(chart, 'beforeRender');
	
	                // depends on inverted and on margins being set
	                if (Pointer) {
	
	                    /**
	                     * The Pointer that keeps track of mouse and touch interaction.
	                     *
	                     * @memberof Chart
	                     * @name pointer
	                     * @type Pointer
	                     */
	                    chart.pointer = new Pointer(chart, options);
	                }
	
	                chart.render();
	
	                // Fire the load event if there are no external images
	                if (!chart.renderer.imgCount && chart.onload) {
	                    chart.onload();
	                }
	
	                // If the chart was rendered outside the top container, put it back in (#3679)
	                chart.temporaryDisplay(true);
	
	            },
	
	            /** 
	             * Internal function that runs on chart load, async if any images are loaded
	             * in the chart. Runs the callbacks and triggers the `load` and `render`
	             * events.
	             *
	             * @private
	             */
	            onload: function() {
	
	                // Run callbacks
	                each([this.callback].concat(this.callbacks), function(fn) {
	                    if (fn && this.index !== undefined) { // Chart destroyed in its own callback (#3600)
	                        fn.apply(this, [this]);
	                    }
	                }, this);
	
	                fireEvent(this, 'load');
	                fireEvent(this, 'render');
	
	
	                // Set up auto resize, check for not destroyed (#6068)
	                if (defined(this.index) && this.options.chart.reflow !== false) {
	                    this.initReflow();
	                }
	
	                // Don't run again
	                this.onload = null;
	            }
	
	        }); // end Chart
	
	    }(Highcharts));
	    (function(Highcharts) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var Point,
	            H = Highcharts,
	
	            each = H.each,
	            extend = H.extend,
	            erase = H.erase,
	            fireEvent = H.fireEvent,
	            format = H.format,
	            isArray = H.isArray,
	            isNumber = H.isNumber,
	            pick = H.pick,
	            removeEvent = H.removeEvent;
	
	        /**
	         * The Point object. The point objects are generated from the `series.data` 
	         * configuration objects or raw numbers. They can be accessed from the
	         * `Series.points` array. Other ways to instaniate points are through {@link
	         * Highcharts.Series#addPoint} or {@link Highcharts.Series#setData}.
	         *
	         * @class
	         */
	
	        Highcharts.Point = Point = function() {};
	        Highcharts.Point.prototype = {
	
	            /**
	             * Initialize the point. Called internally based on the `series.data`
	             * option.
	             * @param  {Series} series
	             *         The series object containing this point.
	             * @param  {Number|Array|Object} options
	             *         The data in either number, array or object format.
	             * @param  {Number} x Optionally, the X value of the point.
	             * @return {Point} The Point instance.
	             */
	            init: function(series, options, x) {
	
	                var point = this,
	                    colors,
	                    colorCount = series.chart.options.chart.colorCount,
	                    colorIndex;
	
	                /**
	                 * The series object associated with the point.
	                 *
	                 * @name series
	                 * @memberof Highcharts.Point
	                 * @type Highcharts.Series
	                 */
	                point.series = series;
	
	
	                /**
	                 * The point's current color.
	                 * @name color
	                 * @memberof Highcharts.Point
	                 * @type {Color}
	                 */
	                point.color = series.color; // #3445
	
	                point.applyOptions(options, x);
	
	                if (series.options.colorByPoint) {
	
	                    colors = series.options.colors || series.chart.options.colors;
	                    point.color = point.color || colors[series.colorCounter];
	                    colorCount = colors.length;
	
	                    colorIndex = series.colorCounter;
	                    series.colorCounter++;
	                    // loop back to zero
	                    if (series.colorCounter === colorCount) {
	                        series.colorCounter = 0;
	                    }
	                } else {
	                    colorIndex = series.colorIndex;
	                }
	                point.colorIndex = pick(point.colorIndex, colorIndex);
	
	                series.chart.pointCount++;
	                return point;
	            },
	            /**
	             * Apply the options containing the x and y data and possible some extra
	             * properties. Called on point init or from point.update.
	             *
	             * @private
	             * @param {Object} options The point options as defined in series.data.
	             * @param {Number} x Optionally, the X value.
	             * @returns {Object} The Point instance.
	             */
	            applyOptions: function(options, x) {
	                var point = this,
	                    series = point.series,
	                    pointValKey = series.options.pointValKey || series.pointValKey;
	
	                options = Point.prototype.optionsToObject.call(this, options);
	
	                // copy options directly to point
	                extend(point, options);
	                point.options = point.options ? extend(point.options, options) : options;
	
	                // Since options are copied into the Point instance, some accidental options must be shielded (#5681)
	                if (options.group) {
	                    delete point.group;
	                }
	
	                // For higher dimension series types. For instance, for ranges, point.y is mapped to point.low.
	                if (pointValKey) {
	                    point.y = point[pointValKey];
	                }
	                point.isNull = pick(
	                    point.isValid && !point.isValid(),
	                    point.x === null || !isNumber(point.y, true)
	                ); // #3571, check for NaN
	
	                // The point is initially selected by options (#5777)
	                if (point.selected) {
	                    point.state = 'select';
	                }
	
	                // If no x is set by now, get auto incremented value. All points must have an
	                // x value, however the y value can be null to create a gap in the series
	                if ('name' in point && x === undefined && series.xAxis && series.xAxis.hasNames) {
	                    point.x = series.xAxis.nameToX(point);
	                }
	                if (point.x === undefined && series) {
	                    if (x === undefined) {
	                        point.x = series.autoIncrement(point);
	                    } else {
	                        point.x = x;
	                    }
	                }
	
	                return point;
	            },
	
	            /**
	             * Transform number or array configs into objects. Used internally to unify
	             * the different configuration formats for points. For example, a simple
	             * number `10` in a line series will be transformed to `{ y: 10 }`, and an
	             * array config like `[1, 10]` in a scatter series will be transformed to
	             * `{ x: 1, y: 10 }`.
	             *
	             * @param  {Number|Array|Object} options
	             *         The input options
	             * @return {Object} Transformed options.
	             */
	            optionsToObject: function(options) {
	                var ret = {},
	                    series = this.series,
	                    keys = series.options.keys,
	                    pointArrayMap = keys || series.pointArrayMap || ['y'],
	                    valueCount = pointArrayMap.length,
	                    firstItemType,
	                    i = 0,
	                    j = 0;
	
	                if (isNumber(options) || options === null) {
	                    ret[pointArrayMap[0]] = options;
	
	                } else if (isArray(options)) {
	                    // with leading x value
	                    if (!keys && options.length > valueCount) {
	                        firstItemType = typeof options[0];
	                        if (firstItemType === 'string') {
	                            ret.name = options[0];
	                        } else if (firstItemType === 'number') {
	                            ret.x = options[0];
	                        }
	                        i++;
	                    }
	                    while (j < valueCount) {
	                        if (!keys || options[i] !== undefined) { // Skip undefined positions for keys
	                            ret[pointArrayMap[j]] = options[i];
	                        }
	                        i++;
	                        j++;
	                    }
	                } else if (typeof options === 'object') {
	                    ret = options;
	
	                    // This is the fastest way to detect if there are individual point dataLabels that need
	                    // to be considered in drawDataLabels. These can only occur in object configs.
	                    if (options.dataLabels) {
	                        series._hasPointLabels = true;
	                    }
	
	                    // Same approach as above for markers
	                    if (options.marker) {
	                        series._hasPointMarkers = true;
	                    }
	                }
	                return ret;
	            },
	
	            /**
	             * Get the CSS class names for individual points. Used internally where the
	             * returned value is set on every point.
	             * 
	             * @returns {String} The class names.
	             */
	            getClassName: function() {
	                return 'highcharts-point' +
	                    (this.selected ? ' highcharts-point-select' : '') +
	                    (this.negative ? ' highcharts-negative' : '') +
	                    (this.isNull ? ' highcharts-null-point' : '') +
	                    (this.colorIndex !== undefined ? ' highcharts-color-' +
	                        this.colorIndex : '') +
	                    (this.options.className ? ' ' + this.options.className : '') +
	                    (this.zone && this.zone.className ? ' ' +
	                        this.zone.className.replace('highcharts-negative', '') : '');
	            },
	
	            /**
	             * In a series with `zones`, return the zone that the point belongs to.
	             *
	             * @return {Object}
	             *         The zone item.
	             */
	            getZone: function() {
	                var series = this.series,
	                    zones = series.zones,
	                    zoneAxis = series.zoneAxis || 'y',
	                    i = 0,
	                    zone;
	
	                zone = zones[i];
	                while (this[zoneAxis] >= zone.value) {
	                    zone = zones[++i];
	                }
	
	                if (zone && zone.color && !this.options.color) {
	                    this.color = zone.color;
	                }
	
	                return zone;
	            },
	
	            /**
	             * Destroy a point to clear memory. Its reference still stays in
	             * `series.data`.
	             *
	             * @private
	             */
	            destroy: function() {
	                var point = this,
	                    series = point.series,
	                    chart = series.chart,
	                    hoverPoints = chart.hoverPoints,
	                    prop;
	
	                chart.pointCount--;
	
	                if (hoverPoints) {
	                    point.setState();
	                    erase(hoverPoints, point);
	                    if (!hoverPoints.length) {
	                        chart.hoverPoints = null;
	                    }
	
	                }
	                if (point === chart.hoverPoint) {
	                    point.onMouseOut();
	                }
	
	                // remove all events
	                if (point.graphic || point.dataLabel) { // removeEvent and destroyElements are performance expensive
	                    removeEvent(point);
	                    point.destroyElements();
	                }
	
	                if (point.legendItem) { // pies have legend items
	                    chart.legend.destroyItem(point);
	                }
	
	                for (prop in point) {
	                    point[prop] = null;
	                }
	
	
	            },
	
	            /**
	             * Destroy SVG elements associated with the point.
	             *
	             * @private
	             */
	            destroyElements: function() {
	                var point = this,
	                    props = ['graphic', 'dataLabel', 'dataLabelUpper', 'connector', 'shadowGroup'],
	                    prop,
	                    i = 6;
	                while (i--) {
	                    prop = props[i];
	                    if (point[prop]) {
	                        point[prop] = point[prop].destroy();
	                    }
	                }
	            },
	
	            /**
	             * Return the configuration hash needed for the data label and tooltip
	             * formatters.
	             *
	             * @returns {Object}
	             *          Abstract object used in formatters and formats.
	             */
	            getLabelConfig: function() {
	                return {
	                    x: this.category,
	                    y: this.y,
	                    color: this.color,
	                    colorIndex: this.colorIndex,
	                    key: this.name || this.category,
	                    series: this.series,
	                    point: this,
	                    percentage: this.percentage,
	                    total: this.total || this.stackTotal
	                };
	            },
	
	            /**
	             * Extendable method for formatting each point's tooltip line.
	             *
	             * @param  {String} pointFormat
	             *         The point format.
	             * @return {String}
	             *         A string to be concatenated in to the common tooltip text.
	             */
	            tooltipFormatter: function(pointFormat) {
	
	                // Insert options for valueDecimals, valuePrefix, and valueSuffix
	                var series = this.series,
	                    seriesTooltipOptions = series.tooltipOptions,
	                    valueDecimals = pick(seriesTooltipOptions.valueDecimals, ''),
	                    valuePrefix = seriesTooltipOptions.valuePrefix || '',
	                    valueSuffix = seriesTooltipOptions.valueSuffix || '';
	
	                // Loop over the point array map and replace unformatted values with sprintf formatting markup
	                each(series.pointArrayMap || ['y'], function(key) {
	                    key = '{point.' + key; // without the closing bracket
	                    if (valuePrefix || valueSuffix) {
	                        pointFormat = pointFormat.replace(key + '}', valuePrefix + key + '}' + valueSuffix);
	                    }
	                    pointFormat = pointFormat.replace(key + '}', key + ':,.' + valueDecimals + 'f}');
	                });
	
	                return format(pointFormat, {
	                    point: this,
	                    series: this.series
	                });
	            },
	
	            /**
	             * Fire an event on the Point object.
	             *
	             * @private
	             * @param {String} eventType
	             * @param {Object} eventArgs Additional event arguments
	             * @param {Function} defaultFunction Default event handler
	             */
	            firePointEvent: function(eventType, eventArgs, defaultFunction) {
	                var point = this,
	                    series = this.series,
	                    seriesOptions = series.options;
	
	                // load event handlers on demand to save time on mouseover/out
	                if (seriesOptions.point.events[eventType] || (point.options && point.options.events && point.options.events[eventType])) {
	                    this.importEvents();
	                }
	
	                // add default handler if in selection mode
	                if (eventType === 'click' && seriesOptions.allowPointSelect) {
	                    defaultFunction = function(event) {
	                        // Control key is for Windows, meta (= Cmd key) for Mac, Shift for Opera
	                        if (point.select) { // Could be destroyed by prior event handlers (#2911)
	                            point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);
	                        }
	                    };
	                }
	
	                fireEvent(this, eventType, eventArgs, defaultFunction);
	            },
	
	            /**
	             * For certain series types, like pie charts, where individual points can
	             * be shown or hidden. 
	             *
	             * @name visible
	             * @memberOf Highcharts.Point
	             * @type {Boolean}
	             */
	            visible: true
	        };
	
	        /**
	         * For categorized axes this property holds the category name for the 
	         * point. For other axes it holds the X value.
	         *
	         * @name category
	         * @memberOf Highcharts.Point
	         * @type {String|Number}
	         */
	
	        /**
	         * The percentage for points in a stacked series or pies.
	         *
	         * @name percentage
	         * @memberOf Highcharts.Point
	         * @type {Number}
	         */
	
	        /**
	         * The total of values in either a stack for stacked series, or a pie in a pie
	         * series.
	         *
	         * @name total
	         * @memberOf Highcharts.Point
	         * @type {Number}
	         */
	
	        /**
	         * The x value of the point.
	         *
	         * @name x
	         * @memberOf Highcharts.Point
	         * @type {Number}
	         */
	
	        /**
	         * The y value of the point.
	         *
	         * @name y
	         * @memberOf Highcharts.Point
	         * @type {Number}
	         */
	
	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var addEvent = H.addEvent,
	            animObject = H.animObject,
	            arrayMax = H.arrayMax,
	            arrayMin = H.arrayMin,
	            correctFloat = H.correctFloat,
	            Date = H.Date,
	            defaultOptions = H.defaultOptions,
	            defaultPlotOptions = H.defaultPlotOptions,
	            defined = H.defined,
	            each = H.each,
	            erase = H.erase,
	            extend = H.extend,
	            fireEvent = H.fireEvent,
	            grep = H.grep,
	            isArray = H.isArray,
	            isNumber = H.isNumber,
	            isString = H.isString,
	            LegendSymbolMixin = H.LegendSymbolMixin, // @todo add as a requirement
	            merge = H.merge,
	            objectEach = H.objectEach,
	            pick = H.pick,
	            Point = H.Point, // @todo  add as a requirement
	            removeEvent = H.removeEvent,
	            splat = H.splat,
	            SVGElement = H.SVGElement,
	            syncTimeout = H.syncTimeout,
	            win = H.win;
	
	        /**
	         * This is the base series prototype that all other series types inherit from.
	         * A new series is initialized either through the {@link https://api.highcharts.com/highcharts/series|
	         * series} option structure, or after the chart is initialized, through {@link
	         * Highcharts.Chart#addSeries}.
	         *
	         * The object can be accessed in a number of ways. All series and point event
	         * handlers give a reference to the `series` object. The chart object has a
	         * {@link Highcharts.Chart.series|series} property that is a collection of all
	         * the chart's series. The point objects and axis objects also have the same
	         * reference.
	         *
	         * Another way to reference the series programmatically is by `id`. Add an id
	         * in the series configuration options, and get the series object by {@link
	         * Highcharts.Chart#get}.
	         *
	         * Configuration options for the series are given in three levels. Options for
	         * all series in a chart are given in the {@link https://api.highcharts.com/highcharts/plotOptions.series|
	         * plotOptions.series} object. Then options for all series of a specific type
	         * are given in the plotOptions of that type, for example `plotOptions.line`.
	         * Next, options for one single series are given in the series array, or as
	         * arguements to `chart.addSeries`.
	         *
	         * The data in the series is stored in various arrays.
	         *
	         * - First, `series.options.data` contains all the original config options for
	         * each point whether added by options or methods like `series.addPoint`.
	         * - Next, `series.data` contains those values converted to points, but in case
	         * the series data length exceeds the `cropThreshold`, or if the data is grouped,
	         * `series.data` doesn't contain all the points. It only contains the points that
	         * have been created on demand.
	         * - Then there's `series.points` that contains all currently visible point
	         * objects. In case of cropping, the cropped-away points are not part of this
	         * array. The `series.points` array starts at `series.cropStart` compared to
	         * `series.data` and `series.options.data`. If however the series data is grouped,
	         * these can't be correlated one to one.
	         * - `series.xData` and `series.processedXData` contain clean x values, equivalent
	         * to `series.data` and `series.points`.
	         * - `series.yData` and `series.processedYData` contain clean y values, equivalent
	         * to `series.data` and `series.points`.
	         *
	         * @class Highcharts.Series
	         * @param  {Highcharts.Chart} chart
	         *         The chart instance.
	         * @param  {Options.plotOptions.series} options
	         *         The series options.
	         *
	         */
	
	        /**
	         * General options for all series types.
	         * @optionparent plotOptions.series
	         */
	        H.Series = H.seriesType('line', null, { // base series options
	
	            //cursor: 'default',
	            //dashStyle: null,
	            //linecap: 'round',
	
	
	
	            /**
	             * Pixel with of the graph line.
	             * 
	             * @type {Number}
	             * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	             * style/style-by-css), the line stroke-width can be set with the
	             * `.highcharts-graph` class name.
	             * @sample {highcharts} highcharts/plotoptions/series-linewidth-general/ On all series
	             * @sample {highcharts} highcharts/plotoptions/series-linewidth-specific/ On one single series
	             * @default 2
	             * @product highcharts highstock
	             */
	            lineWidth: 2,
	            //shadow: false,
	
	
	            /**
	             * For some series, there is a limit that shuts down initial animation
	             * by default when the total number of points in the chart is too high.
	             * For example, for a column chart and its derivatives, animation doesn't
	             * run if there is more than 250 points totally. To disable this cap, set
	             * `animationLimit` to `Infinity`.
	             * 
	             * @type {Number}
	             * @apioption plotOptions.series.animationLimit
	             */
	
	            /**
	             * Allow this series' points to be selected by clicking on the graphic 
	             * (columns, point markers, pie slices, map areas etc).
	             *
	             * @see [Chart#getSelectedPoints](../class-reference/Highcharts.Chart#getSelectedPoints).
	             * 
	             * @type {Boolean}
	             * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-line/
	             *         Line
	             * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-column/
	             *         Column
	             * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-pie/
	             *         Pie
	             * @sample {highmaps} maps/plotoptions/series-allowpointselect/
	             *         Map area
	             * @sample {highmaps} maps/plotoptions/mapbubble-allowpointselect/
	             *         Map bubble
	             * @default false
	             * @since 1.2.0
	             * @product highcharts highstock highmaps
	             */
	            allowPointSelect: false,
	
	
	
	            /**
	             * If true, a checkbox is displayed next to the legend item to allow
	             * selecting the series. The state of the checkbox is determined by
	             * the `selected` option.
	             *
	             * @productdesc {highmaps}
	             * Note that if a `colorAxis` is defined, the color axis is represented in
	             * the legend, not the series.
	             * 
	             * @type {Boolean}
	             * @sample {highcharts} highcharts/plotoptions/series-showcheckbox-true/
	             *         Show select box
	             * @default false
	             * @since 1.2.0
	             */
	            showCheckbox: false,
	
	
	
	            /**
	             * Enable or disable the initial animation when a series is displayed.
	             * The animation can also be set as a configuration object. Please
	             * note that this option only applies to the initial animation of the
	             * series itself. For other animations, see [chart.animation](#chart.
	             * animation) and the animation parameter under the API methods. The
	             * following properties are supported:
	             * 
	             * <dl>
	             * 
	             * <dt>duration</dt>
	             * 
	             * <dd>The duration of the animation in milliseconds.</dd>
	             * 
	             * <dt>easing</dt>
	             * 
	             * <dd>A string reference to an easing function set on the `Math` object.
	             * See [the easing demo](http://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/plotoptions/series-
	             * animation-easing/).</dd>
	             * 
	             * </dl>
	             * 
	             * Due to poor performance, animation is disabled in old IE browsers
	             * for several chart types.
	             * 
	             * @type {Boolean}
	             * @sample {highcharts} highcharts/plotoptions/series-animation-disabled/
	             *         Animation disabled
	             * @sample {highcharts} highcharts/plotoptions/series-animation-slower/
	             *         Slower animation
	             * @sample {highcharts} highcharts/plotoptions/series-animation-easing/
	             *         Custom easing function
	             * @sample {highstock} stock/plotoptions/animation-slower/
	             *         Slower animation
	             * @sample {highstock} stock/plotoptions/animation-easing/
	             *         Custom easing function
	             * @sample {highmaps} maps/plotoptions/series-animation-true/
	             *         Animation enabled on map series
	             * @sample {highmaps} maps/plotoptions/mapbubble-animation-false/
	             *         Disabled on mapbubble series
	             * @default {highcharts} true
	             * @default {highstock} true
	             * @default {highmaps} false
	             */
	            animation: {
	
	
	                /**
	                 */
	                duration: 1000
	            },
	
	            /**
	             * A class name to apply to the series' graphical elements.
	             * 
	             * @type {String}
	             * @since 5.0.0
	             * @apioption plotOptions.series.className
	             */
	
	            /**
	             * The main color of the series. In line type series it applies to the
	             * line and the point markers unless otherwise specified. In bar type
	             * series it applies to the bars unless a color is specified per point.
	             * The default value is pulled from the `options.colors` array.
	             * 
	             * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	             * style/style-by-css), the color can be defined by the [colorIndex](#plotOptions.
	             * series.colorIndex) option. Also, the series color can be set with
	             * the `.highcharts-series`, `.highcharts-color-{n}`, `.highcharts-{type}-
	             * series` or `.highcharts-series-{n}` class, or individual classes
	             * given by the `className` option.
	             *
	             * @productdesc {highmaps}
	             * In maps, the series color is rarely used, as most choropleth maps use the
	             * color to denote the value of each point. The series color can however be
	             * used in a map with multiple series holding categorized data.
	             * 
	             * @type {Color}
	             * @sample {highcharts} highcharts/plotoptions/series-color-general/
	             *         General plot option
	             * @sample {highcharts} highcharts/plotoptions/series-color-specific/
	             *         One specific series
	             * @sample {highcharts} highcharts/plotoptions/series-color-area/
	             *         Area color
	             * @sample {highmaps} maps/demo/category-map/
	             *         Category map by multiple series
	             * @apioption plotOptions.series.color
	             */
	
	            /**
	             * [Styled mode](http://www.highcharts.com/docs/chart-design-and-style/style-
	             * by-css) only. A specific color index to use for the series, so its
	             * graphic representations are given the class name `highcharts-color-
	             * {n}`.
	             * 
	             * @type {Number}
	             * @since 5.0.0
	             * @apioption plotOptions.series.colorIndex
	             */
	
	
	            /**
	             * Whether to connect a graph line across null points, or render a gap
	             * between the two points on either side of the null.
	             * 
	             * @type {Boolean}
	             * @sample {highcharts} highcharts/plotoptions/series-connectnulls-false/
	             *         False by default
	             * @sample {highcharts} highcharts/plotoptions/series-connectnulls-true/
	             *         True
	             * @product highcharts highstock
	             * @apioption plotOptions.series.connectNulls
	             */
	
	
	            /**
	             * You can set the cursor to "pointer" if you have click events attached
	             * to the series, to signal to the user that the points and lines can
	             * be clicked.
	             * 
	             * @validvalue [null, "default", "none", "help", "pointer", "crosshair"]
	             * @type {String}
	             * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	             * style/style-by-css), the series cursor can be set with the same classes
	             * as listed under [series.color](#plotOptions.series.color).
	             * @sample {highcharts} highcharts/plotoptions/series-cursor-line/
	             *         On line graph
	             * @sample {highcharts} highcharts/plotoptions/series-cursor-column/
	             *         On columns
	             * @sample {highcharts} highcharts/plotoptions/series-cursor-scatter/
	             *         On scatter markers
	             * @sample {highstock} stock/plotoptions/cursor/
	             *         Pointer on a line graph
	             * @sample {highmaps} maps/plotoptions/series-allowpointselect/
	             *         Map area
	             * @sample {highmaps} maps/plotoptions/mapbubble-allowpointselect/
	             *         Map bubble
	             * @apioption plotOptions.series.cursor
	             */
	
	
	            /**
	             * A name for the dash style to use for the graph, or for some series types
	             * the outline of each shape. The value for the `dashStyle` include:
	             * 
	             * *   Solid
	             * *   ShortDash
	             * *   ShortDot
	             * *   ShortDashDot
	             * *   ShortDashDotDot
	             * *   Dot
	             * *   Dash
	             * *   LongDash
	             * *   DashDot
	             * *   LongDashDot
	             * *   LongDashDotDot
	             * 
	             * @validvalue ["Solid", "ShortDash", "ShortDot", "ShortDashDot",
	             *             "ShortDashDotDot", "Dot", "Dash" ,"LongDash", "DashDot",
	             *             "LongDashDot", "LongDashDotDot"]
	             * @type {String}
	             * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	             * style/style-by-css), the [stroke dash-array](http://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/series-
	             * dashstyle/) can be set with the same classes as listed under [series.
	             * color](#plotOptions.series.color).
	             * @sample {highcharts} highcharts/plotoptions/series-dashstyle-all/
	             *         Possible values demonstrated
	             * @sample {highcharts} highcharts/plotoptions/series-dashstyle/
	             *         Chart suitable for printing in black and white
	             * @sample {highstock} highcharts/plotoptions/series-dashstyle-all/
	             *         Possible values demonstrated
	             * @sample {highmaps} highcharts/plotoptions/series-dashstyle-all/
	             *         Possible values demonstrated
	             * @sample {highmaps} maps/plotoptions/series-dashstyle/
	             *         Dotted borders on a map
	             * @default Solid
	             * @since 2.1
	             * @apioption plotOptions.series.dashStyle
	             */
	
	            /**
	             * Requires the Accessibility module.
	             * 
	             * A description of the series to add to the screen reader information
	             * about the series.
	             * 
	             * @type {String}
	             * @default undefined
	             * @since 5.0.0
	             * @apioption plotOptions.series.description
	             */
	
	
	
	
	
	            /**
	             * Enable or disable the mouse tracking for a specific series. This
	             * includes point tooltips and click events on graphs and points. For
	             * large datasets it improves performance.
	             * 
	             * @type {Boolean}
	             * @sample {highcharts} highcharts/plotoptions/series-enablemousetracking-false/ No mouse tracking
	             * @sample {highmaps} maps/plotoptions/series-enablemousetracking-false/ No mouse tracking
	             * @default true
	             * @apioption plotOptions.series.enableMouseTracking
	             */
	
	            /**
	             * By default, series are exposed to screen readers as regions. By enabling
	             * this option, the series element itself will be exposed in the same
	             * way as the data points. This is useful if the series is not used
	             * as a grouping entity in the chart, but you still want to attach a
	             * description to the series.
	             * 
	             * Requires the Accessibility module.
	             * 
	             * @type {Boolean}
	             * @sample {highcharts} highcharts/accessibility/art-grants/ Accessible data visualization
	             * @sample {highstock} highcharts/accessibility/art-grants/ Accessible data visualization
	             * @sample {highmaps} highcharts/accessibility/art-grants/ Accessible data visualization
	             * @default undefined
	             * @since 5.0.12
	             * @apioption plotOptions.series.exposeElementToA11y
	             */
	
	            /**
	             * Whether to use the Y extremes of the total chart width or only the
	             * zoomed area when zooming in on parts of the X axis. By default, the
	             * Y axis adjusts to the min and max of the visible data. Cartesian
	             * series only.
	             * 
	             * @type {Boolean}
	             * @default false
	             * @since 4.1.6
	             * @product highcharts highstock
	             * @apioption plotOptions.series.getExtremesFromAll
	             */
	
	            /**
	             * An array specifying which option maps to which key in the data point
	             * array. This makes it convenient to work with unstructured data arrays
	             * from different sources.
	             * 
	             * @type {Array<String>}
	             * @see [series.data](#series<line>.data)
	             * @sample {highcharts} highcharts/series/data-keys/ An extended data array with keys
	             * @sample {highstock} highcharts/series/data-keys/ An extended data array with keys
	             * @since 4.1.6
	             * @product highcharts highstock
	             * @apioption plotOptions.series.keys
	             */
	
	            /**
	             * The line cap used for line ends and line joins on the graph.
	             * 
	             * @validvalue ["round", "square"]
	             * @type {String}
	             * @default round
	             * @product highcharts highstock
	             * @apioption plotOptions.series.linecap
	             */
	
	            /**
	             * The [id](#series.id) of another series to link to. Additionally,
	             * the value can be ":previous" to link to the previous series. When
	             * two series are linked, only the first one appears in the legend.
	             * Toggling the visibility of this also toggles the linked series.
	             * 
	             * @type {String}
	             * @sample {highcharts} highcharts/demo/arearange-line/ Linked series
	             * @sample {highstock} highcharts/demo/arearange-line/ Linked series
	             * @since 3.0
	             * @product highcharts highstock
	             * @apioption plotOptions.series.linkedTo
	             */
	
	            /**
	             * The color for the parts of the graph or points that are below the
	             * [threshold](#plotOptions.series.threshold).
	             * 
	             * @type {Color}
	             * @see In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	             * style/style-by-css), a negative color is applied by setting this
	             * option to `true` combined with the `.highcharts-negative` class name
	             * ([view live demo](http://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/series-
	             * negative-color/)).
	             * @sample {highcharts} highcharts/plotoptions/series-negative-color/ Spline, area and column
	             * @sample {highcharts} highcharts/plotoptions/arearange-negativecolor/ Arearange
	             * @sample {highstock} highcharts/plotoptions/series-negative-color/ Spline, area and column
	             * @sample {highstock} highcharts/plotoptions/arearange-negativecolor/ Arearange
	             * @sample {highmaps} highcharts/plotoptions/series-negative-color/ Spline, area and column
	             * @sample {highmaps} highcharts/plotoptions/arearange-negativecolor/ Arearange
	             * @default null
	             * @since 3.0
	             * @apioption plotOptions.series.negativeColor
	             */
	
	            /**
	             * Same as [accessibility.pointDescriptionFormatter](#accessibility.
	             * pointDescriptionFormatter), but for an individual series. Overrides
	             * the chart wide configuration.
	             * 
	             * @type {Function}
	             * @since 5.0.12
	             * @apioption plotOptions.series.pointDescriptionFormatter
	             */
	
	            /**
	             * If no x values are given for the points in a series, `pointInterval`
	             * defines the interval of the x values. For example, if a series contains
	             * one value every decade starting from year 0, set `pointInterval` to
	             * 10. In true `datetime` axes, the `pointInterval` is set in milliseconds.
	             * 
	             * It can be also be combined with `pointIntervalUnit` to draw irregular
	             * time intervals.
	             * 
	             * @type {Number}
	             * @sample {highcharts} highcharts/plotoptions/series-pointstart-datetime/
	             *         Datetime X axis
	             * @sample {highstock} stock/plotoptions/pointinterval-pointstart/
	             *         Using pointStart and pointInterval
	             * @default 1
	             * @product highcharts highstock
	             * @apioption plotOptions.series.pointInterval
	             */
	
	            /**
	             * On datetime series, this allows for setting the [pointInterval](#plotOptions.
	             * series.pointInterval) to irregular time units, `day`, `month` and
	             * `year`. A day is usually the same as 24 hours, but pointIntervalUnit
	             * also takes the DST crossover into consideration when dealing with
	             * local time. Combine this option with `pointInterval` to draw weeks,
	             *  quarters, 6 months, 10 years etc.
	             * 
	             * @validvalue [null, "day", "month", "year"]
	             * @type {String}
	             * @sample {highcharts} highcharts/plotoptions/series-pointintervalunit/ One point a month
	             * @sample {highstock} highcharts/plotoptions/series-pointintervalunit/ One point a month
	             * @since 4.1.0
	             * @product highcharts highstock
	             * @apioption plotOptions.series.pointIntervalUnit
	             */
	
	            /**
	             * Possible values: `null`, `"on"`, `"between"`.
	             * 
	             * In a column chart, when pointPlacement is `"on"`, the point will
	             * not create any padding of the X axis. In a polar column chart this
	             * means that the first column points directly north. If the pointPlacement
	             * is `"between"`, the columns will be laid out between ticks. This
	             * is useful for example for visualising an amount between two points
	             * in time or in a certain sector of a polar chart.
	             * 
	             * Since Highcharts 3.0.2, the point placement can also be numeric,
	             * where 0 is on the axis value, -0.5 is between this value and the
	             * previous, and 0.5 is between this value and the next. Unlike the
	             * textual options, numeric point placement options won't affect axis
	             * padding.
	             * 
	             * Note that pointPlacement needs a [pointRange](#plotOptions.series.
	             * pointRange) to work. For column series this is computed, but for
	             * line-type series it needs to be set.
	             * 
	             * Defaults to `null` in cartesian charts, `"between"` in polar charts.
	             * 
	             * @validvalue [null, "on", "between"]
	             * @type {String|Number}
	             * @see [xAxis.tickmarkPlacement](#xAxis.tickmarkPlacement)
	             * @sample {highcharts} highcharts/plotoptions/series-pointplacement-between/ Between in a column chart
	             * @sample {highcharts} highcharts/plotoptions/series-pointplacement-numeric/ Numeric placement for custom layout
	             * @sample {highstock} highcharts/plotoptions/series-pointplacement-between/ Between in a column chart
	             * @sample {highstock} highcharts/plotoptions/series-pointplacement-numeric/ Numeric placement for custom layout
	             * @default null
	             * @since 2.3.0
	             * @product highcharts highstock
	             * @apioption plotOptions.series.pointPlacement
	             */
	
	            /**
	             * If no x values are given for the points in a series, pointStart defines
	             * on what value to start. For example, if a series contains one yearly
	             * value starting from 1945, set pointStart to 1945.
	             * 
	             * @type {Number}
	             * @sample {highcharts} highcharts/plotoptions/series-pointstart-linear/ Linear
	             * @sample {highcharts} highcharts/plotoptions/series-pointstart-datetime/ Datetime
	             * @sample {highstock} stock/plotoptions/pointinterval-pointstart/ Using pointStart and pointInterval
	             * @default 0
	             * @product highcharts highstock
	             * @apioption plotOptions.series.pointStart
	             */
	
	            /**
	             * Whether to select the series initially. If `showCheckbox` is true,
	             * the checkbox next to the series name in the legend will be checked for a
	             * selected series.
	             * 
	             * @type {Boolean}
	             * @sample {highcharts} highcharts/plotoptions/series-selected/
	             *         One out of two series selected
	             * @default false
	             * @since 1.2.0
	             * @apioption plotOptions.series.selected
	             */
	
	            /**
	             * Whether to apply a drop shadow to the graph line. Since 2.3 the shadow
	             * can be an object configuration containing `color`, `offsetX`, `offsetY`,
	             *  `opacity` and `width`.
	             * 
	             * @type {Boolean|Object}
	             * @sample {highcharts} highcharts/plotoptions/series-shadow/ Shadow enabled
	             * @default false
	             * @apioption plotOptions.series.shadow
	             */
	
	            /**
	             * Whether to display this particular series or series type in the legend.
	             * The default value is `true` for standalone series, `false` for linked
	             * series.
	             * 
	             * @type {Boolean}
	             * @sample {highcharts} highcharts/plotoptions/series-showinlegend/ One series in the legend, one hidden
	             * @default true
	             * @apioption plotOptions.series.showInLegend
	             */
	
	            /**
	             * If set to `True`, the accessibility module will skip past the points
	             * in this series for keyboard navigation.
	             * 
	             * @type {Boolean}
	             * @since 5.0.12
	             * @apioption plotOptions.series.skipKeyboardNavigation
	             */
	
	            /**
	             * Whether to stack the values of each series on top of each other.
	             * Possible values are null to disable, "normal" to stack by value or
	             * "percent". When stacking is enabled, data must be sorted in ascending
	             * X order.
	             * 
	             * @validvalue [null, "normal", "percent"]
	             * @type {String}
	             * @see [yAxis.reversedStacks](#yAxis.reversedStacks)
	             * @sample {highcharts} highcharts/plotoptions/series-stacking-line/ Line
	             * @sample {highcharts} highcharts/plotoptions/series-stacking-column/ Column
	             * @sample {highcharts} highcharts/plotoptions/series-stacking-bar/ Bar
	             * @sample {highcharts} highcharts/plotoptions/series-stacking-area/ Area
	             * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-line/ Line
	             * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-column/ Column
	             * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-bar/ Bar
	             * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-area/ Area
	             * @sample {highstock} stock/plotoptions/stacking/ Area
	             * @default null
	             * @product highcharts highstock
	             * @apioption plotOptions.series.stacking
	             */
	
	            /**
	             * Whether to apply steps to the line. Possible values are `left`, `center`
	             * and `right`.
	             * 
	             * @validvalue [null, "left", "center", "right"]
	             * @type {String}
	             * @sample {highcharts} highcharts/plotoptions/line-step/ Different step line options
	             * @sample {highcharts} highcharts/plotoptions/area-step/ Stepped, stacked area
	             * @sample {highstock} stock/plotoptions/line-step/ Step line
	             * @default {highcharts} null
	             * @default {highstock} false
	             * @since 1.2.5
	             * @product highcharts highstock
	             * @apioption plotOptions.series.step
	             */
	
	            /**
	             * The threshold, also called zero level or base level. For line type
	             * series this is only used in conjunction with [negativeColor](#plotOptions.
	             * series.negativeColor).
	             * 
	             * @type {Number}
	             * @see [softThreshold](#plotOptions.series.softThreshold).
	             * @default 0
	             * @since 3.0
	             * @product highcharts highstock
	             * @apioption plotOptions.series.threshold
	             */
	
	            /**
	             * Set the initial visibility of the series.
	             * 
	             * @type {Boolean}
	             * @sample {highcharts} highcharts/plotoptions/series-visible/ Two series, one hidden and one visible
	             * @sample {highstock} stock/plotoptions/series-visibility/ Hidden series
	             * @default true
	             * @apioption plotOptions.series.visible
	             */
	
	            /**
	             * Defines the Axis on which the zones are applied.
	             * 
	             * @type {String}
	             * @see [zones](#plotOption.series.zones)
	             * @sample {highcharts} highcharts/series/color-zones-zoneaxis-x/ Zones on the X-Axis
	             * @sample {highstock} highcharts/series/color-zones-zoneaxis-x/ Zones on the X-Axis
	             * @default y
	             * @since 4.1.0
	             * @product highcharts highstock
	             * @apioption plotOptions.series.zoneAxis
	             */
	
	            /**
	             * @product highcharts highstock highmaps
	             */
	            events: {},
	
	
	
	            /**
	             * Options for the point markers of line-like series. Properties like
	             * `fillColor`, `lineColor` and `lineWidth` define the visual appearance
	             * of the markers. Other series types, like column series, don't have
	             * markers, but have visual options on the series level instead.
	             * 
	             * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	             * style/style-by-css), the markers can be styled with the `.highcharts-
	             * point`, `.highcharts-point-hover` and `.highcharts-point-select`
	             * class names.
	             * 
	             * @product highcharts highstock
	             */
	            marker: {
	
	
	
	                /**
	                 * The width of the point marker's outline.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/plotoptions/series-marker-fillcolor/ 2px blue marker
	                 * @default 0
	                 * @product highcharts highstock
	                 */
	                lineWidth: 0,
	
	
	                /**
	                 * The color of the point marker's outline. When `null`, the series'
	                 * or point's color is used.
	                 * 
	                 * @type {Color}
	                 * @sample {highcharts} highcharts/plotoptions/series-marker-fillcolor/ Inherit from series color (null)
	                 * @default #ffffff
	                 * @product highcharts highstock
	                 */
	                lineColor: '#ffffff',
	                //fillColor: null,
	
	                //enabled: true,
	                //symbol: null,
	
	
	                /**
	                 * The radius of the point marker.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/plotoptions/series-marker-radius/ Bigger markers
	                 * @default 4
	                 * @product highcharts highstock
	                 */
	                radius: 4,
	
	
	                /**
	                 * @product highcharts highstock
	                 */
	                states: { // states for a single point
	
	
	
	                    /**
	                     * @product highcharts highstock
	                     */
	                    hover: {
	
	
	
	                        /**
	                         */
	                        animation: {
	
	
	                            /**
	                             */
	                            duration: 50
	                        },
	
	
	
	                        /**
	                         * Enable or disable the point marker.
	                         * 
	                         * @type {Boolean}
	                         * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-enabled/ Disabled hover state
	                         * @default true
	                         * @product highcharts highstock
	                         */
	                        enabled: true,
	
	
	
	                        /**
	                         * The number of pixels to increase the radius of the hovered point.
	                         * 
	                         * @type {Number}
	                         * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/ 5 pixels greater radius on hover
	                         * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/ 5 pixels greater radius on hover
	                         * @default 2
	                         * @since 4.0.3
	                         * @product highcharts highstock
	                         */
	                        radiusPlus: 2,
	
	
	
	
	                        /**
	                         * The additional line width for a hovered point.
	                         * 
	                         * @type {Number}
	                         * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/ 2 pixels wider on hover
	                         * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/ 2 pixels wider on hover
	                         * @default 1
	                         * @since 4.0.3
	                         * @product highcharts highstock
	                         */
	                        lineWidthPlus: 1
	
	                    },
	
	
	
	
	                    /**
	                     * The appearance of the point marker when selected. In order to
	                     * allow a point to be selected, set the `series.allowPointSelect`
	                     * option to true.
	                     * 
	                     * @product highcharts highstock
	                     */
	                    select: {
	
	
	
	                        /**
	                         * The fill color of the point marker.
	                         * 
	                         * @type {Color}
	                         * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-fillcolor/ Solid red discs for selected points
	                         * @default null
	                         * @product highcharts highstock
	                         */
	                        fillColor: '#cccccc',
	
	
	
	                        /**
	                         * The color of the point marker's outline. When `null`, the series'
	                         * or point's color is used.
	                         * 
	                         * @type {Color}
	                         * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-linecolor/ Red line color for selected points
	                         * @default #000000
	                         * @product highcharts highstock
	                         */
	                        lineColor: '#000000',
	
	
	
	                        /**
	                         * The width of the point marker's outline.
	                         * 
	                         * @type {Number}
	                         * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-linewidth/ 3px line width for selected points
	                         * @default 0
	                         * @product highcharts highstock
	                         */
	                        lineWidth: 2
	                    }
	
	                }
	            },
	
	
	
	            /**
	             * Properties for each single point
	             * 
	             * @product highcharts highstock highmaps
	             */
	            point: {
	
	
	                /**
	                 * Events for each single point
	                 * 
	                 * @product highcharts highstock highmaps
	                 */
	                events: {}
	            },
	
	
	
	            /**
	             * Options for the series data labels, appearing next to each data
	             * point.
	             * 
	             * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	             * style/style-by-css), the data labels can be styled wtih the `.highcharts-
	             * data-label-box` and `.highcharts-data-label` class names ([see example](http://jsfiddle.
	             * net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/series-
	             * datalabels)).
	             */
	            dataLabels: {
	
	
	                /**
	                 * The alignment of the data label compared to the point. If `right`,
	                 * the right side of the label should be touching the point. For
	                 * points with an extent, like columns, the alignments also dictates
	                 * how to align it inside the box, as given with the [inside](#plotOptions.
	                 * column.dataLabels.inside) option. Can be one of "left", "center"
	                 * or "right".
	                 * 
	                 * @validvalue ["left", "center", "right"]
	                 * @type {String}
	                 * @sample {highcharts} highcharts/plotoptions/series-datalabels-align-left/ Left aligned
	                 * @default center
	                 */
	                align: 'center',
	
	
	                /**
	                 * Whether to allow data labels to overlap. To make the labels less
	                 * sensitive for overlapping, the [dataLabels.padding](#plotOptions.
	                 * series.dataLabels.padding) can be set to 0.
	                 * 
	                 * @type {Boolean}
	                 * @sample {highcharts} highcharts/plotoptions/series-datalabels-allowoverlap-false/ Don't allow overlap
	                 * @sample {highstock} highcharts/plotoptions/series-datalabels-allowoverlap-false/ Don't allow overlap
	                 * @sample {highmaps} highcharts/plotoptions/series-datalabels-allowoverlap-false/ Don't allow overlap
	                 * @default false
	                 * @since 4.1.0
	                 * @apioption plotOptions.series.dataLabels.allowOverlap
	                 */
	
	
	                /**
	                 * The border radius in pixels for the data label.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/ Data labels box options
	                 * @sample {highstock} highcharts/plotoptions/series-datalabels-box/ Data labels box options
	                 * @sample {highmaps} maps/plotoptions/series-datalabels-box/ Data labels box options
	                 * @default 0
	                 * @since 2.2.1
	                 * @apioption plotOptions.series.dataLabels.borderRadius
	                 */
	
	
	                /**
	                 * The border width in pixels for the data label.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/ Data labels box options
	                 * @sample {highstock} highcharts/plotoptions/series-datalabels-box/ Data labels box options
	                 * @default 0
	                 * @since 2.2.1
	                 * @apioption plotOptions.series.dataLabels.borderWidth
	                 */
	
	                /**
	                 * A class name for the data label. Particularly in [styled mode](http://www.
	                 * highcharts.com/docs/chart-design-and-style/style-by-css), this can
	                 * be used to give each series' or point's data label unique styling.
	                 * In addition to this option, a default color class name is added
	                 * so that we can give the labels a [contrast text shadow](http://jsfiddle.
	                 * net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/data-
	                 * label-contrast/).
	                 * 
	                 * @type {String}
	                 * @sample {highcharts} highcharts/css/series-datalabels/ Styling by CSS
	                 * @sample {highstock} highcharts/css/series-datalabels/ Styling by CSS
	                 * @sample {highmaps} highcharts/css/series-datalabels/ Styling by CSS
	                 * @since 5.0.0
	                 * @apioption plotOptions.series.dataLabels.className
	                 */
	
	                /**
	                 * The text color for the data labels. Defaults to `null`. For certain series
	                 * types, like column or map, the data labels can be drawn inside the points.
	                 * In this case the data label will be drawn with maximum contrast by default.
	                 * Additionally, it will be given a `text-outline` style with the opposite
	                 * color, to further increase the contrast. This can be overridden by setting
	                 * the `text-outline` style to `none` in the `dataLabels.style` option.
	                 * 
	                 * @type {Color}
	                 * @sample {highcharts} highcharts/plotoptions/series-datalabels-color/
	                 *         Red data labels
	                 * @sample {highmaps} maps/demo/color-axis/
	                 *         White data labels
	                 * @apioption plotOptions.series.dataLabels.color
	                 */
	
	                /**
	                 * Whether to hide data labels that are outside the plot area. By default,
	                 * the data label is moved inside the plot area according to the [overflow](#plotOptions.
	                 * series.dataLabels.overflow) option.
	                 * 
	                 * @type {Boolean}
	                 * @default true
	                 * @since 2.3.3
	                 * @apioption plotOptions.series.dataLabels.crop
	                 */
	
	                /**
	                 * Whether to defer displaying the data labels until the initial series
	                 * animation has finished.
	                 * 
	                 * @type {Boolean}
	                 * @default true
	                 * @since 4.0
	                 * @product highcharts highstock
	                 * @apioption plotOptions.series.dataLabels.defer
	                 */
	
	                /**
	                 * Enable or disable the data labels.
	                 * 
	                 * @type {Boolean}
	                 * @sample {highcharts} highcharts/plotoptions/series-datalabels-enabled/ Data labels enabled
	                 * @sample {highmaps} maps/demo/color-axis/ Data labels enabled
	                 * @default false
	                 * @apioption plotOptions.series.dataLabels.enabled
	                 */
	
	                /**
	                 * A [format string](http://www.highcharts.com/docs/chart-concepts/labels-
	                 * and-string-formatting) for the data label. Available variables are
	                 * the same as for `formatter`.
	                 * 
	                 * @type {String}
	                 * @sample {highcharts} highcharts/plotoptions/series-datalabels-format/ Add a unit
	                 * @sample {highstock} highcharts/plotoptions/series-datalabels-format/ Add a unit
	                 * @sample {highmaps} maps/plotoptions/series-datalabels-format/ Formatted value in the data label
	                 * @default {highcharts} {y}
	                 * @default {highstock} {y}
	                 * @default {highmaps} {point.value}
	                 * @since 3.0
	                 * @apioption plotOptions.series.dataLabels.format
	                 */
	
	                /**
	                 * Callback JavaScript function to format the data label. Note that
	                 * if a `format` is defined, the format takes precedence and the formatter
	                 * is ignored. Available data are:
	                 * 
	                 * <table>
	                 * 
	                 * <tbody>
	                 * 
	                 * <tr>
	                 * 
	                 * <td>`this.percentage`</td>
	                 * 
	                 * <td>Stacked series and pies only. The point's percentage of the
	                 * total.</td>
	                 * 
	                 * </tr>
	                 * 
	                 * <tr>
	                 * 
	                 * <td>`this.point`</td>
	                 * 
	                 * <td>The point object. The point name, if defined, is available
	                 * through `this.point.name`.</td>
	                 * 
	                 * </tr>
	                 * 
	                 * <tr>
	                 * 
	                 * <td>`this.series`:</td>
	                 * 
	                 * <td>The series object. The series name is available through `this.
	                 * series.name`.</td>
	                 * 
	                 * </tr>
	                 * 
	                 * <tr>
	                 * 
	                 * <td>`this.total`</td>
	                 * 
	                 * <td>Stacked series only. The total value at this point's x value.
	                 * </td>
	                 * 
	                 * </tr>
	                 * 
	                 * <tr>
	                 * 
	                 * <td>`this.x`:</td>
	                 * 
	                 * <td>The x value.</td>
	                 * 
	                 * </tr>
	                 * 
	                 * <tr>
	                 * 
	                 * <td>`this.y`:</td>
	                 * 
	                 * <td>The y value.</td>
	                 * 
	                 * </tr>
	                 * 
	                 * </tbody>
	                 * 
	                 * </table>
	                 * 
	                 * @type {Function}
	                 * @sample {highmaps} maps/plotoptions/series-datalabels-format/ Formatted value
	                 * @product highcharts highstock highmaps
	                 */
	                formatter: function() {
	                    return this.y === null ? '' : H.numberFormat(this.y, -1);
	                },
	
	
	
	                /**
	                 * Styles for the label. The default `color` setting is `"contrast"`,
	                 * which is a pseudo color that Highcharts picks up and applies the
	                 * maximum contrast to the underlying point item, for example the
	                 * bar in a bar chart. The `textOutline` is a pseudo property that
	                 * applies an outline of the given width with the given color, which
	                 * by default is the maximum contrast to the text. So a bright text
	                 * color will result in a black text outline for maximum readability
	                 * on a mixed background. In some cases, especially with grayscale
	                 * text, the text outline doesn't work well, in which cases it can
	                 * be disabled by setting it to `"none"`.
	                 * 
	                 * @type {CSSObject}
	                 * @sample {highcharts} highcharts/plotoptions/series-datalabels-style/
	                 *         Bold labels
	                 * @sample {highmaps} maps/demo/color-axis/ Bold labels
	                 * @default {"color": "contrast", "fontSize": "11px", "fontWeight": "bold", "textOutline": "1px contrast" }
	                 * @since 4.1.0
	                 */
	                style: {
	                    fontSize: '11px',
	                    fontWeight: 'bold',
	                    color: 'contrast',
	                    textOutline: '1px contrast'
	                },
	
	                /**
	                 * The background color or gradient for the data label. Defaults to
	                 * `undefined`.
	                 * 
	                 * @type {Color}
	                 * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/ Data labels box options
	                 * @sample {highmaps} maps/plotoptions/series-datalabels-box/ Data labels box options
	                 * @since 2.2.1
	                 * @apioption plotOptions.series.dataLabels.backgroundColor
	                 */
	
	                /**
	                 * The border color for the data label. Defaults to `undefined`.
	                 * 
	                 * @type {Color}
	                 * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/ Data labels box options
	                 * @sample {highstock} highcharts/plotoptions/series-datalabels-box/ Data labels box options
	                 * @default undefined
	                 * @since 2.2.1
	                 * @apioption plotOptions.series.dataLabels.borderColor
	                 */
	
	                /**
	                 * The shadow of the box. Works best with `borderWidth` or `backgroundColor`.
	                 * Since 2.3 the shadow can be an object configuration containing `color`,
	                 *  `offsetX`, `offsetY`, `opacity` and `width`.
	                 * 
	                 * @type {Boolean|Object}
	                 * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/ Data labels box options
	                 * @sample {highstock} highcharts/plotoptions/series-datalabels-box/ Data labels box options
	                 * @default false
	                 * @since 2.2.1
	                 * @apioption plotOptions.series.dataLabels.shadow
	                 */
	
	
	                /**
	                 * For points with an extent, like columns or map areas, whether to align the data
	                 * label inside the box or to the actual value point. Defaults to `false`
	                 * in most cases, `true` in stacked columns.
	                 * 
	                 * @type {Boolean}
	                 * @since 3.0
	                 * @apioption plotOptions.series.dataLabels.inside
	                 */
	
	                /**
	                 * How to handle data labels that flow outside the plot area. The default
	                 * is `justify`, which aligns them inside the plot area. For columns
	                 * and bars, this means it will be moved inside the bar. To display
	                 * data labels outside the plot area, set `crop` to `false` and `overflow`
	                 * to `"none"`.
	                 * 
	                 * @validvalue ["justify", "none"]
	                 * @type {String}
	                 * @default justify
	                 * @since 3.0.6
	                 * @apioption plotOptions.series.dataLabels.overflow
	                 */
	
	                /**
	                 * Text rotation in degrees. Note that due to a more complex structure,
	                 * backgrounds, borders and padding will be lost on a rotated data
	                 * label.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/ Vertical labels
	                 * @default 0
	                 * @apioption plotOptions.series.dataLabels.rotation
	                 */
	
	                /**
	                 * The vertical alignment of a data label. Can be one of `top`, `middle`
	                 * or `bottom`. The default value depends on the data, for instance
	                 * in a column chart, the label is above positive values and below
	                 * negative values.
	                 * 
	                 * @validvalue ["top", "middle", "bottom"]
	                 * @type {String}
	                 * @since 2.3.3
	                 * @product highcharts highstock highmaps
	                 */
	                verticalAlign: 'bottom', // above singular point
	
	
	                /**
	                 * The x position offset of the label relative to the point.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/ Vertical and positioned
	                 * @default 0
	                 * @product highcharts highstock highmaps
	                 */
	                x: 0,
	
	
	                /**
	                 * The y position offset of the label relative to the point.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/ Vertical and positioned
	                 * @default -6
	                 * @product highcharts highstock highmaps
	                 */
	                y: 0,
	
	
	                /**
	                 * When either the `borderWidth` or the `backgroundColor` is set,
	                 * this is the padding within the box.
	                 * 
	                 * @type {Number}
	                 * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/ Data labels box options
	                 * @sample {highstock} highcharts/plotoptions/series-datalabels-box/ Data labels box options
	                 * @sample {highmaps} maps/plotoptions/series-datalabels-box/ Data labels box options
	                 * @default {highcharts} 5
	                 * @default {highstock} 5
	                 * @default {highmaps} 0
	                 * @since 2.2.1
	                 * @product highcharts highstock highmaps
	                 */
	                padding: 5
	
	                /**
	                 * The name of a symbol to use for the border around the label. Symbols
	                 * are predefined functions on the Renderer object.
	                 * 
	                 * @type {String}
	                 * @sample {highcharts} highcharts/plotoptions/series-datalabels-shape/ A callout for annotations
	                 * @sample {highstock} highcharts/plotoptions/series-datalabels-shape/ A callout for annotations
	                 * @sample {highmaps} highcharts/plotoptions/series-datalabels-shape/ A callout for annotations (Highcharts demo)
	                 * @default square
	                 * @since 4.1.2
	                 * @apioption plotOptions.series.dataLabels.shape
	                 */
	
	                /**
	                 * The Z index of the data labels. The default Z index puts it above
	                 * the series. Use a Z index of 2 to display it behind the series.
	                 * 
	                 * @type {Number}
	                 * @default 6
	                 * @since 2.3.5
	                 * @apioption plotOptions.series.dataLabels.zIndex
	                 */
	            },
	            // draw points outside the plot area when the number of points is less than
	            // this
	
	
	
	            /**
	             * When the series contains less points than the crop threshold, all
	             * points are drawn, even if the points fall outside the visible plot
	             * area at the current zoom. The advantage of drawing all points (including
	             * markers and columns), is that animation is performed on updates.
	             * On the other hand, when the series contains more points than the
	             * crop threshold, the series data is cropped to only contain points
	             * that fall within the plot area. The advantage of cropping away invisible
	             * points is to increase performance on large series.
	             * 
	             * @type {Number}
	             * @default 300
	             * @since 2.2
	             * @product highcharts highstock
	             */
	            cropThreshold: 300,
	
	
	
	            /**
	             * The width of each point on the x axis. For example in a column chart
	             * with one value each day, the pointRange would be 1 day (= 24 * 3600
	             * * 1000 milliseconds). This is normally computed automatically, but
	             * this option can be used to override the automatic value.
	             * 
	             * @type {Number}
	             * @default 0
	             * @product highstock
	             */
	            pointRange: 0,
	            //pointStart: 0,
	            //pointInterval: 1,
	            //showInLegend: null, // auto = false for linked series
	
	
	
	            /**
	             * When this is true, the series will not cause the Y axis to cross
	             * the zero plane (or [threshold](#plotOptions.series.threshold) option)
	             * unless the data actually crosses the plane.
	             * 
	             * For example, if `softThreshold` is `false`, a series of 0, 1, 2,
	             * 3 will make the Y axis show negative values according to the `minPadding`
	             * option. If `softThreshold` is `true`, the Y axis starts at 0.
	             * 
	             * @type {Boolean}
	             * @default true
	             * @since 4.1.9
	             * @product highcharts highstock
	             */
	            softThreshold: true,
	
	
	
	            /**
	             * A wrapper object for all the series options in specific states.
	             * 
	             * @type {plotOptions.series.states}
	             * @product highcharts highstock highmaps
	             */
	            states: { // states for the entire series
	
	
	                /**
	                 * Options for the hovered series
	                 * 
	                 * @product highcharts highstock highmaps
	                 */
	                hover: {
	                    //enabled: false,
	
	
	
	                    /**
	                     * Animation setting for hovering the graph in line-type series.
	                     * 
	                     * @type {Boolean|Object}
	                     * @default { "duration": 50 }
	                     * @since 5.0.8
	                     * @product highcharts
	                     */
	                    animation: {
	
	
	
	                        /**
	                         */
	                        duration: 50
	                    },
	
	
	
	                    /**
	                     * The additional line width for the graph of a hovered series.
	                     * 
	                     * @type {Number}
	                     * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/ 5 pixels wider
	                     * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/ 5 pixels wider
	                     * @default 1
	                     * @since 4.0.3
	                     * @product highcharts highstock
	                     */
	                    lineWidthPlus: 1,
	
	
	
	                    /**
	                     * In Highcharts 1.0, the appearance of all markers belonging to
	                     * the hovered series. For settings on the hover state of the individual
	                     * point, see [marker.states.hover](#plotOptions.series.marker.states.
	                     * hover).
	                     * 
	                     * @extends plotOptions.series.marker
	                     * @deprecated
	                     * @product highcharts highstock
	                     */
	                    marker: {
	                        // lineWidth: base + 1,
	                        // radius: base + 1
	                    },
	
	
	
	                    /**
	                     * Options for the halo appearing around the hovered point in line-
	                     * type series as well as outside the hovered slice in pie charts.
	                     * By default the halo is filled by the current point or series
	                     * color with an opacity of 0.25\. The halo can be disabled by setting
	                     * the `halo` option to `false`.
	                     * 
	                     * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                     * style/style-by-css), the halo is styled with the `.highcharts-
	                     * halo` class, with colors inherited from `.highcharts-color-{n}`.
	                     * 
	                     * @type {Object}
	                     * @sample {highcharts} highcharts/plotoptions/halo/ Halo options
	                     * @sample {highstock} highcharts/plotoptions/halo/ Halo options
	                     * @since 4.0
	                     * @product highcharts highstock
	                     */
	                    halo: {
	
	
	
	                        /**
	                         * The pixel size of the halo. For point markers this is the radius
	                         * of the halo. For pie slices it is the width of the halo outside
	                         * the slice. For bubbles it defaults to 5 and is the width of the
	                         * halo outside the bubble.
	                         * 
	                         * @type {Number}
	                         * @default 10
	                         * @since 4.0
	                         * @product highcharts highstock
	                         */
	                        size: 10,
	
	
	
	
	                        /**
	                         * Opacity for the halo unless a specific fill is overridden using
	                         * the `attributes` setting. Note that Highcharts is only able to
	                         * apply opacity to colors of hex or rgb(a) formats.
	                         * 
	                         * @type {Number}
	                         * @default 0.25
	                         * @since 4.0
	                         * @product highcharts highstock
	                         */
	                        opacity: 0.25
	
	                    }
	                },
	
	
	                /**
	                 * Specific options for point in selected states, after being selected
	                 * by [allowPointSelect](#plotOptions.series.allowPointSelect) or
	                 * programmatically.
	                 * 
	                 * @type {Object}
	                 * @extends plotOptions.series.states.hover
	                 * @excluding brightness
	                 * @sample {highmaps} maps/plotoptions/series-allowpointselect/ Allow point select demo
	                 * @product highmaps
	                 */
	                select: {
	
	
	
	                    /**
	                     */
	                    marker: {}
	                }
	            },
	
	
	
	            /**
	             * Sticky tracking of mouse events. When true, the `mouseOut` event
	             * on a series isn't triggered until the mouse moves over another series,
	             * or out of the plot area. When false, the `mouseOut` event on a
	             * series is triggered when the mouse leaves the area around the series'
	             * graph or markers. This also implies the tooltip when not shared. When
	             * `stickyTracking` is false and `tooltip.shared` is false, the tooltip will
	             * be hidden when moving the mouse between series. Defaults to true for line
	             * and area type series, but to false for columns, pies etc.
	             * 
	             * @type {Boolean}
	             * @sample {highcharts} highcharts/plotoptions/series-stickytracking-true/
	             *         True by default
	             * @sample {highcharts} highcharts/plotoptions/series-stickytracking-false/
	             *         False
	             * @default {highcharts} true
	             * @default {highstock} true
	             * @default {highmaps} false
	             * @since 2.0
	             * @product highcharts highstock highmaps
	             */
	            stickyTracking: true,
	            //tooltip: {
	            //pointFormat: '<span style="color:{point.color}">\u25CF</span>' +
	            // '{series.name}: <b>{point.y}</b>'
	            //valueDecimals: null,
	            //xDateFormat: '%A, %b %e, %Y',
	            //valuePrefix: '',
	            //ySuffix: ''
	            //}
	
	
	
	            /**
	             * When a series contains a data array that is longer than this, only
	             * one dimensional arrays of numbers, or two dimensional arrays with
	             * x and y values are allowed. Also, only the first point is tested,
	             * and the rest are assumed to be the same format. This saves expensive
	             * data checking and indexing in long series. Set it to `0` disable.
	             * 
	             * @type {Number}
	             * @default 1000
	             * @since 2.2
	             * @product highcharts highstock
	             */
	            turboThreshold: 1000,
	            // zIndex: null
	
	
	
	            /**
	             * Determines whether the series should look for the nearest point
	             * in both dimensions or just the x-dimension when hovering the series.
	             * Defaults to `'xy'` for scatter series and `'x'` for most other
	             * series. If the data has duplicate x-values, it is recommended to
	             * set this to `'xy'` to allow hovering over all points.
	             * 
	             * Applies only to series types using nearest neighbor search (not
	             * direct hover) for tooltip.
	             * 
	             * @validvalue ['x', 'xy']
	             * @type {String}
	             * @sample {highcharts} highcharts/series/findnearestpointby/ Different hover behaviors
	             * @sample {highstock} highcharts/series/findnearestpointby/ Different hover behaviors
	             * @sample {highmaps} highcharts/series/findnearestpointby/ Different hover behaviors
	             * @since 5.0.10
	             * @product highcharts highstock highmaps
	             */
	            findNearestPointBy: 'x'
	
	        }, /** @lends Highcharts.Series.prototype */ {
	            isCartesian: true,
	            pointClass: Point,
	            sorted: true, // requires the data to be sorted
	            requireSorting: true,
	            directTouch: false,
	            axisTypes: ['xAxis', 'yAxis'],
	            colorCounter: 0,
	            // each point's x and y values are stored in this.xData and this.yData
	            parallelArrays: ['x', 'y'],
	            coll: 'series',
	            init: function(chart, options) {
	                var series = this,
	                    events,
	                    chartSeries = chart.series,
	                    lastSeries;
	
	                /**
	                 * Read only. The chart that the series belongs to.
	                 *
	                 * @name chart
	                 * @memberOf Series
	                 * @type {Chart}
	                 */
	                series.chart = chart;
	
	                /**
	                 * Read only. The series' type, like "line", "area", "column" etc. The
	                 * type in the series options anc can be altered using {@link
	                 * Series#update}.
	                 *
	                 * @name type
	                 * @memberOf Series
	                 * @type String
	                 */
	
	                /**
	                 * Read only. The series' current options. To update, use {@link
	                 * Series#update}.
	                 *
	                 * @name options
	                 * @memberOf Series
	                 * @type SeriesOptions
	                 */
	                series.options = options = series.setOptions(options);
	                series.linkedSeries = [];
	
	                // bind the axes
	                series.bindAxes();
	
	                // set some variables
	                extend(series, {
	                    /**
	                     * The series name as given in the options. Defaults to
	                     * "Series {n}".
	                     *
	                     * @name name
	                     * @memberOf Series
	                     * @type {String}
	                     */
	                    name: options.name,
	                    state: '',
	                    /**
	                     * Read only. The series' visibility state as set by {@link
	                     * Series#show}, {@link Series#hide}, or in the initial
	                     * configuration.
	                     *
	                     * @name visible
	                     * @memberOf Series
	                     * @type {Boolean}
	                     */
	                    visible: options.visible !== false, // true by default
	                    /**
	                     * Read only. The series' selected state as set by {@link
	                     * Highcharts.Series#select}.
	                     *
	                     * @name selected
	                     * @memberOf Series
	                     * @type {Boolean}
	                     */
	                    selected: options.selected === true // false by default
	                });
	
	                // register event listeners
	                events = options.events;
	
	                objectEach(events, function(event, eventType) {
	                    addEvent(series, eventType, event);
	                });
	                if (
	                    (events && events.click) ||
	                    (
	                        options.point &&
	                        options.point.events &&
	                        options.point.events.click
	                    ) ||
	                    options.allowPointSelect
	                ) {
	                    chart.runTrackerClick = true;
	                }
	
	                series.getColor();
	                series.getSymbol();
	
	                // Set the data
	                each(series.parallelArrays, function(key) {
	                    series[key + 'Data'] = [];
	                });
	                series.setData(options.data, false);
	
	                // Mark cartesian
	                if (series.isCartesian) {
	                    chart.hasCartesianSeries = true;
	                }
	
	                // Get the index and register the series in the chart. The index is one
	                // more than the current latest series index (#5960).
	                if (chartSeries.length) {
	                    lastSeries = chartSeries[chartSeries.length - 1];
	                }
	                series._i = pick(lastSeries && lastSeries._i, -1) + 1;
	
	                // Insert the series and re-order all series above the insertion point.
	                chart.orderSeries(this.insert(chartSeries));
	            },
	
	            /**
	             * Insert the series in a collection with other series, either the chart
	             * series or yAxis series, in the correct order according to the index
	             * option. Used internally when adding series.
	             *
	             * @private
	             * @param   {Array.<Series>} collection
	             *          A collection of series, like `chart.series` or `xAxis.series`.
	             * @returns {Number} The index of the series in the collection.
	             */
	            insert: function(collection) {
	                var indexOption = this.options.index,
	                    i;
	
	                // Insert by index option
	                if (isNumber(indexOption)) {
	                    i = collection.length;
	                    while (i--) {
	                        // Loop down until the interted element has higher index
	                        if (indexOption >=
	                            pick(collection[i].options.index, collection[i]._i)) {
	                            collection.splice(i + 1, 0, this);
	                            break;
	                        }
	                    }
	                    if (i === -1) {
	                        collection.unshift(this);
	                    }
	                    i = i + 1;
	
	                    // Or just push it to the end
	                } else {
	                    collection.push(this);
	                }
	                return pick(i, collection.length - 1);
	            },
	
	            /**
	             * Set the xAxis and yAxis properties of cartesian series, and register the
	             * series in the `axis.series` array.
	             *
	             * @private
	             */
	            bindAxes: function() {
	                var series = this,
	                    seriesOptions = series.options,
	                    chart = series.chart,
	                    axisOptions;
	
	                // repeat for xAxis and yAxis
	                each(series.axisTypes || [], function(AXIS) {
	
	                    // loop through the chart's axis objects
	                    each(chart[AXIS], function(axis) {
	                        axisOptions = axis.options;
	
	                        // apply if the series xAxis or yAxis option mathches the number
	                        // of the axis, or if undefined, use the first axis
	                        if (
	                            seriesOptions[AXIS] === axisOptions.index ||
	                            (
	                                seriesOptions[AXIS] !== undefined &&
	                                seriesOptions[AXIS] === axisOptions.id
	                            ) ||
	                            (
	                                seriesOptions[AXIS] === undefined &&
	                                axisOptions.index === 0
	                            )
	                        ) {
	
	                            // register this series in the axis.series lookup
	                            series.insert(axis.series);
	
	                            // set this series.xAxis or series.yAxis reference
	                            /**
	                             * Read only. The unique xAxis object associated with the
	                             * series.
	                             *
	                             * @name xAxis
	                             * @memberOf Series
	                             * @type Axis
	                             */
	                            /**
	                             * Read only. The unique yAxis object associated with the
	                             * series.
	                             *
	                             * @name yAxis
	                             * @memberOf Series
	                             * @type Axis
	                             */
	                            series[AXIS] = axis;
	
	                            // mark dirty for redraw
	                            axis.isDirty = true;
	                        }
	                    });
	
	                    // The series needs an X and an Y axis
	                    if (!series[AXIS] && series.optionalAxis !== AXIS) {
	                        H.error(18, true);
	                    }
	
	                });
	            },
	
	            /**
	             * For simple series types like line and column, the data values are held in
	             * arrays like xData and yData for quick lookup to find extremes and more.
	             * For multidimensional series like bubble and map, this can be extended
	             * with arrays like zData and valueData by adding to the
	             * `series.parallelArrays` array.
	             *
	             * @private
	             */
	            updateParallelArrays: function(point, i) {
	                var series = point.series,
	                    args = arguments,
	                    fn = isNumber(i) ?
	                    // Insert the value in the given position
	                    function(key) {
	                        var val = key === 'y' && series.toYData ?
	                            series.toYData(point) :
	                            point[key];
	                        series[key + 'Data'][i] = val;
	                    } :
	                    // Apply the method specified in i with the following arguments
	                    // as arguments
	                    function(key) {
	                        Array.prototype[i].apply(
	                            series[key + 'Data'],
	                            Array.prototype.slice.call(args, 2)
	                        );
	                    };
	
	                each(series.parallelArrays, fn);
	            },
	
	            /**
	             * Return an auto incremented x value based on the pointStart and
	             * pointInterval options. This is only used if an x value is not given for
	             * the point that calls autoIncrement.
	             *
	             * @private
	             */
	            autoIncrement: function() {
	
	                var options = this.options,
	                    xIncrement = this.xIncrement,
	                    date,
	                    pointInterval,
	                    pointIntervalUnit = options.pointIntervalUnit;
	
	                xIncrement = pick(xIncrement, options.pointStart, 0);
	
	                this.pointInterval = pointInterval = pick(
	                    this.pointInterval,
	                    options.pointInterval,
	                    1
	                );
	
	                // Added code for pointInterval strings
	                if (pointIntervalUnit) {
	                    date = new Date(xIncrement);
	
	                    if (pointIntervalUnit === 'day') {
	                        date = +date[Date.hcSetDate](
	                            date[Date.hcGetDate]() + pointInterval
	                        );
	                    } else if (pointIntervalUnit === 'month') {
	                        date = +date[Date.hcSetMonth](
	                            date[Date.hcGetMonth]() + pointInterval
	                        );
	                    } else if (pointIntervalUnit === 'year') {
	                        date = +date[Date.hcSetFullYear](
	                            date[Date.hcGetFullYear]() + pointInterval
	                        );
	                    }
	                    pointInterval = date - xIncrement;
	
	                }
	
	                this.xIncrement = xIncrement + pointInterval;
	                return xIncrement;
	            },
	
	            /**
	             * Set the series options by merging from the options tree. Called
	             * internally on initiating and updating series. This function will not
	             * redraw the series. For API usage, use {@link Series#update}.
	             * 
	             * @param  {Options.plotOptions.series} itemOptions
	             *         The series options.
	             */
	            setOptions: function(itemOptions) {
	                var chart = this.chart,
	                    chartOptions = chart.options,
	                    plotOptions = chartOptions.plotOptions,
	                    userOptions = chart.userOptions || {},
	                    userPlotOptions = userOptions.plotOptions || {},
	                    typeOptions = plotOptions[this.type],
	                    options,
	                    zones;
	
	                this.userOptions = itemOptions;
	
	                // General series options take precedence over type options because
	                // otherwise, default type options like column.animation would be
	                // overwritten by the general option. But issues have been raised here
	                // (#3881), and the solution may be to distinguish between default
	                // option and userOptions like in the tooltip below.
	                options = merge(
	                    typeOptions,
	                    plotOptions.series,
	                    itemOptions
	                );
	
	                // The tooltip options are merged between global and series specific
	                // options. Importance order asscendingly:
	                // globals: (1)tooltip, (2)plotOptions.series, (3)plotOptions[this.type]
	                // init userOptions with possible later updates: 4-6 like 1-3 and
	                // (7)this series options
	                this.tooltipOptions = merge(
	                    defaultOptions.tooltip, // 1
	                    defaultOptions.plotOptions.series &&
	                    defaultOptions.plotOptions.series.tooltip, // 2
	                    defaultOptions.plotOptions[this.type].tooltip, // 3
	                    chartOptions.tooltip.userOptions, // 4
	                    plotOptions.series && plotOptions.series.tooltip, // 5
	                    plotOptions[this.type].tooltip, // 6
	                    itemOptions.tooltip // 7
	                );
	
	                // When shared tooltip, stickyTracking is true by default,
	                // unless user says otherwise.
	                this.stickyTracking = pick(
	                    itemOptions.stickyTracking,
	                    userPlotOptions[this.type] &&
	                    userPlotOptions[this.type].stickyTracking,
	                    userPlotOptions.series && userPlotOptions.series.stickyTracking,
	                    (
	                        this.tooltipOptions.shared && !this.noSharedTooltip ?
	                        true :
	                        options.stickyTracking
	                    )
	                );
	
	                // Delete marker object if not allowed (#1125)
	                if (typeOptions.marker === null) {
	                    delete options.marker;
	                }
	
	                // Handle color zones
	                this.zoneAxis = options.zoneAxis;
	                zones = this.zones = (options.zones || []).slice();
	                if (
	                    (options.negativeColor || options.negativeFillColor) &&
	                    !options.zones
	                ) {
	                    zones.push({
	                        value: options[this.zoneAxis + 'Threshold'] ||
	                            options.threshold ||
	                            0,
	                        className: 'highcharts-negative',
	
	                        color: options.negativeColor,
	                        fillColor: options.negativeFillColor
	
	                    });
	                }
	                if (zones.length) { // Push one extra zone for the rest
	                    if (defined(zones[zones.length - 1].value)) {
	                        zones.push({
	
	                            color: this.color,
	                            fillColor: this.fillColor
	
	                        });
	                    }
	                }
	                return options;
	            },
	
	            getCyclic: function(prop, value, defaults) {
	                var i,
	                    chart = this.chart,
	                    userOptions = this.userOptions,
	                    indexName = prop + 'Index',
	                    counterName = prop + 'Counter',
	                    len = defaults ? defaults.length : pick(
	                        chart.options.chart[prop + 'Count'],
	                        chart[prop + 'Count']
	                    ),
	                    setting;
	
	                if (!value) {
	                    // Pick up either the colorIndex option, or the _colorIndex after
	                    // Series.update()
	                    setting = pick(
	                        userOptions[indexName],
	                        userOptions['_' + indexName]
	                    );
	                    if (defined(setting)) { // after Series.update()
	                        i = setting;
	                    } else {
	                        // #6138
	                        if (!chart.series.length) {
	                            chart[counterName] = 0;
	                        }
	                        userOptions['_' + indexName] = i = chart[counterName] % len;
	                        chart[counterName] += 1;
	                    }
	                    if (defaults) {
	                        value = defaults[i];
	                    }
	                }
	                // Set the colorIndex
	                if (i !== undefined) {
	                    this[indexName] = i;
	                }
	                this[prop] = value;
	            },
	
	            /**
	             * Get the series' color based on either the options or pulled from global
	             * options.
	             *
	             * @return  {Color} The series color.
	             */
	
	            getColor: function() {
	                if (this.options.colorByPoint) {
	                    // #4359, selected slice got series.color even when colorByPoint was
	                    // set.
	                    this.options.color = null;
	                } else {
	                    this.getCyclic(
	                        'color',
	                        this.options.color || defaultPlotOptions[this.type].color,
	                        this.chart.options.colors
	                    );
	                }
	            },
	
	            /**
	             * Get the series' symbol based on either the options or pulled from global
	             * options.
	             */
	            getSymbol: function() {
	                var seriesMarkerOption = this.options.marker;
	
	                this.getCyclic(
	                    'symbol',
	                    seriesMarkerOption.symbol,
	                    this.chart.options.symbols
	                );
	            },
	
	            drawLegendSymbol: LegendSymbolMixin.drawLineMarker,
	
	            /**
	             * Apply a new set of data to the series and optionally redraw it. The new
	             * data array is passed by reference (except in case of `updatePoints`), and
	             * may later be mutated when updating the chart data.
	             *
	             * Note the difference in behaviour when setting the same amount of points,
	             * or a different amount of points, as handled by the `updatePoints`
	             * parameter.
	             *
	             * @param  {SeriesDataOptions} data
	             *         Takes an array of data in the same format as described under
	             *         `series<type>data` for the given series type.
	             * @param  {Boolean} [redraw=true]
	             *         Whether to redraw the chart after the series is altered. If doing
	             *         more operations on the chart, it is a good idea to set redraw to
	             *         false and call {@link Chart#redraw} after.
	             * @param  {AnimationOptions} [animation]
	             *         When the updated data is the same length as the existing data,
	             *         points will be updated by default, and animation visualizes how
	             *         the points are changed. Set false to disable animation, or a
	             *         configuration object to set duration or easing.
	             * @param  {Boolean} [updatePoints=true]
	             *         When the updated data is the same length as the existing data,
	             *         points will be updated instead of replaced. This allows updating
	             *         with animation and performs better. In this case, the original
	             *         array is not passed by reference. Set false to prevent.
	             *
	             * @sample highcharts/members/series-setdata/
	             *         Set new data from a button
	             * @sample highcharts/members/series-setdata-pie/
	             *         Set data in a pie
	             * @sample stock/members/series-setdata/
	             *         Set new data in Highstock
	             * @sample maps/members/series-setdata/
	             *         Set new data in Highmaps
	             */
	            setData: function(data, redraw, animation, updatePoints) {
	                var series = this,
	                    oldData = series.points,
	                    oldDataLength = (oldData && oldData.length) || 0,
	                    dataLength,
	                    options = series.options,
	                    chart = series.chart,
	                    firstPoint = null,
	                    xAxis = series.xAxis,
	                    i,
	                    turboThreshold = options.turboThreshold,
	                    pt,
	                    xData = this.xData,
	                    yData = this.yData,
	                    pointArrayMap = series.pointArrayMap,
	                    valueCount = pointArrayMap && pointArrayMap.length;
	
	                data = data || [];
	                dataLength = data.length;
	                redraw = pick(redraw, true);
	
	                // If the point count is the same as is was, just run Point.update which
	                // is cheaper, allows animation, and keeps references to points.
	                if (
	                    updatePoints !== false &&
	                    dataLength &&
	                    oldDataLength === dataLength &&
	                    !series.cropped &&
	                    !series.hasGroupedData &&
	                    series.visible
	                ) {
	                    each(data, function(point, i) {
	                        // .update doesn't exist on a linked, hidden series (#3709)
	                        if (oldData[i].update && point !== options.data[i]) {
	                            oldData[i].update(point, false, null, false);
	                        }
	                    });
	
	                } else {
	
	                    // Reset properties
	                    series.xIncrement = null;
	
	                    series.colorCounter = 0; // for series with colorByPoint (#1547)
	
	                    // Update parallel arrays
	                    each(this.parallelArrays, function(key) {
	                        series[key + 'Data'].length = 0;
	                    });
	
	                    // In turbo mode, only one- or twodimensional arrays of numbers are
	                    // allowed. The first value is tested, and we assume that all the
	                    // rest are defined the same way. Although the 'for' loops are
	                    // similar, they are repeated inside each if-else conditional for
	                    // max performance.
	                    if (turboThreshold && dataLength > turboThreshold) {
	
	                        // find the first non-null point
	                        i = 0;
	                        while (firstPoint === null && i < dataLength) {
	                            firstPoint = data[i];
	                            i++;
	                        }
	
	
	                        if (isNumber(firstPoint)) { // assume all points are numbers
	                            for (i = 0; i < dataLength; i++) {
	                                xData[i] = this.autoIncrement();
	                                yData[i] = data[i];
	                            }
	
	                            // Assume all points are arrays when first point is
	                        } else if (isArray(firstPoint)) {
	                            if (valueCount) { // [x, low, high] or [x, o, h, l, c]
	                                for (i = 0; i < dataLength; i++) {
	                                    pt = data[i];
	                                    xData[i] = pt[0];
	                                    yData[i] = pt.slice(1, valueCount + 1);
	                                }
	                            } else { // [x, y]
	                                for (i = 0; i < dataLength; i++) {
	                                    pt = data[i];
	                                    xData[i] = pt[0];
	                                    yData[i] = pt[1];
	                                }
	                            }
	                        } else {
	                            // Highcharts expects configs to be numbers or arrays in
	                            // turbo mode
	                            H.error(12);
	                        }
	                    } else {
	                        for (i = 0; i < dataLength; i++) {
	                            if (data[i] !== undefined) { // stray commas in oldIE
	                                pt = {
	                                    series: series
	                                };
	                                series.pointClass.prototype.applyOptions.apply(
	                                    pt, [data[i]]
	                                );
	                                series.updateParallelArrays(pt, i);
	                            }
	                        }
	                    }
	
	                    // Forgetting to cast strings to numbers is a common caveat when
	                    // handling CSV or JSON
	                    if (isString(yData[0])) {
	                        H.error(14, true);
	                    }
	
	                    series.data = [];
	                    series.options.data = series.userOptions.data = data;
	
	                    // destroy old points
	                    i = oldDataLength;
	                    while (i--) {
	                        if (oldData[i] && oldData[i].destroy) {
	                            oldData[i].destroy();
	                        }
	                    }
	
	                    // reset minRange (#878)
	                    if (xAxis) {
	                        xAxis.minRange = xAxis.userMinRange;
	                    }
	
	                    // redraw
	                    series.isDirty = chart.isDirtyBox = true;
	                    series.isDirtyData = !!oldData;
	                    animation = false;
	                }
	
	                // Typically for pie series, points need to be processed and generated
	                // prior to rendering the legend
	                if (options.legendType === 'point') {
	                    this.processData();
	                    this.generatePoints();
	                }
	
	                if (redraw) {
	                    chart.redraw(animation);
	                }
	            },
	
	            /**
	             * Internal function to process the data by cropping away unused data points
	             * if the series is longer than the crop threshold. This saves computing
	             * time for large series. In Highstock, this function is extended to
	             * provide data grouping.
	             *
	             * @private
	             * @param  {Boolean} force
	             *         Force data grouping.
	             */
	            processData: function(force) {
	                var series = this,
	                    processedXData = series.xData, // copied during slice operation
	                    processedYData = series.yData,
	                    dataLength = processedXData.length,
	                    croppedData,
	                    cropStart = 0,
	                    cropped,
	                    distance,
	                    closestPointRange,
	                    xAxis = series.xAxis,
	                    i, // loop variable
	                    options = series.options,
	                    cropThreshold = options.cropThreshold,
	                    getExtremesFromAll =
	                    series.getExtremesFromAll ||
	                    options.getExtremesFromAll, // #4599
	                    isCartesian = series.isCartesian,
	                    xExtremes,
	                    val2lin = xAxis && xAxis.val2lin,
	                    isLog = xAxis && xAxis.isLog,
	                    min,
	                    max;
	
	                // If the series data or axes haven't changed, don't go through this.
	                // Return false to pass the message on to override methods like in data
	                // grouping.
	                if (
	                    isCartesian &&
	                    !series.isDirty &&
	                    !xAxis.isDirty &&
	                    !series.yAxis.isDirty &&
	                    !force
	                ) {
	                    return false;
	                }
	
	                if (xAxis) {
	                    xExtremes = xAxis.getExtremes(); // corrected for log axis (#3053)
	                    min = xExtremes.min;
	                    max = xExtremes.max;
	                }
	
	                // optionally filter out points outside the plot area
	                if (
	                    isCartesian &&
	                    series.sorted &&
	                    !getExtremesFromAll &&
	                    (!cropThreshold || dataLength > cropThreshold || series.forceCrop)
	                ) {
	
	                    // it's outside current extremes
	                    if (
	                        processedXData[dataLength - 1] < min ||
	                        processedXData[0] > max
	                    ) {
	                        processedXData = [];
	                        processedYData = [];
	
	                        // only crop if it's actually spilling out
	                    } else if (
	                        processedXData[0] < min ||
	                        processedXData[dataLength - 1] > max
	                    ) {
	                        croppedData = this.cropData(
	                            series.xData,
	                            series.yData,
	                            min,
	                            max
	                        );
	                        processedXData = croppedData.xData;
	                        processedYData = croppedData.yData;
	                        cropStart = croppedData.start;
	                        cropped = true;
	                    }
	                }
	
	
	                // Find the closest distance between processed points
	                i = processedXData.length || 1;
	                while (--i) {
	                    distance = isLog ?
	                        val2lin(processedXData[i]) - val2lin(processedXData[i - 1]) :
	                        processedXData[i] - processedXData[i - 1];
	
	                    if (
	                        distance > 0 &&
	                        (
	                            closestPointRange === undefined ||
	                            distance < closestPointRange
	                        )
	                    ) {
	                        closestPointRange = distance;
	
	                        // Unsorted data is not supported by the line tooltip, as well as
	                        // data grouping and navigation in Stock charts (#725) and width
	                        // calculation of columns (#1900)
	                    } else if (distance < 0 && series.requireSorting) {
	                        H.error(15);
	                    }
	                }
	
	                // Record the properties
	                series.cropped = cropped; // undefined or true
	                series.cropStart = cropStart;
	                series.processedXData = processedXData;
	                series.processedYData = processedYData;
	
	                series.closestPointRange = closestPointRange;
	
	            },
	
	            /**
	             * Iterate over xData and crop values between min and max. Returns object
	             * containing crop start/end cropped xData with corresponding part of yData,
	             * dataMin and dataMax within the cropped range.
	             *
	             * @private
	             */
	            cropData: function(xData, yData, min, max) {
	                var dataLength = xData.length,
	                    cropStart = 0,
	                    cropEnd = dataLength,
	                    // line-type series need one point outside
	                    cropShoulder = pick(this.cropShoulder, 1),
	                    i,
	                    j;
	
	                // iterate up to find slice start
	                for (i = 0; i < dataLength; i++) {
	                    if (xData[i] >= min) {
	                        cropStart = Math.max(0, i - cropShoulder);
	                        break;
	                    }
	                }
	
	                // proceed to find slice end
	                for (j = i; j < dataLength; j++) {
	                    if (xData[j] > max) {
	                        cropEnd = j + cropShoulder;
	                        break;
	                    }
	                }
	
	                return {
	                    xData: xData.slice(cropStart, cropEnd),
	                    yData: yData.slice(cropStart, cropEnd),
	                    start: cropStart,
	                    end: cropEnd
	                };
	            },
	
	
	            /**
	             * Generate the data point after the data has been processed by cropping
	             * away unused points and optionally grouped in Highcharts Stock.
	             *
	             * @private
	             */
	            generatePoints: function() {
	                var series = this,
	                    options = series.options,
	                    dataOptions = options.data,
	                    data = series.data,
	                    dataLength,
	                    processedXData = series.processedXData,
	                    processedYData = series.processedYData,
	                    PointClass = series.pointClass,
	                    processedDataLength = processedXData.length,
	                    cropStart = series.cropStart || 0,
	                    cursor,
	                    hasGroupedData = series.hasGroupedData,
	                    keys = options.keys,
	                    point,
	                    points = [],
	                    i;
	
	                if (!data && !hasGroupedData) {
	                    var arr = [];
	                    arr.length = dataOptions.length;
	                    data = series.data = arr;
	                }
	
	                if (keys && hasGroupedData) {
	                    // grouped data has already applied keys (#6590)
	                    series.options.keys = false;
	                }
	
	                for (i = 0; i < processedDataLength; i++) {
	                    cursor = cropStart + i;
	                    if (!hasGroupedData) {
	                        point = data[cursor];
	                        if (!point && dataOptions[cursor] !== undefined) { // #970
	                            data[cursor] = point = (new PointClass()).init(
	                                series,
	                                dataOptions[cursor],
	                                processedXData[i]
	                            );
	                        }
	                    } else {
	                        // splat the y data in case of ohlc data array
	                        point = (new PointClass()).init(
	                            series, [processedXData[i]].concat(splat(processedYData[i]))
	                        );
	
	                        /**
	                         * Highstock only. If a point object is created by data
	                         * grouping, it doesn't reflect actual points in the raw data.
	                         * In this case, the `dataGroup` property holds information
	                         * that points back to the raw data.
	                         *
	                         * - `dataGroup.start` is the index of the first raw data point
	                         * in the group.
	                         * - `dataGroup.length` is the amount of points in the group.
	                         *
	                         * @name dataGroup
	                         * @memberOf Point
	                         * @type {Object}
	                         *
	                         */
	                        point.dataGroup = series.groupMap[i];
	                    }
	                    if (point) { // #6279
	                        point.index = cursor; // For faster access in Point.update
	                        points[i] = point;
	                    }
	                }
	
	                // restore keys options (#6590)
	                series.options.keys = keys;
	
	                // Hide cropped-away points - this only runs when the number of points
	                // is above cropThreshold, or when swithching view from non-grouped
	                // data to grouped data (#637)
	                if (
	                    data &&
	                    (
	                        processedDataLength !== (dataLength = data.length) ||
	                        hasGroupedData
	                    )
	                ) {
	                    for (i = 0; i < dataLength; i++) {
	                        // when has grouped data, clear all points
	                        if (i === cropStart && !hasGroupedData) {
	                            i += processedDataLength;
	                        }
	                        if (data[i]) {
	                            data[i].destroyElements();
	                            data[i].plotX = undefined; // #1003
	                        }
	                    }
	                }
	
	                /**
	                 * Read only. An array containing the series' data point objects. To
	                 * modify the data, use {@link Highcharts.Series#setData} or {@link
	                 * Highcharts.Point#update}.
	                 *
	                 * @name data
	                 * @memberOf Highcharts.Series
	                 * @type {Array.<Highcharts.Point>}
	                 */
	                series.data = data;
	
	                /**
	                 * An array containing all currently visible point objects. In case of
	                 * cropping, the cropped-away points are not part of this array. The
	                 * `series.points` array starts at `series.cropStart` compared to
	                 * `series.data` and `series.options.data`. If however the series data
	                 * is grouped, these can't be correlated one to one. To
	                 * modify the data, use {@link Highcharts.Series#setData} or {@link
	                 * Highcharts.Point#update}.
	                 * @name point
	                 * @memberof Series
	                 * @type {Array.<Point>}
	                 */
	                series.points = points;
	            },
	
	            /**
	             * Calculate Y extremes for the visible data. The result is set as 
	             * `dataMin` and `dataMax` on the Series item.
	             *
	             * @param  {Array.<Number>} [yData]
	             *         The data to inspect. Defaults to the current data within the
	             *         visible range.
	             * 
	             */
	            getExtremes: function(yData) {
	                var xAxis = this.xAxis,
	                    yAxis = this.yAxis,
	                    xData = this.processedXData,
	                    yDataLength,
	                    activeYData = [],
	                    activeCounter = 0,
	                    // #2117, need to compensate for log X axis
	                    xExtremes = xAxis.getExtremes(),
	                    xMin = xExtremes.min,
	                    xMax = xExtremes.max,
	                    validValue,
	                    withinRange,
	                    x,
	                    y,
	                    i,
	                    j;
	
	                yData = yData || this.stackedYData || this.processedYData || [];
	                yDataLength = yData.length;
	
	                for (i = 0; i < yDataLength; i++) {
	
	                    x = xData[i];
	                    y = yData[i];
	
	                    // For points within the visible range, including the first point
	                    // outside the visible range, consider y extremes
	                    validValue =
	                        (isNumber(y, true) || isArray(y)) &&
	                        (!yAxis.positiveValuesOnly || (y.length || y > 0));
	                    withinRange =
	                        this.getExtremesFromAll ||
	                        this.options.getExtremesFromAll ||
	                        this.cropped ||
	                        ((xData[i] || x) >= xMin && (xData[i] || x) <= xMax);
	
	                    if (validValue && withinRange) {
	
	                        j = y.length;
	                        if (j) { // array, like ohlc or range data
	                            while (j--) {
	                                if (y[j] !== null) {
	                                    activeYData[activeCounter++] = y[j];
	                                }
	                            }
	                        } else {
	                            activeYData[activeCounter++] = y;
	                        }
	                    }
	                }
	
	                this.dataMin = arrayMin(activeYData);
	                this.dataMax = arrayMax(activeYData);
	            },
	
	            /**
	             * Translate data points from raw data values to chart specific positioning
	             * data needed later in the `drawPoints` and `drawGraph` functions. This
	             * function can be overridden in plugins and custom series type
	             * implementations.
	             */
	            translate: function() {
	                if (!this.processedXData) { // hidden series
	                    this.processData();
	                }
	                this.generatePoints();
	                var series = this,
	                    options = series.options,
	                    stacking = options.stacking,
	                    xAxis = series.xAxis,
	                    categories = xAxis.categories,
	                    yAxis = series.yAxis,
	                    points = series.points,
	                    dataLength = points.length,
	                    hasModifyValue = !!series.modifyValue,
	                    i,
	                    pointPlacement = options.pointPlacement,
	                    dynamicallyPlaced =
	                    pointPlacement === 'between' ||
	                    isNumber(pointPlacement),
	                    threshold = options.threshold,
	                    stackThreshold = options.startFromThreshold ? threshold : 0,
	                    plotX,
	                    plotY,
	                    lastPlotX,
	                    stackIndicator,
	                    closestPointRangePx = Number.MAX_VALUE;
	
	                // Point placement is relative to each series pointRange (#5889)
	                if (pointPlacement === 'between') {
	                    pointPlacement = 0.5;
	                }
	                if (isNumber(pointPlacement)) {
	                    pointPlacement *= pick(options.pointRange || xAxis.pointRange);
	                }
	
	                // Translate each point
	                for (i = 0; i < dataLength; i++) {
	                    var point = points[i],
	                        xValue = point.x,
	                        yValue = point.y,
	                        yBottom = point.low,
	                        stack = stacking && yAxis.stacks[(
	                            series.negStacks &&
	                            yValue < (stackThreshold ? 0 : threshold) ? '-' : ''
	                        ) + series.stackKey],
	                        pointStack,
	                        stackValues;
	
	                    // Discard disallowed y values for log axes (#3434)
	                    if (yAxis.positiveValuesOnly && yValue !== null && yValue <= 0) {
	                        point.isNull = true;
	                    }
	
	                    // Get the plotX translation
	                    point.plotX = plotX = correctFloat( // #5236
	                        Math.min(Math.max(-1e5, xAxis.translate(
	                            xValue,
	                            0,
	                            0,
	                            0,
	                            1,
	                            pointPlacement,
	                            this.type === 'flags'
	                        )), 1e5) // #3923
	                    );
	
	                    // Calculate the bottom y value for stacked series
	                    if (
	                        stacking &&
	                        series.visible &&
	                        !point.isNull &&
	                        stack &&
	                        stack[xValue]
	                    ) {
	                        stackIndicator = series.getStackIndicator(
	                            stackIndicator,
	                            xValue,
	                            series.index
	                        );
	                        pointStack = stack[xValue];
	                        stackValues = pointStack.points[stackIndicator.key];
	                        yBottom = stackValues[0];
	                        yValue = stackValues[1];
	
	                        if (
	                            yBottom === stackThreshold &&
	                            stackIndicator.key === stack[xValue].base
	                        ) {
	                            yBottom = pick(threshold, yAxis.min);
	                        }
	                        if (yAxis.positiveValuesOnly && yBottom <= 0) { // #1200, #1232
	                            yBottom = null;
	                        }
	
	                        point.total = point.stackTotal = pointStack.total;
	                        point.percentage =
	                            pointStack.total &&
	                            (point.y / pointStack.total * 100);
	                        point.stackY = yValue;
	
	                        // Place the stack label
	                        pointStack.setOffset(
	                            series.pointXOffset || 0,
	                            series.barW || 0
	                        );
	
	                    }
	
	                    // Set translated yBottom or remove it
	                    point.yBottom = defined(yBottom) ?
	                        yAxis.translate(yBottom, 0, 1, 0, 1) :
	                        null;
	
	                    // general hook, used for Highstock compare mode
	                    if (hasModifyValue) {
	                        yValue = series.modifyValue(yValue, point);
	                    }
	
	                    // Set the the plotY value, reset it for redraws
	                    point.plotY = plotY =
	                        (typeof yValue === 'number' && yValue !== Infinity) ?
	                        Math.min(Math.max(-1e5,
	                            yAxis.translate(yValue, 0, 1, 0, 1)), 1e5) : // #3201
	                        undefined;
	
	                    point.isInside =
	                        plotY !== undefined &&
	                        plotY >= 0 &&
	                        plotY <= yAxis.len && // #3519
	                        plotX >= 0 &&
	                        plotX <= xAxis.len;
	
	
	                    // Set client related positions for mouse tracking
	                    point.clientX = dynamicallyPlaced ?
	                        correctFloat(
	                            xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement)
	                        ) :
	                        plotX; // #1514, #5383, #5518
	
	                    point.negative = point.y < (threshold || 0);
	
	                    // some API data
	                    point.category = categories && categories[point.x] !== undefined ?
	                        categories[point.x] : point.x;
	
	                    // Determine auto enabling of markers (#3635, #5099)
	                    if (!point.isNull) {
	                        if (lastPlotX !== undefined) {
	                            closestPointRangePx = Math.min(
	                                closestPointRangePx,
	                                Math.abs(plotX - lastPlotX)
	                            );
	                        }
	                        lastPlotX = plotX;
	                    }
	
	                    // Find point zone
	                    point.zone = this.zones.length && point.getZone();
	                }
	                series.closestPointRangePx = closestPointRangePx;
	            },
	
	            /**
	             * Return the series points with null points filtered out.
	             *
	             * @param  {Array.<Point>} [points]
	             *         The points to inspect, defaults to {@link Series.points}.
	             * @param  {Boolean} [insideOnly=false]
	             *         Whether to inspect only the points that are inside the visible
	             *         view.
	             *
	             * @return {Array.<Point>}
	             *         The valid points.
	             */
	            getValidPoints: function(points, insideOnly) {
	                var chart = this.chart;
	                // #3916, #5029, #5085
	                return grep(points || this.points || [], function isValidPoint(point) {
	                    if (insideOnly && !chart.isInsidePlot(
	                            point.plotX,
	                            point.plotY,
	                            chart.inverted
	                        )) {
	                        return false;
	                    }
	                    return !point.isNull;
	                });
	            },
	
	            /**
	             * Set the clipping for the series. For animated series it is called twice,
	             * first to initiate animating the clip then the second time without the
	             * animation to set the final clip.
	             *
	             * @private
	             */
	            setClip: function(animation) {
	                var chart = this.chart,
	                    options = this.options,
	                    renderer = chart.renderer,
	                    inverted = chart.inverted,
	                    seriesClipBox = this.clipBox,
	                    clipBox = seriesClipBox || chart.clipBox,
	                    sharedClipKey =
	                    this.sharedClipKey || [
	                        '_sharedClip',
	                        animation && animation.duration,
	                        animation && animation.easing,
	                        clipBox.height,
	                        options.xAxis,
	                        options.yAxis
	                    ].join(','), // #4526
	                    clipRect = chart[sharedClipKey],
	                    markerClipRect = chart[sharedClipKey + 'm'];
	
	                // If a clipping rectangle with the same properties is currently present
	                // in the chart, use that.
	                if (!clipRect) {
	
	                    // When animation is set, prepare the initial positions
	                    if (animation) {
	                        clipBox.width = 0;
	
	                        chart[sharedClipKey + 'm'] = markerClipRect = renderer.clipRect(-99, // include the width of the first marker
	                            inverted ? -chart.plotLeft : -chart.plotTop,
	                            99,
	                            inverted ? chart.chartWidth : chart.chartHeight
	                        );
	                    }
	                    chart[sharedClipKey] = clipRect = renderer.clipRect(clipBox);
	                    // Create hashmap for series indexes
	                    clipRect.count = {
	                        length: 0
	                    };
	
	                }
	                if (animation) {
	                    if (!clipRect.count[this.index]) {
	                        clipRect.count[this.index] = true;
	                        clipRect.count.length += 1;
	                    }
	                }
	
	                if (options.clip !== false) {
	                    this.group.clip(animation || seriesClipBox ? clipRect : chart.clipRect);
	                    this.markerGroup.clip(markerClipRect);
	                    this.sharedClipKey = sharedClipKey;
	                }
	
	                // Remove the shared clipping rectangle when all series are shown
	                if (!animation) {
	                    if (clipRect.count[this.index]) {
	                        delete clipRect.count[this.index];
	                        clipRect.count.length -= 1;
	                    }
	
	                    if (clipRect.count.length === 0 && sharedClipKey && chart[sharedClipKey]) {
	                        if (!seriesClipBox) {
	                            chart[sharedClipKey] = chart[sharedClipKey].destroy();
	                        }
	                        if (chart[sharedClipKey + 'm']) {
	                            chart[sharedClipKey + 'm'] = chart[sharedClipKey + 'm'].destroy();
	                        }
	                    }
	                }
	            },
	
	            /**
	             * Animate in the series. Called internally twice. First with the `init`
	             * parameter set to true, which sets up the initial state of the animation.
	             * Then when ready, it is called with the `init` parameter undefined, in 
	             * order to perform the actual animation. After the second run, the function
	             * is removed.
	             *
	             * @param  {Boolean} init
	             *         Initialize the animation.
	             */
	            animate: function(init) {
	                var series = this,
	                    chart = series.chart,
	                    clipRect,
	                    animation = animObject(series.options.animation),
	                    sharedClipKey;
	
	                // Initialize the animation. Set up the clipping rectangle.
	                if (init) {
	
	                    series.setClip(animation);
	
	                    // Run the animation
	                } else {
	                    sharedClipKey = this.sharedClipKey;
	                    clipRect = chart[sharedClipKey];
	                    if (clipRect) {
	                        clipRect.animate({
	                            width: chart.plotSizeX
	                        }, animation);
	                    }
	                    if (chart[sharedClipKey + 'm']) {
	                        chart[sharedClipKey + 'm'].animate({
	                            width: chart.plotSizeX + 99
	                        }, animation);
	                    }
	
	                    // Delete this function to allow it only once
	                    series.animate = null;
	
	                }
	            },
	
	            /**
	             * This runs after animation to land on the final plot clipping.
	             *
	             * @private
	             */
	            afterAnimate: function() {
	                this.setClip();
	                fireEvent(this, 'afterAnimate');
	                this.finishedAnimating = true;
	            },
	
	            /**
	             * Draw the markers for line-like series types, and columns or other
	             * graphical representation for {@link Point} objects for other series
	             * types. The resulting element is typically stored as {@link
	             * Point.graphic}, and is created on the first call and updated and moved on
	             * subsequent calls.
	             */
	            drawPoints: function() {
	                var series = this,
	                    points = series.points,
	                    chart = series.chart,
	                    plotY,
	                    i,
	                    point,
	                    symbol,
	                    graphic,
	                    options = series.options,
	                    seriesMarkerOptions = options.marker,
	                    pointMarkerOptions,
	                    hasPointMarker,
	                    enabled,
	                    isInside,
	                    markerGroup = series[series.specialGroup] || series.markerGroup,
	                    xAxis = series.xAxis,
	                    markerAttribs,
	                    globallyEnabled = pick(
	                        seriesMarkerOptions.enabled,
	                        xAxis.isRadial ? true : null,
	                        // Use larger or equal as radius is null in bubbles (#6321)
	                        series.closestPointRangePx >= 2 * seriesMarkerOptions.radius
	                    );
	
	                if (seriesMarkerOptions.enabled !== false || series._hasPointMarkers) {
	
	                    for (i = 0; i < points.length; i++) {
	                        point = points[i];
	                        plotY = point.plotY;
	                        graphic = point.graphic;
	                        pointMarkerOptions = point.marker || {};
	                        hasPointMarker = !!point.marker;
	                        enabled = (globallyEnabled && pointMarkerOptions.enabled === undefined) || pointMarkerOptions.enabled;
	                        isInside = point.isInside;
	
	                        // only draw the point if y is defined
	                        if (enabled && isNumber(plotY) && point.y !== null) {
	
	                            // Shortcuts
	                            symbol = pick(pointMarkerOptions.symbol, series.symbol);
	                            point.hasImage = symbol.indexOf('url') === 0;
	
	                            markerAttribs = series.markerAttribs(
	                                point,
	                                point.selected && 'select'
	                            );
	
	                            if (graphic) { // update
	                                graphic[isInside ? 'show' : 'hide'](true) // Since the marker group isn't clipped, each individual marker must be toggled
	                                    .animate(markerAttribs);
	                            } else if (isInside && (markerAttribs.width > 0 || point.hasImage)) {
	
	                                /**
	                                 * The graphic representation of the point. Typically
	                                 * this is a simple shape, like a `rect` for column
	                                 * charts or `path` for line markers, but for some 
	                                 * complex series types like boxplot or 3D charts, the
	                                 * graphic may be a `g` element containing other shapes.
	                                 * The graphic is generated the first time {@link
	                                 * Series#drawPoints} runs, and updated and moved on
	                                 * subsequent runs.
	                                 *
	                                 * @memberof Point
	                                 * @name graphic
	                                 * @type {SVGElement}
	                                 */
	                                point.graphic = graphic = chart.renderer.symbol(
	                                        symbol,
	                                        markerAttribs.x,
	                                        markerAttribs.y,
	                                        markerAttribs.width,
	                                        markerAttribs.height,
	                                        hasPointMarker ? pointMarkerOptions : seriesMarkerOptions
	                                    )
	                                    .add(markerGroup);
	                            }
	
	
	                            // Presentational attributes
	                            if (graphic) {
	                                graphic.attr(series.pointAttribs(point, point.selected && 'select'));
	                            }
	
	
	                            if (graphic) {
	                                graphic.addClass(point.getClassName(), true);
	                            }
	
	                        } else if (graphic) {
	                            point.graphic = graphic.destroy(); // #1269
	                        }
	                    }
	                }
	
	            },
	
	            /**
	             * Get non-presentational attributes for a point. Used internally for both
	             * styled mode and classic. Can be overridden for different series types.
	             *
	             * @see    Series#pointAttribs
	             *
	             * @param  {Point} point
	             *         The Point to inspect.
	             * @param  {String} [state]
	             *         The state, can be either `hover`, `select` or undefined.
	             *
	             * @return {SVGAttributes}
	             *         A hash containing those attributes that are not settable from
	             *         CSS.
	             */
	            markerAttribs: function(point, state) {
	                var seriesMarkerOptions = this.options.marker,
	                    seriesStateOptions,
	                    pointMarkerOptions = point.marker || {},
	                    pointStateOptions,
	                    radius = pick(
	                        pointMarkerOptions.radius,
	                        seriesMarkerOptions.radius
	                    ),
	                    attribs;
	
	                // Handle hover and select states
	                if (state) {
	                    seriesStateOptions = seriesMarkerOptions.states[state];
	                    pointStateOptions = pointMarkerOptions.states &&
	                        pointMarkerOptions.states[state];
	
	                    radius = pick(
	                        pointStateOptions && pointStateOptions.radius,
	                        seriesStateOptions && seriesStateOptions.radius,
	                        radius + (seriesStateOptions && seriesStateOptions.radiusPlus || 0)
	                    );
	                }
	
	                if (point.hasImage) {
	                    radius = 0; // and subsequently width and height is not set
	                }
	
	                attribs = {
	                    x: Math.floor(point.plotX) - radius, // Math.floor for #1843
	                    y: point.plotY - radius
	                };
	
	                if (radius) {
	                    attribs.width = attribs.height = 2 * radius;
	                }
	
	                return attribs;
	
	            },
	
	
	            /**
	             * Internal function to get presentational attributes for each point. Unlike
	             * {@link Series#markerAttribs}, this function should return those
	             * attributes that can also be set in CSS. In styled mode, `pointAttribs`
	             * won't be called.
	             *
	             * @param  {Point} point
	             *         The point instance to inspect.
	             * @param  {String} [state]
	             *         The point state, can be either `hover`, `select` or undefined for
	             *         normal state.
	             *
	             * @return {SVGAttributes}
	             *         The presentational attributes to be set on the point.
	             */
	            pointAttribs: function(point, state) {
	                var seriesMarkerOptions = this.options.marker,
	                    seriesStateOptions,
	                    pointOptions = point && point.options,
	                    pointMarkerOptions = (pointOptions && pointOptions.marker) || {},
	                    pointStateOptions,
	                    color = this.color,
	                    pointColorOption = pointOptions && pointOptions.color,
	                    pointColor = point && point.color,
	                    strokeWidth = pick(
	                        pointMarkerOptions.lineWidth,
	                        seriesMarkerOptions.lineWidth
	                    ),
	                    zoneColor = point && point.zone && point.zone.color,
	                    fill,
	                    stroke;
	
	                color = pointColorOption || zoneColor || pointColor || color;
	                fill = pointMarkerOptions.fillColor || seriesMarkerOptions.fillColor || color;
	                stroke = pointMarkerOptions.lineColor || seriesMarkerOptions.lineColor || color;
	
	                // Handle hover and select states
	                if (state) {
	                    seriesStateOptions = seriesMarkerOptions.states[state];
	                    pointStateOptions = (pointMarkerOptions.states && pointMarkerOptions.states[state]) || {};
	                    strokeWidth = pick(
	                        pointStateOptions.lineWidth,
	                        seriesStateOptions.lineWidth,
	                        strokeWidth + pick(
	                            pointStateOptions.lineWidthPlus,
	                            seriesStateOptions.lineWidthPlus,
	                            0
	                        )
	                    );
	                    fill = pointStateOptions.fillColor || seriesStateOptions.fillColor || fill;
	                    stroke = pointStateOptions.lineColor || seriesStateOptions.lineColor || stroke;
	                }
	
	                return {
	                    'stroke': stroke,
	                    'stroke-width': strokeWidth,
	                    'fill': fill
	                };
	            },
	
	            /**
	             * Clear DOM objects and free up memory.
	             *
	             * @private
	             */
	            destroy: function() {
	                var series = this,
	                    chart = series.chart,
	                    issue134 = /AppleWebKit\/533/.test(win.navigator.userAgent),
	                    destroy,
	                    i,
	                    data = series.data || [],
	                    point,
	                    axis;
	
	                // add event hook
	                fireEvent(series, 'destroy');
	
	                // remove all events
	                removeEvent(series);
	
	                // erase from axes
	                each(series.axisTypes || [], function(AXIS) {
	                    axis = series[AXIS];
	                    if (axis && axis.series) {
	                        erase(axis.series, series);
	                        axis.isDirty = axis.forceRedraw = true;
	                    }
	                });
	
	                // remove legend items
	                if (series.legendItem) {
	                    series.chart.legend.destroyItem(series);
	                }
	
	                // destroy all points with their elements
	                i = data.length;
	                while (i--) {
	                    point = data[i];
	                    if (point && point.destroy) {
	                        point.destroy();
	                    }
	                }
	                series.points = null;
	
	                // Clear the animation timeout if we are destroying the series during initial animation
	                clearTimeout(series.animationTimeout);
	
	                // Destroy all SVGElements associated to the series
	                objectEach(series, function(val, prop) {
	                    if (val instanceof SVGElement && !val.survive) { // Survive provides a hook for not destroying
	
	                        // issue 134 workaround
	                        destroy = issue134 && prop === 'group' ?
	                            'hide' :
	                            'destroy';
	
	                        val[destroy]();
	                    }
	                });
	
	                // remove from hoverSeries
	                if (chart.hoverSeries === series) {
	                    chart.hoverSeries = null;
	                }
	                erase(chart.series, series);
	                chart.orderSeries();
	
	                // clear all members
	                objectEach(series, function(val, prop) {
	                    delete series[prop];
	                });
	            },
	
	            /**
	             * Get the graph path.
	             *
	             * @private
	             */
	            getGraphPath: function(points, nullsAsZeroes, connectCliffs) {
	                var series = this,
	                    options = series.options,
	                    step = options.step,
	                    reversed,
	                    graphPath = [],
	                    xMap = [],
	                    gap;
	
	                points = points || series.points;
	
	                // Bottom of a stack is reversed
	                reversed = points.reversed;
	                if (reversed) {
	                    points.reverse();
	                }
	                // Reverse the steps (#5004)
	                step = {
	                    right: 1,
	                    center: 2
	                }[step] || (step && 3);
	                if (step && reversed) {
	                    step = 4 - step;
	                }
	
	                // Remove invalid points, especially in spline (#5015)
	                if (options.connectNulls && !nullsAsZeroes && !connectCliffs) {
	                    points = this.getValidPoints(points);
	                }
	
	                // Build the line
	                each(points, function(point, i) {
	
	                    var plotX = point.plotX,
	                        plotY = point.plotY,
	                        lastPoint = points[i - 1],
	                        pathToPoint; // the path to this point from the previous
	
	                    if ((point.leftCliff || (lastPoint && lastPoint.rightCliff)) && !connectCliffs) {
	                        gap = true; // ... and continue
	                    }
	
	                    // Line series, nullsAsZeroes is not handled
	                    if (point.isNull && !defined(nullsAsZeroes) && i > 0) {
	                        gap = !options.connectNulls;
	
	                        // Area series, nullsAsZeroes is set
	                    } else if (point.isNull && !nullsAsZeroes) {
	                        gap = true;
	
	                    } else {
	
	                        if (i === 0 || gap) {
	                            pathToPoint = ['M', point.plotX, point.plotY];
	
	                        } else if (series.getPointSpline) { // generate the spline as defined in the SplineSeries object
	
	                            pathToPoint = series.getPointSpline(points, point, i);
	
	                        } else if (step) {
	
	                            if (step === 1) { // right
	                                pathToPoint = [
	                                    'L',
	                                    lastPoint.plotX,
	                                    plotY
	                                ];
	
	                            } else if (step === 2) { // center
	                                pathToPoint = [
	                                    'L',
	                                    (lastPoint.plotX + plotX) / 2,
	                                    lastPoint.plotY,
	                                    'L',
	                                    (lastPoint.plotX + plotX) / 2,
	                                    plotY
	                                ];
	
	                            } else {
	                                pathToPoint = [
	                                    'L',
	                                    plotX,
	                                    lastPoint.plotY
	                                ];
	                            }
	                            pathToPoint.push('L', plotX, plotY);
	
	                        } else {
	                            // normal line to next point
	                            pathToPoint = [
	                                'L',
	                                plotX,
	                                plotY
	                            ];
	                        }
	
	                        // Prepare for animation. When step is enabled, there are two path nodes for each x value.
	                        xMap.push(point.x);
	                        if (step) {
	                            xMap.push(point.x);
	                        }
	
	                        graphPath.push.apply(graphPath, pathToPoint);
	                        gap = false;
	                    }
	                });
	
	                graphPath.xMap = xMap;
	                series.graphPath = graphPath;
	
	                return graphPath;
	
	            },
	
	            /**
	             * Draw the graph. Called internally when rendering line-like series types.
	             * The first time it generates the `series.graph` item and optionally other
	             * series-wide items like `series.area` for area charts. On subsequent calls
	             * these items are updated with new positions and attributes.
	             */
	            drawGraph: function() {
	                var series = this,
	                    options = this.options,
	                    graphPath = (this.gappedPath || this.getGraphPath).call(this),
	                    props = [
	                        [
	                            'graph',
	                            'highcharts-graph',
	
	                            options.lineColor || this.color,
	                            options.dashStyle
	
	                        ]
	                    ];
	
	                // Add the zone properties if any
	                each(this.zones, function(zone, i) {
	                    props.push([
	                        'zone-graph-' + i,
	                        'highcharts-graph highcharts-zone-graph-' + i + ' ' + (zone.className || ''),
	
	                        zone.color || series.color,
	                        zone.dashStyle || options.dashStyle
	
	                    ]);
	                });
	
	                // Draw the graph
	                each(props, function(prop, i) {
	                    var graphKey = prop[0],
	                        graph = series[graphKey],
	                        attribs;
	
	                    if (graph) {
	                        graph.endX = graphPath.xMap;
	                        graph.animate({
	                            d: graphPath
	                        });
	
	                    } else if (graphPath.length) { // #1487
	
	                        series[graphKey] = series.chart.renderer.path(graphPath)
	                            .addClass(prop[1])
	                            .attr({
	                                zIndex: 1
	                            }) // #1069
	                            .add(series.group);
	
	
	                        attribs = {
	                            'stroke': prop[2],
	                            'stroke-width': options.lineWidth,
	                            'fill': (series.fillGraph && series.color) || 'none' // Polygon series use filled graph
	                        };
	
	                        if (prop[3]) {
	                            attribs.dashstyle = prop[3];
	                        } else if (options.linecap !== 'square') {
	                            attribs['stroke-linecap'] = attribs['stroke-linejoin'] = 'round';
	                        }
	
	                        graph = series[graphKey]
	                            .attr(attribs)
	                            .shadow((i < 2) && options.shadow); // add shadow to normal series (0) or to first zone (1) #3932
	
	                    }
	
	                    // Helpers for animation
	                    if (graph) {
	                        graph.startX = graphPath.xMap;
	                        //graph.shiftUnit = options.step ? 2 : 1;
	                        graph.isArea = graphPath.isArea; // For arearange animation
	                    }
	                });
	            },
	
	            /**
	             * Clip the graphs into zones for colors and styling.
	             *
	             * @private
	             */
	            applyZones: function() {
	                var series = this,
	                    chart = this.chart,
	                    renderer = chart.renderer,
	                    zones = this.zones,
	                    translatedFrom,
	                    translatedTo,
	                    clips = this.clips || [],
	                    clipAttr,
	                    graph = this.graph,
	                    area = this.area,
	                    chartSizeMax = Math.max(chart.chartWidth, chart.chartHeight),
	                    axis = this[(this.zoneAxis || 'y') + 'Axis'],
	                    extremes,
	                    reversed,
	                    inverted = chart.inverted,
	                    horiz,
	                    pxRange,
	                    pxPosMin,
	                    pxPosMax,
	                    ignoreZones = false;
	
	                if (zones.length && (graph || area) && axis && axis.min !== undefined) {
	                    reversed = axis.reversed;
	                    horiz = axis.horiz;
	                    // The use of the Color Threshold assumes there are no gaps
	                    // so it is safe to hide the original graph and area
	                    if (graph) {
	                        graph.hide();
	                    }
	                    if (area) {
	                        area.hide();
	                    }
	
	                    // Create the clips
	                    extremes = axis.getExtremes();
	                    each(zones, function(threshold, i) {
	
	                        translatedFrom = reversed ?
	                            (horiz ? chart.plotWidth : 0) :
	                            (horiz ? 0 : axis.toPixels(extremes.min));
	                        translatedFrom = Math.min(Math.max(pick(translatedTo, translatedFrom), 0), chartSizeMax);
	                        translatedTo = Math.min(Math.max(Math.round(axis.toPixels(pick(threshold.value, extremes.max), true)), 0), chartSizeMax);
	
	                        if (ignoreZones) {
	                            translatedFrom = translatedTo = axis.toPixels(extremes.max);
	                        }
	
	                        pxRange = Math.abs(translatedFrom - translatedTo);
	                        pxPosMin = Math.min(translatedFrom, translatedTo);
	                        pxPosMax = Math.max(translatedFrom, translatedTo);
	                        if (axis.isXAxis) {
	                            clipAttr = {
	                                x: inverted ? pxPosMax : pxPosMin,
	                                y: 0,
	                                width: pxRange,
	                                height: chartSizeMax
	                            };
	                            if (!horiz) {
	                                clipAttr.x = chart.plotHeight - clipAttr.x;
	                            }
	                        } else {
	                            clipAttr = {
	                                x: 0,
	                                y: inverted ? pxPosMax : pxPosMin,
	                                width: chartSizeMax,
	                                height: pxRange
	                            };
	                            if (horiz) {
	                                clipAttr.y = chart.plotWidth - clipAttr.y;
	                            }
	                        }
	
	
	                        /// VML SUPPPORT
	                        if (inverted && renderer.isVML) {
	                            if (axis.isXAxis) {
	                                clipAttr = {
	                                    x: 0,
	                                    y: reversed ? pxPosMin : pxPosMax,
	                                    height: clipAttr.width,
	                                    width: chart.chartWidth
	                                };
	                            } else {
	                                clipAttr = {
	                                    x: clipAttr.y - chart.plotLeft - chart.spacingBox.x,
	                                    y: 0,
	                                    width: clipAttr.height,
	                                    height: chart.chartHeight
	                                };
	                            }
	                        }
	                        /// END OF VML SUPPORT
	
	
	                        if (clips[i]) {
	                            clips[i].animate(clipAttr);
	                        } else {
	                            clips[i] = renderer.clipRect(clipAttr);
	
	                            if (graph) {
	                                series['zone-graph-' + i].clip(clips[i]);
	                            }
	
	                            if (area) {
	                                series['zone-area-' + i].clip(clips[i]);
	                            }
	                        }
	                        // if this zone extends out of the axis, ignore the others
	                        ignoreZones = threshold.value > extremes.max;
	                    });
	                    this.clips = clips;
	                }
	            },
	
	            /**
	             * Initialize and perform group inversion on series.group and
	             * series.markerGroup.
	             *
	             * @private
	             */
	            invertGroups: function(inverted) {
	                var series = this,
	                    chart = series.chart,
	                    remover;
	
	                function setInvert() {
	                    each(['group', 'markerGroup'], function(groupName) {
	                        if (series[groupName]) {
	
	                            // VML/HTML needs explicit attributes for flipping
	                            if (chart.renderer.isVML) {
	                                series[groupName].attr({
	                                    width: series.yAxis.len,
	                                    height: series.xAxis.len
	                                });
	                            }
	
	                            series[groupName].width = series.yAxis.len;
	                            series[groupName].height = series.xAxis.len;
	                            series[groupName].invert(inverted);
	                        }
	                    });
	                }
	
	                // Pie, go away (#1736)
	                if (!series.xAxis) {
	                    return;
	                }
	
	                // A fixed size is needed for inversion to work
	                remover = addEvent(chart, 'resize', setInvert);
	                addEvent(series, 'destroy', remover);
	
	                // Do it now
	                setInvert(inverted); // do it now
	
	                // On subsequent render and redraw, just do setInvert without setting up events again
	                series.invertGroups = setInvert;
	            },
	
	            /**
	             * General abstraction for creating plot groups like series.group,
	             * series.dataLabelsGroup and series.markerGroup. On subsequent calls, the
	             * group will only be adjusted to the updated plot size.
	             *
	             * @private
	             */
	            plotGroup: function(prop, name, visibility, zIndex, parent) {
	                var group = this[prop],
	                    isNew = !group;
	
	                // Generate it on first call
	                if (isNew) {
	                    this[prop] = group = this.chart.renderer.g()
	                        .attr({
	                            zIndex: zIndex || 0.1 // IE8 and pointer logic use this
	                        })
	                        .add(parent);
	
	                }
	
	                // Add the class names, and replace existing ones as response to
	                // Series.update (#6660)
	                group.addClass(
	                    (
	                        'highcharts-' + name +
	                        ' highcharts-series-' + this.index +
	                        ' highcharts-' + this.type + '-series ' +
	                        'highcharts-color-' + this.colorIndex + ' ' +
	                        (this.options.className || '')
	                    ),
	                    true
	                );
	
	                // Place it on first and subsequent (redraw) calls
	                group.attr({
	                    visibility: visibility
	                })[isNew ? 'attr' : 'animate'](
	                    this.getPlotBox()
	                );
	                return group;
	            },
	
	            /**
	             * Get the translation and scale for the plot area of this series.
	             */
	            getPlotBox: function() {
	                var chart = this.chart,
	                    xAxis = this.xAxis,
	                    yAxis = this.yAxis;
	
	                // Swap axes for inverted (#2339)
	                if (chart.inverted) {
	                    xAxis = yAxis;
	                    yAxis = this.xAxis;
	                }
	                return {
	                    translateX: xAxis ? xAxis.left : chart.plotLeft,
	                    translateY: yAxis ? yAxis.top : chart.plotTop,
	                    scaleX: 1, // #1623
	                    scaleY: 1
	                };
	            },
	
	            /**
	             * Render the graph and markers. Called internally when first rendering and
	             * later when redrawing the chart. This function can be extended in plugins,
	             * but normally shouldn't be called directly.
	             */
	            render: function() {
	                var series = this,
	                    chart = series.chart,
	                    group,
	                    options = series.options,
	                    // Animation doesn't work in IE8 quirks when the group div is
	                    // hidden, and looks bad in other oldIE
	                    animDuration = (!!series.animate &&
	                        chart.renderer.isSVG &&
	                        animObject(options.animation).duration
	                    ),
	                    visibility = series.visible ? 'inherit' : 'hidden', // #2597
	                    zIndex = options.zIndex,
	                    hasRendered = series.hasRendered,
	                    chartSeriesGroup = chart.seriesGroup,
	                    inverted = chart.inverted;
	
	                // the group
	                group = series.plotGroup(
	                    'group',
	                    'series',
	                    visibility,
	                    zIndex,
	                    chartSeriesGroup
	                );
	
	                series.markerGroup = series.plotGroup(
	                    'markerGroup',
	                    'markers',
	                    visibility,
	                    zIndex,
	                    chartSeriesGroup
	                );
	
	                // initiate the animation
	                if (animDuration) {
	                    series.animate(true);
	                }
	
	                // SVGRenderer needs to know this before drawing elements (#1089, #1795)
	                group.inverted = series.isCartesian ? inverted : false;
	
	                // draw the graph if any
	                if (series.drawGraph) {
	                    series.drawGraph();
	                    series.applyZones();
	                }
	
	                /*		each(series.points, function (point) {
	                			if (point.redraw) {
	                				point.redraw();
	                			}
	                		});*/
	
	                // draw the data labels (inn pies they go before the points)
	                if (series.drawDataLabels) {
	                    series.drawDataLabels();
	                }
	
	                // draw the points
	                if (series.visible) {
	                    series.drawPoints();
	                }
	
	
	                // draw the mouse tracking area
	                if (
	                    series.drawTracker &&
	                    series.options.enableMouseTracking !== false
	                ) {
	                    series.drawTracker();
	                }
	
	                // Handle inverted series and tracker groups
	                series.invertGroups(inverted);
	
	                // Initial clipping, must be defined after inverting groups for VML.
	                // Applies to columns etc. (#3839).
	                if (options.clip !== false && !series.sharedClipKey && !hasRendered) {
	                    group.clip(chart.clipRect);
	                }
	
	                // Run the animation
	                if (animDuration) {
	                    series.animate();
	                }
	
	                // Call the afterAnimate function on animation complete (but don't
	                // overwrite the animation.complete option which should be available to
	                // the user).
	                if (!hasRendered) {
	                    series.animationTimeout = syncTimeout(function() {
	                        series.afterAnimate();
	                    }, animDuration);
	                }
	
	                series.isDirty = false; // means data is in accordance with what you see
	                // (See #322) series.isDirty = series.isDirtyData = false; // means
	                // data is in accordance with what you see
	                series.hasRendered = true;
	            },
	
	            /**
	             * Redraw the series. This function is called internally from `chart.redraw`
	             * and normally shouldn't be called directly.
	             *
	             * @private
	             */
	            redraw: function() {
	                var series = this,
	                    chart = series.chart,
	                    // cache it here as it is set to false in render, but used after
	                    wasDirty = series.isDirty || series.isDirtyData,
	                    group = series.group,
	                    xAxis = series.xAxis,
	                    yAxis = series.yAxis;
	
	                // reposition on resize
	                if (group) {
	                    if (chart.inverted) {
	                        group.attr({
	                            width: chart.plotWidth,
	                            height: chart.plotHeight
	                        });
	                    }
	
	                    group.animate({
	                        translateX: pick(xAxis && xAxis.left, chart.plotLeft),
	                        translateY: pick(yAxis && yAxis.top, chart.plotTop)
	                    });
	                }
	
	                series.translate();
	                series.render();
	                if (wasDirty) { // #3868, #3945
	                    delete this.kdTree;
	                }
	            },
	
	            kdAxisArray: ['clientX', 'plotY'],
	
	            searchPoint: function(e, compareX) {
	                var series = this,
	                    xAxis = series.xAxis,
	                    yAxis = series.yAxis,
	                    inverted = series.chart.inverted;
	
	                return this.searchKDTree({
	                    clientX: inverted ?
	                        xAxis.len - e.chartY + xAxis.pos : e.chartX - xAxis.pos,
	                    plotY: inverted ?
	                        yAxis.len - e.chartX + yAxis.pos : e.chartY - yAxis.pos
	                }, compareX);
	            },
	
	            /**
	             * Build the k-d-tree that is used by mouse and touch interaction to get the
	             * closest point. Line-like series typically have a one-dimensional tree
	             * where points are searched along the X axis, while scatter-like series
	             * typically search in two dimensions, X and Y.
	             *
	             * @private
	             */
	            buildKDTree: function() {
	
	                // Prevent multiple k-d-trees from being built simultaneously (#6235)
	                this.buildingKdTree = true;
	
	                var series = this,
	                    dimensions = series.options.findNearestPointBy.indexOf('y') > -1 ?
	                    2 : 1;
	
	                // Internal function
	                function _kdtree(points, depth, dimensions) {
	                    var axis,
	                        median,
	                        length = points && points.length;
	
	                    if (length) {
	
	                        // alternate between the axis
	                        axis = series.kdAxisArray[depth % dimensions];
	
	                        // sort point array
	                        points.sort(function(a, b) {
	                            return a[axis] - b[axis];
	                        });
	
	                        median = Math.floor(length / 2);
	
	                        // build and return nod
	                        return {
	                            point: points[median],
	                            left: _kdtree(
	                                points.slice(0, median), depth + 1, dimensions
	                            ),
	                            right: _kdtree(
	                                points.slice(median + 1), depth + 1, dimensions
	                            )
	                        };
	
	                    }
	                }
	
	                // Start the recursive build process with a clone of the points array
	                // and null points filtered out (#3873)
	                function startRecursive() {
	                    series.kdTree = _kdtree(
	                        series.getValidPoints(
	                            null,
	                            // For line-type series restrict to plot area, but
	                            // column-type series not (#3916, #4511)
	                            !series.directTouch
	                        ),
	                        dimensions,
	                        dimensions
	                    );
	                    series.buildingKdTree = false;
	                }
	                delete series.kdTree;
	
	                // For testing tooltips, don't build async
	                syncTimeout(startRecursive, series.options.kdNow ? 0 : 1);
	            },
	
	            searchKDTree: function(point, compareX) {
	                var series = this,
	                    kdX = this.kdAxisArray[0],
	                    kdY = this.kdAxisArray[1],
	                    kdComparer = compareX ? 'distX' : 'dist',
	                    kdDimensions = series.options.findNearestPointBy.indexOf('y') > -1 ?
	                    2 : 1;
	
	                // Set the one and two dimensional distance on the point object
	                function setDistance(p1, p2) {
	                    var x = (defined(p1[kdX]) && defined(p2[kdX])) ?
	                        Math.pow(p1[kdX] - p2[kdX], 2) :
	                        null,
	                        y = (defined(p1[kdY]) && defined(p2[kdY])) ?
	                        Math.pow(p1[kdY] - p2[kdY], 2) :
	                        null,
	                        r = (x || 0) + (y || 0);
	
	                    p2.dist = defined(r) ? Math.sqrt(r) : Number.MAX_VALUE;
	                    p2.distX = defined(x) ? Math.sqrt(x) : Number.MAX_VALUE;
	                }
	
	                function _search(search, tree, depth, dimensions) {
	                    var point = tree.point,
	                        axis = series.kdAxisArray[depth % dimensions],
	                        tdist,
	                        sideA,
	                        sideB,
	                        ret = point,
	                        nPoint1,
	                        nPoint2;
	
	                    setDistance(search, point);
	
	                    // Pick side based on distance to splitting point
	                    tdist = search[axis] - point[axis];
	                    sideA = tdist < 0 ? 'left' : 'right';
	                    sideB = tdist < 0 ? 'right' : 'left';
	
	                    // End of tree
	                    if (tree[sideA]) {
	                        nPoint1 = _search(search, tree[sideA], depth + 1, dimensions);
	
	                        ret = (nPoint1[kdComparer] < ret[kdComparer] ? nPoint1 : point);
	                    }
	                    if (tree[sideB]) {
	                        // compare distance to current best to splitting point to decide
	                        // wether to check side B or not
	                        if (Math.sqrt(tdist * tdist) < ret[kdComparer]) {
	                            nPoint2 = _search(
	                                search,
	                                tree[sideB],
	                                depth + 1,
	                                dimensions
	                            );
	                            ret = nPoint2[kdComparer] < ret[kdComparer] ?
	                                nPoint2 :
	                                ret;
	                        }
	                    }
	
	                    return ret;
	                }
	
	                if (!this.kdTree && !this.buildingKdTree) {
	                    this.buildKDTree();
	                }
	
	                if (this.kdTree) {
	                    return _search(point, this.kdTree, kdDimensions, kdDimensions);
	                }
	            }
	
	        }); // end Series prototype
	
	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var addEvent = H.addEvent,
	            animate = H.animate,
	            Axis = H.Axis,
	            Chart = H.Chart,
	            createElement = H.createElement,
	            css = H.css,
	            defined = H.defined,
	            each = H.each,
	            erase = H.erase,
	            extend = H.extend,
	            fireEvent = H.fireEvent,
	            inArray = H.inArray,
	            isNumber = H.isNumber,
	            isObject = H.isObject,
	            isArray = H.isArray,
	            merge = H.merge,
	            objectEach = H.objectEach,
	            pick = H.pick,
	            Point = H.Point,
	            Series = H.Series,
	            seriesTypes = H.seriesTypes,
	            setAnimation = H.setAnimation,
	            splat = H.splat;
	
	        // Extend the Chart prototype for dynamic methods
	        extend(Chart.prototype, /** @lends Highcharts.Chart.prototype */ {
	
	            /**
	             * Add a series to the chart after render time. Note that this method should
	             * never be used when adding data synchronously at chart render time, as it
	             * adds expense to the calculations and rendering. When adding data at the
	             * same time as the chart is initialized, add the series as a configuration
	             * option instead. With multiple axes, the `offset` is dynamically adjusted.
	             *
	             * @param  {SeriesOptions} options
	             *         The config options for the series.
	             * @param  {Boolean} [redraw=true]
	             *         Whether to redraw the chart after adding.
	             * @param  {AnimationOptions} animation
	             *         Whether to apply animation, and optionally animation
	             *         configuration.
	             *
	             * @return {Highcharts.Series}
	             *         The newly created series object.
	             *
	             * @sample highcharts/members/chart-addseries/
	             *         Add a series from a button
	             * @sample stock/members/chart-addseries/
	             *         Add a series in Highstock
	             */
	            addSeries: function(options, redraw, animation) {
	                var series,
	                    chart = this;
	
	                if (options) {
	                    redraw = pick(redraw, true); // defaults to true
	
	                    fireEvent(chart, 'addSeries', {
	                        options: options
	                    }, function() {
	                        series = chart.initSeries(options);
	
	                        chart.isDirtyLegend = true; // the series array is out of sync with the display
	                        chart.linkSeries();
	                        if (redraw) {
	                            chart.redraw(animation);
	                        }
	                    });
	                }
	
	                return series;
	            },
	
	            /**
	             * Add an axis to the chart after render time. Note that this method should
	             * never be used when adding data synchronously at chart render time, as it
	             * adds expense to the calculations and rendering. When adding data at the
	             * same time as the chart is initialized, add the axis as a configuration
	             * option instead.
	             * @param  {AxisOptions} options
	             *         The axis options.
	             * @param  {Boolean} [isX=false]
	             *         Whether it is an X axis or a value axis.
	             * @param  {Boolean} [redraw=true]
	             *         Whether to redraw the chart after adding.
	             * @param  {AnimationOptions} [animation=true]
	             *         Whether and how to apply animation in the redraw.
	             *
	             * @sample highcharts/members/chart-addaxis/ Add and remove axes
	             *
	             * @return {Axis}
	             *         The newly generated Axis object.
	             */
	            addAxis: function(options, isX, redraw, animation) {
	                var key = isX ? 'xAxis' : 'yAxis',
	                    chartOptions = this.options,
	                    userOptions = merge(options, {
	                        index: this[key].length,
	                        isX: isX
	                    }),
	                    axis;
	
	                axis = new Axis(this, userOptions);
	
	                // Push the new axis options to the chart options
	                chartOptions[key] = splat(chartOptions[key] || {});
	                chartOptions[key].push(userOptions);
	
	                if (pick(redraw, true)) {
	                    this.redraw(animation);
	                }
	
	                return axis;
	            },
	
	            /**
	             * Dim the chart and show a loading text or symbol. Options for the loading
	             * screen are defined in {@link
	             * https://api.highcharts.com/highcharts/loading|the loading options}.
	             * 
	             * @param  {String} str
	             *         An optional text to show in the loading label instead of the
	             *         default one. The default text is set in {@link
	             *         http://api.highcharts.com/highcharts/lang.loading|lang.loading}.
	             *
	             * @sample highcharts/members/chart-hideloading/
	             *         Show and hide loading from a button
	             * @sample highcharts/members/chart-showloading/
	             *         Apply different text labels
	             * @sample stock/members/chart-show-hide-loading/
	             *         Toggle loading in Highstock
	             */
	            showLoading: function(str) {
	                var chart = this,
	                    options = chart.options,
	                    loadingDiv = chart.loadingDiv,
	                    loadingOptions = options.loading,
	                    setLoadingSize = function() {
	                        if (loadingDiv) {
	                            css(loadingDiv, {
	                                left: chart.plotLeft + 'px',
	                                top: chart.plotTop + 'px',
	                                width: chart.plotWidth + 'px',
	                                height: chart.plotHeight + 'px'
	                            });
	                        }
	                    };
	
	                // create the layer at the first call
	                if (!loadingDiv) {
	                    chart.loadingDiv = loadingDiv = createElement('div', {
	                        className: 'highcharts-loading highcharts-loading-hidden'
	                    }, null, chart.container);
	
	                    chart.loadingSpan = createElement(
	                        'span', {
	                            className: 'highcharts-loading-inner'
	                        },
	                        null,
	                        loadingDiv
	                    );
	                    addEvent(chart, 'redraw', setLoadingSize); // #1080
	                }
	
	                loadingDiv.className = 'highcharts-loading';
	
	                // Update text
	                chart.loadingSpan.innerHTML = str || options.lang.loading;
	
	
	                // Update visuals
	                css(loadingDiv, extend(loadingOptions.style, {
	                    zIndex: 10
	                }));
	                css(chart.loadingSpan, loadingOptions.labelStyle);
	
	                // Show it
	                if (!chart.loadingShown) {
	                    css(loadingDiv, {
	                        opacity: 0,
	                        display: ''
	                    });
	                    animate(loadingDiv, {
	                        opacity: loadingOptions.style.opacity || 0.5
	                    }, {
	                        duration: loadingOptions.showDuration || 0
	                    });
	                }
	
	
	                chart.loadingShown = true;
	                setLoadingSize();
	            },
	
	            /**
	             * Hide the loading layer.
	             *
	             * @see    Highcharts.Chart#showLoading
	             * @sample highcharts/members/chart-hideloading/
	             *         Show and hide loading from a button
	             * @sample stock/members/chart-show-hide-loading/
	             *         Toggle loading in Highstock
	             */
	            hideLoading: function() {
	                var options = this.options,
	                    loadingDiv = this.loadingDiv;
	
	                if (loadingDiv) {
	                    loadingDiv.className = 'highcharts-loading highcharts-loading-hidden';
	
	                    animate(loadingDiv, {
	                        opacity: 0
	                    }, {
	                        duration: options.loading.hideDuration || 100,
	                        complete: function() {
	                            css(loadingDiv, {
	                                display: 'none'
	                            });
	                        }
	                    });
	
	                }
	                this.loadingShown = false;
	            },
	
	            /** 
	             * These properties cause isDirtyBox to be set to true when updating. Can be extended from plugins.
	             */
	            propsRequireDirtyBox: ['backgroundColor', 'borderColor', 'borderWidth', 'margin', 'marginTop', 'marginRight',
	                'marginBottom', 'marginLeft', 'spacing', 'spacingTop', 'spacingRight', 'spacingBottom', 'spacingLeft',
	                'borderRadius', 'plotBackgroundColor', 'plotBackgroundImage', 'plotBorderColor', 'plotBorderWidth',
	                'plotShadow', 'shadow'
	            ],
	
	            /** 
	             * These properties cause all series to be updated when updating. Can be
	             * extended from plugins.
	             */
	            propsRequireUpdateSeries: ['chart.inverted', 'chart.polar',
	                'chart.ignoreHiddenSeries', 'chart.type', 'colors', 'plotOptions',
	                'tooltip'
	            ],
	
	            /**
	             * A generic function to update any element of the chart. Elements can be
	             * enabled and disabled, moved, re-styled, re-formatted etc.
	             *
	             * A special case is configuration objects that take arrays, for example
	             * {@link https://api.highcharts.com/highcharts/xAxis|xAxis}, 
	             * {@link https://api.highcharts.com/highcharts/yAxis|yAxis} or 
	             * {@link https://api.highcharts.com/highcharts/series|series}. For these
	             * collections, an `id` option is used to map the new option set to an
	             * existing object. If an existing object of the same id is not found, the
	             * corresponding item is updated. So for example, running `chart.update`
	             * with a series item without an id, will cause the existing chart's series
	             * with the same index in the series array to be updated. When the
	             * `oneToOne` parameter is true, `chart.update` will also take care of
	             * adding and removing items from the collection. Read more under the
	             * parameter description below.
	             *
	             * See also the {@link https://api.highcharts.com/highcharts/responsive|
	             * responsive option set}. Switching between `responsive.rules` basically
	             * runs `chart.update` under the hood.
	             *
	             * @param  {Options} options
	             *         A configuration object for the new chart options.
	             * @param  {Boolean} [redraw=true]
	             *         Whether to redraw the chart.
	             * @param  {Boolean} [oneToOne=false]
	             *         When `true`, the `series`, `xAxis` and `yAxis` collections will
	             *         be updated one to one, and items will be either added or removed
	             *         to match the new updated options. For example, if the chart has
	             *         two series and we call `chart.update` with a configuration 
	             *         containing three series, one will be added. If we call
	             *         `chart.update` with one series, one will be removed. Setting an
	             *         empty `series` array will remove all series, but leaving out the
	             *         `series` property will leave all series untouched. If the series
	             *         have id's, the new series options will be matched by id, and the
	             *         remaining ones removed.
	             *
	             * @sample highcharts/members/chart-update/
	             *         Update chart geometry 
	             */
	            update: function(options, redraw, oneToOne) {
	                var chart = this,
	                    adders = {
	                        credits: 'addCredits',
	                        title: 'setTitle',
	                        subtitle: 'setSubtitle'
	                    },
	                    optionsChart = options.chart,
	                    updateAllAxes,
	                    updateAllSeries,
	                    newWidth,
	                    newHeight,
	                    itemsForRemoval = [];
	
	                // If the top-level chart option is present, some special updates are required		
	                if (optionsChart) {
	                    merge(true, chart.options.chart, optionsChart);
	
	                    // Setter function
	                    if ('className' in optionsChart) {
	                        chart.setClassName(optionsChart.className);
	                    }
	
	                    if ('inverted' in optionsChart || 'polar' in optionsChart) {
	                        // Parse options.chart.inverted and options.chart.polar together
	                        // with the available series.
	                        chart.propFromSeries();
	                        updateAllAxes = true;
	                    }
	
	                    if ('alignTicks' in optionsChart) { // #6452
	                        updateAllAxes = true;
	                    }
	
	                    objectEach(optionsChart, function(val, key) {
	                        if (inArray('chart.' + key, chart.propsRequireUpdateSeries) !== -1) {
	                            updateAllSeries = true;
	                        }
	                        // Only dirty box
	                        if (inArray(key, chart.propsRequireDirtyBox) !== -1) {
	                            chart.isDirtyBox = true;
	                        }
	                    });
	
	
	                    if ('style' in optionsChart) {
	                        chart.renderer.setStyle(optionsChart.style);
	                    }
	
	                }
	
	                // Moved up, because tooltip needs updated plotOptions (#6218)
	
	                if (options.colors) {
	                    this.options.colors = options.colors;
	                }
	
	
	                if (options.plotOptions) {
	                    merge(true, this.options.plotOptions, options.plotOptions);
	                }
	
	                // Some option stuctures correspond one-to-one to chart objects that
	                // have update methods, for example
	                // options.credits => chart.credits
	                // options.legend => chart.legend
	                // options.title => chart.title
	                // options.tooltip => chart.tooltip
	                // options.subtitle => chart.subtitle
	                // options.mapNavigation => chart.mapNavigation
	                // options.navigator => chart.navigator
	                // options.scrollbar => chart.scrollbar
	                objectEach(options, function(val, key) {
	                    if (chart[key] && typeof chart[key].update === 'function') {
	                        chart[key].update(val, false);
	
	                        // If a one-to-one object does not exist, look for an adder function
	                    } else if (typeof chart[adders[key]] === 'function') {
	                        chart[adders[key]](val);
	                    }
	
	                    if (
	                        key !== 'chart' &&
	                        inArray(key, chart.propsRequireUpdateSeries) !== -1
	                    ) {
	                        updateAllSeries = true;
	                    }
	                });
	
	                // Setters for collections. For axes and series, each item is referred
	                // by an id. If the id is not found, it defaults to the corresponding
	                // item in the collection, so setting one series without an id, will
	                // update the first series in the chart. Setting two series without
	                // an id will update the first and the second respectively (#6019)
	                // chart.update and responsive.
	                each([
	                    'xAxis',
	                    'yAxis',
	                    'zAxis',
	                    'series',
	                    'colorAxis',
	                    'pane'
	                ], function(coll) {
	                    if (options[coll]) {
	                        each(splat(options[coll]), function(newOptions, i) {
	                            var item = (
	                                defined(newOptions.id) &&
	                                chart.get(newOptions.id)
	                            ) || chart[coll][i];
	                            if (item && item.coll === coll) {
	                                item.update(newOptions, false);
	
	                                if (oneToOne) {
	                                    item.touched = true;
	                                }
	                            }
	
	                            // If oneToOne and no matching item is found, add one
	                            if (!item && oneToOne) {
	                                if (coll === 'series') {
	                                    chart.addSeries(newOptions, false)
	                                        .touched = true;
	                                } else if (coll === 'xAxis' || coll === 'yAxis') {
	                                    chart.addAxis(newOptions, coll === 'xAxis', false)
	                                        .touched = true;
	                                }
	                            }
	
	                        });
	
	                        // Add items for removal
	                        if (oneToOne) {
	                            each(chart[coll], function(item) {
	                                if (!item.touched) {
	                                    itemsForRemoval.push(item);
	                                } else {
	                                    delete item.touched;
	                                }
	                            });
	                        }
	
	
	                    }
	                });
	
	                each(itemsForRemoval, function(item) {
	                    item.remove(false);
	                });
	
	                if (updateAllAxes) {
	                    each(chart.axes, function(axis) {
	                        axis.update({}, false);
	                    });
	                }
	
	                // Certain options require the whole series structure to be thrown away
	                // and rebuilt
	                if (updateAllSeries) {
	                    each(chart.series, function(series) {
	                        series.update({}, false);
	                    });
	                }
	
	                // For loading, just update the options, do not redraw
	                if (options.loading) {
	                    merge(true, chart.options.loading, options.loading);
	                }
	
	                // Update size. Redraw is forced.
	                newWidth = optionsChart && optionsChart.width;
	                newHeight = optionsChart && optionsChart.height;
	                if ((isNumber(newWidth) && newWidth !== chart.chartWidth) ||
	                    (isNumber(newHeight) && newHeight !== chart.chartHeight)) {
	                    chart.setSize(newWidth, newHeight);
	                } else if (pick(redraw, true)) {
	                    chart.redraw();
	                }
	            },
	
	            /**
	             * Shortcut to set the subtitle options. This can also be done from {@link
	             * Chart#update} or {@link Chart#setTitle}.
	             *
	             * @param  {SubtitleOptions} options
	             *         New subtitle options. The subtitle text itself is set by the
	             *         `options.text` property.
	             */
	            setSubtitle: function(options) {
	                this.setTitle(undefined, options);
	            }
	
	
	        });
	
	        // extend the Point prototype for dynamic methods
	        extend(Point.prototype, /** @lends Highcharts.Point.prototype */ {
	            /**
	             * Update point with new options (typically x/y data) and optionally redraw
	             * the series.
	             *
	             * @param  {Object} options
	             *         The point options. Point options are handled as described under
	             *         the `series<type>.data` item for each series type. For example
	             *         for a line series, if options is a single number, the point will
	             *         be given that number as the main y value. If it is an array, it
	             *         will be interpreted as x and y values respectively. If it is an
	             *         object, advanced options are applied. 
	             * @param  {Boolean} [redraw=true]
	             *          Whether to redraw the chart after the point is updated. If doing
	             *          more operations on the chart, it is best practice to set
	             *          `redraw` to false and call `chart.redraw()` after.
	             * @param  {AnimationOptions} [animation=true]
	             *         Whether to apply animation, and optionally animation
	             *         configuration.
	             *
	             * @sample highcharts/members/point-update-column/
	             *         Update column value
	             * @sample highcharts/members/point-update-pie/
	             *         Update pie slice
	             * @sample maps/members/point-update/
	             *         Update map area value in Highmaps
	             */
	            update: function(options, redraw, animation, runEvent) {
	                var point = this,
	                    series = point.series,
	                    graphic = point.graphic,
	                    i,
	                    chart = series.chart,
	                    seriesOptions = series.options;
	
	                redraw = pick(redraw, true);
	
	                function update() {
	
	                    point.applyOptions(options);
	
	                    // Update visuals
	                    if (point.y === null && graphic) { // #4146
	                        point.graphic = graphic.destroy();
	                    }
	                    if (isObject(options, true)) {
	                        // Destroy so we can get new elements
	                        if (graphic && graphic.element) {
	                            // "null" is also a valid symbol
	                            if (options && options.marker && options.marker.symbol !== undefined) {
	                                point.graphic = graphic.destroy();
	                            }
	                        }
	                        if (options && options.dataLabels && point.dataLabel) { // #2468
	                            point.dataLabel = point.dataLabel.destroy();
	                        }
	                    }
	
	                    // record changes in the parallel arrays
	                    i = point.index;
	                    series.updateParallelArrays(point, i);
	
	                    // Record the options to options.data. If the old or the new config
	                    // is an object, use point options, otherwise use raw options
	                    // (#4701, #4916).
	                    seriesOptions.data[i] = (
	                            isObject(seriesOptions.data[i], true) ||
	                            isObject(options, true)
	                        ) ?
	                        point.options :
	                        options;
	
	                    // redraw
	                    series.isDirty = series.isDirtyData = true;
	                    if (!series.fixedBox && series.hasCartesianSeries) { // #1906, #2320
	                        chart.isDirtyBox = true;
	                    }
	
	                    if (seriesOptions.legendType === 'point') { // #1831, #1885
	                        chart.isDirtyLegend = true;
	                    }
	                    if (redraw) {
	                        chart.redraw(animation);
	                    }
	                }
	
	                // Fire the event with a default handler of doing the update
	                if (runEvent === false) { // When called from setData
	                    update();
	                } else {
	                    point.firePointEvent('update', {
	                        options: options
	                    }, update);
	                }
	            },
	
	            /**
	             * Remove a point and optionally redraw the series and if necessary the axes
	             * @param  {Boolean} redraw
	             *         Whether to redraw the chart or wait for an explicit call. When
	             *         doing more operations on the chart, for example running
	             *         `point.remove()` in a loop, it is best practice to set `redraw`
	             *         to false and call `chart.redraw()` after.         
	             * @param  {AnimationOptions} [animation=false]
	             *         Whether to apply animation, and optionally animation
	             *         configuration.
	             *
	             * @sample highcharts/plotoptions/series-point-events-remove/
	             *         Remove point and confirm
	             * @sample highcharts/members/point-remove/
	             *         Remove pie slice
	             * @sample maps/members/point-remove/
	             *         Remove selected points in Highmaps
	             */
	            remove: function(redraw, animation) {
	                this.series.removePoint(inArray(this, this.series.data), redraw, animation);
	            }
	        });
	
	        // Extend the series prototype for dynamic methods
	        extend(Series.prototype, /** @lends Series.prototype */ {
	            /**
	             * Add a point to the series after render time. The point can be added at
	             * the end, or by giving it an X value, to the start or in the middle of the
	             * series.
	             * 
	             * @param  {Number|Array|Object} options
	             *         The point options. If options is a single number, a point with
	             *         that y value is appended to the series.If it is an array, it will
	             *         be interpreted as x and y values respectively. If it is an
	             *         object, advanced options as outlined under `series.data` are
	             *         applied.
	             * @param  {Boolean} [redraw=true]
	             *         Whether to redraw the chart after the point is added. When adding
	             *         more than one point, it is highly recommended that the redraw
	             *         option be set to false, and instead {@link Chart#redraw}
	             *         is explicitly called after the adding of points is finished.
	             *         Otherwise, the chart will redraw after adding each point.
	             * @param  {Boolean} [shift=false]
	             *         If true, a point is shifted off the start of the series as one is
	             *         appended to the end.
	             * @param  {AnimationOptions} [animation]
	             *         Whether to apply animation, and optionally animation
	             *         configuration.
	             *
	             * @sample highcharts/members/series-addpoint-append/
	             *         Append point
	             * @sample highcharts/members/series-addpoint-append-and-shift/
	             *         Append and shift
	             * @sample highcharts/members/series-addpoint-x-and-y/
	             *         Both X and Y values given
	             * @sample highcharts/members/series-addpoint-pie/
	             *         Append pie slice
	             * @sample stock/members/series-addpoint/
	             *         Append 100 points in Highstock
	             * @sample stock/members/series-addpoint-shift/
	             *         Append and shift in Highstock
	             * @sample maps/members/series-addpoint/
	             *         Add a point in Highmaps
	             */
	            addPoint: function(options, redraw, shift, animation) {
	                var series = this,
	                    seriesOptions = series.options,
	                    data = series.data,
	                    chart = series.chart,
	                    xAxis = series.xAxis,
	                    names = xAxis && xAxis.hasNames && xAxis.names,
	                    dataOptions = seriesOptions.data,
	                    point,
	                    isInTheMiddle,
	                    xData = series.xData,
	                    i,
	                    x;
	
	                // Optional redraw, defaults to true
	                redraw = pick(redraw, true);
	
	                // Get options and push the point to xData, yData and series.options. In series.generatePoints
	                // the Point instance will be created on demand and pushed to the series.data array.
	                point = {
	                    series: series
	                };
	                series.pointClass.prototype.applyOptions.apply(point, [options]);
	                x = point.x;
	
	                // Get the insertion point
	                i = xData.length;
	                if (series.requireSorting && x < xData[i - 1]) {
	                    isInTheMiddle = true;
	                    while (i && xData[i - 1] > x) {
	                        i--;
	                    }
	                }
	
	                series.updateParallelArrays(point, 'splice', i, 0, 0); // insert undefined item
	                series.updateParallelArrays(point, i); // update it
	
	                if (names && point.name) {
	                    names[x] = point.name;
	                }
	                dataOptions.splice(i, 0, options);
	
	                if (isInTheMiddle) {
	                    series.data.splice(i, 0, null);
	                    series.processData();
	                }
	
	                // Generate points to be added to the legend (#1329)
	                if (seriesOptions.legendType === 'point') {
	                    series.generatePoints();
	                }
	
	                // Shift the first point off the parallel arrays
	                if (shift) {
	                    if (data[0] && data[0].remove) {
	                        data[0].remove(false);
	                    } else {
	                        data.shift();
	                        series.updateParallelArrays(point, 'shift');
	
	                        dataOptions.shift();
	                    }
	                }
	
	                // redraw
	                series.isDirty = true;
	                series.isDirtyData = true;
	
	                if (redraw) {
	                    chart.redraw(animation); // Animation is set anyway on redraw, #5665
	                }
	            },
	
	            /**
	             * Remove a point from the series. Unlike the {@link Highcharts.Point#remove}
	             * method, this can also be done on a point that is not instanciated because
	             * it is outside the view or subject to Highstock data grouping.
	             *
	             * @param  {Number} i
	             *         The index of the point in the {@link Highcharts.Series.data|data}
	             *         array.
	             * @param  {Boolean} [redraw=true]
	             *         Whether to redraw the chart after the point is added. When 
	             *         removing more than one point, it is highly recommended that the
	             *         `redraw` option be set to `false`, and instead {@link
	             *         Highcharts.Chart#redraw} is explicitly called after the adding of
	             *         points is finished.
	             * @param  {AnimationOptions} [animation]
	             *         Whether and optionally how the series should be animated.
	             *
	             * @sample highcharts/members/series-removepoint/
	             *         Remove cropped point
	             */
	            removePoint: function(i, redraw, animation) {
	
	                var series = this,
	                    data = series.data,
	                    point = data[i],
	                    points = series.points,
	                    chart = series.chart,
	                    remove = function() {
	
	                        if (points && points.length === data.length) { // #4935
	                            points.splice(i, 1);
	                        }
	                        data.splice(i, 1);
	                        series.options.data.splice(i, 1);
	                        series.updateParallelArrays(point || {
	                            series: series
	                        }, 'splice', i, 1);
	
	                        if (point) {
	                            point.destroy();
	                        }
	
	                        // redraw
	                        series.isDirty = true;
	                        series.isDirtyData = true;
	                        if (redraw) {
	                            chart.redraw();
	                        }
	                    };
	
	                setAnimation(animation, chart);
	                redraw = pick(redraw, true);
	
	                // Fire the event with a default handler of removing the point
	                if (point) {
	                    point.firePointEvent('remove', null, remove);
	                } else {
	                    remove();
	                }
	            },
	
	            /**
	             * Remove a series and optionally redraw the chart.
	             *
	             * @param  {Boolean} [redraw=true]
	             *         Whether to redraw the chart or wait for an explicit call to
	             *         {@link Highcharts.Chart#redraw}.
	             * @param  {AnimationOptions} [animation]
	             *         Whether to apply animation, and optionally animation
	             *         configuration
	             * @param  {Boolean} [withEvent=true]
	             *         Used internally, whether to fire the series `remove` event.
	             *
	             * @sample highcharts/members/series-remove/
	             *         Remove first series from a button
	             */
	            remove: function(redraw, animation, withEvent) {
	                var series = this,
	                    chart = series.chart;
	
	                function remove() {
	
	                    // Destroy elements
	                    series.destroy();
	
	                    // Redraw
	                    chart.isDirtyLegend = chart.isDirtyBox = true;
	                    chart.linkSeries();
	
	                    if (pick(redraw, true)) {
	                        chart.redraw(animation);
	                    }
	                }
	
	                // Fire the event with a default handler of removing the point
	                if (withEvent !== false) {
	                    fireEvent(series, 'remove', null, remove);
	                } else {
	                    remove();
	                }
	            },
	
	            /**
	             * Update the series with a new set of options. For a clean and precise
	             * handling of new options, all methods and elements from the series are
	             * removed, and it is initiated from scratch. Therefore, this method is more
	             * performance expensive than some other utility methods like {@link
	             * Series#setData} or {@link Series#setVisible}.
	             *
	             * @param  {SeriesOptions} options
	             *         New options that will be merged with the series' existing
	             *         options.
	             * @param  {Boolean} [redraw=true]
	             *         Whether to redraw the chart after the series is altered. If doing
	             *         more operations on the chart, it is a good idea to set redraw to
	             *         false and call {@link Chart#redraw} after.
	             *
	             * @sample highcharts/members/series-update/
	             *         Updating series options
	             * @sample maps/members/series-update/
	             *         Update series options in Highmaps
	             */
	            update: function(newOptions, redraw) {
	                var series = this,
	                    chart = series.chart,
	                    // must use user options when changing type because series.options
	                    // is merged in with type specific plotOptions
	                    oldOptions = series.userOptions,
	                    oldType = series.oldType || series.type,
	                    newType = newOptions.type || oldOptions.type || chart.options.chart.type,
	                    proto = seriesTypes[oldType].prototype,
	                    n,
	                    preserve = [
	                        'group',
	                        'markerGroup',
	                        'dataLabelsGroup',
	                        'navigatorSeries',
	                        'baseSeries'
	                    ],
	
	                    // Animation must be enabled when calling update before the initial
	                    // animation has first run. This happens when calling update
	                    // directly after chart initialization, or when applying responsive
	                    // rules (#6912).
	                    animation = series.finishedAnimating && {
	                        animation: false
	                    };
	
	                // Running Series.update to update the data only is an intuitive usage,
	                // so we want to make sure that when used like this, we run the
	                // cheaper setData function and allow animation instead of completely
	                // recreating the series instance.
	                if (Object.keys && Object.keys(newOptions).toString() === 'data') {
	                    return this.setData(newOptions.data, redraw);
	                }
	
	                // If we're changing type or zIndex, create new groups (#3380, #3404)
	                if ((newType && newType !== oldType) || newOptions.zIndex !== undefined) {
	                    preserve.length = 0;
	                }
	
	                // Make sure groups are not destroyed (#3094)
	                each(preserve, function(prop) {
	                    preserve[prop] = series[prop];
	                    delete series[prop];
	                });
	
	                // Do the merge, with some forced options
	                newOptions = merge(oldOptions, animation, {
	                    index: series.index,
	                    pointStart: series.xData[0] // when updating after addPoint
	                }, {
	                    data: series.options.data
	                }, newOptions);
	
	                // Destroy the series and delete all properties. Reinsert all methods
	                // and properties from the new type prototype (#2270, #3719)
	                series.remove(false, null, false);
	                for (n in proto) {
	                    series[n] = undefined;
	                }
	                extend(series, seriesTypes[newType || oldType].prototype);
	
	                // Re-register groups (#3094) and other preserved properties
	                each(preserve, function(prop) {
	                    series[prop] = preserve[prop];
	                });
	
	                series.init(chart, newOptions);
	                series.oldType = oldType;
	                chart.linkSeries(); // Links are lost in series.remove (#3028)
	                if (pick(redraw, true)) {
	                    chart.redraw(false);
	                }
	            }
	        });
	
	        // Extend the Axis.prototype for dynamic methods
	        extend(Axis.prototype, /** @lends Highcharts.Axis.prototype */ {
	
	            /**
	             * Update an axis object with a new set of options. The options are merged
	             * with the existing options, so only new or altered options need to be
	             * specified.
	             *
	             * @param  {Object} options
	             *         The new options that will be merged in with existing options on
	             *         the axis.
	             * @sample highcharts/members/axis-update/ Axis update demo
	             */
	            update: function(options, redraw) {
	                var chart = this.chart;
	
	                options = chart.options[this.coll][this.options.index] =
	                    merge(this.userOptions, options);
	
	                this.destroy(true);
	
	                this.init(chart, extend(options, {
	                    events: undefined
	                }));
	
	                chart.isDirtyBox = true;
	                if (pick(redraw, true)) {
	                    chart.redraw();
	                }
	            },
	
	            /**
	             * Remove the axis from the chart.
	             *
	             * @param {Boolean} [redraw=true] Whether to redraw the chart following the
	             * remove.
	             *
	             * @sample highcharts/members/chart-addaxis/ Add and remove axes
	             */
	            remove: function(redraw) {
	                var chart = this.chart,
	                    key = this.coll, // xAxis or yAxis
	                    axisSeries = this.series,
	                    i = axisSeries.length;
	
	                // Remove associated series (#2687)
	                while (i--) {
	                    if (axisSeries[i]) {
	                        axisSeries[i].remove(false);
	                    }
	                }
	
	                // Remove the axis
	                erase(chart.axes, this);
	                erase(chart[key], this);
	
	                if (isArray(chart.options[key])) {
	                    chart.options[key].splice(this.options.index, 1);
	                } else { // color axis, #6488
	                    delete chart.options[key];
	                }
	
	                each(chart[key], function(axis, i) { // Re-index, #1706
	                    axis.options.index = i;
	                });
	                this.destroy();
	                chart.isDirtyBox = true;
	
	                if (pick(redraw, true)) {
	                    chart.redraw();
	                }
	            },
	
	            /**
	             * Update the axis title by options after render time.
	             *
	             * @param  {TitleOptions} titleOptions
	             *         The additional title options.
	             * @param  {Boolean} [redraw=true]
	             *         Whether to redraw the chart after setting the title.
	             * @sample highcharts/members/axis-settitle/ Set a new Y axis title
	             */
	            setTitle: function(titleOptions, redraw) {
	                this.update({
	                    title: titleOptions
	                }, redraw);
	            },
	
	            /**
	             * Set new axis categories and optionally redraw.
	             * @param {Array.<String>} categories - The new categories.
	             * @param {Boolean} [redraw=true] - Whether to redraw the chart.
	             * @sample highcharts/members/axis-setcategories/ Set categories by click on
	             * a button
	             */
	            setCategories: function(categories, redraw) {
	                this.update({
	                    categories: categories
	                }, redraw);
	            }
	
	        });
	
	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var animObject = H.animObject,
	            color = H.color,
	            each = H.each,
	            extend = H.extend,
	            isNumber = H.isNumber,
	            LegendSymbolMixin = H.LegendSymbolMixin,
	            merge = H.merge,
	            noop = H.noop,
	            pick = H.pick,
	            Series = H.Series,
	            seriesType = H.seriesType,
	            svg = H.svg;
	        /**
	         * The column series type.
	         *
	         * @constructor seriesTypes.column
	         * @augments Series
	         */
	
	        /**
	         * @extends {plotOptions.line}
	         * @optionparent plotOptions.column
	         * @excluding connectNulls,dashStyle,linecap,lineWidth,marker,connectEnds,step
	         */
	        seriesType('column', 'line', {
	
	            /**
	             * The corner radius of the border surrounding each column or bar.
	             * 
	             * @type {Number}
	             * @sample {highcharts} highcharts/plotoptions/column-borderradius/ Rounded columns
	             * @default 0
	             * @product highcharts highstock
	             */
	            borderRadius: 0,
	            //colorByPoint: undefined,
	
	            /**
	             * When true, each column edge is rounded to its nearest pixel in order
	             * to render sharp on screen. In some cases, when there are a lot of
	             * densely packed columns, this leads to visible difference in column
	             * widths or distance between columns. In these cases, setting `crisp`
	             * to `false` may look better, even though each column is rendered
	             * blurry.
	             * 
	             * @type {Boolean}
	             * @sample {highcharts} highcharts/plotoptions/column-crisp-false/ Crisp is false
	             * @default true
	             * @since 5.0.10
	             * @product highcharts highstock
	             */
	            crisp: true,
	
	            /**
	             * Padding between each value groups, in x axis units.
	             * 
	             * @type {Number}
	             * @sample {highcharts} highcharts/plotoptions/column-grouppadding-default/ 0.2 by default
	             * @sample {highcharts} highcharts/plotoptions/column-grouppadding-none/ No group padding - all     columns are evenly spaced
	             * @default 0.2
	             * @product highcharts highstock
	             */
	            groupPadding: 0.2,
	            //grouping: true,
	
	            /**
	             */
	            marker: null, // point options are specified in the base options
	
	            /**
	             * Padding between each column or bar, in x axis units.
	             * 
	             * @type {Number}
	             * @sample {highcharts} highcharts/plotoptions/column-pointpadding-default/ 0.1 by default
	             * @sample {highcharts} highcharts/plotoptions/column-pointpadding-025/ 0.25
	             * @sample {highcharts} highcharts/plotoptions/column-pointpadding-none/ 0 for tightly packed columns
	             * @default 0.1
	             * @product highcharts highstock
	             */
	            pointPadding: 0.1,
	            //pointWidth: null,
	
	            /**
	             * The minimal height for a column or width for a bar. By default,
	             * 0 values are not shown. To visualize a 0 (or close to zero) point,
	             * set the minimal point length to a pixel value like 3\. In stacked
	             * column charts, minPointLength might not be respected for tightly
	             * packed values.
	             * 
	             * @type {Number}
	             * @sample {highcharts} highcharts/plotoptions/column-minpointlength/ Zero base value
	             * @sample {highcharts} highcharts/plotoptions/column-minpointlength-pos-and-neg/ Positive and negative close to zero values
	             * @default 0
	             * @product highcharts highstock
	             */
	            minPointLength: 0,
	
	            /**
	             * When the series contains less points than the crop threshold, all
	             * points are drawn, event if the points fall outside the visible plot
	             * area at the current zoom. The advantage of drawing all points (including
	             * markers and columns), is that animation is performed on updates.
	             * On the other hand, when the series contains more points than the
	             * crop threshold, the series data is cropped to only contain points
	             * that fall within the plot area. The advantage of cropping away invisible
	             * points is to increase performance on large series. .
	             * 
	             * @type {Number}
	             * @default 50
	             * @product highcharts highstock
	             */
	            cropThreshold: 50,
	
	            /**
	             * The X axis range that each point is valid for. This determines the
	             * width of the column. On a categorized axis, the range will be 1
	             * by default (one category unit). On linear and datetime axes, the
	             * range will be computed as the distance between the two closest data
	             * points.
	             *
	             * The default `null` means it is computed automatically, but this option
	             * can be used to override the automatic value.
	             * 
	             * @type {Number}
	             * @sample {highcharts} highcharts/plotoptions/column-pointrange/
	             *         Set the point range to one day on a data set with one week
	             *         between the points
	             * @default null
	             * @since 2.3
	             * @product highcharts highstock
	             */
	            pointRange: null,
	
	            /**
	             */
	            states: {
	
	                /**
	                 * @extends plotOptions.series.states.hover
	                 * @excluding lineWidth,lineWidthPlus,marker
	                 * @product highcharts highstock
	                 */
	                hover: {
	
	                    /**
	                     */
	                    halo: false,
	
	
	                    /**
	                     * How much to brighten the point on interaction. Requires the main
	                     * color to be defined in hex or rgb(a) format.
	                     * 
	                     * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	                     * style/style-by-css), the hover brightening is by default replaced
	                     * with a fill-opacity set in the `.highcharts-point:hover` rule.
	                     * 
	                     * @type {Number}
	                     * @sample {highcharts} highcharts/plotoptions/column-states-hover-brightness/ Brighten by 0.5
	                     * @default 0.1
	                     * @product highcharts highstock
	                     */
	                    brightness: 0.1,
	
	                    /**
	                     */
	                    shadow: false
	
	                },
	
	
	                /**
	                 */
	                select: {
	
	                    /**
	                     */
	                    color: '#cccccc',
	
	                    /**
	                     */
	                    borderColor: '#000000',
	
	                    /**
	                     */
	                    shadow: false
	                }
	
	            },
	
	            /**
	             */
	            dataLabels: {
	
	                /**
	                 */
	                align: null, // auto
	
	                /**
	                 */
	                verticalAlign: null, // auto
	
	                /**
	                 */
	                y: null
	            },
	
	            /**
	             * When this is true, the series will not cause the Y axis to cross
	             * the zero plane (or [threshold](#plotOptions.series.threshold) option)
	             * unless the data actually crosses the plane.
	             * 
	             * For example, if `softThreshold` is `false`, a series of 0, 1, 2,
	             * 3 will make the Y axis show negative values according to the `minPadding`
	             * option. If `softThreshold` is `true`, the Y axis starts at 0.
	             * 
	             * @type {Boolean}
	             * @default {highcharts} true
	             * @default {highstock} false
	             * @since 4.1.9
	             * @product highcharts highstock
	             */
	            softThreshold: false,
	
	            /**
	             */
	            startFromThreshold: true, // false doesn't work well: http://jsfiddle.net/highcharts/hz8fopan/14/
	
	            /**
	             */
	            stickyTracking: false,
	
	            /**
	             */
	            tooltip: {
	
	                /**
	                 */
	                distance: 6
	            },
	
	            /**
	             * The Y axis value to serve as the base for the columns, for distinguishing
	             * between values above and below a threshold. If `null`, the columns
	             * extend from the padding Y axis minimum.
	             * 
	             * @type {Number}
	             * @default 0
	             * @since 2.0
	             * @product highcharts
	             */
	            threshold: 0,
	
	
	            /**
	             * The color of the border surrounding each column or bar.
	             * 
	             * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	             * style/style-by-css), the border stroke can be set with the `.highcharts-
	             * point` rule.
	             * 
	             * @type {Color}
	             * @sample {highcharts} highcharts/plotoptions/column-bordercolor/ Dark gray border
	             * @default #ffffff
	             * @product highcharts highstock
	             */
	            borderColor: '#ffffff'
	            // borderWidth: 1
	
	
	        }, /** @lends seriesTypes.column.prototype */ {
	            cropShoulder: 0,
	            directTouch: true, // When tooltip is not shared, this series (and derivatives) requires direct touch/hover. KD-tree does not apply.
	            trackerGroups: ['group', 'dataLabelsGroup'],
	            negStacks: true, // use separate negative stacks, unlike area stacks where a negative
	            // point is substracted from previous (#1910)
	
	            /**
	             * Initialize the series. Extends the basic Series.init method by
	             * marking other series of the same type as dirty.
	             *
	             * @function #init
	             * @memberOf seriesTypes.column
	             * 
	             */
	            init: function() {
	                Series.prototype.init.apply(this, arguments);
	
	                var series = this,
	                    chart = series.chart;
	
	                // if the series is added dynamically, force redraw of other
	                // series affected by a new column
	                if (chart.hasRendered) {
	                    each(chart.series, function(otherSeries) {
	                        if (otherSeries.type === series.type) {
	                            otherSeries.isDirty = true;
	                        }
	                    });
	                }
	            },
	
	            /**
	             * Return the width and x offset of the columns adjusted for grouping, groupPadding, pointPadding,
	             * pointWidth etc.
	             */
	            getColumnMetrics: function() {
	
	                var series = this,
	                    options = series.options,
	                    xAxis = series.xAxis,
	                    yAxis = series.yAxis,
	                    reversedXAxis = xAxis.reversed,
	                    stackKey,
	                    stackGroups = {},
	                    columnCount = 0;
	
	                // Get the total number of column type series.
	                // This is called on every series. Consider moving this logic to a
	                // chart.orderStacks() function and call it on init, addSeries and removeSeries
	                if (options.grouping === false) {
	                    columnCount = 1;
	                } else {
	                    each(series.chart.series, function(otherSeries) {
	                        var otherOptions = otherSeries.options,
	                            otherYAxis = otherSeries.yAxis,
	                            columnIndex;
	                        if (
	                            otherSeries.type === series.type &&
	                            (
	                                otherSeries.visible ||
	                                !series.chart.options.chart.ignoreHiddenSeries
	                            ) &&
	                            yAxis.len === otherYAxis.len &&
	                            yAxis.pos === otherYAxis.pos
	                        ) { // #642, #2086
	                            if (otherOptions.stacking) {
	                                stackKey = otherSeries.stackKey;
	                                if (stackGroups[stackKey] === undefined) {
	                                    stackGroups[stackKey] = columnCount++;
	                                }
	                                columnIndex = stackGroups[stackKey];
	                            } else if (otherOptions.grouping !== false) { // #1162
	                                columnIndex = columnCount++;
	                            }
	                            otherSeries.columnIndex = columnIndex;
	                        }
	                    });
	                }
	
	                var categoryWidth = Math.min(
	                        Math.abs(xAxis.transA) * (xAxis.ordinalSlope || options.pointRange || xAxis.closestPointRange || xAxis.tickInterval || 1), // #2610
	                        xAxis.len // #1535
	                    ),
	                    groupPadding = categoryWidth * options.groupPadding,
	                    groupWidth = categoryWidth - 2 * groupPadding,
	                    pointOffsetWidth = groupWidth / (columnCount || 1),
	                    pointWidth = Math.min(
	                        options.maxPointWidth || xAxis.len,
	                        pick(options.pointWidth, pointOffsetWidth * (1 - 2 * options.pointPadding))
	                    ),
	                    pointPadding = (pointOffsetWidth - pointWidth) / 2,
	                    colIndex = (series.columnIndex || 0) + (reversedXAxis ? 1 : 0), // #1251, #3737
	                    pointXOffset = pointPadding + (groupPadding + colIndex *
	                        pointOffsetWidth - (categoryWidth / 2)) *
	                    (reversedXAxis ? -1 : 1);
	
	                // Save it for reading in linked series (Error bars particularly)
	                series.columnMetrics = {
	                    width: pointWidth,
	                    offset: pointXOffset
	                };
	                return series.columnMetrics;
	
	            },
	
	            /**
	             * Make the columns crisp. The edges are rounded to the nearest full pixel.
	             */
	            crispCol: function(x, y, w, h) {
	                var chart = this.chart,
	                    borderWidth = this.borderWidth,
	                    xCrisp = -(borderWidth % 2 ? 0.5 : 0),
	                    yCrisp = borderWidth % 2 ? 0.5 : 1,
	                    right,
	                    bottom,
	                    fromTop;
	
	                if (chart.inverted && chart.renderer.isVML) {
	                    yCrisp += 1;
	                }
	
	                // Horizontal. We need to first compute the exact right edge, then round it
	                // and compute the width from there.
	                if (this.options.crisp) {
	                    right = Math.round(x + w) + xCrisp;
	                    x = Math.round(x) + xCrisp;
	                    w = right - x;
	                }
	
	                // Vertical
	                bottom = Math.round(y + h) + yCrisp;
	                fromTop = Math.abs(y) <= 0.5 && bottom > 0.5; // #4504, #4656
	                y = Math.round(y) + yCrisp;
	                h = bottom - y;
	
	                // Top edges are exceptions
	                if (fromTop && h) { // #5146
	                    y -= 1;
	                    h += 1;
	                }
	
	                return {
	                    x: x,
	                    y: y,
	                    width: w,
	                    height: h
	                };
	            },
	
	            /**
	             * Translate each point to the plot area coordinate system and find shape positions
	             */
	            translate: function() {
	                var series = this,
	                    chart = series.chart,
	                    options = series.options,
	                    dense = series.dense = series.closestPointRange * series.xAxis.transA < 2,
	                    borderWidth = series.borderWidth = pick(
	                        options.borderWidth,
	                        dense ? 0 : 1 // #3635
	                    ),
	                    yAxis = series.yAxis,
	                    threshold = options.threshold,
	                    translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold),
	                    minPointLength = pick(options.minPointLength, 5),
	                    metrics = series.getColumnMetrics(),
	                    pointWidth = metrics.width,
	                    seriesBarW = series.barW = Math.max(pointWidth, 1 + 2 * borderWidth), // postprocessed for border width
	                    pointXOffset = series.pointXOffset = metrics.offset;
	
	                if (chart.inverted) {
	                    translatedThreshold -= 0.5; // #3355
	                }
	
	                // When the pointPadding is 0, we want the columns to be packed tightly, so we allow individual
	                // columns to have individual sizes. When pointPadding is greater, we strive for equal-width
	                // columns (#2694).
	                if (options.pointPadding) {
	                    seriesBarW = Math.ceil(seriesBarW);
	                }
	
	                Series.prototype.translate.apply(series);
	
	                // Record the new values
	                each(series.points, function(point) {
	                    var yBottom = pick(point.yBottom, translatedThreshold),
	                        safeDistance = 999 + Math.abs(yBottom),
	                        plotY = Math.min(Math.max(-safeDistance, point.plotY), yAxis.len + safeDistance), // Don't draw too far outside plot area (#1303, #2241, #4264)
	                        barX = point.plotX + pointXOffset,
	                        barW = seriesBarW,
	                        barY = Math.min(plotY, yBottom),
	                        up,
	                        barH = Math.max(plotY, yBottom) - barY;
	
	                    // Handle options.minPointLength
	                    if (Math.abs(barH) < minPointLength) {
	                        if (minPointLength) {
	                            barH = minPointLength;
	                            up = (!yAxis.reversed && !point.negative) || (yAxis.reversed && point.negative);
	                            barY = Math.abs(barY - translatedThreshold) > minPointLength ? // stacked
	                                yBottom - minPointLength : // keep position
	                                translatedThreshold - (up ? minPointLength : 0); // #1485, #4051
	                        }
	                    }
	
	                    // Cache for access in polar
	                    point.barX = barX;
	                    point.pointWidth = pointWidth;
	
	                    // Fix the tooltip on center of grouped columns (#1216, #424, #3648)
	                    point.tooltipPos = chart.inverted ? [yAxis.len + yAxis.pos - chart.plotLeft - plotY, series.xAxis.len - barX - barW / 2, barH] : [barX + barW / 2, plotY + yAxis.pos - chart.plotTop, barH];
	
	                    // Register shape type and arguments to be used in drawPoints
	                    point.shapeType = 'rect';
	                    point.shapeArgs = series.crispCol.apply(
	                        series,
	                        point.isNull ?
	                        // #3169, drilldown from null must have a position to work from
	                        // #6585, dataLabel should be placed on xAxis, not floating in the middle of the chart
	                        [barX, translatedThreshold, barW, 0] : [barX, barY, barW, barH]
	                    );
	                });
	
	            },
	
	            getSymbol: noop,
	
	            /**
	             * Use a solid rectangle like the area series types
	             */
	            drawLegendSymbol: LegendSymbolMixin.drawRectangle,
	
	
	            /**
	             * Columns have no graph
	             */
	            drawGraph: function() {
	                this.group[this.dense ? 'addClass' : 'removeClass']('highcharts-dense-data');
	            },
	
	
	            /**
	             * Get presentational attributes
	             */
	            pointAttribs: function(point, state) {
	                var options = this.options,
	                    stateOptions,
	                    ret,
	                    p2o = this.pointAttrToOptions || {},
	                    strokeOption = p2o.stroke || 'borderColor',
	                    strokeWidthOption = p2o['stroke-width'] || 'borderWidth',
	                    fill = (point && point.color) || this.color,
	                    stroke = point[strokeOption] || options[strokeOption] ||
	                    this.color || fill, // set to fill when borderColor null
	                    strokeWidth = point[strokeWidthOption] ||
	                    options[strokeWidthOption] || this[strokeWidthOption] || 0,
	                    dashstyle = options.dashStyle,
	                    zone,
	                    brightness;
	
	                // Handle zone colors
	                if (point && this.zones.length) {
	                    zone = point.getZone();
	                    fill = point.options.color || (zone && zone.color) || this.color; // When zones are present, don't use point.color (#4267). Changed order (#6527)
	                }
	
	                // Select or hover states
	                if (state) {
	                    stateOptions = merge(
	                        options.states[state],
	                        point.options.states && point.options.states[state] || {} // #6401
	                    );
	                    brightness = stateOptions.brightness;
	                    fill = stateOptions.color ||
	                        (brightness !== undefined && color(fill).brighten(stateOptions.brightness).get()) ||
	                        fill;
	                    stroke = stateOptions[strokeOption] || stroke;
	                    strokeWidth = stateOptions[strokeWidthOption] || strokeWidth;
	                    dashstyle = stateOptions.dashStyle || dashstyle;
	                }
	
	                ret = {
	                    'fill': fill,
	                    'stroke': stroke,
	                    'stroke-width': strokeWidth
	                };
	
	                if (dashstyle) {
	                    ret.dashstyle = dashstyle;
	                }
	
	                return ret;
	            },
	
	
	            /**
	             * Draw the columns. For bars, the series.group is rotated, so the same coordinates
	             * apply for columns and bars. This method is inherited by scatter series.
	             *
	             */
	            drawPoints: function() {
	                var series = this,
	                    chart = this.chart,
	                    options = series.options,
	                    renderer = chart.renderer,
	                    animationLimit = options.animationLimit || 250,
	                    shapeArgs;
	
	                // draw the columns
	                each(series.points, function(point) {
	                    var plotY = point.plotY,
	                        graphic = point.graphic;
	
	                    if (isNumber(plotY) && point.y !== null) {
	                        shapeArgs = point.shapeArgs;
	
	                        if (graphic) { // update
	                            graphic[chart.pointCount < animationLimit ? 'animate' : 'attr'](
	                                merge(shapeArgs)
	                            );
	
	                        } else {
	                            point.graphic = graphic = renderer[point.shapeType](shapeArgs)
	                                .add(point.group || series.group);
	                        }
	
	                        // Border radius is not stylable (#6900)
	                        if (options.borderRadius) {
	                            graphic.attr({
	                                r: options.borderRadius
	                            });
	                        }
	
	
	                        // Presentational
	                        graphic
	                            .attr(series.pointAttribs(point, point.selected && 'select'))
	                            .shadow(options.shadow, null, options.stacking && !options.borderRadius);
	
	
	                        graphic.addClass(point.getClassName(), true);
	
	
	                    } else if (graphic) {
	                        point.graphic = graphic.destroy(); // #1269
	                    }
	                });
	            },
	
	            /**
	             * Animate the column heights one by one from zero
	             * @param {Boolean} init Whether to initialize the animation or run it
	             */
	            animate: function(init) {
	                var series = this,
	                    yAxis = this.yAxis,
	                    options = series.options,
	                    inverted = this.chart.inverted,
	                    attr = {},
	                    translatedThreshold;
	
	                if (svg) { // VML is too slow anyway
	                    if (init) {
	                        attr.scaleY = 0.001;
	                        translatedThreshold = Math.min(yAxis.pos + yAxis.len, Math.max(yAxis.pos, yAxis.toPixels(options.threshold)));
	                        if (inverted) {
	                            attr.translateX = translatedThreshold - yAxis.len;
	                        } else {
	                            attr.translateY = translatedThreshold;
	                        }
	                        series.group.attr(attr);
	
	                    } else { // run the animation
	
	                        attr[inverted ? 'translateX' : 'translateY'] = yAxis.pos;
	                        series.group.animate(attr, extend(animObject(series.options.animation), {
	                            // Do the scale synchronously to ensure smooth updating (#5030)
	                            step: function(val, fx) {
	                                series.group.attr({
	                                    scaleY: Math.max(0.001, fx.pos) // #5250
	                                });
	                            }
	                        }));
	
	                        // delete this function to allow it only once
	                        series.animate = null;
	                    }
	                }
	            },
	
	            /**
	             * Remove this series from the chart
	             */
	            remove: function() {
	                var series = this,
	                    chart = series.chart;
	
	                // column and bar series affects other series of the same type
	                // as they are either stacked or grouped
	                if (chart.hasRendered) {
	                    each(chart.series, function(otherSeries) {
	                        if (otherSeries.type === series.type) {
	                            otherSeries.isDirty = true;
	                        }
	                    });
	                }
	
	                Series.prototype.remove.apply(series, arguments);
	            }
	        });
	
	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var Series = H.Series,
	            seriesType = H.seriesType;
	        /**
	         * The scatter series type
	         */
	
	        /**
	         * @extends {plotOptions.line}
	         * @optionparent plotOptions.scatter
	         */
	        seriesType('scatter', 'line', {
	
	            /**
	             * The width of the line connecting the data points.
	             * 
	             * @type {Number}
	             * @sample {highcharts} highcharts/plotoptions/scatter-linewidth-none/ 0 by default
	             * @sample {highcharts} highcharts/plotoptions/scatter-linewidth-1/ 1px
	             * @default 0
	             * @product highcharts highstock
	             */
	            lineWidth: 0,
	
	            /**
	             */
	            findNearestPointBy: 'xy',
	
	            /**
	             */
	            marker: {
	
	                /**
	                 */
	                enabled: true // Overrides auto-enabling in line series (#3647)
	            },
	
	            /**
	             * A configuration object for the tooltip rendering of each single
	             * series. Properties are inherited from <a class="internal">#tooltip</a>.
	             * Overridable properties are `headerFormat`, `pointFormat`, `yDecimals`,
	             * `xDateFormat`, `yPrefix` and `ySuffix`. Unlike other series, in
	             * a scatter plot the series.name by default shows in the headerFormat
	             * and point.x and point.y in the pointFormat.
	             * 
	             * @product highcharts highstock
	             */
	            tooltip: {
	
	                headerFormat: '<span style="color:{point.color}">\u25CF</span> ' +
	                    '<span style="font-size: 0.85em"> {series.name}</span><br/>',
	
	
	                /**
	                 */
	                pointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>'
	            }
	
	            // Prototype members
	        }, {
	            sorted: false,
	            requireSorting: false,
	            noSharedTooltip: true,
	            trackerGroups: ['group', 'markerGroup', 'dataLabelsGroup'],
	            takeOrdinalPosition: false, // #2342
	            drawGraph: function() {
	                if (this.options.lineWidth) {
	                    Series.prototype.drawGraph.call(this);
	                }
	            }
	        });
	
	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var addEvent = H.addEvent,
	            arrayMax = H.arrayMax,
	            defined = H.defined,
	            each = H.each,
	            extend = H.extend,
	            format = H.format,
	            map = H.map,
	            merge = H.merge,
	            noop = H.noop,
	            pick = H.pick,
	            relativeLength = H.relativeLength,
	            Series = H.Series,
	            seriesTypes = H.seriesTypes,
	            stableSort = H.stableSort;
	
	
	        /**
	         * Generatl distribution algorithm for distributing labels of differing size along a
	         * confined length in two dimensions. The algorithm takes an array of objects containing
	         * a size, a target and a rank. It will place the labels as close as possible to their 
	         * targets, skipping the lowest ranked labels if necessary.
	         */
	        H.distribute = function(boxes, len) {
	
	            var i,
	                overlapping = true,
	                origBoxes = boxes, // Original array will be altered with added .pos
	                restBoxes = [], // The outranked overshoot
	                box,
	                target,
	                total = 0;
	
	            function sortByTarget(a, b) {
	                return a.target - b.target;
	            }
	
	            // If the total size exceeds the len, remove those boxes with the lowest rank
	            i = boxes.length;
	            while (i--) {
	                total += boxes[i].size;
	            }
	
	            // Sort by rank, then slice away overshoot
	            if (total > len) {
	                stableSort(boxes, function(a, b) {
	                    return (b.rank || 0) - (a.rank || 0);
	                });
	                i = 0;
	                total = 0;
	                while (total <= len) {
	                    total += boxes[i].size;
	                    i++;
	                }
	                restBoxes = boxes.splice(i - 1, boxes.length);
	            }
	
	            // Order by target
	            stableSort(boxes, sortByTarget);
	
	
	            // So far we have been mutating the original array. Now
	            // create a copy with target arrays
	            boxes = map(boxes, function(box) {
	                return {
	                    size: box.size,
	                    targets: [box.target]
	                };
	            });
	
	            while (overlapping) {
	                // Initial positions: target centered in box
	                i = boxes.length;
	                while (i--) {
	                    box = boxes[i];
	                    // Composite box, average of targets
	                    target = (Math.min.apply(0, box.targets) + Math.max.apply(0, box.targets)) / 2;
	                    box.pos = Math.min(Math.max(0, target - box.size / 2), len - box.size);
	                }
	
	                // Detect overlap and join boxes
	                i = boxes.length;
	                overlapping = false;
	                while (i--) {
	                    if (i > 0 && boxes[i - 1].pos + boxes[i - 1].size > boxes[i].pos) { // Overlap
	                        boxes[i - 1].size += boxes[i].size; // Add this size to the previous box
	                        boxes[i - 1].targets = boxes[i - 1].targets.concat(boxes[i].targets);
	
	                        // Overlapping right, push left
	                        if (boxes[i - 1].pos + boxes[i - 1].size > len) {
	                            boxes[i - 1].pos = len - boxes[i - 1].size;
	                        }
	                        boxes.splice(i, 1); // Remove this item
	                        overlapping = true;
	                    }
	                }
	            }
	
	            // Now the composite boxes are placed, we need to put the original boxes within them
	            i = 0;
	            each(boxes, function(box) {
	                var posInCompositeBox = 0;
	                each(box.targets, function() {
	                    origBoxes[i].pos = box.pos + posInCompositeBox;
	                    posInCompositeBox += origBoxes[i].size;
	                    i++;
	                });
	            });
	
	            // Add the rest (hidden) boxes and sort by target
	            origBoxes.push.apply(origBoxes, restBoxes);
	            stableSort(origBoxes, sortByTarget);
	        };
	
	
	        /**
	         * Draw the data labels
	         */
	        Series.prototype.drawDataLabels = function() {
	            var series = this,
	                seriesOptions = series.options,
	                options = seriesOptions.dataLabels,
	                points = series.points,
	                pointOptions,
	                generalOptions,
	                hasRendered = series.hasRendered || 0,
	                str,
	                dataLabelsGroup,
	                defer = pick(options.defer, !!seriesOptions.animation),
	                renderer = series.chart.renderer;
	
	            if (options.enabled || series._hasPointLabels) {
	
	                // Process default alignment of data labels for columns
	                if (series.dlProcessOptions) {
	                    series.dlProcessOptions(options);
	                }
	
	                // Create a separate group for the data labels to avoid rotation
	                dataLabelsGroup = series.plotGroup(
	                    'dataLabelsGroup',
	                    'data-labels',
	                    defer && !hasRendered ? 'hidden' : 'visible', // #5133
	                    options.zIndex || 6
	                );
	
	                if (defer) {
	                    dataLabelsGroup.attr({
	                        opacity: +hasRendered
	                    }); // #3300
	                    if (!hasRendered) {
	                        addEvent(series, 'afterAnimate', function() {
	                            if (series.visible) { // #2597, #3023, #3024
	                                dataLabelsGroup.show(true);
	                            }
	                            dataLabelsGroup[seriesOptions.animation ? 'animate' : 'attr']({
	                                opacity: 1
	                            }, {
	                                duration: 200
	                            });
	                        });
	                    }
	                }
	
	                // Make the labels for each point
	                generalOptions = options;
	                each(points, function(point) {
	                    var enabled,
	                        dataLabel = point.dataLabel,
	                        labelConfig,
	                        attr,
	                        rotation,
	                        connector = point.connector,
	                        isNew = !dataLabel,
	                        style;
	                    // Determine if each data label is enabled
	                    // @note dataLabelAttribs (like pointAttribs) would eradicate
	                    // the need for dlOptions, and simplify the section below.
	                    pointOptions = point.dlOptions || (point.options && point.options.dataLabels); // dlOptions is used in treemaps
	                    enabled = pick(pointOptions && pointOptions.enabled, generalOptions.enabled) && point.y !== null; // #2282, #4641
	                    if (enabled) {
	                        // Create individual options structure that can be extended without
	                        // affecting others
	                        options = merge(generalOptions, pointOptions);
	                        labelConfig = point.getLabelConfig();
	                        str = options.format ?
	                            format(options.format, labelConfig) :
	                            options.formatter.call(labelConfig, options);
	                        style = options.style;
	                        rotation = options.rotation;
	
	                        // Determine the color
	                        style.color = pick(options.color, style.color, series.color, '#000000');
	                        // Get automated contrast color
	                        if (style.color === 'contrast') {
	                            point.contrastColor = renderer.getContrast(point.color || series.color);
	                            style.color = options.inside || pick(point.labelDistance, options.distance) < 0 ||
	                                !!seriesOptions.stacking ? point.contrastColor : '#000000';
	                        }
	                        if (seriesOptions.cursor) {
	                            style.cursor = seriesOptions.cursor;
	                        }
	
	
	                        attr = {
	                            //align: align,
	
	                            fill: options.backgroundColor,
	                            stroke: options.borderColor,
	                            'stroke-width': options.borderWidth,
	
	                            r: options.borderRadius || 0,
	                            rotation: rotation,
	                            padding: options.padding,
	                            zIndex: 1
	                        };
	
	                        // Remove unused attributes (#947)
	                        H.objectEach(attr, function(val, name) {
	                            if (val === undefined) {
	                                delete attr[name];
	                            }
	                        });
	                    }
	                    // If the point is outside the plot area, destroy it. #678, #820
	                    if (dataLabel && (!enabled || !defined(str))) {
	                        point.dataLabel = dataLabel = dataLabel.destroy();
	                        if (connector) {
	                            point.connector = connector.destroy();
	                        }
	                        // Individual labels are disabled if the are explicitly disabled
	                        // in the point options, or if they fall outside the plot area.
	                    } else if (enabled && defined(str)) {
	                        // create new label
	                        if (!dataLabel) {
	                            dataLabel = point.dataLabel = renderer[rotation ? 'text' : 'label']( // labels don't support rotation
	                                str,
	                                0, -9999,
	                                options.shape,
	                                null,
	                                null,
	                                options.useHTML,
	                                null,
	                                'data-label'
	                            );
	                            dataLabel.addClass(
	                                'highcharts-data-label-color-' + point.colorIndex +
	                                ' ' + (options.className || '') +
	                                (options.useHTML ? 'highcharts-tracker' : '') // #3398
	                            );
	                        } else {
	                            attr.text = str;
	                        }
	                        dataLabel.attr(attr);
	
	                        // Styles must be applied before add in order to read text bounding box
	                        dataLabel.css(style).shadow(options.shadow);
	
	
	                        if (!dataLabel.added) {
	                            dataLabel.add(dataLabelsGroup);
	                        }
	                        // Now the data label is created and placed at 0,0, so we need to align it
	                        series.alignDataLabel(point, dataLabel, options, null, isNew);
	                    }
	                });
	            }
	        };
	
	        /**
	         * Align each individual data label
	         */
	        Series.prototype.alignDataLabel = function(point, dataLabel, options, alignTo, isNew) {
	            var chart = this.chart,
	                inverted = chart.inverted,
	                plotX = pick(point.plotX, -9999),
	                plotY = pick(point.plotY, -9999),
	                bBox = dataLabel.getBBox(),
	                fontSize,
	                baseline,
	                rotation = options.rotation,
	                normRotation,
	                negRotation,
	                align = options.align,
	                rotCorr, // rotation correction
	                // Math.round for rounding errors (#2683), alignTo to allow column labels (#2700)
	                visible =
	                this.visible &&
	                (
	                    point.series.forceDL ||
	                    chart.isInsidePlot(plotX, Math.round(plotY), inverted) ||
	                    (
	                        alignTo && chart.isInsidePlot(
	                            plotX,
	                            inverted ? alignTo.x + 1 : alignTo.y + alignTo.height - 1,
	                            inverted
	                        )
	                    )
	                ),
	                alignAttr, // the final position;
	                justify = pick(options.overflow, 'justify') === 'justify';
	
	            if (visible) {
	
	
	                fontSize = options.style.fontSize;
	
	
	                baseline = chart.renderer.fontMetrics(fontSize, dataLabel).b;
	
	                // The alignment box is a singular point
	                alignTo = extend({
	                    x: inverted ? this.yAxis.len - plotY : plotX,
	                    y: Math.round(inverted ? this.xAxis.len - plotX : plotY),
	                    width: 0,
	                    height: 0
	                }, alignTo);
	
	                // Add the text size for alignment calculation
	                extend(options, {
	                    width: bBox.width,
	                    height: bBox.height
	                });
	
	                // Allow a hook for changing alignment in the last moment, then do the alignment
	                if (rotation) {
	                    justify = false; // Not supported for rotated text
	                    rotCorr = chart.renderer.rotCorr(baseline, rotation); // #3723
	                    alignAttr = {
	                        x: alignTo.x + options.x + alignTo.width / 2 + rotCorr.x,
	                        y: alignTo.y + options.y + {
	                            top: 0,
	                            middle: 0.5,
	                            bottom: 1
	                        }[options.verticalAlign] * alignTo.height
	                    };
	                    dataLabel[isNew ? 'attr' : 'animate'](alignAttr)
	                        .attr({ // #3003
	                            align: align
	                        });
	
	                    // Compensate for the rotated label sticking out on the sides
	                    normRotation = (rotation + 720) % 360;
	                    negRotation = normRotation > 180 && normRotation < 360;
	
	                    if (align === 'left') {
	                        alignAttr.y -= negRotation ? bBox.height : 0;
	                    } else if (align === 'center') {
	                        alignAttr.x -= bBox.width / 2;
	                        alignAttr.y -= bBox.height / 2;
	                    } else if (align === 'right') {
	                        alignAttr.x -= bBox.width;
	                        alignAttr.y -= negRotation ? 0 : bBox.height;
	                    }
	
	
	                } else {
	                    dataLabel.align(options, null, alignTo);
	                    alignAttr = dataLabel.alignAttr;
	                }
	
	                // Handle justify or crop
	                if (justify) {
	                    point.isLabelJustified = this.justifyDataLabel(
	                        dataLabel,
	                        options,
	                        alignAttr,
	                        bBox,
	                        alignTo,
	                        isNew
	                    );
	
	                    // Now check that the data label is within the plot area
	                } else if (pick(options.crop, true)) {
	                    visible = chart.isInsidePlot(alignAttr.x, alignAttr.y) && chart.isInsidePlot(alignAttr.x + bBox.width, alignAttr.y + bBox.height);
	                }
	
	                // When we're using a shape, make it possible with a connector or an arrow pointing to thie point
	                if (options.shape && !rotation) {
	                    dataLabel[isNew ? 'attr' : 'animate']({
	                        anchorX: inverted ? chart.plotWidth - point.plotY : point.plotX,
	                        anchorY: inverted ? chart.plotHeight - point.plotX : point.plotY
	                    });
	                }
	            }
	
	            // Show or hide based on the final aligned position
	            if (!visible) {
	                dataLabel.attr({
	                    y: -9999
	                });
	                dataLabel.placed = false; // don't animate back in
	            }
	
	        };
	
	        /**
	         * If data labels fall partly outside the plot area, align them back in, in a way that
	         * doesn't hide the point.
	         */
	        Series.prototype.justifyDataLabel = function(dataLabel, options, alignAttr, bBox, alignTo, isNew) {
	            var chart = this.chart,
	                align = options.align,
	                verticalAlign = options.verticalAlign,
	                off,
	                justified,
	                padding = dataLabel.box ? 0 : (dataLabel.padding || 0);
	
	            // Off left
	            off = alignAttr.x + padding;
	            if (off < 0) {
	                if (align === 'right') {
	                    options.align = 'left';
	                } else {
	                    options.x = -off;
	                }
	                justified = true;
	            }
	
	            // Off right
	            off = alignAttr.x + bBox.width - padding;
	            if (off > chart.plotWidth) {
	                if (align === 'left') {
	                    options.align = 'right';
	                } else {
	                    options.x = chart.plotWidth - off;
	                }
	                justified = true;
	            }
	
	            // Off top
	            off = alignAttr.y + padding;
	            if (off < 0) {
	                if (verticalAlign === 'bottom') {
	                    options.verticalAlign = 'top';
	                } else {
	                    options.y = -off;
	                }
	                justified = true;
	            }
	
	            // Off bottom
	            off = alignAttr.y + bBox.height - padding;
	            if (off > chart.plotHeight) {
	                if (verticalAlign === 'top') {
	                    options.verticalAlign = 'bottom';
	                } else {
	                    options.y = chart.plotHeight - off;
	                }
	                justified = true;
	            }
	
	            if (justified) {
	                dataLabel.placed = !isNew;
	                dataLabel.align(options, null, alignTo);
	            }
	
	            return justified;
	        };
	
	        /**
	         * Override the base drawDataLabels method by pie specific functionality
	         */
	        if (seriesTypes.pie) {
	            seriesTypes.pie.prototype.drawDataLabels = function() {
	                var series = this,
	                    data = series.data,
	                    point,
	                    chart = series.chart,
	                    options = series.options.dataLabels,
	                    connectorPadding = pick(options.connectorPadding, 10),
	                    connectorWidth = pick(options.connectorWidth, 1),
	                    plotWidth = chart.plotWidth,
	                    plotHeight = chart.plotHeight,
	                    connector,
	                    seriesCenter = series.center,
	                    radius = seriesCenter[2] / 2,
	                    centerY = seriesCenter[1],
	                    dataLabel,
	                    dataLabelWidth,
	                    labelPos,
	                    labelHeight,
	                    halves = [ // divide the points into right and left halves for anti collision
	                        [], // right
	                        [] // left
	                    ],
	                    x,
	                    y,
	                    visibility,
	                    j,
	                    overflow = [0, 0, 0, 0]; // top, right, bottom, left
	
	                // get out if not enabled
	                if (!series.visible || (!options.enabled && !series._hasPointLabels)) {
	                    return;
	                }
	
	                // Reset all labels that have been shortened
	                each(data, function(point) {
	                    if (point.dataLabel && point.visible && point.dataLabel.shortened) {
	                        point.dataLabel
	                            .attr({
	                                width: 'auto'
	                            }).css({
	                                width: 'auto',
	                                textOverflow: 'clip'
	                            });
	                        point.dataLabel.shortened = false;
	                    }
	                });
	
	
	                // run parent method
	                Series.prototype.drawDataLabels.apply(series);
	
	                each(data, function(point) {
	                    if (point.dataLabel && point.visible) { // #407, #2510
	
	                        // Arrange points for detection collision
	                        halves[point.half].push(point);
	
	                        // Reset positions (#4905)
	                        point.dataLabel._pos = null;
	                    }
	                });
	
	                /* Loop over the points in each half, starting from the top and bottom
	                 * of the pie to detect overlapping labels.
	                 */
	                each(halves, function(points, i) {
	
	                    var top,
	                        bottom,
	                        length = points.length,
	                        positions = [],
	                        naturalY,
	                        sideOverflow,
	                        positionsIndex, // Point index in positions array.
	                        size;
	
	                    if (!length) {
	                        return;
	                    }
	
	                    // Sort by angle
	                    series.sortByAngle(points, i - 0.5);
	                    // Only do anti-collision when we have dataLabels outside the pie 
	                    // and have connectors. (#856)
	                    if (series.maxLabelDistance > 0) {
	                        top = Math.max(
	                            0,
	                            centerY - radius - series.maxLabelDistance
	                        );
	                        bottom = Math.min(
	                            centerY + radius + series.maxLabelDistance,
	                            chart.plotHeight
	                        );
	                        each(points, function(point) {
	                            // check if specific points' label is outside the pie
	                            if (point.labelDistance > 0 && point.dataLabel) {
	                                // point.top depends on point.labelDistance value
	                                // Used for calculation of y value in getX method 
	                                point.top = Math.max(
	                                    0,
	                                    centerY - radius - point.labelDistance
	                                );
	                                point.bottom = Math.min(
	                                    centerY + radius + point.labelDistance,
	                                    chart.plotHeight
	                                );
	                                size = point.dataLabel.getBBox().height || 21;
	
	                                // point.positionsIndex is needed for getting index of 
	                                // parameter related to specific point inside positions 
	                                // array - not every point is in positions array.
	                                point.positionsIndex = positions.push({
	                                    target: point.labelPos[1] - point.top + size / 2,
	                                    size: size,
	                                    rank: point.y
	                                }) - 1;
	                            }
	                        });
	                        H.distribute(positions, bottom + size - top);
	                    }
	
	                    // Now the used slots are sorted, fill them up sequentially
	                    for (j = 0; j < length; j++) {
	
	                        point = points[j];
	                        positionsIndex = point.positionsIndex;
	                        labelPos = point.labelPos;
	                        dataLabel = point.dataLabel;
	                        visibility = point.visible === false ? 'hidden' : 'inherit';
	                        naturalY = labelPos[1];
	
	                        if (positions && defined(positions[positionsIndex])) {
	                            if (positions[positionsIndex].pos === undefined) {
	                                visibility = 'hidden';
	                            } else {
	                                labelHeight = positions[positionsIndex].size;
	                                y = point.top + positions[positionsIndex].pos;
	                            }
	
	                        } else {
	                            y = naturalY;
	                        }
	
	                        // It is needed to delete point.positionIndex for 
	                        // dynamically added points etc.
	
	                        delete point.positionIndex;
	
	                        // get the x - use the natural x position for labels near the 
	                        // top and bottom, to prevent the top and botton slice connectors 
	                        // from touching each other on either side
	                        if (options.justify) {
	                            x = seriesCenter[0] + (i ? -1 : 1) * (radius + point.labelDistance);
	                        } else {
	                            x = series.getX(y < point.top + 2 || y > point.bottom - 2 ? naturalY : y, i, point);
	                        }
	
	
	                        // Record the placement and visibility
	                        dataLabel._attr = {
	                            visibility: visibility,
	                            align: labelPos[6]
	                        };
	                        dataLabel._pos = {
	                            x: x + options.x +
	                                ({
	                                    left: connectorPadding,
	                                    right: -connectorPadding
	                                }[labelPos[6]] || 0),
	                            y: y + options.y - 10 // 10 is for the baseline (label vs text)
	                        };
	                        labelPos.x = x;
	                        labelPos.y = y;
	
	
	                        // Detect overflowing data labels
	                        if (pick(options.crop, true)) {
	                            dataLabelWidth = dataLabel.getBBox().width;
	
	                            sideOverflow = null;
	                            // Overflow left
	                            if (x - dataLabelWidth < connectorPadding) {
	                                sideOverflow = Math.round(
	                                    dataLabelWidth - x + connectorPadding
	                                );
	                                overflow[3] = Math.max(sideOverflow, overflow[3]);
	
	                                // Overflow right
	                            } else if (
	                                x + dataLabelWidth >
	                                plotWidth - connectorPadding
	                            ) {
	                                sideOverflow = Math.round(
	                                    x + dataLabelWidth - plotWidth + connectorPadding
	                                );
	                                overflow[1] = Math.max(sideOverflow, overflow[1]);
	                            }
	
	                            // Overflow top
	                            if (y - labelHeight / 2 < 0) {
	                                overflow[0] = Math.max(
	                                    Math.round(-y + labelHeight / 2),
	                                    overflow[0]
	                                );
	
	                                // Overflow left
	                            } else if (y + labelHeight / 2 > plotHeight) {
	                                overflow[2] = Math.max(
	                                    Math.round(y + labelHeight / 2 - plotHeight),
	                                    overflow[2]
	                                );
	                            }
	                            dataLabel.sideOverflow = sideOverflow;
	                        }
	                    } // for each point
	                }); // for each half
	
	                // Do not apply the final placement and draw the connectors until we have verified
	                // that labels are not spilling over.
	                if (arrayMax(overflow) === 0 || this.verifyDataLabelOverflow(overflow)) {
	
	                    // Place the labels in the final position
	                    this.placeDataLabels();
	
	                    // Draw the connectors
	                    if (connectorWidth) {
	                        each(this.points, function(point) {
	                            var isNew;
	
	                            connector = point.connector;
	                            dataLabel = point.dataLabel;
	
	                            if (
	                                dataLabel &&
	                                dataLabel._pos &&
	                                point.visible &&
	                                point.labelDistance > 0
	                            ) {
	                                visibility = dataLabel._attr.visibility;
	
	                                isNew = !connector;
	
	                                if (isNew) {
	                                    point.connector = connector = chart.renderer.path()
	                                        .addClass('highcharts-data-label-connector highcharts-color-' + point.colorIndex)
	                                        .add(series.dataLabelsGroup);
	
	
	                                    connector.attr({
	                                        'stroke-width': connectorWidth,
	                                        'stroke': options.connectorColor || point.color || '#666666'
	                                    });
	
	                                }
	                                connector[isNew ? 'attr' : 'animate']({
	                                    d: series.connectorPath(point.labelPos)
	                                });
	                                connector.attr('visibility', visibility);
	
	                            } else if (connector) {
	                                point.connector = connector.destroy();
	                            }
	                        });
	                    }
	                }
	            };
	
	            /**
	             * Extendable method for getting the path of the connector between the data label
	             * and the pie slice.
	             */
	            seriesTypes.pie.prototype.connectorPath = function(labelPos) {
	                var x = labelPos.x,
	                    y = labelPos.y;
	                return pick(this.options.dataLabels.softConnector, true) ? [
	                    'M',
	                    x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label
	                    'C',
	                    x, y, // first break, next to the label
	                    2 * labelPos[2] - labelPos[4], 2 * labelPos[3] - labelPos[5],
	                    labelPos[2], labelPos[3], // second break
	                    'L',
	                    labelPos[4], labelPos[5] // base
	                ] : [
	                    'M',
	                    x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label
	                    'L',
	                    labelPos[2], labelPos[3], // second break
	                    'L',
	                    labelPos[4], labelPos[5] // base
	                ];
	            };
	
	            /**
	             * Perform the final placement of the data labels after we have verified that they
	             * fall within the plot area.
	             */
	            seriesTypes.pie.prototype.placeDataLabels = function() {
	                each(this.points, function(point) {
	                    var dataLabel = point.dataLabel,
	                        _pos;
	                    if (dataLabel && point.visible) {
	                        _pos = dataLabel._pos;
	                        if (_pos) {
	
	                            // Shorten data labels with ellipsis if they still overflow
	                            // after the pie has reached minSize (#223).
	                            if (dataLabel.sideOverflow) {
	                                dataLabel._attr.width =
	                                    dataLabel.getBBox().width - dataLabel.sideOverflow;
	                                dataLabel.css({
	                                    width: dataLabel._attr.width + 'px',
	                                    textOverflow: 'ellipsis'
	                                });
	                                dataLabel.shortened = true;
	                            }
	
	                            dataLabel.attr(dataLabel._attr);
	                            dataLabel[dataLabel.moved ? 'animate' : 'attr'](_pos);
	                            dataLabel.moved = true;
	                        } else if (dataLabel) {
	                            dataLabel.attr({
	                                y: -9999
	                            });
	                        }
	                    }
	                }, this);
	            };
	
	            seriesTypes.pie.prototype.alignDataLabel = noop;
	
	            /**
	             * Verify whether the data labels are allowed to draw, or we should run more translation and data
	             * label positioning to keep them inside the plot area. Returns true when data labels are ready
	             * to draw.
	             */
	            seriesTypes.pie.prototype.verifyDataLabelOverflow = function(overflow) {
	
	                var center = this.center,
	                    options = this.options,
	                    centerOption = options.center,
	                    minSize = options.minSize || 80,
	                    newSize = minSize,
	                    // If a size is set, return true and don't try to shrink the pie
	                    // to fit the labels.
	                    ret = options.size !== null;
	
	                if (!ret) {
	                    // Handle horizontal size and center
	                    if (centerOption[0] !== null) { // Fixed center
	                        newSize = Math.max(center[2] -
	                            Math.max(overflow[1], overflow[3]), minSize);
	
	                    } else { // Auto center
	                        newSize = Math.max(
	                            // horizontal overflow
	                            center[2] - overflow[1] - overflow[3],
	                            minSize
	                        );
	                        // horizontal center
	                        center[0] += (overflow[3] - overflow[1]) / 2;
	                    }
	
	                    // Handle vertical size and center
	                    if (centerOption[1] !== null) { // Fixed center
	                        newSize = Math.max(Math.min(newSize, center[2] -
	                            Math.max(overflow[0], overflow[2])), minSize);
	
	                    } else { // Auto center
	                        newSize = Math.max(
	                            Math.min(
	                                newSize,
	                                // vertical overflow
	                                center[2] - overflow[0] - overflow[2]
	                            ),
	                            minSize
	                        );
	                        // vertical center
	                        center[1] += (overflow[0] - overflow[2]) / 2;
	                    }
	
	                    // If the size must be decreased, we need to run translate and
	                    // drawDataLabels again
	                    if (newSize < center[2]) {
	                        center[2] = newSize;
	                        center[3] = Math.min( // #3632
	                            relativeLength(options.innerSize || 0, newSize),
	                            newSize
	                        );
	                        this.translate(center);
	
	                        if (this.drawDataLabels) {
	                            this.drawDataLabels();
	                        }
	                        // Else, return true to indicate that the pie and its labels is
	                        // within the plot area
	                    } else {
	                        ret = true;
	                    }
	                }
	                return ret;
	            };
	        }
	
	        if (seriesTypes.column) {
	
	            /**
	             * Override the basic data label alignment by adjusting for the position of the column
	             */
	            seriesTypes.column.prototype.alignDataLabel = function(point, dataLabel, options, alignTo, isNew) {
	                var inverted = this.chart.inverted,
	                    series = point.series,
	                    dlBox = point.dlBox || point.shapeArgs, // data label box for alignment
	                    below = pick(point.below, point.plotY > pick(this.translatedThreshold, series.yAxis.len)), // point.below is used in range series
	                    inside = pick(options.inside, !!this.options.stacking), // draw it inside the box?
	                    overshoot;
	
	                // Align to the column itself, or the top of it
	                if (dlBox) { // Area range uses this method but not alignTo
	                    alignTo = merge(dlBox);
	
	                    if (alignTo.y < 0) {
	                        alignTo.height += alignTo.y;
	                        alignTo.y = 0;
	                    }
	                    overshoot = alignTo.y + alignTo.height - series.yAxis.len;
	                    if (overshoot > 0) {
	                        alignTo.height -= overshoot;
	                    }
	
	                    if (inverted) {
	                        alignTo = {
	                            x: series.yAxis.len - alignTo.y - alignTo.height,
	                            y: series.xAxis.len - alignTo.x - alignTo.width,
	                            width: alignTo.height,
	                            height: alignTo.width
	                        };
	                    }
	
	                    // Compute the alignment box
	                    if (!inside) {
	                        if (inverted) {
	                            alignTo.x += below ? 0 : alignTo.width;
	                            alignTo.width = 0;
	                        } else {
	                            alignTo.y += below ? alignTo.height : 0;
	                            alignTo.height = 0;
	                        }
	                    }
	                }
	
	
	                // When alignment is undefined (typically columns and bars), display the individual
	                // point below or above the point depending on the threshold
	                options.align = pick(
	                    options.align, !inverted || inside ? 'center' : below ? 'right' : 'left'
	                );
	                options.verticalAlign = pick(
	                    options.verticalAlign,
	                    inverted || inside ? 'middle' : below ? 'top' : 'bottom'
	                );
	
	                // Call the parent method
	                Series.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);
	
	                // If label was justified and we have contrast, set it:
	                if (point.isLabelJustified && point.contrastColor) {
	                    point.dataLabel.css({
	                        color: point.contrastColor
	                    });
	                }
	            };
	        }
	
	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2009-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        /**
	         * Highcharts module to hide overlapping data labels. This module is included in
	         * Highcharts.
	         */
	        var Chart = H.Chart,
	            each = H.each,
	            objectEach = H.objectEach,
	            pick = H.pick,
	            addEvent = H.addEvent;
	
	        // Collect potensial overlapping data labels. Stack labels probably don't need
	        // to be considered because they are usually accompanied by data labels that lie
	        // inside the columns.
	        Chart.prototype.callbacks.push(function(chart) {
	            function collectAndHide() {
	                var labels = [];
	
	                each(chart.yAxis || [], function(yAxis) {
	                    if (
	                        yAxis.options.stackLabels &&
	                        !yAxis.options.stackLabels.allowOverlap
	                    ) {
	                        objectEach(yAxis.stacks, function(stack) {
	                            objectEach(stack, function(stackItem) {
	                                labels.push(stackItem.label);
	                            });
	                        });
	                    }
	                });
	
	                each(chart.series || [], function(series) {
	                    var dlOptions = series.options.dataLabels,
	                        // Range series have two collections
	                        collections = series.dataLabelCollections || ['dataLabel'];
	
	                    if (
	                        (dlOptions.enabled || series._hasPointLabels) &&
	                        !dlOptions.allowOverlap &&
	                        series.visible
	                    ) { // #3866
	                        each(collections, function(coll) {
	                            each(series.points, function(point) {
	                                if (point[coll]) {
	                                    point[coll].labelrank = pick(
	                                        point.labelrank,
	                                        point.shapeArgs && point.shapeArgs.height
	                                    ); // #4118
	                                    labels.push(point[coll]);
	                                }
	                            });
	                        });
	                    }
	                });
	                chart.hideOverlappingLabels(labels);
	            }
	
	            // Do it now ...
	            collectAndHide();
	
	            // ... and after each chart redraw
	            addEvent(chart, 'redraw', collectAndHide);
	
	        });
	
	        /**
	         * Hide overlapping labels. Labels are moved and faded in and out on zoom to
	         * provide a smooth visual imression.
	         */
	        Chart.prototype.hideOverlappingLabels = function(labels) {
	
	            var len = labels.length,
	                label,
	                i,
	                j,
	                label1,
	                label2,
	                isIntersecting,
	                pos1,
	                pos2,
	                parent1,
	                parent2,
	                padding,
	                bBox,
	                intersectRect = function(x1, y1, w1, h1, x2, y2, w2, h2) {
	                    return !(
	                        x2 > x1 + w1 ||
	                        x2 + w2 < x1 ||
	                        y2 > y1 + h1 ||
	                        y2 + h2 < y1
	                    );
	                };
	
	            for (i = 0; i < len; i++) {
	                label = labels[i];
	                if (label) {
	
	                    // Mark with initial opacity
	                    label.oldOpacity = label.opacity;
	                    label.newOpacity = 1;
	
	                    // Get width and height if pure text nodes (stack labels)
	                    if (!label.width) {
	                        bBox = label.getBBox();
	                        label.width = bBox.width;
	                        label.height = bBox.height;
	                    }
	                }
	            }
	
	            // Prevent a situation in a gradually rising slope, that each label will
	            // hide the previous one because the previous one always has lower rank.
	            labels.sort(function(a, b) {
	                return (b.labelrank || 0) - (a.labelrank || 0);
	            });
	
	            // Detect overlapping labels
	            for (i = 0; i < len; i++) {
	                label1 = labels[i];
	
	                for (j = i + 1; j < len; ++j) {
	                    label2 = labels[j];
	                    if (
	                        label1 && label2 &&
	                        label1 !== label2 && // #6465, polar chart with connectEnds
	                        label1.placed && label2.placed &&
	                        label1.newOpacity !== 0 && label2.newOpacity !== 0
	                    ) {
	                        pos1 = label1.alignAttr;
	                        pos2 = label2.alignAttr;
	                        // Different panes have different positions
	                        parent1 = label1.parentGroup;
	                        parent2 = label2.parentGroup;
	                        // Substract the padding if no background or border (#4333)
	                        padding = 2 * (label1.box ? 0 : (label1.padding || 0));
	                        isIntersecting = intersectRect(
	                            pos1.x + parent1.translateX,
	                            pos1.y + parent1.translateY,
	                            label1.width - padding,
	                            label1.height - padding,
	                            pos2.x + parent2.translateX,
	                            pos2.y + parent2.translateY,
	                            label2.width - padding,
	                            label2.height - padding
	                        );
	
	                        if (isIntersecting) {
	                            (label1.labelrank < label2.labelrank ? label1 : label2)
	                            .newOpacity = 0;
	                        }
	                    }
	                }
	            }
	
	            // Hide or show
	            each(labels, function(label) {
	                var complete,
	                    newOpacity;
	
	                if (label) {
	                    newOpacity = label.newOpacity;
	
	                    if (label.oldOpacity !== newOpacity && label.placed) {
	
	                        // Make sure the label is completely hidden to avoid catching
	                        // clicks (#4362)
	                        if (newOpacity) {
	                            label.show(true);
	                        } else {
	                            complete = function() {
	                                label.hide();
	                            };
	                        }
	
	                        // Animate or set the opacity					
	                        label.alignAttr.opacity = newOpacity;
	                        label[label.isOld ? 'animate' : 'attr'](
	                            label.alignAttr,
	                            null,
	                            complete
	                        );
	
	                    }
	                    label.isOld = true;
	                }
	            });
	        };
	
	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var addEvent = H.addEvent,
	            Chart = H.Chart,
	            createElement = H.createElement,
	            css = H.css,
	            defaultOptions = H.defaultOptions,
	            defaultPlotOptions = H.defaultPlotOptions,
	            each = H.each,
	            extend = H.extend,
	            fireEvent = H.fireEvent,
	            hasTouch = H.hasTouch,
	            inArray = H.inArray,
	            isObject = H.isObject,
	            Legend = H.Legend,
	            merge = H.merge,
	            pick = H.pick,
	            Point = H.Point,
	            Series = H.Series,
	            seriesTypes = H.seriesTypes,
	            svg = H.svg,
	            TrackerMixin;
	
	        /**
	         * TrackerMixin for points and graphs.
	         */
	        TrackerMixin = H.TrackerMixin = {
	
	            /**
	             * Draw the tracker for a point.
	             */
	            drawTrackerPoint: function() {
	                var series = this,
	                    chart = series.chart,
	                    pointer = chart.pointer,
	                    onMouseOver = function(e) {
	                        var point = pointer.getPointFromEvent(e);
	                        // undefined on graph in scatterchart
	                        if (point !== undefined) {
	                            pointer.isDirectTouch = true;
	                            point.onMouseOver(e);
	                        }
	                    };
	
	                // Add reference to the point
	                each(series.points, function(point) {
	                    if (point.graphic) {
	                        point.graphic.element.point = point;
	                    }
	                    if (point.dataLabel) {
	                        if (point.dataLabel.div) {
	                            point.dataLabel.div.point = point;
	                        } else {
	                            point.dataLabel.element.point = point;
	                        }
	                    }
	                });
	
	                // Add the event listeners, we need to do this only once
	                if (!series._hasTracking) {
	                    each(series.trackerGroups, function(key) {
	                        if (series[key]) { // we don't always have dataLabelsGroup
	                            series[key]
	                                .addClass('highcharts-tracker')
	                                .on('mouseover', onMouseOver)
	                                .on('mouseout', function(e) {
	                                    pointer.onTrackerMouseOut(e);
	                                });
	                            if (hasTouch) {
	                                series[key].on('touchstart', onMouseOver);
	                            }
	
	
	                            if (series.options.cursor) {
	                                series[key]
	                                    .css(css)
	                                    .css({
	                                        cursor: series.options.cursor
	                                    });
	                            }
	
	                        }
	                    });
	                    series._hasTracking = true;
	                }
	            },
	
	            /**
	             * Draw the tracker object that sits above all data labels and markers to
	             * track mouse events on the graph or points. For the line type charts
	             * the tracker uses the same graphPath, but with a greater stroke width
	             * for better control.
	             */
	            drawTrackerGraph: function() {
	                var series = this,
	                    options = series.options,
	                    trackByArea = options.trackByArea,
	                    trackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath),
	                    trackerPathLength = trackerPath.length,
	                    chart = series.chart,
	                    pointer = chart.pointer,
	                    renderer = chart.renderer,
	                    snap = chart.options.tooltip.snap,
	                    tracker = series.tracker,
	                    i,
	                    onMouseOver = function() {
	                        if (chart.hoverSeries !== series) {
	                            series.onMouseOver();
	                        }
	                    },
	                    /*
	                     * Empirical lowest possible opacities for TRACKER_FILL for an element to stay invisible but clickable
	                     * IE6: 0.002
	                     * IE7: 0.002
	                     * IE8: 0.002
	                     * IE9: 0.00000000001 (unlimited)
	                     * IE10: 0.0001 (exporting only)
	                     * FF: 0.00000000001 (unlimited)
	                     * Chrome: 0.000001
	                     * Safari: 0.000001
	                     * Opera: 0.00000000001 (unlimited)
	                     */
	                    TRACKER_FILL = 'rgba(192,192,192,' + (svg ? 0.0001 : 0.002) + ')';
	
	                // Extend end points. A better way would be to use round linecaps,
	                // but those are not clickable in VML.
	                if (trackerPathLength && !trackByArea) {
	                    i = trackerPathLength + 1;
	                    while (i--) {
	                        if (trackerPath[i] === 'M') { // extend left side
	                            trackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], 'L');
	                        }
	                        if ((i && trackerPath[i] === 'M') || i === trackerPathLength) { // extend right side
	                            trackerPath.splice(i, 0, 'L', trackerPath[i - 2] + snap, trackerPath[i - 1]);
	                        }
	                    }
	                }
	
	                // handle single points
	                /*for (i = 0; i < singlePoints.length; i++) {
	                	singlePoint = singlePoints[i];
	                	trackerPath.push(M, singlePoint.plotX - snap, singlePoint.plotY,
	                	L, singlePoint.plotX + snap, singlePoint.plotY);
	                }*/
	
	                // draw the tracker
	                if (tracker) {
	                    tracker.attr({
	                        d: trackerPath
	                    });
	                } else if (series.graph) { // create
	
	                    series.tracker = renderer.path(trackerPath)
	                        .attr({
	                            'stroke-linejoin': 'round', // #1225
	                            visibility: series.visible ? 'visible' : 'hidden',
	                            stroke: TRACKER_FILL,
	                            fill: trackByArea ? TRACKER_FILL : 'none',
	                            'stroke-width': series.graph.strokeWidth() + (trackByArea ? 0 : 2 * snap),
	                            zIndex: 2
	                        })
	                        .add(series.group);
	
	                    // The tracker is added to the series group, which is clipped, but is covered
	                    // by the marker group. So the marker group also needs to capture events.
	                    each([series.tracker, series.markerGroup], function(tracker) {
	                        tracker.addClass('highcharts-tracker')
	                            .on('mouseover', onMouseOver)
	                            .on('mouseout', function(e) {
	                                pointer.onTrackerMouseOut(e);
	                            });
	
	
	                        if (options.cursor) {
	                            tracker.css({
	                                cursor: options.cursor
	                            });
	                        }
	
	
	                        if (hasTouch) {
	                            tracker.on('touchstart', onMouseOver);
	                        }
	                    });
	                }
	            }
	        };
	        /* End TrackerMixin */
	
	
	        /**
	         * Add tracking event listener to the series group, so the point graphics
	         * themselves act as trackers
	         */
	
	        if (seriesTypes.column) {
	            seriesTypes.column.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
	        }
	
	        if (seriesTypes.pie) {
	            seriesTypes.pie.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
	        }
	
	        if (seriesTypes.scatter) {
	            seriesTypes.scatter.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
	        }
	
	        /*
	         * Extend Legend for item events
	         */
	        extend(Legend.prototype, {
	
	            setItemEvents: function(item, legendItem, useHTML) {
	                var legend = this,
	                    boxWrapper = legend.chart.renderer.boxWrapper,
	                    activeClass = 'highcharts-legend-' + (item.series ? 'point' : 'series') + '-active';
	
	                // Set the events on the item group, or in case of useHTML, the item itself (#1249)
	                (useHTML ? legendItem : item.legendGroup).on('mouseover', function() {
	                        item.setState('hover');
	
	                        // A CSS class to dim or hide other than the hovered series
	                        boxWrapper.addClass(activeClass);
	
	
	                        legendItem.css(legend.options.itemHoverStyle);
	
	                    })
	                    .on('mouseout', function() {
	
	                        legendItem.css(merge(item.visible ? legend.itemStyle : legend.itemHiddenStyle));
	
	
	                        // A CSS class to dim or hide other than the hovered series
	                        boxWrapper.removeClass(activeClass);
	
	                        item.setState();
	                    })
	                    .on('click', function(event) {
	                        var strLegendItemClick = 'legendItemClick',
	                            fnLegendItemClick = function() {
	                                if (item.setVisible) {
	                                    item.setVisible();
	                                }
	                            };
	
	                        // Pass over the click/touch event. #4.
	                        event = {
	                            browserEvent: event
	                        };
	
	                        // click the name or symbol
	                        if (item.firePointEvent) { // point
	                            item.firePointEvent(strLegendItemClick, event, fnLegendItemClick);
	                        } else {
	                            fireEvent(item, strLegendItemClick, event, fnLegendItemClick);
	                        }
	                    });
	            },
	
	            createCheckboxForItem: function(item) {
	                var legend = this;
	
	                item.checkbox = createElement('input', {
	                    type: 'checkbox',
	                    checked: item.selected,
	                    defaultChecked: item.selected // required by IE7
	                }, legend.options.itemCheckboxStyle, legend.chart.container);
	
	                addEvent(item.checkbox, 'click', function(event) {
	                    var target = event.target;
	                    fireEvent(
	                        item.series || item,
	                        'checkboxClick', { // #3712
	                            checked: target.checked,
	                            item: item
	                        },
	                        function() {
	                            item.select();
	                        }
	                    );
	                });
	            }
	        });
	
	
	
	        // Add pointer cursor to legend itemstyle in defaultOptions
	        defaultOptions.legend.itemStyle.cursor = 'pointer';
	
	
	
	        /*
	         * Extend the Chart object with interaction
	         */
	
	        extend(Chart.prototype, /** @lends Chart.prototype */ {
	            /**
	             * Display the zoom button.
	             *
	             * @private
	             */
	            showResetZoom: function() {
	                var chart = this,
	                    lang = defaultOptions.lang,
	                    btnOptions = chart.options.chart.resetZoomButton,
	                    theme = btnOptions.theme,
	                    states = theme.states,
	                    alignTo = btnOptions.relativeTo === 'chart' ? null : 'plotBox';
	
	                function zoomOut() {
	                    chart.zoomOut();
	                }
	
	                this.resetZoomButton = chart.renderer.button(lang.resetZoom, null, null, zoomOut, theme, states && states.hover)
	                    .attr({
	                        align: btnOptions.position.align,
	                        title: lang.resetZoomTitle
	                    })
	                    .addClass('highcharts-reset-zoom')
	                    .add()
	                    .align(btnOptions.position, false, alignTo);
	
	            },
	
	            /**
	             * Zoom out to 1:1.
	             *
	             * @private
	             */
	            zoomOut: function() {
	                var chart = this;
	                fireEvent(chart, 'selection', {
	                    resetSelection: true
	                }, function() {
	                    chart.zoom();
	                });
	            },
	
	            /**
	             * Zoom into a given portion of the chart given by axis coordinates.
	             * @param {Object} event
	             *
	             * @private
	             */
	            zoom: function(event) {
	                var chart = this,
	                    hasZoomed,
	                    pointer = chart.pointer,
	                    displayButton = false,
	                    resetZoomButton;
	
	                // If zoom is called with no arguments, reset the axes
	                if (!event || event.resetSelection) {
	                    each(chart.axes, function(axis) {
	                        hasZoomed = axis.zoom();
	                    });
	                    pointer.initiated = false; // #6804
	
	                } else { // else, zoom in on all axes
	                    each(event.xAxis.concat(event.yAxis), function(axisData) {
	                        var axis = axisData.axis,
	                            isXAxis = axis.isXAxis;
	
	                        // don't zoom more than minRange
	                        if (pointer[isXAxis ? 'zoomX' : 'zoomY']) {
	                            hasZoomed = axis.zoom(axisData.min, axisData.max);
	                            if (axis.displayBtn) {
	                                displayButton = true;
	                            }
	                        }
	                    });
	                }
	
	                // Show or hide the Reset zoom button
	                resetZoomButton = chart.resetZoomButton;
	                if (displayButton && !resetZoomButton) {
	                    chart.showResetZoom();
	                } else if (!displayButton && isObject(resetZoomButton)) {
	                    chart.resetZoomButton = resetZoomButton.destroy();
	                }
	
	
	                // Redraw
	                if (hasZoomed) {
	                    chart.redraw(
	                        pick(chart.options.chart.animation, event && event.animation, chart.pointCount < 100) // animation
	                    );
	                }
	            },
	
	            /**
	             * Pan the chart by dragging the mouse across the pane. This function is
	             * called on mouse move, and the distance to pan is computed from chartX
	             * compared to the first chartX position in the dragging operation.
	             *
	             * @private
	             */
	            pan: function(e, panning) {
	
	                var chart = this,
	                    hoverPoints = chart.hoverPoints,
	                    doRedraw;
	
	                // remove active points for shared tooltip
	                if (hoverPoints) {
	                    each(hoverPoints, function(point) {
	                        point.setState();
	                    });
	                }
	
	                each(panning === 'xy' ? [1, 0] : [1], function(isX) { // xy is used in maps
	                    var axis = chart[isX ? 'xAxis' : 'yAxis'][0],
	                        horiz = axis.horiz,
	                        mousePos = e[horiz ? 'chartX' : 'chartY'],
	                        mouseDown = horiz ? 'mouseDownX' : 'mouseDownY',
	                        startPos = chart[mouseDown],
	                        halfPointRange = (axis.pointRange || 0) / 2,
	                        extremes = axis.getExtremes(),
	                        panMin = axis.toValue(startPos - mousePos, true) +
	                        halfPointRange,
	                        panMax = axis.toValue(startPos + axis.len - mousePos, true) -
	                        halfPointRange,
	                        flipped = panMax < panMin,
	                        newMin = flipped ? panMax : panMin,
	                        newMax = flipped ? panMin : panMax,
	                        paddedMin = Math.min(
	                            extremes.dataMin,
	                            axis.toValue(
	                                axis.toPixels(extremes.min) - axis.minPixelPadding
	                            )
	                        ),
	                        paddedMax = Math.max(
	                            extremes.dataMax,
	                            axis.toValue(
	                                axis.toPixels(extremes.max) + axis.minPixelPadding
	                            )
	                        ),
	                        spill;
	
	                    // If the new range spills over, either to the min or max, adjust
	                    // the new range.
	                    spill = paddedMin - newMin;
	                    if (spill > 0) {
	                        newMax += spill;
	                        newMin = paddedMin;
	                    }
	                    spill = newMax - paddedMax;
	                    if (spill > 0) {
	                        newMax = paddedMax;
	                        newMin -= spill;
	                    }
	
	                    // Set new extremes if they are actually new
	                    if (axis.series.length && newMin !== extremes.min && newMax !== extremes.max) {
	                        axis.setExtremes(
	                            newMin,
	                            newMax,
	                            false,
	                            false, {
	                                trigger: 'pan'
	                            }
	                        );
	                        doRedraw = true;
	                    }
	
	                    chart[mouseDown] = mousePos; // set new reference for next run
	                });
	
	                if (doRedraw) {
	                    chart.redraw(false);
	                }
	                css(chart.container, {
	                    cursor: 'move'
	                });
	            }
	        });
	
	        /*
	         * Extend the Point object with interaction
	         */
	        extend(Point.prototype, /** @lends Highcharts.Point.prototype */ {
	            /**
	             * Toggle the selection status of a point.
	             * @param  {Boolean} [selected]
	             *         When `true`, the point is selected. When `false`, the point is
	             *         unselected. When `null` or `undefined`, the selection state is
	             *         toggled.
	             * @param  {Boolean} [accumulate=false]
	             *         When `true`, the selection is added to other selected points.
	             *         When `false`, other selected points are deselected. Internally in
	             *         Highcharts, when {@link http://api.highcharts.com/highcharts/plotOptions.series.allowPointSelect|allowPointSelect}
	             *         is `true`, selected points are accumulated on Control, Shift or
	             *         Cmd clicking the point.
	             *
	             * @see    Highcharts.Chart#getSelectedPoints
	             *
	             * @sample highcharts/members/point-select/
	             *         Select a point from a button
	             * @sample highcharts/chart/events-selection-points/
	             *         Select a range of points through a drag selection
	             * @sample maps/series/data-id/
	             *         Select a point in Highmaps
	             */
	            select: function(selected, accumulate) {
	                var point = this,
	                    series = point.series,
	                    chart = series.chart;
	
	                selected = pick(selected, !point.selected);
	
	                // fire the event with the default handler
	                point.firePointEvent(selected ? 'select' : 'unselect', {
	                    accumulate: accumulate
	                }, function() {
	
	                    /**
	                     * Whether the point is selected or not. 
	                     * @see Point#select
	                     * @see Chart#getSelectedPoints
	                     * @memberof Point
	                     * @name selected
	                     * @type {Boolean}
	                     */
	                    point.selected = point.options.selected = selected;
	                    series.options.data[inArray(point, series.data)] = point.options;
	
	                    point.setState(selected && 'select');
	
	                    // unselect all other points unless Ctrl or Cmd + click
	                    if (!accumulate) {
	                        each(chart.getSelectedPoints(), function(loopPoint) {
	                            if (loopPoint.selected && loopPoint !== point) {
	                                loopPoint.selected = loopPoint.options.selected = false;
	                                series.options.data[inArray(loopPoint, series.data)] = loopPoint.options;
	                                loopPoint.setState('');
	                                loopPoint.firePointEvent('unselect');
	                            }
	                        });
	                    }
	                });
	            },
	
	            /**
	             * Runs on mouse over the point. Called internally from mouse and touch
	             * events.
	             * 
	             * @param {Object} e The event arguments
	             */
	            onMouseOver: function(e) {
	                var point = this,
	                    series = point.series,
	                    chart = series.chart,
	                    pointer = chart.pointer;
	                e = e ?
	                    pointer.normalize(e) :
	                    // In cases where onMouseOver is called directly without an event
	                    pointer.getChartCoordinatesFromPoint(point, chart.inverted);
	                pointer.runPointActions(e, point);
	            },
	
	            /**
	             * Runs on mouse out from the point. Called internally from mouse and touch
	             * events.
	             */
	            onMouseOut: function() {
	                var point = this,
	                    chart = point.series.chart;
	                point.firePointEvent('mouseOut');
	                each(chart.hoverPoints || [], function(p) {
	                    p.setState();
	                });
	                chart.hoverPoints = chart.hoverPoint = null;
	            },
	
	            /**
	             * Import events from the series' and point's options. Only do it on
	             * demand, to save processing time on hovering.
	             *
	             * @private
	             */
	            importEvents: function() {
	                if (!this.hasImportedEvents) {
	                    var point = this,
	                        options = merge(point.series.options.point, point.options),
	                        events = options.events;
	
	                    point.events = events;
	
	                    H.objectEach(events, function(event, eventType) {
	                        addEvent(point, eventType, event);
	                    });
	                    this.hasImportedEvents = true;
	
	                }
	            },
	
	            /**
	             * Set the point's state.
	             * @param  {String} [state]
	             *         The new state, can be one of `''` (an empty string), `hover` or
	             *         `select`.
	             */
	            setState: function(state, move) {
	                var point = this,
	                    plotX = Math.floor(point.plotX), // #4586
	                    plotY = point.plotY,
	                    series = point.series,
	                    stateOptions = series.options.states[state] || {},
	                    markerOptions = defaultPlotOptions[series.type].marker &&
	                    series.options.marker,
	                    normalDisabled = markerOptions && markerOptions.enabled === false,
	                    markerStateOptions = (markerOptions && markerOptions.states &&
	                        markerOptions.states[state]) || {},
	                    stateDisabled = markerStateOptions.enabled === false,
	                    stateMarkerGraphic = series.stateMarkerGraphic,
	                    pointMarker = point.marker || {},
	                    chart = series.chart,
	                    halo = series.halo,
	                    haloOptions,
	                    markerAttribs,
	                    hasMarkers = markerOptions && series.markerAttribs,
	                    newSymbol;
	
	                state = state || ''; // empty string
	
	                if (
	                    // already has this state
	                    (state === point.state && !move) ||
	
	                    // selected points don't respond to hover
	                    (point.selected && state !== 'select') ||
	
	                    // series' state options is disabled
	                    (stateOptions.enabled === false) ||
	
	                    // general point marker's state options is disabled
	                    (state && (
	                        stateDisabled ||
	                        (normalDisabled && markerStateOptions.enabled === false)
	                    )) ||
	
	                    // individual point marker's state options is disabled
	                    (
	                        state &&
	                        pointMarker.states &&
	                        pointMarker.states[state] &&
	                        pointMarker.states[state].enabled === false
	                    ) // #1610
	
	                ) {
	                    return;
	                }
	
	                if (hasMarkers) {
	                    markerAttribs = series.markerAttribs(point, state);
	                }
	
	                // Apply hover styles to the existing point
	                if (point.graphic) {
	
	                    if (point.state) {
	                        point.graphic.removeClass('highcharts-point-' + point.state);
	                    }
	                    if (state) {
	                        point.graphic.addClass('highcharts-point-' + state);
	                    }
	
	                    /*attribs = radius ? { // new symbol attributes (#507, #612)
	                    	x: plotX - radius,
	                    	y: plotY - radius,
	                    	width: 2 * radius,
	                    	height: 2 * radius
	                    } : {};*/
	
	
	                    //attribs = merge(series.pointAttribs(point, state), attribs);
	                    point.graphic.animate(
	                        series.pointAttribs(point, state),
	                        pick(
	                            chart.options.chart.animation,
	                            stateOptions.animation
	                        )
	                    );
	
	
	                    if (markerAttribs) {
	                        point.graphic.animate(
	                            markerAttribs,
	                            pick(
	                                chart.options.chart.animation, // Turn off globally
	                                markerStateOptions.animation,
	                                markerOptions.animation
	                            )
	                        );
	                    }
	
	                    // Zooming in from a range with no markers to a range with markers
	                    if (stateMarkerGraphic) {
	                        stateMarkerGraphic.hide();
	                    }
	                } else {
	                    // if a graphic is not applied to each point in the normal state, create a shared
	                    // graphic for the hover state
	                    if (state && markerStateOptions) {
	                        newSymbol = pointMarker.symbol || series.symbol;
	
	                        // If the point has another symbol than the previous one, throw away the
	                        // state marker graphic and force a new one (#1459)
	                        if (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {
	                            stateMarkerGraphic = stateMarkerGraphic.destroy();
	                        }
	
	                        // Add a new state marker graphic
	                        if (!stateMarkerGraphic) {
	                            if (newSymbol) {
	                                series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(
	                                        newSymbol,
	                                        markerAttribs.x,
	                                        markerAttribs.y,
	                                        markerAttribs.width,
	                                        markerAttribs.height
	                                    )
	                                    .add(series.markerGroup);
	                                stateMarkerGraphic.currentSymbol = newSymbol;
	                            }
	
	                            // Move the existing graphic
	                        } else {
	                            stateMarkerGraphic[move ? 'animate' : 'attr']({ // #1054
	                                x: markerAttribs.x,
	                                y: markerAttribs.y
	                            });
	                        }
	
	                        if (stateMarkerGraphic) {
	                            stateMarkerGraphic.attr(series.pointAttribs(point, state));
	                        }
	
	                    }
	
	                    if (stateMarkerGraphic) {
	                        stateMarkerGraphic[state && chart.isInsidePlot(plotX, plotY, chart.inverted) ? 'show' : 'hide'](); // #2450
	                        stateMarkerGraphic.element.point = point; // #4310
	                    }
	                }
	
	                // Show me your halo
	                haloOptions = stateOptions.halo;
	                if (haloOptions && haloOptions.size) {
	                    if (!halo) {
	                        series.halo = halo = chart.renderer.path()
	                            // #5818, #5903, #6705
	                            .add((point.graphic || stateMarkerGraphic).parentGroup);
	                    }
	                    halo[move ? 'animate' : 'attr']({
	                        d: point.haloPath(haloOptions.size)
	                    });
	                    halo.attr({
	                        'class': 'highcharts-halo highcharts-color-' +
	                            pick(point.colorIndex, series.colorIndex)
	                    });
	                    halo.point = point; // #6055
	
	
	                    halo.attr(extend({
	                        'fill': point.color || series.color,
	                        'fill-opacity': haloOptions.opacity,
	                        'zIndex': -1 // #4929, IE8 added halo above everything
	                    }, haloOptions.attributes));
	
	
	                } else if (halo && halo.point && halo.point.haloPath) {
	                    // Animate back to 0 on the current halo point (#6055)
	                    halo.animate({
	                        d: halo.point.haloPath(0)
	                    });
	                }
	
	                point.state = state;
	            },
	
	            /**
	             * Get the path definition for the halo, which is usually a shadow-like
	             * circle around the currently hovered point.
	             * @param  {Number} size
	             *         The radius of the circular halo.
	             * @return {Array} The path definition
	             */
	            haloPath: function(size) {
	                var series = this.series,
	                    chart = series.chart;
	
	                return chart.renderer.symbols.circle(
	                    Math.floor(this.plotX) - size,
	                    this.plotY - size,
	                    size * 2,
	                    size * 2
	                );
	            }
	        });
	
	        /*
	         * Extend the Series object with interaction
	         */
	
	        extend(Series.prototype, /** @lends Highcharts.Series.prototype */ {
	            /**
	             * Runs on mouse over the series graphical items.
	             */
	            onMouseOver: function() {
	                var series = this,
	                    chart = series.chart,
	                    hoverSeries = chart.hoverSeries;
	
	                // set normal state to previous series
	                if (hoverSeries && hoverSeries !== series) {
	                    hoverSeries.onMouseOut();
	                }
	
	                // trigger the event, but to save processing time,
	                // only if defined
	                if (series.options.events.mouseOver) {
	                    fireEvent(series, 'mouseOver');
	                }
	
	                // hover this
	                series.setState('hover');
	                chart.hoverSeries = series;
	            },
	
	            /**
	             * Runs on mouse out of the series graphical items.
	             */
	            onMouseOut: function() {
	                // trigger the event only if listeners exist
	                var series = this,
	                    options = series.options,
	                    chart = series.chart,
	                    tooltip = chart.tooltip,
	                    hoverPoint = chart.hoverPoint;
	
	                chart.hoverSeries = null; // #182, set to null before the mouseOut event fires
	
	                // trigger mouse out on the point, which must be in this series
	                if (hoverPoint) {
	                    hoverPoint.onMouseOut();
	                }
	
	                // fire the mouse out event
	                if (series && options.events.mouseOut) {
	                    fireEvent(series, 'mouseOut');
	                }
	
	
	                // hide the tooltip
	                if (tooltip && !series.stickyTracking && (!tooltip.shared || series.noSharedTooltip)) {
	                    tooltip.hide();
	                }
	
	                // set normal state
	                series.setState();
	            },
	
	            /**
	             * Set the state of the series. Called internally on mouse interaction and
	             * select operations, but it can also be called directly to visually
	             * highlight a series.
	             *
	             * @param  {String} [state]
	             *         Can be either `hover`, `select` or undefined to set to normal
	             *         state.
	             */
	            setState: function(state) {
	                var series = this,
	                    options = series.options,
	                    graph = series.graph,
	                    stateOptions = options.states,
	                    lineWidth = options.lineWidth,
	                    attribs,
	                    i = 0;
	
	                state = state || '';
	
	                if (series.state !== state) {
	
	                    // Toggle class names
	                    each([
	                        series.group,
	                        series.markerGroup,
	                        series.dataLabelsGroup
	                    ], function(group) {
	                        if (group) {
	                            // Old state
	                            if (series.state) {
	                                group.removeClass('highcharts-series-' + series.state);
	                            }
	                            // New state
	                            if (state) {
	                                group.addClass('highcharts-series-' + state);
	                            }
	                        }
	                    });
	
	                    series.state = state;
	
	
	
	                    if (stateOptions[state] && stateOptions[state].enabled === false) {
	                        return;
	                    }
	
	                    if (state) {
	                        lineWidth = stateOptions[state].lineWidth || lineWidth + (stateOptions[state].lineWidthPlus || 0); // #4035
	                    }
	
	                    if (graph && !graph.dashstyle) { // hover is turned off for dashed lines in VML
	                        attribs = {
	                            'stroke-width': lineWidth
	                        };
	
	                        // Animate the graph stroke-width. By default a quick animation
	                        // to hover, slower to un-hover.
	                        graph.animate(
	                            attribs,
	                            pick(
	                                series.chart.options.chart.animation,
	                                stateOptions[state] && stateOptions[state].animation
	                            )
	                        );
	                        while (series['zone-graph-' + i]) {
	                            series['zone-graph-' + i].attr(attribs);
	                            i = i + 1;
	                        }
	                    }
	
	                }
	            },
	
	            /**
	             * Show or hide the series.
	             *
	             * @param  {Boolean} [visible]
	             *         True to show the series, false to hide. If undefined, the
	             *         visibility is toggled.
	             * @param  {Boolean} [redraw=true]
	             *         Whether to redraw the chart after the series is altered. If doing
	             *         more operations on the chart, it is a good idea to set redraw to
	             *         false and call {@link Chart#redraw|chart.redraw()} after.
	             */
	            setVisible: function(vis, redraw) {
	                var series = this,
	                    chart = series.chart,
	                    legendItem = series.legendItem,
	                    showOrHide,
	                    ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,
	                    oldVisibility = series.visible;
	
	                // if called without an argument, toggle visibility
	                series.visible = vis = series.options.visible = series.userOptions.visible = vis === undefined ? !oldVisibility : vis; // #5618
	                showOrHide = vis ? 'show' : 'hide';
	
	                // show or hide elements
	                each(['group', 'dataLabelsGroup', 'markerGroup', 'tracker', 'tt'], function(key) {
	                    if (series[key]) {
	                        series[key][showOrHide]();
	                    }
	                });
	
	
	                // hide tooltip (#1361)
	                if (chart.hoverSeries === series || (chart.hoverPoint && chart.hoverPoint.series) === series) {
	                    series.onMouseOut();
	                }
	
	
	                if (legendItem) {
	                    chart.legend.colorizeItem(series, vis);
	                }
	
	
	                // rescale or adapt to resized chart
	                series.isDirty = true;
	                // in a stack, all other series are affected
	                if (series.options.stacking) {
	                    each(chart.series, function(otherSeries) {
	                        if (otherSeries.options.stacking && otherSeries.visible) {
	                            otherSeries.isDirty = true;
	                        }
	                    });
	                }
	
	                // show or hide linked series
	                each(series.linkedSeries, function(otherSeries) {
	                    otherSeries.setVisible(vis, false);
	                });
	
	                if (ignoreHiddenSeries) {
	                    chart.isDirtyBox = true;
	                }
	                if (redraw !== false) {
	                    chart.redraw();
	                }
	
	                fireEvent(series, showOrHide);
	            },
	
	            /**
	             * Show the series if hidden.
	             *
	             * @sample highcharts/members/series-hide/
	             *         Toggle visibility from a button
	             */
	            show: function() {
	                this.setVisible(true);
	            },
	
	            /**
	             * Hide the series if visible. If the {@link
	             * https://api.highcharts.com/highcharts/chart.ignoreHiddenSeries|
	             * chart.ignoreHiddenSeries} option is true, the chart is redrawn without
	             * this series.
	             *
	             * @sample highcharts/members/series-hide/
	             *         Toggle visibility from a button
	             */
	            hide: function() {
	                this.setVisible(false);
	            },
	
	
	            /**
	             * Select or unselect the series. This means its {@link
	             * Highcharts.Series.selected|selected} property is set, the checkbox in the
	             * legend is toggled and when selected, the series is returned by the
	             * {@link Highcharts.Chart#getSelectedSeries} function.
	             *
	             * @param  {Boolean} [selected]
	             *         True to select the series, false to unselect. If	undefined, the
	             *         selection state is toggled.
	             *
	             * @sample highcharts/members/series-select/
	             *         Select a series from a button
	             */
	            select: function(selected) {
	                var series = this;
	
	                series.selected = selected = (selected === undefined) ?
	                    !series.selected :
	                    selected;
	
	                if (series.checkbox) {
	                    series.checkbox.checked = selected;
	                }
	
	                fireEvent(series, selected ? 'select' : 'unselect');
	            },
	
	            drawTracker: TrackerMixin.drawTrackerGraph
	        });
	
	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var Chart = H.Chart,
	            each = H.each,
	            inArray = H.inArray,
	            isArray = H.isArray,
	            isObject = H.isObject,
	            pick = H.pick,
	            splat = H.splat;
	
	        /**
	         * Update the chart based on the current chart/document size and options for
	         * responsiveness.
	         */
	        Chart.prototype.setResponsive = function(redraw) {
	            var options = this.options.responsive,
	                ruleIds = [],
	                currentResponsive = this.currentResponsive,
	                currentRuleIds;
	
	            if (options && options.rules) {
	                each(options.rules, function(rule) {
	                    if (rule._id === undefined) {
	                        rule._id = H.uniqueKey();
	                    }
	
	                    this.matchResponsiveRule(rule, ruleIds, redraw);
	                }, this);
	            }
	
	            // Merge matching rules
	            var mergedOptions = H.merge.apply(0, H.map(ruleIds, function(ruleId) {
	                return H.find(options.rules, function(rule) {
	                    return rule._id === ruleId;
	                }).chartOptions;
	            }));
	
	            // Stringified key for the rules that currently apply.
	            ruleIds = ruleIds.toString() || undefined;
	            currentRuleIds = currentResponsive && currentResponsive.ruleIds;
	
	
	            // Changes in what rules apply
	            if (ruleIds !== currentRuleIds) {
	
	                // Undo previous rules. Before we apply a new set of rules, we need to
	                // roll back completely to base options (#6291).
	                if (currentResponsive) {
	                    this.update(currentResponsive.undoOptions, redraw);
	                }
	
	                if (ruleIds) {
	                    // Get undo-options for matching rules
	                    this.currentResponsive = {
	                        ruleIds: ruleIds,
	                        mergedOptions: mergedOptions,
	                        undoOptions: this.currentOptions(mergedOptions)
	                    };
	
	                    this.update(mergedOptions, redraw);
	
	                } else {
	                    this.currentResponsive = undefined;
	                }
	            }
	        };
	
	        /**
	         * Handle a single responsiveness rule
	         */
	        Chart.prototype.matchResponsiveRule = function(rule, matches) {
	            var condition = rule.condition,
	                fn = condition.callback || function() {
	                    return this.chartWidth <= pick(condition.maxWidth, Number.MAX_VALUE) &&
	                        this.chartHeight <= pick(condition.maxHeight, Number.MAX_VALUE) &&
	                        this.chartWidth >= pick(condition.minWidth, 0) &&
	                        this.chartHeight >= pick(condition.minHeight, 0);
	                };
	
	            if (fn.call(this)) {
	                matches.push(rule._id);
	            }
	
	        };
	
	        /**
	         * Get the current values for a given set of options. Used before we update
	         * the chart with a new responsiveness rule.
	         * TODO: Restore axis options (by id?)
	         */
	        Chart.prototype.currentOptions = function(options) {
	
	            var ret = {};
	
	            /**
	             * Recurse over a set of options and its current values,
	             * and store the current values in the ret object.
	             */
	            function getCurrent(options, curr, ret, depth) {
	                var i;
	                H.objectEach(options, function(val, key) {
	                    if (!depth && inArray(key, ['series', 'xAxis', 'yAxis']) > -1) {
	                        options[key] = splat(options[key]);
	
	                        ret[key] = [];
	
	                        // Iterate over collections like series, xAxis or yAxis and map
	                        // the items by index.
	                        for (i = 0; i < options[key].length; i++) {
	                            if (curr[key][i]) { // Item exists in current data (#6347)
	                                ret[key][i] = {};
	                                getCurrent(
	                                    val[i],
	                                    curr[key][i],
	                                    ret[key][i],
	                                    depth + 1
	                                );
	                            }
	                        }
	                    } else if (isObject(val)) {
	                        ret[key] = isArray(val) ? [] : {};
	                        getCurrent(val, curr[key] || {}, ret[key], depth + 1);
	                    } else {
	                        ret[key] = curr[key] || null;
	                    }
	                });
	            }
	
	            getCurrent(options, this.options, ret, 0);
	            return ret;
	        };
	
	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var Axis = H.Axis,
	            each = H.each,
	            pick = H.pick,
	            wrap = H.wrap;
	        /**
	         * Override to use the extreme coordinates from the SVG shape, not the
	         * data values
	         */
	        wrap(Axis.prototype, 'getSeriesExtremes', function(proceed) {
	            var isXAxis = this.isXAxis,
	                dataMin,
	                dataMax,
	                xData = [],
	                useMapGeometry;
	
	            // Remove the xData array and cache it locally so that the proceed method doesn't use it
	            if (isXAxis) {
	                each(this.series, function(series, i) {
	                    if (series.useMapGeometry) {
	                        xData[i] = series.xData;
	                        series.xData = [];
	                    }
	                });
	            }
	
	            // Call base to reach normal cartesian series (like mappoint)
	            proceed.call(this);
	
	            // Run extremes logic for map and mapline
	            if (isXAxis) {
	                dataMin = pick(this.dataMin, Number.MAX_VALUE);
	                dataMax = pick(this.dataMax, -Number.MAX_VALUE);
	                each(this.series, function(series, i) {
	                    if (series.useMapGeometry) {
	                        dataMin = Math.min(dataMin, pick(series.minX, dataMin));
	                        dataMax = Math.max(dataMax, pick(series.maxX, dataMax));
	                        series.xData = xData[i]; // Reset xData array
	                        useMapGeometry = true;
	                    }
	                });
	                if (useMapGeometry) {
	                    this.dataMin = dataMin;
	                    this.dataMax = dataMax;
	                }
	            }
	        });
	
	        /**
	         * Override axis translation to make sure the aspect ratio is always kept
	         */
	        wrap(Axis.prototype, 'setAxisTranslation', function(proceed) {
	            var chart = this.chart,
	                mapRatio,
	                plotRatio = chart.plotWidth / chart.plotHeight,
	                adjustedAxisLength,
	                xAxis = chart.xAxis[0],
	                padAxis,
	                fixTo,
	                fixDiff,
	                preserveAspectRatio;
	
	
	            // Run the parent method
	            proceed.call(this);
	
	            // Check for map-like series
	            if (this.coll === 'yAxis' && xAxis.transA !== undefined) {
	                each(this.series, function(series) {
	                    if (series.preserveAspectRatio) {
	                        preserveAspectRatio = true;
	                    }
	                });
	            }
	
	            // On Y axis, handle both
	            if (preserveAspectRatio) {
	
	                // Use the same translation for both axes
	                this.transA = xAxis.transA = Math.min(this.transA, xAxis.transA);
	
	                mapRatio = plotRatio / ((xAxis.max - xAxis.min) / (this.max - this.min));
	
	                // What axis to pad to put the map in the middle
	                padAxis = mapRatio < 1 ? this : xAxis;
	
	                // Pad it
	                adjustedAxisLength = (padAxis.max - padAxis.min) * padAxis.transA;
	                padAxis.pixelPadding = padAxis.len - adjustedAxisLength;
	                padAxis.minPixelPadding = padAxis.pixelPadding / 2;
	
	                fixTo = padAxis.fixTo;
	                if (fixTo) {
	                    fixDiff = fixTo[1] - padAxis.toValue(fixTo[0], true);
	                    fixDiff *= padAxis.transA;
	                    if (Math.abs(fixDiff) > padAxis.minPixelPadding || (padAxis.min === padAxis.dataMin && padAxis.max === padAxis.dataMax)) { // zooming out again, keep within restricted area
	                        fixDiff = 0;
	                    }
	                    padAxis.minPixelPadding -= fixDiff;
	                }
	            }
	        });
	
	        /**
	         * Override Axis.render in order to delete the fixTo prop
	         */
	        wrap(Axis.prototype, 'render', function(proceed) {
	            proceed.call(this);
	            this.fixTo = null;
	        });
	
	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var Axis = H.Axis,
	            Chart = H.Chart,
	            color = H.color,
	            ColorAxis,
	            each = H.each,
	            extend = H.extend,
	            isNumber = H.isNumber,
	            Legend = H.Legend,
	            LegendSymbolMixin = H.LegendSymbolMixin,
	            noop = H.noop,
	            merge = H.merge,
	            pick = H.pick,
	            wrap = H.wrap;
	
	        /**
	         * The ColorAxis object for inclusion in gradient legends
	         */
	        ColorAxis = H.ColorAxis = function() {
	            this.init.apply(this, arguments);
	        };
	        extend(ColorAxis.prototype, Axis.prototype);
	        extend(ColorAxis.prototype, {
	            /**	 
	             * @extends {xAxis}
	             * @optionparent colorAxis
	             */
	            defaultColorAxisOptions: {
	
	                /**
	                 */
	                lineWidth: 0,
	
	                /**
	                 * Padding of the min value relative to the length of the axis. A
	                 * padding of 0.05 will make a 100px axis 5px longer.
	                 * 
	                 * @type {Number}
	                 * @product highmaps
	                 */
	                minPadding: 0,
	
	                /**
	                 * Padding of the max value relative to the length of the axis. A
	                 * padding of 0.05 will make a 100px axis 5px longer.
	                 * 
	                 * @type {Number}
	                 * @product highmaps
	                 */
	                maxPadding: 0,
	
	                /**
	                 * The width of the grid lines extending from the axis across the
	                 * gradient of a scalar color axis.
	                 * 
	                 * @type {Number}
	                 * @sample {highmaps} maps/coloraxis/gridlines/ Grid lines demonstrated
	                 * @default 1
	                 * @product highmaps
	                 */
	                gridLineWidth: 1,
	
	                /**
	                 * If [tickInterval](#colorAxis.tickInterval) is `null` this option
	                 * sets the approximate pixel interval of the tick marks.
	                 * 
	                 * @type {Number}
	                 * @default 72
	                 * @product highmaps
	                 */
	                tickPixelInterval: 72,
	
	                /**
	                 * Whether to force the axis to start on a tick. Use this option with
	                 * the `maxPadding` option to control the axis start.
	                 * 
	                 * @type {Boolean}
	                 * @default true
	                 * @product highmaps
	                 */
	                startOnTick: true,
	
	                /**
	                 * Whether to force the axis to end on a tick. Use this option with
	                 * the [maxPadding](#colorAxis.maxPadding) option to control the axis
	                 * end.
	                 * 
	                 * @type {Boolean}
	                 * @default true
	                 * @product highmaps
	                 */
	                endOnTick: true,
	
	                /**
	                 */
	                offset: 0,
	
	                /**
	                 * The triangular marker on a scalar color axis that points to the
	                 * value of the hovered area. To disable the marker, set `marker:
	                 * null`.
	                 * 
	                 * @type {Object}
	                 * @sample {highmaps} maps/coloraxis/marker/ Black marker
	                 * @product highmaps
	                 */
	                marker: {
	
	                    /**
	                     * Animation for the marker as it moves between values. Set to `false`
	                     * to disable animation. Defaults to `{ duration: 50 }`.
	                     * 
	                     * @type {Object|Boolean}
	                     * @product highmaps
	                     */
	                    animation: {
	
	                        /**
	                         */
	                        duration: 50
	                    },
	
	                    /**
	                     */
	                    width: 0.01,
	
	
	                    /**
	                     * The color of the marker.
	                     * 
	                     * @type {Color}
	                     * @default #999999
	                     * @product highmaps
	                     */
	                    color: '#999999'
	
	                },
	
	                /**
	                 * The axis labels show the number for each tick.
	                 * 
	                 * For more live examples on label options, see [xAxis.labels in the
	                 * Highcharts API.](/highcharts#xAxis.labels)
	                 * 
	                 * @type {Object}
	                 * @extends xAxis.labels
	                 * @product highmaps
	                 */
	                labels: {
	
	                    /**
	                     * How to handle overflowing labels on horizontal axis. Can be undefined
	                     * or "justify". If "justify", labels will not render outside the
	                     * plot area. If there is room to move it, it will be aligned to
	                     * the edge, else it will be removed.
	                     * 
	                     * @validvalue [null, "justify"]
	                     * @type {String}
	                     * @default justify
	                     * @product highmaps
	                     */
	                    overflow: 'justify',
	
	                    /**
	                     */
	                    rotation: 0
	                },
	
	                /**
	                 * The color to represent the minimum of the color axis. Unless [dataClasses](#colorAxis.
	                 * dataClasses) or [stops](#colorAxis.stops) are set, the gradient
	                 * starts at this value.
	                 * 
	                 * If dataClasses are set, the color is based on minColor and maxColor
	                 * unless a color is set for each data class, or the [dataClassColor](#colorAxis.
	                 * dataClassColor) is set.
	                 * 
	                 * @type {Color}
	                 * @sample {highmaps} maps/coloraxis/mincolor-maxcolor/ Min and max colors on scalar (gradient) axis
	                 * @sample {highmaps} maps/coloraxis/mincolor-maxcolor-dataclasses/ On data classes
	                 * @default #e6ebf5
	                 * @product highmaps
	                 */
	                minColor: '#e6ebf5',
	
	                /**
	                 * The color to represent the maximum of the color axis. Unless [dataClasses](#colorAxis.
	                 * dataClasses) or [stops](#colorAxis.stops) are set, the gradient
	                 * ends at this value.
	                 * 
	                 * If dataClasses are set, the color is based on minColor and maxColor
	                 * unless a color is set for each data class, or the [dataClassColor](#colorAxis.
	                 * dataClassColor) is set.
	                 * 
	                 * @type {Color}
	                 * @sample {highmaps} maps/coloraxis/mincolor-maxcolor/ Min and max colors on scalar (gradient) axis
	                 * @sample {highmaps} maps/coloraxis/mincolor-maxcolor-dataclasses/ On data classes
	                 * @default #003399
	                 * @product highmaps
	                 */
	                maxColor: '#003399',
	
	                /**
	                 */
	                tickLength: 5,
	
	                /**
	                 * Whether to display the colorAxis in the legend.
	                 * 
	                 * @type {Boolean}
	                 * @see [heatmap.showInLegend](#series<heatmap>.showInLegend)
	                 * @default true
	                 * @since 4.2.7
	                 * @product highmaps
	                 */
	                showInLegend: true
	            },
	
	            // Properties to preserve after destroy, for Axis.update (#5881, #6025)
	            keepProps: [
	                'legendGroup',
	                'legendItemHeight',
	                'legendItemWidth',
	                'legendItem',
	                'legendSymbol'
	            ].concat(Axis.prototype.keepProps),
	
	            /**
	             * Initialize the color axis
	             */
	            init: function(chart, userOptions) {
	                var horiz = chart.options.legend.layout !== 'vertical',
	                    options;
	
	                this.coll = 'colorAxis';
	
	                // Build the options
	                options = merge(this.defaultColorAxisOptions, {
	                    side: horiz ? 2 : 1,
	                    reversed: !horiz
	                }, userOptions, {
	                    opposite: !horiz,
	                    showEmpty: false,
	                    title: null
	                });
	
	                Axis.prototype.init.call(this, chart, options);
	
	                // Base init() pushes it to the xAxis array, now pop it again
	                // chart[this.isXAxis ? 'xAxis' : 'yAxis'].pop();
	
	                // Prepare data classes
	                if (userOptions.dataClasses) {
	                    this.initDataClasses(userOptions);
	                }
	                this.initStops();
	
	                // Override original axis properties
	                this.horiz = horiz;
	                this.zoomEnabled = false;
	
	                // Add default values		
	                this.defaultLegendLength = 200;
	            },
	
	            initDataClasses: function(userOptions) {
	                var chart = this.chart,
	                    dataClasses,
	                    colorCounter = 0,
	                    colorCount = chart.options.chart.colorCount,
	                    options = this.options,
	                    len = userOptions.dataClasses.length;
	                this.dataClasses = dataClasses = [];
	                this.legendItems = [];
	
	                each(userOptions.dataClasses, function(dataClass, i) {
	                    var colors;
	
	                    dataClass = merge(dataClass);
	                    dataClasses.push(dataClass);
	
	
	                    if (dataClass.color) {
	                        return;
	                    }
	
	                    if (options.dataClassColor === 'category') {
	
	                        colors = chart.options.colors;
	                        colorCount = colors.length;
	                        dataClass.color = colors[colorCounter];
	
	                        dataClass.colorIndex = colorCounter;
	
	                        // increase and loop back to zero
	                        colorCounter++;
	                        if (colorCounter === colorCount) {
	                            colorCounter = 0;
	                        }
	                    } else {
	                        dataClass.color = color(options.minColor).tweenTo(
	                            color(options.maxColor),
	                            len < 2 ? 0.5 : i / (len - 1) // #3219
	                        );
	                    }
	                });
	            },
	
	            /**
	             * Override so that ticks are not added in data class axes (#6914)
	             */
	            setTickPositions: function() {
	                if (!this.dataClasses) {
	                    return Axis.prototype.setTickPositions.call(this);
	                }
	            },
	
	
	            initStops: function() {
	                this.stops = this.options.stops || [
	                    [0, this.options.minColor],
	                    [1, this.options.maxColor]
	                ];
	                each(this.stops, function(stop) {
	                    stop.color = color(stop[1]);
	                });
	            },
	
	            /**
	             * Extend the setOptions method to process extreme colors and color
	             * stops.
	             */
	            setOptions: function(userOptions) {
	                Axis.prototype.setOptions.call(this, userOptions);
	
	                this.options.crosshair = this.options.marker;
	            },
	
	            setAxisSize: function() {
	                var symbol = this.legendSymbol,
	                    chart = this.chart,
	                    legendOptions = chart.options.legend || {},
	                    x,
	                    y,
	                    width,
	                    height;
	
	                if (symbol) {
	                    this.left = x = symbol.attr('x');
	                    this.top = y = symbol.attr('y');
	                    this.width = width = symbol.attr('width');
	                    this.height = height = symbol.attr('height');
	                    this.right = chart.chartWidth - x - width;
	                    this.bottom = chart.chartHeight - y - height;
	
	                    this.len = this.horiz ? width : height;
	                    this.pos = this.horiz ? x : y;
	                } else {
	                    // Fake length for disabled legend to avoid tick issues
	                    // and such (#5205)
	                    this.len = (
	                        this.horiz ?
	                        legendOptions.symbolWidth :
	                        legendOptions.symbolHeight
	                    ) || this.defaultLegendLength;
	                }
	            },
	
	            normalizedValue: function(value) {
	                if (this.isLog) {
	                    value = this.val2lin(value);
	                }
	                return 1 - ((this.max - value) / ((this.max - this.min) || 1));
	            },
	
	            /**
	             * Translate from a value to a color
	             */
	            toColor: function(value, point) {
	                var pos,
	                    stops = this.stops,
	                    from,
	                    to,
	                    color,
	                    dataClasses = this.dataClasses,
	                    dataClass,
	                    i;
	
	                if (dataClasses) {
	                    i = dataClasses.length;
	                    while (i--) {
	                        dataClass = dataClasses[i];
	                        from = dataClass.from;
	                        to = dataClass.to;
	                        if (
	                            (from === undefined || value >= from) &&
	                            (to === undefined || value <= to)
	                        ) {
	
	                            color = dataClass.color;
	
	                            if (point) {
	                                point.dataClass = i;
	                                point.colorIndex = dataClass.colorIndex;
	                            }
	                            break;
	                        }
	                    }
	
	                } else {
	
	                    pos = this.normalizedValue(value);
	                    i = stops.length;
	                    while (i--) {
	                        if (pos > stops[i][0]) {
	                            break;
	                        }
	                    }
	                    from = stops[i] || stops[i + 1];
	                    to = stops[i + 1] || from;
	
	                    // The position within the gradient
	                    pos = 1 - (to[0] - pos) / ((to[0] - from[0]) || 1);
	
	                    color = from.color.tweenTo(
	                        to.color,
	                        pos
	                    );
	                }
	                return color;
	            },
	
	            /**
	             * Override the getOffset method to add the whole axis groups inside
	             * the legend.
	             */
	            getOffset: function() {
	                var group = this.legendGroup,
	                    sideOffset = this.chart.axisOffset[this.side];
	
	                if (group) {
	
	                    // Hook for the getOffset method to add groups to this parent group
	                    this.axisParent = group;
	
	                    // Call the base
	                    Axis.prototype.getOffset.call(this);
	
	                    // First time only
	                    if (!this.added) {
	
	                        this.added = true;
	
	                        this.labelLeft = 0;
	                        this.labelRight = this.width;
	                    }
	                    // Reset it to avoid color axis reserving space
	                    this.chart.axisOffset[this.side] = sideOffset;
	                }
	            },
	
	            /**
	             * Create the color gradient
	             */
	            setLegendColor: function() {
	                var grad,
	                    horiz = this.horiz,
	                    reversed = this.reversed,
	                    one = reversed ? 1 : 0,
	                    zero = reversed ? 0 : 1;
	
	                grad = horiz ? [one, 0, zero, 0] : [0, zero, 0, one]; // #3190
	                this.legendColor = {
	                    linearGradient: {
	                        x1: grad[0],
	                        y1: grad[1],
	                        x2: grad[2],
	                        y2: grad[3]
	                    },
	                    stops: this.stops
	                };
	            },
	
	            /**
	             * The color axis appears inside the legend and has its own legend symbol
	             */
	            drawLegendSymbol: function(legend, item) {
	                var padding = legend.padding,
	                    legendOptions = legend.options,
	                    horiz = this.horiz,
	                    width = pick(
	                        legendOptions.symbolWidth,
	                        horiz ? this.defaultLegendLength : 12
	                    ),
	                    height = pick(
	                        legendOptions.symbolHeight,
	                        horiz ? 12 : this.defaultLegendLength
	                    ),
	                    labelPadding = pick(legendOptions.labelPadding, horiz ? 16 : 30),
	                    itemDistance = pick(legendOptions.itemDistance, 10);
	
	                this.setLegendColor();
	
	                // Create the gradient
	                item.legendSymbol = this.chart.renderer.rect(
	                    0,
	                    legend.baseline - 11,
	                    width,
	                    height
	                ).attr({
	                    zIndex: 1
	                }).add(item.legendGroup);
	
	                // Set how much space this legend item takes up
	                this.legendItemWidth = width + padding +
	                    (horiz ? itemDistance : labelPadding);
	                this.legendItemHeight = height + padding + (horiz ? labelPadding : 0);
	            },
	            /**
	             * Fool the legend
	             */
	            setState: noop,
	            visible: true,
	            setVisible: noop,
	            getSeriesExtremes: function() {
	                var series = this.series,
	                    i = series.length;
	                this.dataMin = Infinity;
	                this.dataMax = -Infinity;
	                while (i--) {
	                    if (series[i].valueMin !== undefined) {
	                        this.dataMin = Math.min(this.dataMin, series[i].valueMin);
	                        this.dataMax = Math.max(this.dataMax, series[i].valueMax);
	                    }
	                }
	            },
	            drawCrosshair: function(e, point) {
	                var plotX = point && point.plotX,
	                    plotY = point && point.plotY,
	                    crossPos,
	                    axisPos = this.pos,
	                    axisLen = this.len;
	
	                if (point) {
	                    crossPos = this.toPixels(point[point.series.colorKey]);
	                    if (crossPos < axisPos) {
	                        crossPos = axisPos - 2;
	                    } else if (crossPos > axisPos + axisLen) {
	                        crossPos = axisPos + axisLen + 2;
	                    }
	
	                    point.plotX = crossPos;
	                    point.plotY = this.len - crossPos;
	                    Axis.prototype.drawCrosshair.call(this, e, point);
	                    point.plotX = plotX;
	                    point.plotY = plotY;
	
	                    if (this.cross) {
	                        this.cross
	                            .addClass('highcharts-coloraxis-marker')
	                            .add(this.legendGroup);
	
	
	                        this.cross.attr({
	                            fill: this.crosshair.color
	                        });
	
	
	                    }
	                }
	            },
	            getPlotLinePath: function(a, b, c, d, pos) {
	                // crosshairs only
	                return isNumber(pos) ? // pos can be 0 (#3969)
	                    (
	                        this.horiz ? [
	                            'M',
	                            pos - 4, this.top - 6,
	                            'L',
	                            pos + 4, this.top - 6,
	                            pos, this.top,
	                            'Z'
	                        ] : [
	                            'M',
	                            this.left, pos,
	                            'L',
	                            this.left - 6, pos + 6,
	                            this.left - 6, pos - 6,
	                            'Z'
	                        ]
	                    ) :
	                    Axis.prototype.getPlotLinePath.call(this, a, b, c, d);
	            },
	
	            update: function(newOptions, redraw) {
	                var chart = this.chart,
	                    legend = chart.legend;
	
	                each(this.series, function(series) {
	                    // Needed for Axis.update when choropleth colors change
	                    series.isDirtyData = true;
	                });
	
	                // When updating data classes, destroy old items and make sure new ones
	                // are created (#3207)
	                if (newOptions.dataClasses && legend.allItems) {
	                    each(legend.allItems, function(item) {
	                        if (item.isDataClass && item.legendGroup) {
	                            item.legendGroup.destroy();
	                        }
	                    });
	                    chart.isDirtyLegend = true;
	                }
	
	                // Keep the options structure updated for export. Unlike xAxis and
	                // yAxis, the colorAxis is not an array. (#3207)
	                chart.options[this.coll] = merge(this.userOptions, newOptions);
	
	                Axis.prototype.update.call(this, newOptions, redraw);
	                if (this.legendItem) {
	                    this.setLegendColor();
	                    legend.colorizeItem(this, true);
	                }
	            },
	
	            /**
	             * Extend basic axis remove by also removing the legend item.
	             */
	            remove: function() {
	                if (this.legendItem) {
	                    this.chart.legend.destroyItem(this);
	                }
	                Axis.prototype.remove.call(this);
	            },
	
	            /**
	             * Get the legend item symbols for data classes
	             */
	            getDataClassLegendSymbols: function() {
	                var axis = this,
	                    chart = this.chart,
	                    legendItems = this.legendItems,
	                    legendOptions = chart.options.legend,
	                    valueDecimals = legendOptions.valueDecimals,
	                    valueSuffix = legendOptions.valueSuffix || '',
	                    name;
	
	                if (!legendItems.length) {
	                    each(this.dataClasses, function(dataClass, i) {
	                        var vis = true,
	                            from = dataClass.from,
	                            to = dataClass.to;
	
	                        // Assemble the default name. This can be overridden
	                        // by legend.options.labelFormatter
	                        name = '';
	                        if (from === undefined) {
	                            name = '< ';
	                        } else if (to === undefined) {
	                            name = '> ';
	                        }
	                        if (from !== undefined) {
	                            name += H.numberFormat(from, valueDecimals) + valueSuffix;
	                        }
	                        if (from !== undefined && to !== undefined) {
	                            name += ' - ';
	                        }
	                        if (to !== undefined) {
	                            name += H.numberFormat(to, valueDecimals) + valueSuffix;
	                        }
	                        // Add a mock object to the legend items
	                        legendItems.push(extend({
	                            chart: chart,
	                            name: name,
	                            options: {},
	                            drawLegendSymbol: LegendSymbolMixin.drawRectangle,
	                            visible: true,
	                            setState: noop,
	                            isDataClass: true,
	                            setVisible: function() {
	                                vis = this.visible = !vis;
	                                each(axis.series, function(series) {
	                                    each(series.points, function(point) {
	                                        if (point.dataClass === i) {
	                                            point.setVisible(vis);
	                                        }
	                                    });
	                                });
	
	                                chart.legend.colorizeItem(this, vis);
	                            }
	                        }, dataClass));
	                    });
	                }
	                return legendItems;
	            },
	            name: '' // Prevents 'undefined' in legend in IE8
	        });
	
	        /**
	         * Handle animation of the color attributes directly
	         */
	        each(['fill', 'stroke'], function(prop) {
	            H.Fx.prototype[prop + 'Setter'] = function() {
	                this.elem.attr(
	                    prop,
	                    color(this.start).tweenTo(
	                        color(this.end),
	                        this.pos
	                    ),
	                    null,
	                    true
	                );
	            };
	        });
	
	        /**
	         * Extend the chart getAxes method to also get the color axis
	         */
	        wrap(Chart.prototype, 'getAxes', function(proceed) {
	
	            var options = this.options,
	                colorAxisOptions = options.colorAxis;
	
	            proceed.call(this);
	
	            this.colorAxis = [];
	            if (colorAxisOptions) {
	                new ColorAxis(this, colorAxisOptions); // eslint-disable-line no-new
	            }
	        });
	
	
	        /**
	         * Wrap the legend getAllItems method to add the color axis. This also removes
	         * the axis' own series to prevent them from showing up individually.
	         */
	        wrap(Legend.prototype, 'getAllItems', function(proceed) {
	            var allItems = [],
	                colorAxis = this.chart.colorAxis[0];
	
	            if (colorAxis && colorAxis.options) {
	                if (colorAxis.options.showInLegend) {
	                    // Data classes
	                    if (colorAxis.options.dataClasses) {
	                        allItems = allItems.concat(
	                            colorAxis.getDataClassLegendSymbols()
	                        );
	                        // Gradient legend
	                    } else {
	                        // Add this axis on top
	                        allItems.push(colorAxis);
	                    }
	                }
	
	                // Don't add the color axis' series
	                each(colorAxis.series, function(series) {
	                    series.options.showInLegend = false;
	                });
	            }
	
	            return allItems.concat(proceed.call(this));
	        });
	
	        wrap(Legend.prototype, 'colorizeItem', function(proceed, item, visible) {
	            proceed.call(this, item, visible);
	            if (visible && item.legendColor) {
	                item.legendSymbol.attr({
	                    fill: item.legendColor
	                });
	            }
	        });
	
	        // Updates in the legend need to be reflected in the color axis (6888)
	        wrap(Legend.prototype, 'update', function(proceed) {
	            proceed.apply(this, [].slice.call(arguments, 1));
	
	            if (this.chart.colorAxis[0]) {
	                this.chart.colorAxis[0].update({}, arguments[2]);
	            }
	        });
	
	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var defined = H.defined,
	            each = H.each,
	            noop = H.noop,
	            seriesTypes = H.seriesTypes;
	
	        /**
	         * Mixin for maps and heatmaps
	         */
	        H.colorPointMixin = {
	            /**
	             * Color points have a value option that determines whether or not it is
	             * a null point
	             */
	            isValid: function() {
	                return this.value !== null;
	            },
	
	            /**
	             * Set the visibility of a single point
	             */
	            setVisible: function(vis) {
	                var point = this,
	                    method = vis ? 'show' : 'hide';
	
	                // Show and hide associated elements
	                each(['graphic', 'dataLabel'], function(key) {
	                    if (point[key]) {
	                        point[key][method]();
	                    }
	                });
	            },
	            setState: function(state) {
	                H.Point.prototype.setState.call(this, state);
	                if (this.graphic) {
	                    this.graphic.attr({
	                        zIndex: state === 'hover' ? 1 : 0
	                    });
	                }
	            }
	        };
	
	        H.colorSeriesMixin = {
	            pointArrayMap: ['value'],
	            axisTypes: ['xAxis', 'yAxis', 'colorAxis'],
	            optionalAxis: 'colorAxis',
	            trackerGroups: ['group', 'markerGroup', 'dataLabelsGroup'],
	            getSymbol: noop,
	            parallelArrays: ['x', 'y', 'value'],
	            colorKey: 'value',
	
	
	            pointAttribs: seriesTypes.column.prototype.pointAttribs,
	
	
	            /**
	             * In choropleth maps, the color is a result of the value, so this needs
	             * translation too
	             */
	            translateColors: function() {
	                var series = this,
	                    nullColor = this.options.nullColor,
	                    colorAxis = this.colorAxis,
	                    colorKey = this.colorKey;
	
	                each(this.data, function(point) {
	                    var value = point[colorKey],
	                        color;
	
	                    color = point.options.color ||
	                        (
	                            point.isNull ?
	                            nullColor :
	                            (colorAxis && value !== undefined) ?
	                            colorAxis.toColor(value, point) :
	                            point.color || series.color
	                        );
	
	                    if (color) {
	                        point.color = color;
	                    }
	                });
	            },
	
	            /**
	             * Get the color attibutes to apply on the graphic
	             */
	            colorAttribs: function(point) {
	                var ret = {};
	                if (defined(point.color)) {
	                    ret[this.colorProp || 'fill'] = point.color;
	                }
	                return ret;
	            }
	        };
	
	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var addEvent = H.addEvent,
	            Chart = H.Chart,
	            doc = H.doc,
	            each = H.each,
	            extend = H.extend,
	            merge = H.merge,
	            pick = H.pick,
	            wrap = H.wrap;
	
	        function stopEvent(e) {
	            if (e) {
	                if (e.preventDefault) {
	                    e.preventDefault();
	                }
	                if (e.stopPropagation) {
	                    e.stopPropagation();
	                }
	                e.cancelBubble = true;
	            }
	        }
	
	        /**
	         * The MapNavigation handles buttons for navigation in addition to mousewheel
	         * and doubleclick handlers for chart zooming.
	         * @param {Chart} chart The Chart instance.
	         */
	        function MapNavigation(chart) {
	            this.init(chart);
	        }
	
	        /**
	         * Initiator function.
	         * @param  {Chart} chart The Chart instance.
	         */
	        MapNavigation.prototype.init = function(chart) {
	            this.chart = chart;
	            chart.mapNavButtons = [];
	        };
	
	        /**
	         * Update the map navigation with new options. Calling this is the same as 
	         * calling `chart.update({ mapNavigation: {} })`. 
	         * @param  {Object} options New options for the map navigation.
	         */
	        MapNavigation.prototype.update = function(options) {
	            var chart = this.chart,
	                o = chart.options.mapNavigation,
	                buttonOptions,
	                attr,
	                states,
	                hoverStates,
	                selectStates,
	                outerHandler = function(e) {
	                    this.handler.call(chart, e);
	                    stopEvent(e); // Stop default click event (#4444)
	                },
	                mapNavButtons = chart.mapNavButtons;
	
	            // Merge in new options in case of update, and register back to chart
	            // options.
	            if (options) {
	                o = chart.options.mapNavigation =
	                    merge(chart.options.mapNavigation, options);
	            }
	
	            // Destroy buttons in case of dynamic update
	            while (mapNavButtons.length) {
	                mapNavButtons.pop().destroy();
	            }
	
	            if (pick(o.enableButtons, o.enabled) && !chart.renderer.forExport) {
	
	                H.objectEach(o.buttons, function(button, n) {
	                    buttonOptions = merge(o.buttonOptions, button);
	
	
	                    // Presentational
	                    attr = buttonOptions.theme;
	                    attr.style = merge(
	                        buttonOptions.theme.style,
	                        buttonOptions.style // #3203
	                    );
	                    states = attr.states;
	                    hoverStates = states && states.hover;
	                    selectStates = states && states.select;
	
	
	                    button = chart.renderer.button(
	                            buttonOptions.text,
	                            0,
	                            0,
	                            outerHandler,
	                            attr,
	                            hoverStates,
	                            selectStates,
	                            0,
	                            n === 'zoomIn' ? 'topbutton' : 'bottombutton'
	                        )
	                        .addClass('highcharts-map-navigation')
	                        .attr({
	                            width: buttonOptions.width,
	                            height: buttonOptions.height,
	                            title: chart.options.lang[n],
	                            padding: buttonOptions.padding,
	                            zIndex: 5
	                        })
	                        .add();
	                    button.handler = buttonOptions.onclick;
	                    button.align(
	                        extend(buttonOptions, {
	                            width: button.width,
	                            height: 2 * button.height
	                        }),
	                        null,
	                        buttonOptions.alignTo
	                    );
	                    // Stop double click event (#4444)
	                    addEvent(button.element, 'dblclick', stopEvent);
	
	                    mapNavButtons.push(button);
	
	                });
	            }
	
	            this.updateEvents(o);
	        };
	
	        /**
	         * Update events, called internally from the update function. Add new event
	         * handlers, or unbinds events if disabled.
	         * @param  {Object} options Options for map navigation.
	         */
	        MapNavigation.prototype.updateEvents = function(options) {
	            var chart = this.chart;
	
	            // Add the double click event
	            if (
	                pick(options.enableDoubleClickZoom, options.enabled) ||
	                options.enableDoubleClickZoomTo
	            ) {
	                this.unbindDblClick = this.unbindDblClick || addEvent(
	                    chart.container,
	                    'dblclick',
	                    function(e) {
	                        chart.pointer.onContainerDblClick(e);
	                    }
	                );
	            } else if (this.unbindDblClick) {
	                // Unbind and set unbinder to undefined
	                this.unbindDblClick = this.unbindDblClick();
	            }
	
	            // Add the mousewheel event
	            if (pick(options.enableMouseWheelZoom, options.enabled)) {
	                this.unbindMouseWheel = this.unbindMouseWheel || addEvent(
	                    chart.container,
	                    doc.onmousewheel === undefined ? 'DOMMouseScroll' : 'mousewheel',
	                    function(e) {
	                        chart.pointer.onContainerMouseWheel(e);
	                        // Issue #5011, returning false from non-jQuery event does
	                        // not prevent default
	                        stopEvent(e);
	                        return false;
	                    }
	                );
	            } else if (this.unbindMouseWheel) {
	                // Unbind and set unbinder to undefined
	                this.unbindMouseWheel = this.unbindMouseWheel();
	            }
	
	        };
	
	        // Add events to the Chart object itself
	        extend(Chart.prototype, /** @lends Chart.prototype */ {
	
	            /**
	             * Fit an inner box to an outer. If the inner box overflows left or right,
	             * align it to the sides of the outer. If it overflows both sides, fit it
	             * within the outer. This is a pattern that occurs more places in
	             * Highcharts, perhaps it should be elevated to a common utility function.
	             *
	             * @private
	             */
	            fitToBox: function(inner, outer) {
	                each([
	                    ['x', 'width'],
	                    ['y', 'height']
	                ], function(dim) {
	                    var pos = dim[0],
	                        size = dim[1];
	
	                    if (inner[pos] + inner[size] > outer[pos] + outer[size]) { // right overflow
	                        if (inner[size] > outer[size]) { // the general size is greater, fit fully to outer
	                            inner[size] = outer[size];
	                            inner[pos] = outer[pos];
	                        } else { // align right
	                            inner[pos] = outer[pos] + outer[size] - inner[size];
	                        }
	                    }
	                    if (inner[size] > outer[size]) {
	                        inner[size] = outer[size];
	                    }
	                    if (inner[pos] < outer[pos]) {
	                        inner[pos] = outer[pos];
	                    }
	                });
	
	
	                return inner;
	            },
	
	            /**
	             * Highmaps only. Zoom in or out of the map. See also {@link Point#zoomTo}.
	             * See {@link Chart#fromLatLonToPoint} for how to get the `centerX` and
	             * `centerY` parameters for a geographic location.
	             *
	             * @param  {Number} [howMuch]
	             *         How much to zoom the map. Values less than 1 zooms in. 0.5 zooms
	             *         in to half the current view. 2 zooms to twice the current view.
	             *         If omitted, the zoom is reset.
	             * @param  {Number} [centerX]
	             *         The X axis position to center around if available space.
	             * @param  {Number} [centerY]
	             *         The Y axis position to center around if available space.
	             * @param  {Number} [mouseX]
	             *         Fix the zoom to this position if possible. This is used for
	             *         example in mousewheel events, where the area under the mouse
	             *         should be fixed as we zoom in.
	             * @param  {Number} [mouseY]
	             *         Fix the zoom to this position if possible.
	             */
	            mapZoom: function(howMuch, centerXArg, centerYArg, mouseX, mouseY) {
	                /*if (this.isMapZooming) {
	                	this.mapZoomQueue = arguments;
	                	return;
	                }*/
	
	                var chart = this,
	                    xAxis = chart.xAxis[0],
	                    xRange = xAxis.max - xAxis.min,
	                    centerX = pick(centerXArg, xAxis.min + xRange / 2),
	                    newXRange = xRange * howMuch,
	                    yAxis = chart.yAxis[0],
	                    yRange = yAxis.max - yAxis.min,
	                    centerY = pick(centerYArg, yAxis.min + yRange / 2),
	                    newYRange = yRange * howMuch,
	                    fixToX = mouseX ? ((mouseX - xAxis.pos) / xAxis.len) : 0.5,
	                    fixToY = mouseY ? ((mouseY - yAxis.pos) / yAxis.len) : 0.5,
	                    newXMin = centerX - newXRange * fixToX,
	                    newYMin = centerY - newYRange * fixToY,
	                    newExt = chart.fitToBox({
	                        x: newXMin,
	                        y: newYMin,
	                        width: newXRange,
	                        height: newYRange
	                    }, {
	                        x: xAxis.dataMin,
	                        y: yAxis.dataMin,
	                        width: xAxis.dataMax - xAxis.dataMin,
	                        height: yAxis.dataMax - yAxis.dataMin
	                    }),
	                    zoomOut = newExt.x <= xAxis.dataMin &&
	                    newExt.width >= xAxis.dataMax - xAxis.dataMin &&
	                    newExt.y <= yAxis.dataMin &&
	                    newExt.height >= yAxis.dataMax - yAxis.dataMin;
	
	                // When mousewheel zooming, fix the point under the mouse
	                if (mouseX) {
	                    xAxis.fixTo = [mouseX - xAxis.pos, centerXArg];
	                }
	                if (mouseY) {
	                    yAxis.fixTo = [mouseY - yAxis.pos, centerYArg];
	                }
	
	                // Zoom
	                if (howMuch !== undefined && !zoomOut) {
	                    xAxis.setExtremes(newExt.x, newExt.x + newExt.width, false);
	                    yAxis.setExtremes(newExt.y, newExt.y + newExt.height, false);
	
	                    // Reset zoom
	                } else {
	                    xAxis.setExtremes(undefined, undefined, false);
	                    yAxis.setExtremes(undefined, undefined, false);
	                }
	
	                // Prevent zooming until this one is finished animating
	                /*chart.holdMapZoom = true;
	                setTimeout(function () {
	                	chart.holdMapZoom = false;
	                }, 200);*/
	                /*delay = animation ? animation.duration || 500 : 0;
	                if (delay) {
	                	chart.isMapZooming = true;
	                	setTimeout(function () {
	                		chart.isMapZooming = false;
	                		if (chart.mapZoomQueue) {
	                			chart.mapZoom.apply(chart, chart.mapZoomQueue);
	                		}
	                		chart.mapZoomQueue = null;
	                	}, delay);
	                }*/
	
	                chart.redraw();
	            }
	        });
	
	        /**
	         * Extend the Chart.render method to add zooming and panning
	         */
	        wrap(Chart.prototype, 'render', function(proceed) {
	            // Render the plus and minus buttons. Doing this before the shapes makes getBBox much quicker, at least in Chrome.
	            this.mapNavigation = new MapNavigation(this);
	            this.mapNavigation.update();
	
	            proceed.call(this);
	        });
	
	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var extend = H.extend,
	            pick = H.pick,
	            Pointer = H.Pointer,
	            wrap = H.wrap;
	
	        // Extend the Pointer
	        extend(Pointer.prototype, {
	
	            /**
	             * The event handler for the doubleclick event
	             */
	            onContainerDblClick: function(e) {
	                var chart = this.chart;
	
	                e = this.normalize(e);
	
	                if (chart.options.mapNavigation.enableDoubleClickZoomTo) {
	                    if (chart.pointer.inClass(e.target, 'highcharts-tracker') && chart.hoverPoint) {
	                        chart.hoverPoint.zoomTo();
	                    }
	                } else if (chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {
	                    chart.mapZoom(
	                        0.5,
	                        chart.xAxis[0].toValue(e.chartX),
	                        chart.yAxis[0].toValue(e.chartY),
	                        e.chartX,
	                        e.chartY
	                    );
	                }
	            },
	
	            /**
	             * The event handler for the mouse scroll event
	             */
	            onContainerMouseWheel: function(e) {
	                var chart = this.chart,
	                    delta;
	
	                e = this.normalize(e);
	
	                // Firefox uses e.detail, WebKit and IE uses wheelDelta
	                delta = e.detail || -(e.wheelDelta / 120);
	                if (chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {
	                    chart.mapZoom(
	                        Math.pow(chart.options.mapNavigation.mouseWheelSensitivity, delta),
	                        chart.xAxis[0].toValue(e.chartX),
	                        chart.yAxis[0].toValue(e.chartY),
	                        e.chartX,
	                        e.chartY
	                    );
	                }
	            }
	        });
	
	        // The pinchType is inferred from mapNavigation options.
	        wrap(Pointer.prototype, 'zoomOption', function(proceed) {
	
	
	            var mapNavigation = this.chart.options.mapNavigation;
	
	            // Pinch status
	            if (pick(mapNavigation.enableTouchZoom, mapNavigation.enabled)) {
	                this.chart.options.chart.pinchType = 'xy';
	            }
	
	            proceed.apply(this, [].slice.call(arguments, 1));
	
	        });
	
	        // Extend the pinchTranslate method to preserve fixed ratio when zooming
	        wrap(Pointer.prototype, 'pinchTranslate', function(proceed, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch) {
	            var xBigger;
	            proceed.call(this, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
	
	            // Keep ratio
	            if (this.chart.options.chart.type === 'map' && this.hasZoom) {
	                xBigger = transform.scaleX > transform.scaleY;
	                this.pinchTranslateDirection(!xBigger,
	                    pinchDown,
	                    touches,
	                    transform,
	                    selectionMarker,
	                    clip,
	                    lastValidTouch,
	                    xBigger ? transform.scaleX : transform.scaleY
	                );
	            }
	        });
	
	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var colorPointMixin = H.colorPointMixin,
	            colorSeriesMixin = H.colorSeriesMixin,
	            doc = H.doc,
	            each = H.each,
	            extend = H.extend,
	            isNumber = H.isNumber,
	            LegendSymbolMixin = H.LegendSymbolMixin,
	            map = H.map,
	            merge = H.merge,
	            noop = H.noop,
	            pick = H.pick,
	            isArray = H.isArray,
	            Point = H.Point,
	            Series = H.Series,
	            seriesType = H.seriesType,
	            seriesTypes = H.seriesTypes,
	            splat = H.splat;
	
	        // The vector-effect attribute is not supported in IE <= 11 (at least), so we need
	        // diffent logic (#3218)
	        var supportsVectorEffect = doc.documentElement.style.vectorEffect !== undefined;
	
	
	        // Add the map series type
	        /**
	         * @extends {plotOptions.scatter}
	         * @optionparent plotOptions.map
	         */
	        seriesType('map', 'scatter', {
	
	            /**
	             */
	            allAreas: true,
	
	
	            /**
	             */
	            animation: false, // makes the complex shapes slow
	
	            /**
	             * The color to apply to null points.
	             * 
	             * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	             * style/style-by-css), the null point fill is set in the `.highcharts-
	             * null-point` class.
	             * 
	             * @type {Color}
	             * @sample {highmaps} maps/demo/all-areas-as-null/ Null color
	             * @default #f7f7f7
	             * @product highmaps
	             */
	            nullColor: '#f7f7f7',
	
	            /**
	             */
	            borderColor: '#cccccc',
	
	            /**
	             */
	            borderWidth: 1,
	
	            /**
	             */
	            marker: null,
	
	            /**
	             */
	            stickyTracking: false,
	
	            /**
	             */
	            joinBy: 'hc-key',
	
	            /**
	             */
	            dataLabels: {
	
	                /**
	                 */
	                formatter: function() { // #2945
	                    return this.point.value;
	                },
	
	                /**
	                 */
	                inside: true, // for the color
	
	                /**
	                 */
	                verticalAlign: 'middle',
	
	                /**
	                 */
	                crop: false,
	
	                /**
	                 */
	                overflow: false,
	
	                /**
	                 */
	                padding: 0
	            },
	
	            /**
	             */
	            turboThreshold: 0,
	
	            /**
	             */
	            tooltip: {
	
	                /**
	                 */
	                followPointer: true,
	
	                /**
	                 */
	                pointFormat: '{point.name}: {point.value}<br/>'
	            },
	
	            /**
	             */
	            states: {
	
	                /**
	                 */
	                normal: {
	
	                    /**
	                     */
	                    animation: true
	                },
	
	                /**
	                 */
	                hover: {
	
	                    /**
	                     */
	                    brightness: 0.2,
	
	                    /**
	                     */
	                    halo: null
	                },
	
	                /**
	                 */
	                select: {
	
	                    /**
	                     */
	                    color: '#cccccc'
	                }
	            }
	
	            // Prototype members
	        }, merge(colorSeriesMixin, {
	            type: 'map',
	            getExtremesFromAll: true,
	            useMapGeometry: true, // get axis extremes from paths, not values
	            forceDL: true,
	            searchPoint: noop,
	            directTouch: true, // When tooltip is not shared, this series (and derivatives) requires direct touch/hover. KD-tree does not apply.
	            preserveAspectRatio: true, // X axis and Y axis must have same translation slope
	            pointArrayMap: ['value'],
	            /**
	             * Get the bounding box of all paths in the map combined.
	             */
	            getBox: function(paths) {
	                var MAX_VALUE = Number.MAX_VALUE,
	                    maxX = -MAX_VALUE,
	                    minX = MAX_VALUE,
	                    maxY = -MAX_VALUE,
	                    minY = MAX_VALUE,
	                    minRange = MAX_VALUE,
	                    xAxis = this.xAxis,
	                    yAxis = this.yAxis,
	                    hasBox;
	
	                // Find the bounding box
	                each(paths || [], function(point) {
	
	                    if (point.path) {
	                        if (typeof point.path === 'string') {
	                            point.path = H.splitPath(point.path);
	                        }
	
	                        var path = point.path || [],
	                            i = path.length,
	                            even = false, // while loop reads from the end
	                            pointMaxX = -MAX_VALUE,
	                            pointMinX = MAX_VALUE,
	                            pointMaxY = -MAX_VALUE,
	                            pointMinY = MAX_VALUE,
	                            properties = point.properties;
	
	                        // The first time a map point is used, analyze its box
	                        if (!point._foundBox) {
	                            while (i--) {
	                                if (isNumber(path[i])) {
	                                    if (even) { // even = x
	                                        pointMaxX = Math.max(pointMaxX, path[i]);
	                                        pointMinX = Math.min(pointMinX, path[i]);
	                                    } else { // odd = Y
	                                        pointMaxY = Math.max(pointMaxY, path[i]);
	                                        pointMinY = Math.min(pointMinY, path[i]);
	                                    }
	                                    even = !even;
	                                }
	                            }
	                            // Cache point bounding box for use to position data labels,
	                            // bubbles etc
	                            point._midX = pointMinX + (pointMaxX - pointMinX) * pick(
	                                point.middleX,
	                                properties && properties['hc-middle-x'],
	                                0.5
	                            );
	                            point._midY = pointMinY + (pointMaxY - pointMinY) * pick(
	                                point.middleY,
	                                properties && properties['hc-middle-y'],
	                                0.5
	                            );
	                            point._maxX = pointMaxX;
	                            point._minX = pointMinX;
	                            point._maxY = pointMaxY;
	                            point._minY = pointMinY;
	                            point.labelrank = pick(point.labelrank, (pointMaxX - pointMinX) * (pointMaxY - pointMinY));
	                            point._foundBox = true;
	                        }
	
	                        maxX = Math.max(maxX, point._maxX);
	                        minX = Math.min(minX, point._minX);
	                        maxY = Math.max(maxY, point._maxY);
	                        minY = Math.min(minY, point._minY);
	                        minRange = Math.min(point._maxX - point._minX, point._maxY - point._minY, minRange);
	                        hasBox = true;
	                    }
	                });
	
	                // Set the box for the whole series
	                if (hasBox) {
	                    this.minY = Math.min(minY, pick(this.minY, MAX_VALUE));
	                    this.maxY = Math.max(maxY, pick(this.maxY, -MAX_VALUE));
	                    this.minX = Math.min(minX, pick(this.minX, MAX_VALUE));
	                    this.maxX = Math.max(maxX, pick(this.maxX, -MAX_VALUE));
	
	                    // If no minRange option is set, set the default minimum zooming range to 5 times the
	                    // size of the smallest element
	                    if (xAxis && xAxis.options.minRange === undefined) {
	                        xAxis.minRange = Math.min(5 * minRange, (this.maxX - this.minX) / 5, xAxis.minRange || MAX_VALUE);
	                    }
	                    if (yAxis && yAxis.options.minRange === undefined) {
	                        yAxis.minRange = Math.min(5 * minRange, (this.maxY - this.minY) / 5, yAxis.minRange || MAX_VALUE);
	                    }
	                }
	            },
	
	            getExtremes: function() {
	                // Get the actual value extremes for colors
	                Series.prototype.getExtremes.call(this, this.valueData);
	
	                // Recalculate box on updated data
	                if (this.chart.hasRendered && this.isDirtyData) {
	                    this.getBox(this.options.data);
	                }
	
	                this.valueMin = this.dataMin;
	                this.valueMax = this.dataMax;
	
	                // Extremes for the mock Y axis
	                this.dataMin = this.minY;
	                this.dataMax = this.maxY;
	            },
	
	            /**
	             * Translate the path so that it automatically fits into the plot area box
	             * @param {Object} path
	             */
	            translatePath: function(path) {
	
	                var series = this,
	                    even = false, // while loop reads from the end
	                    xAxis = series.xAxis,
	                    yAxis = series.yAxis,
	                    xMin = xAxis.min,
	                    xTransA = xAxis.transA,
	                    xMinPixelPadding = xAxis.minPixelPadding,
	                    yMin = yAxis.min,
	                    yTransA = yAxis.transA,
	                    yMinPixelPadding = yAxis.minPixelPadding,
	                    i,
	                    ret = []; // Preserve the original
	
	                // Do the translation
	                if (path) {
	                    i = path.length;
	                    while (i--) {
	                        if (isNumber(path[i])) {
	                            ret[i] = even ?
	                                (path[i] - xMin) * xTransA + xMinPixelPadding :
	                                (path[i] - yMin) * yTransA + yMinPixelPadding;
	                            even = !even;
	                        } else {
	                            ret[i] = path[i];
	                        }
	                    }
	                }
	
	                return ret;
	            },
	
	            /**
	             * Extend setData to join in mapData. If the allAreas option is true, all areas
	             * from the mapData are used, and those that don't correspond to a data value
	             * are given null values.
	             */
	            setData: function(data, redraw, animation, updatePoints) {
	                var options = this.options,
	                    chartOptions = this.chart.options.chart,
	                    globalMapData = chartOptions && chartOptions.map,
	                    mapData = options.mapData,
	                    joinBy = options.joinBy,
	                    joinByNull = joinBy === null,
	                    pointArrayMap = options.keys || this.pointArrayMap,
	                    dataUsed = [],
	                    mapMap = {},
	                    mapPoint,
	                    mapTransforms = this.chart.mapTransforms,
	                    props,
	                    i;
	
	                // Collect mapData from chart options if not defined on series
	                if (!mapData && globalMapData) {
	                    mapData = typeof globalMapData === 'string' ? H.maps[globalMapData] : globalMapData;
	                }
	
	                if (joinByNull) {
	                    joinBy = '_i';
	                }
	                joinBy = this.joinBy = splat(joinBy);
	                if (!joinBy[1]) {
	                    joinBy[1] = joinBy[0];
	                }
	
	                // Pick up numeric values, add index
	                // Convert Array point definitions to objects using pointArrayMap
	                if (data) {
	                    each(data, function(val, i) {
	                        var ix = 0;
	                        if (isNumber(val)) {
	                            data[i] = {
	                                value: val
	                            };
	                        } else if (isArray(val)) {
	                            data[i] = {};
	                            // Automatically copy first item to hc-key if there is an extra leading string
	                            if (!options.keys && val.length > pointArrayMap.length && typeof val[0] === 'string') {
	                                data[i]['hc-key'] = val[0];
	                                ++ix;
	                            }
	                            // Run through pointArrayMap and what's left of the point data array in parallel, copying over the values
	                            for (var j = 0; j < pointArrayMap.length; ++j, ++ix) {
	                                if (pointArrayMap[j]) {
	                                    data[i][pointArrayMap[j]] = val[ix];
	                                }
	                            }
	                        }
	                        if (joinByNull) {
	                            data[i]._i = i;
	                        }
	                    });
	                }
	
	                this.getBox(data);
	
	                // Pick up transform definitions for chart
	                this.chart.mapTransforms = mapTransforms = chartOptions && chartOptions.mapTransforms || mapData && mapData['hc-transform'] || mapTransforms;
	
	                // Cache cos/sin of transform rotation angle
	                if (mapTransforms) {
	                    H.objectEach(mapTransforms, function(transform) {
	                        if (transform.rotation) {
	                            transform.cosAngle = Math.cos(transform.rotation);
	                            transform.sinAngle = Math.sin(transform.rotation);
	                        }
	                    });
	                }
	
	                if (mapData) {
	                    if (mapData.type === 'FeatureCollection') {
	                        this.mapTitle = mapData.title;
	                        mapData = H.geojson(mapData, this.type, this);
	                    }
	
	                    this.mapData = mapData;
	                    this.mapMap = {};
	
	                    for (i = 0; i < mapData.length; i++) {
	                        mapPoint = mapData[i];
	                        props = mapPoint.properties;
	
	                        mapPoint._i = i;
	                        // Copy the property over to root for faster access
	                        if (joinBy[0] && props && props[joinBy[0]]) {
	                            mapPoint[joinBy[0]] = props[joinBy[0]];
	                        }
	                        mapMap[mapPoint[joinBy[0]]] = mapPoint;
	                    }
	                    this.mapMap = mapMap;
	
	                    // Registered the point codes that actually hold data
	                    if (data && joinBy[1]) {
	                        each(data, function(point) {
	                            if (mapMap[point[joinBy[1]]]) {
	                                dataUsed.push(mapMap[point[joinBy[1]]]);
	                            }
	                        });
	                    }
	
	                    if (options.allAreas) {
	                        this.getBox(mapData);
	                        data = data || [];
	
	                        // Registered the point codes that actually hold data
	                        if (joinBy[1]) {
	                            each(data, function(point) {
	                                dataUsed.push(point[joinBy[1]]);
	                            });
	                        }
	
	                        // Add those map points that don't correspond to data, which will be drawn as null points
	                        dataUsed = '|' + map(dataUsed, function(point) {
	                            return point && point[joinBy[0]];
	                        }).join('|') + '|'; // String search is faster than array.indexOf
	
	                        each(mapData, function(mapPoint) {
	                            if (!joinBy[0] || dataUsed.indexOf('|' + mapPoint[joinBy[0]] + '|') === -1) {
	                                data.push(merge(mapPoint, {
	                                    value: null
	                                }));
	                                updatePoints = false; // #5050 - adding all areas causes the update optimization of setData to kick in, even though the point order has changed
	                            }
	                        });
	                    } else {
	                        this.getBox(dataUsed); // Issue #4784
	                    }
	                }
	                Series.prototype.setData.call(this, data, redraw, animation, updatePoints);
	            },
	
	
	            /**
	             * No graph for the map series
	             */
	            drawGraph: noop,
	
	            /**
	             * We need the points' bounding boxes in order to draw the data labels, so
	             * we skip it now and call it from drawPoints instead.
	             */
	            drawDataLabels: noop,
	
	            /**
	             * Allow a quick redraw by just translating the area group. Used for zooming and panning
	             * in capable browsers.
	             */
	            doFullTranslate: function() {
	                return this.isDirtyData || this.chart.isResizing || this.chart.renderer.isVML || !this.baseTrans;
	            },
	
	            /**
	             * Add the path option for data points. Find the max value for color calculation.
	             */
	            translate: function() {
	                var series = this,
	                    xAxis = series.xAxis,
	                    yAxis = series.yAxis,
	                    doFullTranslate = series.doFullTranslate();
	
	                series.generatePoints();
	
	                each(series.data, function(point) {
	
	                    // Record the middle point (loosely based on centroid), determined
	                    // by the middleX and middleY options.
	                    point.plotX = xAxis.toPixels(point._midX, true);
	                    point.plotY = yAxis.toPixels(point._midY, true);
	
	                    if (doFullTranslate) {
	
	                        point.shapeType = 'path';
	                        point.shapeArgs = {
	                            d: series.translatePath(point.path)
	                        };
	                    }
	                });
	
	                series.translateColors();
	            },
	
	            /**
	             * Get presentational attributes. In the maps series this runs in both 
	             * styled and non-styled mode, because colors hold data when a colorAxis
	             * is used.
	             */
	            pointAttribs: function(point, state) {
	                var attr;
	
	                attr = seriesTypes.column.prototype.pointAttribs.call(
	                    this, point, state
	                );
	
	
	                // If vector-effect is not supported, we set the stroke-width on the group element
	                // and let all point graphics inherit. That way we don't have to iterate over all 
	                // points to update the stroke-width on zooming. TODO: Check unstyled
	                if (supportsVectorEffect) {
	                    attr['vector-effect'] = 'non-scaling-stroke';
	                } else {
	                    attr['stroke-width'] = 'inherit';
	                }
	
	                return attr;
	            },
	
	            /** 
	             * Use the drawPoints method of column, that is able to handle simple shapeArgs.
	             * Extend it by assigning the tooltip position.
	             */
	            drawPoints: function() {
	                var series = this,
	                    xAxis = series.xAxis,
	                    yAxis = series.yAxis,
	                    group = series.group,
	                    chart = series.chart,
	                    renderer = chart.renderer,
	                    scaleX,
	                    scaleY,
	                    translateX,
	                    translateY,
	                    baseTrans = this.baseTrans,
	                    transformGroup,
	                    startTranslateX,
	                    startTranslateY,
	                    startScaleX,
	                    startScaleY;
	
	                // Set a group that handles transform during zooming and panning in order to preserve clipping
	                // on series.group
	                if (!series.transformGroup) {
	                    series.transformGroup = renderer.g()
	                        .attr({
	                            scaleX: 1,
	                            scaleY: 1
	                        })
	                        .add(group);
	                    series.transformGroup.survive = true;
	                }
	
	                // Draw the shapes again
	                if (series.doFullTranslate()) {
	
	                    // Individual point actions. TODO: Check unstyled.
	
	                    if (chart.hasRendered) {
	                        each(series.points, function(point) {
	
	                            // Restore state color on update/redraw (#3529)
	                            if (point.shapeArgs) {
	                                point.shapeArgs.fill = series.pointAttribs(point, point.state).fill;
	                            }
	                        });
	                    }
	
	
	                    // Draw them in transformGroup
	                    series.group = series.transformGroup;
	                    seriesTypes.column.prototype.drawPoints.apply(series);
	                    series.group = group; // Reset
	
	                    // Add class names
	                    each(series.points, function(point) {
	                        if (point.graphic) {
	                            if (point.name) {
	                                point.graphic.addClass('highcharts-name-' + point.name.replace(/ /g, '-').toLowerCase());
	                            }
	                            if (point.properties && point.properties['hc-key']) {
	                                point.graphic.addClass('highcharts-key-' + point.properties['hc-key'].toLowerCase());
	                            }
	
	
	                        }
	                    });
	
	                    // Set the base for later scale-zooming. The originX and originY properties are the
	                    // axis values in the plot area's upper left corner.
	                    this.baseTrans = {
	                        originX: xAxis.min - xAxis.minPixelPadding / xAxis.transA,
	                        originY: yAxis.min - yAxis.minPixelPadding / yAxis.transA + (yAxis.reversed ? 0 : yAxis.len / yAxis.transA),
	                        transAX: xAxis.transA,
	                        transAY: yAxis.transA
	                    };
	
	                    // Reset transformation in case we're doing a full translate (#3789)
	                    this.transformGroup.animate({
	                        translateX: 0,
	                        translateY: 0,
	                        scaleX: 1,
	                        scaleY: 1
	                    });
	
	                    // Just update the scale and transform for better performance
	                } else {
	                    scaleX = xAxis.transA / baseTrans.transAX;
	                    scaleY = yAxis.transA / baseTrans.transAY;
	                    translateX = xAxis.toPixels(baseTrans.originX, true);
	                    translateY = yAxis.toPixels(baseTrans.originY, true);
	
	                    // Handle rounding errors in normal view (#3789)
	                    if (scaleX > 0.99 && scaleX < 1.01 && scaleY > 0.99 && scaleY < 1.01) {
	                        scaleX = 1;
	                        scaleY = 1;
	                        translateX = Math.round(translateX);
	                        translateY = Math.round(translateY);
	                    }
	
	                    // Animate or move to the new zoom level. In order to prevent
	                    // flickering as the different transform components are set out of 
	                    // sync (#5991), we run a fake animator attribute and set scale and
	                    // translation synchronously in the same step.
	                    // A possible improvement to the API would be to handle this in the
	                    // renderer or animation engine itself, to ensure that when we are 
	                    // animating multiple properties, we make sure that each step for
	                    // each property is performed in the same step. Also, for symbols
	                    // and for transform properties, it should induce a single 
	                    // updateTransform and symbolAttr call.
	                    transformGroup = this.transformGroup;
	                    if (chart.renderer.globalAnimation) {
	                        startTranslateX = transformGroup.attr('translateX');
	                        startTranslateY = transformGroup.attr('translateY');
	                        startScaleX = transformGroup.attr('scaleX');
	                        startScaleY = transformGroup.attr('scaleY');
	                        transformGroup
	                            .attr({
	                                animator: 0
	                            })
	                            .animate({
	                                animator: 1
	                            }, {
	                                step: function(now, fx) {
	                                    transformGroup.attr({
	                                        translateX: startTranslateX +
	                                            (translateX - startTranslateX) * fx.pos,
	                                        translateY: startTranslateY +
	                                            (translateY - startTranslateY) * fx.pos,
	                                        scaleX: startScaleX +
	                                            (scaleX - startScaleX) * fx.pos,
	                                        scaleY: startScaleY +
	                                            (scaleY - startScaleY) * fx.pos
	                                    });
	
	                                }
	                            });
	
	                        // When dragging, animation is off.
	                    } else {
	                        transformGroup.attr({
	                            translateX: translateX,
	                            translateY: translateY,
	                            scaleX: scaleX,
	                            scaleY: scaleY
	                        });
	                    }
	
	                }
	
	                // Set the stroke-width directly on the group element so the children inherit it. We need to use
	                // setAttribute directly, because the stroke-widthSetter method expects a stroke color also to be
	                // set.
	                if (!supportsVectorEffect) {
	                    series.group.element.setAttribute(
	                        'stroke-width',
	                        series.options[
	                            (series.pointAttrToOptions && series.pointAttrToOptions['stroke-width']) || 'borderWidth'
	                        ] / (scaleX || 1)
	                    );
	                }
	
	                this.drawMapDataLabels();
	
	
	            },
	
	            /**
	             * Draw the data labels. Special for maps is the time that the data labels are drawn (after points),
	             * and the clipping of the dataLabelsGroup.
	             */
	            drawMapDataLabels: function() {
	
	                Series.prototype.drawDataLabels.call(this);
	                if (this.dataLabelsGroup) {
	                    this.dataLabelsGroup.clip(this.chart.clipRect);
	                }
	            },
	
	            /**
	             * Override render to throw in an async call in IE8. Otherwise it chokes on the US counties demo.
	             */
	            render: function() {
	                var series = this,
	                    render = Series.prototype.render;
	
	                // Give IE8 some time to breathe.
	                if (series.chart.renderer.isVML && series.data.length > 3000) {
	                    setTimeout(function() {
	                        render.call(series);
	                    });
	                } else {
	                    render.call(series);
	                }
	            },
	
	            /**
	             * The initial animation for the map series. By default, animation is disabled.
	             * Animation of map shapes is not at all supported in VML browsers.
	             */
	            animate: function(init) {
	                var chart = this.chart,
	                    animation = this.options.animation,
	                    group = this.group,
	                    xAxis = this.xAxis,
	                    yAxis = this.yAxis,
	                    left = xAxis.pos,
	                    top = yAxis.pos;
	
	                if (chart.renderer.isSVG) {
	
	                    if (animation === true) {
	                        animation = {
	                            duration: 1000
	                        };
	                    }
	
	                    // Initialize the animation
	                    if (init) {
	
	                        // Scale down the group and place it in the center
	                        group.attr({
	                            translateX: left + xAxis.len / 2,
	                            translateY: top + yAxis.len / 2,
	                            scaleX: 0.001, // #1499
	                            scaleY: 0.001
	                        });
	
	                        // Run the animation
	                    } else {
	                        group.animate({
	                            translateX: left,
	                            translateY: top,
	                            scaleX: 1,
	                            scaleY: 1
	                        }, animation);
	
	                        // Delete this function to allow it only once
	                        this.animate = null;
	                    }
	                }
	            },
	
	            /**
	             * Animate in the new series from the clicked point in the old series.
	             * Depends on the drilldown.js module
	             */
	            animateDrilldown: function(init) {
	                var toBox = this.chart.plotBox,
	                    level = this.chart.drilldownLevels[this.chart.drilldownLevels.length - 1],
	                    fromBox = level.bBox,
	                    animationOptions = this.chart.options.drilldown.animation,
	                    scale;
	
	                if (!init) {
	
	                    scale = Math.min(fromBox.width / toBox.width, fromBox.height / toBox.height);
	                    level.shapeArgs = {
	                        scaleX: scale,
	                        scaleY: scale,
	                        translateX: fromBox.x,
	                        translateY: fromBox.y
	                    };
	
	                    each(this.points, function(point) {
	                        if (point.graphic) {
	                            point.graphic
	                                .attr(level.shapeArgs)
	                                .animate({
	                                    scaleX: 1,
	                                    scaleY: 1,
	                                    translateX: 0,
	                                    translateY: 0
	                                }, animationOptions);
	                        }
	                    });
	
	                    this.animate = null;
	                }
	
	            },
	
	            drawLegendSymbol: LegendSymbolMixin.drawRectangle,
	
	            /**
	             * When drilling up, pull out the individual point graphics from the lower series
	             * and animate them into the origin point in the upper series.
	             */
	            animateDrillupFrom: function(level) {
	                seriesTypes.column.prototype.animateDrillupFrom.call(this, level);
	            },
	
	
	            /**
	             * When drilling up, keep the upper series invisible until the lower series has
	             * moved into place
	             */
	            animateDrillupTo: function(init) {
	                seriesTypes.column.prototype.animateDrillupTo.call(this, init);
	            }
	
	            // Point class
	        }), extend({
	            /**
	             * Extend the Point object to split paths
	             */
	            applyOptions: function(options, x) {
	
	                var point = Point.prototype.applyOptions.call(this, options, x),
	                    series = this.series,
	                    joinBy = series.joinBy,
	                    mapPoint;
	
	                if (series.mapData) {
	                    mapPoint = point[joinBy[1]] !== undefined && series.mapMap[point[joinBy[1]]];
	                    if (mapPoint) {
	                        // This applies only to bubbles
	                        if (series.xyFromShape) {
	                            point.x = mapPoint._midX;
	                            point.y = mapPoint._midY;
	                        }
	                        extend(point, mapPoint); // copy over properties
	                    } else {
	                        point.value = point.value || null;
	                    }
	                }
	
	                return point;
	            },
	
	            /**
	             * Stop the fade-out
	             */
	            onMouseOver: function(e) {
	                clearTimeout(this.colorInterval);
	                if (this.value !== null || this.series.options.nullInteraction) {
	                    Point.prototype.onMouseOver.call(this, e);
	                } else { //#3401 Tooltip doesn't hide when hovering over null points
	                    this.series.onMouseOut(e);
	                }
	            },
	
	            /**
	             * Highmaps only. Zoom in on the point using the global animation.
	             *
	             * @function #zoomTo
	             * @memberOf Point
	             * @sample maps/members/point-zoomto/
	             *         Zoom to points from butons
	             */
	            zoomTo: function() {
	                var point = this,
	                    series = point.series;
	
	                series.xAxis.setExtremes(
	                    point._minX,
	                    point._maxX,
	                    false
	                );
	                series.yAxis.setExtremes(
	                    point._minY,
	                    point._maxY,
	                    false
	                );
	                series.chart.redraw();
	            }
	        }, colorPointMixin));
	
	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var seriesType = H.seriesType,
	            seriesTypes = H.seriesTypes;
	
	        // The mapline series type
	        // 
	        /**
	         * @extends {plotOptions.map}
	         * @optionparent plotOptions.mapline
	         */
	        seriesType('mapline', 'map', {
	
	
	            /**
	             * The width of the map line.
	             * 
	             * @type {Number}
	             * @default 1
	             * @product highmaps
	             */
	            lineWidth: 1,
	
	            /**
	             * Fill color for the map line shapes
	             * 
	             * @type {Color}
	             * @default none
	             * @product highmaps
	             */
	            fillColor: 'none'
	
	        }, {
	            type: 'mapline',
	            colorProp: 'stroke',
	
	            pointAttrToOptions: {
	                'stroke': 'color',
	                'stroke-width': 'lineWidth'
	            },
	            /**
	             * Get presentational attributes
	             */
	            pointAttribs: function(point, state) {
	                var attr = seriesTypes.map.prototype.pointAttribs.call(this, point, state);
	
	                // The difference from a map series is that the stroke takes the point color
	                attr.fill = this.options.fillColor;
	
	                return attr;
	            },
	
	            drawLegendSymbol: seriesTypes.line.prototype.drawLegendSymbol
	        });
	
	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var merge = H.merge,
	            Point = H.Point,
	            seriesType = H.seriesType;
	
	        // The mappoint series type
	        /**
	         * @extends plotOptions.scatter
	         * @optionparent plotOptions.mappoint
	         */
	        seriesType('mappoint', 'scatter', {
	
	            /**
	             */
	            dataLabels: {
	
	                /**
	                 */
	                enabled: true,
	
	                /**
	                 */
	                formatter: function() { // #2945
	                    return this.point.name;
	                },
	
	                /**
	                 */
	                crop: false,
	
	                /**
	                 */
	                defer: false,
	
	                /**
	                 */
	                overflow: false,
	
	                /**
	                 */
	                style: {
	
	                    /**
	                     */
	                    color: '#000000'
	                }
	            }
	
	            // Prototype members
	        }, {
	            type: 'mappoint',
	            forceDL: true
	
	            // Point class
	        }, {
	            applyOptions: function(options, x) {
	                var mergedOptions = options.lat !== undefined && options.lon !== undefined ? merge(options, this.series.chart.fromLatLonToPoint(options)) : options;
	                return Point.prototype.applyOptions.call(this, mergedOptions, x);
	            }
	        });
	
	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var arrayMax = H.arrayMax,
	            arrayMin = H.arrayMin,
	            Axis = H.Axis,
	            color = H.color,
	            each = H.each,
	            isNumber = H.isNumber,
	            noop = H.noop,
	            pick = H.pick,
	            pInt = H.pInt,
	            Point = H.Point,
	            Series = H.Series,
	            seriesType = H.seriesType,
	            seriesTypes = H.seriesTypes;
	
	        /* ****************************************************************************
	         * Start Bubble series code											          *
	         *****************************************************************************/
	
	
	        /**
	         * @extends plotOptions.scatter
	         * @optionparent plotOptions.bubble
	         */
	        seriesType('bubble', 'scatter', {
	
	            /**
	             */
	            dataLabels: {
	
	                /**
	                 */
	                formatter: function() { // #2945
	                    return this.point.z;
	                },
	
	                /**
	                 */
	                inside: true,
	
	                /**
	                 */
	                verticalAlign: 'middle'
	            },
	            // displayNegative: true,
	
	            /**
	             * Options for the point markers of line-like series. Properties like
	             * `fillColor`, `lineColor` and `lineWidth` define the visual appearance
	             * of the markers. Other series types, like column series, don't have
	             * markers, but have visual options on the series level instead.
	             * 
	             * In [styled mode](http://www.highcharts.com/docs/chart-design-and-
	             * style/style-by-css), the markers can be styled with the `.highcharts-
	             * point`, `.highcharts-point-hover` and `.highcharts-point-select`
	             * class names.
	             * 
	             * @type {Object}
	             * @extends plotOptions.series.marker
	             * @excluding radius
	             * @product highcharts
	             */
	            marker: {
	
	                // fillOpacity: 0.5,
	
	                /**
	                 */
	                lineColor: null, // inherit from series.color
	
	                /**
	                 */
	                lineWidth: 1,
	
	                // Avoid offset in Point.setState
	
	                /**
	                 */
	                radius: null,
	
	                /**
	                 */
	                states: {
	
	                    /**
	                     */
	                    hover: {
	
	                        /**
	                         */
	                        radiusPlus: 0
	                    }
	                },
	
	                /**
	                 * A predefined shape or symbol for the marker. Possible values are
	                 * "circle", "square", "diamond", "triangle" and "triangle-down".
	                 * 
	                 * Additionally, the URL to a graphic can be given on the form `url(graphic.
	                 * png)`. Note that for the image to be applied to exported charts,
	                 * its URL needs to be accessible by the export server.
	                 * 
	                 * Custom callbacks for symbol path generation can also be added to
	                 * `Highcharts.SVGRenderer.prototype.symbols`. The callback is then
	                 * used by its method name, as shown in the demo.
	                 * 
	                 * @validvalue ["circle", "square", "diamond", "triangle", "triangle-down"]
	                 * @type {String}
	                 * @sample {highcharts} highcharts/plotoptions/bubble-symbol/ Bubble chart with various symbols
	                 * @sample {highcharts} highcharts/plotoptions/series-marker-symbol/ General chart with predefined, graphic and custom markers
	                 * @default circle
	                 * @since 5.0.11
	                 * @product highcharts
	                 */
	                symbol: 'circle'
	            },
	
	            /**
	             * Minimum bubble size. Bubbles will automatically size between the
	             * `minSize` and `maxSize` to reflect the `z` value of each bubble.
	             * Can be either pixels (when no unit is given), or a percentage of
	             * the smallest one of the plot width and height.
	             * 
	             * @type {String}
	             * @sample {highcharts} highcharts/plotoptions/bubble-size/ Bubble size
	             * @default 8
	             * @since 3.0
	             * @product highcharts
	             */
	            minSize: 8,
	
	            /**
	             * Maximum bubble size. Bubbles will automatically size between the
	             * `minSize` and `maxSize` to reflect the `z` value of each bubble.
	             * Can be either pixels (when no unit is given), or a percentage of
	             * the smallest one of the plot width and height.
	             * 
	             * @type {String}
	             * @sample {highcharts} highcharts/plotoptions/bubble-size/ Bubble size
	             * @default 20%
	             * @since 3.0
	             * @product highcharts
	             */
	            maxSize: '20%',
	            // negativeColor: null,
	            // sizeBy: 'area'
	
	            /**
	             * When this is true, the series will not cause the Y axis to cross
	             * the zero plane (or [threshold](#plotOptions.series.threshold) option)
	             * unless the data actually crosses the plane.
	             * 
	             * For example, if `softThreshold` is `false`, a series of 0, 1, 2,
	             * 3 will make the Y axis show negative values according to the `minPadding`
	             * option. If `softThreshold` is `true`, the Y axis starts at 0.
	             * 
	             * @type {Boolean}
	             * @default false
	             * @since 4.1.9
	             * @product highcharts
	             */
	            softThreshold: false,
	
	            /**
	             */
	            states: {
	
	                /**
	                 */
	                hover: {
	
	                    /**
	                     */
	                    halo: {
	
	                        /**
	                         */
	                        size: 5
	                    }
	                }
	            },
	
	            /**
	             */
	            tooltip: {
	
	                /**
	                 */
	                pointFormat: '({point.x}, {point.y}), Size: {point.z}'
	            },
	
	            /**
	             */
	            turboThreshold: 0,
	
	            /**
	             * When [displayNegative](#plotOptions.bubble.displayNegative) is `false`,
	             * bubbles with lower Z values are skipped. When `displayNegative`
	             * is `true` and a [negativeColor](#plotOptions.bubble.negativeColor)
	             * is given, points with lower Z is colored.
	             * 
	             * @type {Number}
	             * @sample {highcharts} highcharts/plotoptions/bubble-negative/ Negative bubbles
	             * @default 0
	             * @since 3.0
	             * @product highcharts
	             */
	            zThreshold: 0,
	
	            /**
	             */
	            zoneAxis: 'z'
	
	            // Prototype members
	        }, {
	            pointArrayMap: ['y', 'z'],
	            parallelArrays: ['x', 'y', 'z'],
	            trackerGroups: ['group', 'dataLabelsGroup'],
	            specialGroup: 'group', // To allow clipping (#6296)
	            bubblePadding: true,
	            zoneAxis: 'z',
	            directTouch: true,
	
	
	            pointAttribs: function(point, state) {
	                var markerOptions = this.options.marker,
	                    fillOpacity = pick(markerOptions.fillOpacity, 0.5),
	                    attr = Series.prototype.pointAttribs.call(this, point, state);
	
	                if (fillOpacity !== 1) {
	                    attr.fill = color(attr.fill).setOpacity(fillOpacity).get('rgba');
	                }
	
	                return attr;
	            },
	
	
	            /**
	             * Get the radius for each point based on the minSize, maxSize and each point's Z value. This
	             * must be done prior to Series.translate because the axis needs to add padding in
	             * accordance with the point sizes.
	             */
	            getRadii: function(zMin, zMax, minSize, maxSize) {
	                var len,
	                    i,
	                    pos,
	                    zData = this.zData,
	                    radii = [],
	                    options = this.options,
	                    sizeByArea = options.sizeBy !== 'width',
	                    zThreshold = options.zThreshold,
	                    zRange = zMax - zMin,
	                    value,
	                    radius;
	
	                // Set the shape type and arguments to be picked up in drawPoints
	                for (i = 0, len = zData.length; i < len; i++) {
	
	                    value = zData[i];
	
	                    // When sizing by threshold, the absolute value of z determines the size
	                    // of the bubble.
	                    if (options.sizeByAbsoluteValue && value !== null) {
	                        value = Math.abs(value - zThreshold);
	                        zMax = Math.max(zMax - zThreshold, Math.abs(zMin - zThreshold));
	                        zMin = 0;
	                    }
	
	                    if (value === null) {
	                        radius = null;
	                        // Issue #4419 - if value is less than zMin, push a radius that's always smaller than the minimum size
	                    } else if (value < zMin) {
	                        radius = minSize / 2 - 1;
	                    } else {
	                        // Relative size, a number between 0 and 1
	                        pos = zRange > 0 ? (value - zMin) / zRange : 0.5;
	
	                        if (sizeByArea && pos >= 0) {
	                            pos = Math.sqrt(pos);
	                        }
	                        radius = Math.ceil(minSize + pos * (maxSize - minSize)) / 2;
	                    }
	                    radii.push(radius);
	                }
	                this.radii = radii;
	            },
	
	            /**
	             * Perform animation on the bubbles
	             */
	            animate: function(init) {
	                var animation = this.options.animation;
	
	                if (!init) { // run the animation
	                    each(this.points, function(point) {
	                        var graphic = point.graphic,
	                            animationTarget;
	
	                        if (graphic && graphic.width) { // URL symbols don't have width
	                            animationTarget = {
	                                x: graphic.x,
	                                y: graphic.y,
	                                width: graphic.width,
	                                height: graphic.height
	                            };
	
	                            // Start values
	                            graphic.attr({
	                                x: point.plotX,
	                                y: point.plotY,
	                                width: 1,
	                                height: 1
	                            });
	
	                            // Run animation
	                            graphic.animate(animationTarget, animation);
	                        }
	                    });
	
	                    // delete this function to allow it only once
	                    this.animate = null;
	                }
	            },
	
	            /**
	             * Extend the base translate method to handle bubble size
	             */
	            translate: function() {
	
	                var i,
	                    data = this.data,
	                    point,
	                    radius,
	                    radii = this.radii;
	
	                // Run the parent method
	                seriesTypes.scatter.prototype.translate.call(this);
	
	                // Set the shape type and arguments to be picked up in drawPoints
	                i = data.length;
	
	                while (i--) {
	                    point = data[i];
	                    radius = radii ? radii[i] : 0; // #1737
	
	                    if (isNumber(radius) && radius >= this.minPxSize / 2) {
	                        // Shape arguments
	                        point.marker = H.extend(point.marker, {
	                            radius: radius,
	                            width: 2 * radius,
	                            height: 2 * radius
	                        });
	
	                        // Alignment box for the data label
	                        point.dlBox = {
	                            x: point.plotX - radius,
	                            y: point.plotY - radius,
	                            width: 2 * radius,
	                            height: 2 * radius
	                        };
	                    } else { // below zThreshold
	                        point.shapeArgs = point.plotY = point.dlBox = undefined; // #1691
	                    }
	                }
	            },
	
	            alignDataLabel: seriesTypes.column.prototype.alignDataLabel,
	            buildKDTree: noop,
	            applyZones: noop
	
	            // Point class
	        }, {
	            haloPath: function(size) {
	                return Point.prototype.haloPath.call(
	                    this,
	                    size === 0 ? 0 : (this.marker ? this.marker.radius || 0 : 0) + size // #6067
	                );
	            },
	            ttBelow: false
	        });
	
	        /**
	         * Add logic to pad each axis with the amount of pixels
	         * necessary to avoid the bubbles to overflow.
	         */
	        Axis.prototype.beforePadding = function() {
	            var axis = this,
	                axisLength = this.len,
	                chart = this.chart,
	                pxMin = 0,
	                pxMax = axisLength,
	                isXAxis = this.isXAxis,
	                dataKey = isXAxis ? 'xData' : 'yData',
	                min = this.min,
	                extremes = {},
	                smallestSize = Math.min(chart.plotWidth, chart.plotHeight),
	                zMin = Number.MAX_VALUE,
	                zMax = -Number.MAX_VALUE,
	                range = this.max - min,
	                transA = axisLength / range,
	                activeSeries = [];
	
	            // Handle padding on the second pass, or on redraw
	            each(this.series, function(series) {
	
	                var seriesOptions = series.options,
	                    zData;
	
	                if (series.bubblePadding && (series.visible || !chart.options.chart.ignoreHiddenSeries)) {
	
	                    // Correction for #1673
	                    axis.allowZoomOutside = true;
	
	                    // Cache it
	                    activeSeries.push(series);
	
	                    if (isXAxis) { // because X axis is evaluated first
	
	                        // For each series, translate the size extremes to pixel values
	                        each(['minSize', 'maxSize'], function(prop) {
	                            var length = seriesOptions[prop],
	                                isPercent = /%$/.test(length);
	
	                            length = pInt(length);
	                            extremes[prop] = isPercent ?
	                                smallestSize * length / 100 :
	                                length;
	
	                        });
	                        series.minPxSize = extremes.minSize;
	                        // Prioritize min size if conflict to make sure bubbles are
	                        // always visible. #5873
	                        series.maxPxSize = Math.max(extremes.maxSize, extremes.minSize);
	
	                        // Find the min and max Z
	                        zData = series.zData;
	                        if (zData.length) { // #1735
	                            zMin = pick(seriesOptions.zMin, Math.min(
	                                zMin,
	                                Math.max(
	                                    arrayMin(zData),
	                                    seriesOptions.displayNegative === false ? seriesOptions.zThreshold : -Number.MAX_VALUE
	                                )
	                            ));
	                            zMax = pick(seriesOptions.zMax, Math.max(zMax, arrayMax(zData)));
	                        }
	                    }
	                }
	            });
	
	            each(activeSeries, function(series) {
	
	                var data = series[dataKey],
	                    i = data.length,
	                    radius;
	
	                if (isXAxis) {
	                    series.getRadii(zMin, zMax, series.minPxSize, series.maxPxSize);
	                }
	
	                if (range > 0) {
	                    while (i--) {
	                        if (isNumber(data[i]) && axis.dataMin <= data[i] && data[i] <= axis.dataMax) {
	                            radius = series.radii[i];
	                            pxMin = Math.min(((data[i] - min) * transA) - radius, pxMin);
	                            pxMax = Math.max(((data[i] - min) * transA) + radius, pxMax);
	                        }
	                    }
	                }
	            });
	
	            if (activeSeries.length && range > 0 && !this.isLog) {
	                pxMax -= axisLength;
	                transA *= (axisLength + pxMin - pxMax) / axisLength;
	                each([
	                    ['min', 'userMin', pxMin],
	                    ['max', 'userMax', pxMax]
	                ], function(keys) {
	                    if (pick(axis.options[keys[0]], axis[keys[1]]) === undefined) {
	                        axis[keys[0]] += keys[2] / transA;
	                    }
	                });
	            }
	        };
	
	        /* ****************************************************************************
	         * End Bubble series code                                                     *
	         *****************************************************************************/
	
	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var merge = H.merge,
	            Point = H.Point,
	            seriesType = H.seriesType,
	            seriesTypes = H.seriesTypes;
	
	        // The mapbubble series type
	        if (seriesTypes.bubble) {
	
	            /**
	             * @extends {plotOptions.bubble}
	             * @optionparent plotOptions.mapbubble
	             */
	            seriesType('mapbubble', 'bubble', {
	
	                /**
	                 */
	                animationLimit: 500,
	
	                /**
	                 */
	                tooltip: {
	
	                    /**
	                     */
	                    pointFormat: '{point.name}: {point.z}'
	                }
	
	                // Prototype members
	            }, {
	                xyFromShape: true,
	                type: 'mapbubble',
	                pointArrayMap: ['z'], // If one single value is passed, it is interpreted as z
	                /**
	                 * Return the map area identified by the dataJoinBy option
	                 */
	                getMapData: seriesTypes.map.prototype.getMapData,
	                getBox: seriesTypes.map.prototype.getBox,
	                setData: seriesTypes.map.prototype.setData
	
	                // Point class
	            }, {
	                applyOptions: function(options, x) {
	                    var point;
	                    if (options && options.lat !== undefined && options.lon !== undefined) {
	                        point = Point.prototype.applyOptions.call(
	                            this,
	                            merge(options, this.series.chart.fromLatLonToPoint(options)),
	                            x
	                        );
	                    } else {
	                        point = seriesTypes.map.prototype.pointClass.prototype.applyOptions.call(this, options, x);
	                    }
	                    return point;
	                },
	                ttBelow: false
	            });
	        }
	
	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var colorPointMixin = H.colorPointMixin,
	            colorSeriesMixin = H.colorSeriesMixin,
	            each = H.each,
	            LegendSymbolMixin = H.LegendSymbolMixin,
	            merge = H.merge,
	            noop = H.noop,
	            pick = H.pick,
	            Series = H.Series,
	            seriesType = H.seriesType,
	            seriesTypes = H.seriesTypes;
	
	        // The Heatmap series type
	
	        /**
	         * @extends {plotOptions.scatter}
	         * @optionparent plotOptions.heatmap
	         */
	        seriesType('heatmap', 'scatter', {
	
	            /**
	             */
	            animation: false,
	
	            /**
	             */
	            borderWidth: 0,
	
	
	            /**
	             */
	            nullColor: '#f7f7f7',
	
	
	            /**
	             */
	            dataLabels: {
	
	                /**
	                 */
	                formatter: function() { // #2945
	                    return this.point.value;
	                },
	
	                /**
	                 */
	                inside: true,
	
	                /**
	                 */
	                verticalAlign: 'middle',
	
	                /**
	                 */
	                crop: false,
	
	                /**
	                 */
	                overflow: false,
	
	                /**
	                 */
	                padding: 0 // #3837
	            },
	
	            /**
	             */
	            marker: null,
	
	            /**
	             */
	            pointRange: null, // dynamically set to colsize by default
	
	            /**
	             */
	            tooltip: {
	
	                /**
	                 */
	                pointFormat: '{point.x}, {point.y}: {point.value}<br/>'
	            },
	
	            /**
	             */
	            states: {
	
	                /**
	                 */
	                normal: {
	
	                    /**
	                     */
	                    animation: true
	                },
	
	                /**
	                 */
	                hover: {
	
	                    /**
	                     */
	                    halo: false, // #3406, halo is not required on heatmaps
	
	                    /**
	                     */
	                    brightness: 0.2
	                }
	            }
	        }, merge(colorSeriesMixin, {
	            pointArrayMap: ['y', 'value'],
	            hasPointSpecificOptions: true,
	            getExtremesFromAll: true,
	            directTouch: true,
	
	            /**
	             * Override the init method to add point ranges on both axes.
	             */
	            init: function() {
	                var options;
	                seriesTypes.scatter.prototype.init.apply(this, arguments);
	
	                options = this.options;
	                // #3758, prevent resetting in setData
	                options.pointRange = pick(options.pointRange, options.colsize || 1);
	                this.yAxis.axisPointRange = options.rowsize || 1; // general point range
	            },
	            translate: function() {
	                var series = this,
	                    options = series.options,
	                    xAxis = series.xAxis,
	                    yAxis = series.yAxis,
	                    between = function(x, a, b) {
	                        return Math.min(Math.max(a, x), b);
	                    };
	
	                series.generatePoints();
	
	                each(series.points, function(point) {
	                    var xPad = (options.colsize || 1) / 2,
	                        yPad = (options.rowsize || 1) / 2,
	                        x1 = between(
	                            Math.round(
	                                xAxis.len -
	                                xAxis.translate(point.x - xPad, 0, 1, 0, 1)
	                            ), -xAxis.len, 2 * xAxis.len
	                        ),
	                        x2 = between(
	                            Math.round(
	                                xAxis.len -
	                                xAxis.translate(point.x + xPad, 0, 1, 0, 1)
	                            ), -xAxis.len, 2 * xAxis.len
	                        ),
	                        y1 = between(
	                            Math.round(yAxis.translate(point.y - yPad, 0, 1, 0, 1)), -yAxis.len, 2 * yAxis.len
	                        ),
	                        y2 = between(
	                            Math.round(yAxis.translate(point.y + yPad, 0, 1, 0, 1)), -yAxis.len, 2 * yAxis.len
	                        );
	
	                    // Set plotX and plotY for use in K-D-Tree and more
	                    point.plotX = point.clientX = (x1 + x2) / 2;
	                    point.plotY = (y1 + y2) / 2;
	
	                    point.shapeType = 'rect';
	                    point.shapeArgs = {
	                        x: Math.min(x1, x2),
	                        y: Math.min(y1, y2),
	                        width: Math.abs(x2 - x1),
	                        height: Math.abs(y2 - y1)
	                    };
	                });
	
	                series.translateColors();
	            },
	            drawPoints: function() {
	                seriesTypes.column.prototype.drawPoints.call(this);
	
	                each(this.points, function(point) {
	
	                    point.graphic.attr(this.colorAttribs(point));
	
	                }, this);
	            },
	            animate: noop,
	            getBox: noop,
	            drawLegendSymbol: LegendSymbolMixin.drawRectangle,
	            alignDataLabel: seriesTypes.column.prototype.alignDataLabel,
	            getExtremes: function() {
	                // Get the extremes from the value data
	                Series.prototype.getExtremes.call(this, this.valueData);
	                this.valueMin = this.dataMin;
	                this.valueMax = this.dataMax;
	
	                // Get the extremes from the y data
	                Series.prototype.getExtremes.call(this);
	            }
	
	        }), colorPointMixin);
	
	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var Chart = H.Chart,
	            each = H.each,
	            extend = H.extend,
	            format = H.format,
	            merge = H.merge,
	            win = H.win,
	            wrap = H.wrap;
	        /** 
	         * Test for point in polygon. Polygon defined as array of [x,y] points.
	         */
	        function pointInPolygon(point, polygon) {
	            var i,
	                j,
	                rel1,
	                rel2,
	                c = false,
	                x = point.x,
	                y = point.y;
	
	            for (i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
	                rel1 = polygon[i][1] > y;
	                rel2 = polygon[j][1] > y;
	                if (rel1 !== rel2 && (x < (polygon[j][0] - polygon[i][0]) * (y - polygon[i][1]) / (polygon[j][1] - polygon[i][1]) + polygon[i][0])) {
	                    c = !c;
	                }
	            }
	
	            return c;
	        }
	
	        /**
	         * Highmaps only. Get point from latitude and longitude using specified
	         * transform definition.
	         *
	         * @function transformFromLatLon
	         * @memberOf Chart.prototype
	         *
	         * @param  {Object} latLon
	         *         A latitude/longitude object.
	         * @param  {Number} latLon.lat
	         *         The latitude.
	         * @param  {Number} latLon.lon
	         *         The longitude.
	         * @param  {Object} transform
	         *         The transform definition to use as explained in the {@link
	         *         https://www.highcharts.com/docs/maps/latlon|documentation}.
	         *
	         * @return {Object}
	         *         An object with `x` and `y` properties.
	         *
	         * @sample maps/series/latlon-transform/
	         *         Use specific transformation for lat/lon
	         */
	        Chart.prototype.transformFromLatLon = function(latLon, transform) {
	            if (win.proj4 === undefined) {
	                H.error(21);
	                return {
	                    x: 0,
	                    y: null
	                };
	            }
	
	            var projected = win.proj4(transform.crs, [latLon.lon, latLon.lat]),
	                cosAngle = transform.cosAngle || (transform.rotation && Math.cos(transform.rotation)),
	                sinAngle = transform.sinAngle || (transform.rotation && Math.sin(transform.rotation)),
	                rotated = transform.rotation ? [projected[0] * cosAngle + projected[1] * sinAngle, -projected[0] * sinAngle + projected[1] * cosAngle] : projected;
	
	            return {
	                x: ((rotated[0] - (transform.xoffset || 0)) * (transform.scale || 1) + (transform.xpan || 0)) * (transform.jsonres || 1) + (transform.jsonmarginX || 0),
	                y: (((transform.yoffset || 0) - rotated[1]) * (transform.scale || 1) + (transform.ypan || 0)) * (transform.jsonres || 1) - (transform.jsonmarginY || 0)
	            };
	        };
	
	        /**
	         * Highmaps only. Get latLon from point using specified transform definition.
	         * The method returns an object with the numeric properties `lat` and `lon`.
	         *
	         * @function transformToLatLon
	         * @memberOf Chart.prototype
	         *
	         * @param  {Point|Object} point
	         *         A `Point` instance, or or any object containing the properties `x`
	         *         and `y` with numeric values.
	         * @param  {Object} transform
	         *         The transform definition to use as explained in the {@link
	         *         https://www.highcharts.com/docs/maps/latlon|documentation}.
	         *
	         * @return {Object}
	         *         An object with `lat` and `lon` properties.
	         *
	         * @sample maps/series/latlon-transform/
	         *         Use specific transformation for lat/lon
	         *                         
	         */
	        Chart.prototype.transformToLatLon = function(point, transform) {
	            if (win.proj4 === undefined) {
	                H.error(21);
	                return;
	            }
	
	            var normalized = {
	                    x: ((point.x - (transform.jsonmarginX || 0)) / (transform.jsonres || 1) - (transform.xpan || 0)) / (transform.scale || 1) + (transform.xoffset || 0),
	                    y: ((-point.y - (transform.jsonmarginY || 0)) / (transform.jsonres || 1) + (transform.ypan || 0)) / (transform.scale || 1) + (transform.yoffset || 0)
	                },
	                cosAngle = transform.cosAngle || (transform.rotation && Math.cos(transform.rotation)),
	                sinAngle = transform.sinAngle || (transform.rotation && Math.sin(transform.rotation)),
	                // Note: Inverted sinAngle to reverse rotation direction
	                projected = win.proj4(transform.crs, 'WGS84', transform.rotation ? {
	                    x: normalized.x * cosAngle + normalized.y * -sinAngle,
	                    y: normalized.x * sinAngle + normalized.y * cosAngle
	                } : normalized);
	
	            return {
	                lat: projected.y,
	                lon: projected.x
	            };
	        };
	
	        /**
	         * Highmaps only. Calculate latitude/longitude values for a point. Returns an
	         * object with the numeric properties `lat` and `lon`.
	         *
	         * @function fromPointToLatLon
	         * @memberOf Chart.prototype
	         * 
	         * @param  {Point|Object} point
	         *         A `Point` instance or anything containing `x` and `y` properties
	         *         with numeric values
	         * @return {Object}
	         *         An object with `lat` and `lon` properties.
	         *
	         * @sample maps/demo/latlon-advanced/
	         *         Advanced lat/lon demo
	         */
	        Chart.prototype.fromPointToLatLon = function(point) {
	            var transforms = this.mapTransforms,
	                transform;
	
	            if (!transforms) {
	                H.error(22);
	                return;
	            }
	
	            for (transform in transforms) {
	                if (transforms.hasOwnProperty(transform) && transforms[transform].hitZone &&
	                    pointInPolygon({
	                        x: point.x,
	                        y: -point.y
	                    }, transforms[transform].hitZone.coordinates[0])) {
	                    return this.transformToLatLon(point, transforms[transform]);
	                }
	            }
	
	            return this.transformToLatLon(point, transforms['default']); // eslint-disable-line dot-notation
	        };
	
	        /**
	         * Highmaps only. Get chart coordinates from latitude/longitude. Returns an
	         * object with x and y values corresponding to the `xAxis` and `yAxis`.
	         *
	         * @function fromLatLonToPoint
	         * @memberOf Chart.prototype
	         * 
	         * @param  {Object} latLon
	         *         Coordinates.
	         * @param  {Number} latLon.lat
	         *         The latitude.
	         * @param  {Number} latLon.lon
	         *         The longitude.
	         *
	         * @sample maps/series/latlon-to-point/
	         *         Find a point from lat/lon
	         *         
	         * @return {Object}
	         *         X and Y coordinates in terms of chart axis values.
	         */
	        Chart.prototype.fromLatLonToPoint = function(latLon) {
	            var transforms = this.mapTransforms,
	                transform,
	                coords;
	
	            if (!transforms) {
	                H.error(22);
	                return {
	                    x: 0,
	                    y: null
	                };
	            }
	
	            for (transform in transforms) {
	                if (transforms.hasOwnProperty(transform) && transforms[transform].hitZone) {
	                    coords = this.transformFromLatLon(latLon, transforms[transform]);
	                    if (pointInPolygon({
	                            x: coords.x,
	                            y: -coords.y
	                        }, transforms[transform].hitZone.coordinates[0])) {
	                        return coords;
	                    }
	                }
	            }
	
	            return this.transformFromLatLon(latLon, transforms['default']); // eslint-disable-line dot-notation
	        };
	
	        /**
	         * Highmaps only. Restructure a GeoJSON object in preparation to be read
	         * directly by the {@link
	         * https://api.highcharts.com/highmaps/plotOptions.series.mapData|
	         * series.mapData} option. The GeoJSON will be broken down to fit a specific
	         * Highcharts type, either `map`, `mapline` or `mappoint`. Meta data in
	         * GeoJSON's properties object will be copied directly over to 
	         * {@link Point.properties} in Highmaps.
	         *
	         * @function #geojson
	         * @memberOf Highcharts
	         *
	         * @param  {Object} geojson
	         *         The GeoJSON structure to parse, represented as a JavaScript object
	         *         rather than a JSON string.
	         * @param  {String} [hType=map]
	         *         The Highmaps series type to prepare for. Setting "map" will return
	         *         GeoJSON polygons and multipolygons. Setting "mapline" will return
	         *         GeoJSON linestrings and multilinestrings. Setting "mappoint" will
	         *         return GeoJSON points and multipoints.
	         *
	         * @return {Object}
	         *         An object ready for the `mapData` option.
	         *
	         * @sample samples/maps/demo/geojson/
	         *         Simple areas
	         * @sample maps/demo/geojson-multiple-types/
	         *         Multiple types
	         *         
	         */
	        H.geojson = function(geojson, hType, series) {
	            var mapData = [],
	                path = [],
	                polygonToPath = function(polygon) {
	                    var i,
	                        len = polygon.length;
	                    path.push('M');
	                    for (i = 0; i < len; i++) {
	                        if (i === 1) {
	                            path.push('L');
	                        }
	                        path.push(polygon[i][0], -polygon[i][1]);
	                    }
	                };
	
	            hType = hType || 'map';
	
	            each(geojson.features, function(feature) {
	
	                var geometry = feature.geometry,
	                    type = geometry.type,
	                    coordinates = geometry.coordinates,
	                    properties = feature.properties,
	                    point;
	
	                path = [];
	
	                if (hType === 'map' || hType === 'mapbubble') {
	                    if (type === 'Polygon') {
	                        each(coordinates, polygonToPath);
	                        path.push('Z');
	
	                    } else if (type === 'MultiPolygon') {
	                        each(coordinates, function(items) {
	                            each(items, polygonToPath);
	                        });
	                        path.push('Z');
	                    }
	
	                    if (path.length) {
	                        point = {
	                            path: path
	                        };
	                    }
	
	                } else if (hType === 'mapline') {
	                    if (type === 'LineString') {
	                        polygonToPath(coordinates);
	                    } else if (type === 'MultiLineString') {
	                        each(coordinates, polygonToPath);
	                    }
	
	                    if (path.length) {
	                        point = {
	                            path: path
	                        };
	                    }
	
	                } else if (hType === 'mappoint') {
	                    if (type === 'Point') {
	                        point = {
	                            x: coordinates[0],
	                            y: -coordinates[1]
	                        };
	                    }
	                }
	                if (point) {
	                    mapData.push(extend(point, {
	                        name: properties.name || properties.NAME,
	
	                        /**
	                         * In Highmaps, when data is loaded from GeoJSON, the GeoJSON
	                         * item's properies are copied over here.
	                         *
	                         * @name #properties
	                         * @memberOf Point
	                         * @type {Object}
	                         */
	                        properties: properties
	                    }));
	                }
	
	            });
	
	            // Create a credits text that includes map source, to be picked up in Chart.addCredits
	            if (series && geojson.copyrightShort) {
	                series.chart.mapCredits = format(series.chart.options.credits.mapText, {
	                    geojson: geojson
	                });
	                series.chart.mapCreditsFull = format(series.chart.options.credits.mapTextFull, {
	                    geojson: geojson
	                });
	            }
	
	            return mapData;
	        };
	
	        /**
	         * Override addCredits to include map source by default
	         */
	        wrap(Chart.prototype, 'addCredits', function(proceed, credits) {
	
	            credits = merge(true, this.options.credits, credits);
	
	            // Disable credits link if map credits enabled. This to allow for in-text anchors.
	            if (this.mapCredits) {
	                credits.href = null;
	            }
	
	            proceed.call(this, credits);
	
	            // Add full map credits to hover
	            if (this.credits && this.mapCreditsFull) {
	                this.credits.attr({
	                    title: this.mapCreditsFull
	                });
	            }
	        });
	
	    }(Highcharts));
	    (function(H) {
	        /**
	         * (c) 2010-2017 Torstein Honsi
	         *
	         * License: www.highcharts.com/license
	         */
	        var Chart = H.Chart,
	            defaultOptions = H.defaultOptions,
	            each = H.each,
	            extend = H.extend,
	            merge = H.merge,
	            pick = H.pick,
	            Renderer = H.Renderer,
	            SVGRenderer = H.SVGRenderer,
	            VMLRenderer = H.VMLRenderer;
	
	
	        // Add language
	        extend(defaultOptions.lang, {
	            zoomIn: 'Zoom in',
	            zoomOut: 'Zoom out'
	        });
	
	
	        // Set the default map navigation options
	
	        /** 
	         * @products highmaps
	         * @optionparent mapNavigation 
	         */
	        defaultOptions.mapNavigation = {
	
	            /**
	             * General options for the map navigation buttons. Individual options
	             * can be given from the [mapNavigation.buttons](#mapNavigation.buttons)
	             * option set.
	             * 
	             * @type {Object}
	             * @sample {highmaps} maps/mapnavigation/button-theme/ Theming the navigation buttons
	             * @product highmaps
	             */
	            buttonOptions: {
	
	                /**
	                 * What box to align the buttons to. Possible values are `plotBox`
	                 * and `spacingBox`.
	                 * 
	                 * @validvalue ["plotBox", "spacingBox"]
	                 * @type {String}
	                 * @default plotBox
	                 * @product highmaps
	                 */
	                alignTo: 'plotBox',
	
	                /**
	                 * The alignment of the navigation buttons.
	                 * 
	                 * @validvalue ["left", "center", "right"]
	                 * @type {String}
	                 * @default left
	                 * @product highmaps
	                 */
	                align: 'left',
	
	                /**
	                 * The vertical alignment of the buttons. Individual alignment can
	                 * be adjusted by each button's `y` offset.
	                 * 
	                 * @validvalue ["top", "middle", "bottom"]
	                 * @type {String}
	                 * @default bottom
	                 * @product highmaps
	                 */
	                verticalAlign: 'top',
	
	                /**
	                 * The X offset of the buttons relative to its `align` setting.
	                 * 
	                 * @type {Number}
	                 * @default 0
	                 * @product highmaps
	                 */
	                x: 0,
	
	                /**
	                 * The width of the map navigation buttons.
	                 * 
	                 * @type {Number}
	                 * @default 18
	                 * @product highmaps
	                 */
	                width: 18,
	
	                /**
	                 * The pixel height of the map navigation buttons.
	                 * 
	                 * @type {Number}
	                 * @default 18
	                 * @product highmaps
	                 */
	                height: 18,
	
	                /**
	                 * Padding for the navigation buttons.
	                 * 
	                 * @type {Number}
	                 * @default 5
	                 * @since 5.0.0
	                 * @product highmaps
	                 */
	                padding: 5,
	
	
	                /**
	                 * Text styles for the map navigation buttons. Defaults to
	                 * 
	                 * <pre>{
	                 * fontSize: '15px',
	                 * fontWeight: 'bold',
	                 * textAlign: 'center'
	                 * }</pre>
	                 * 
	                 * @type {CSSObject}
	                 * @product highmaps
	                 */
	                style: {
	
	                    /**
	                     */
	                    fontSize: '15px',
	
	                    /**
	                     */
	                    fontWeight: 'bold'
	                },
	
	                /**
	                 * A configuration object for the button theme. The object accepts
	                 * SVG properties like `stroke-width`, `stroke` and `fill`. Tri-state
	                 * button styles are supported by the `states.hover` and `states.select`
	                 * objects.
	                 * 
	                 * @type {Object}
	                 * @sample {highmaps} maps/mapnavigation/button-theme/ Themed navigation buttons
	                 * @product highmaps
	                 */
	                theme: {
	                    'stroke-width': 1,
	
	                    /**
	                     */
	                    'text-align': 'center'
	                }
	
	            },
	
	            /**
	             * The individual buttons for the map navigation. This usually includes
	             * the zoom in and zoom out buttons. Properties for each button is
	             * inherited from [mapNavigation.buttonOptions](#mapNavigation.buttonOptions),
	             * while individual options can be overridden. But default, the `onclick`,
	             *  `text` and `y` options are individual.
	             * 
	             * @type {Object}
	             * @product highmaps
	             */
	            buttons: {
	
	                /**
	                 * Options for the zoom in button. Properties for the zoom in and
	                 * zoom out buttons are inherited from [mapNavigation.buttonOptions](#mapNavigation.
	                 * buttonOptions), while individual options can be overridden. By
	                 * default, the `onclick`, `text` and `y` options are individual.
	                 * 
	                 * @type {Object}
	                 * @extends mapNavigation.buttonOptions
	                 * @product highmaps
	                 */
	                zoomIn: {
	
	                    /**
	                     * Click handler for the button. Defaults to:
	                     * 
	                     * <pre>function () {
	                     * this.mapZoom(0.5);
	                     * }</pre>
	                     * 
	                     * @type {Function}
	                     * @product highmaps
	                     */
	                    onclick: function() {
	                        this.mapZoom(0.5);
	                    },
	
	                    /**
	                     * The text for the button. The tooltip (title) is a language option
	                     * given by [lang.zoomIn](#lang.zoomIn).
	                     * 
	                     * @type {String}
	                     * @default +
	                     * @product highmaps
	                     */
	                    text: '+',
	
	                    /**
	                     * The position of the zoomIn button relative to the vertical alignment.
	                     * 
	                     * @type {Number}
	                     * @default 0
	                     * @product highmaps
	                     */
	                    y: 0
	                },
	
	                /**
	                 * Options for the zoom out button. Properties for the zoom in and
	                 * zoom out buttons are inherited from [mapNavigation.buttonOptions](#mapNavigation.
	                 * buttonOptions), while individual options can be overridden. By
	                 * default, the `onclick`, `text` and `y` options are individual.
	                 * 
	                 * @type {Object}
	                 * @extends mapNavigation.buttonOptions
	                 * @product highmaps
	                 */
	                zoomOut: {
	
	                    /**
	                     * Click handler for the button. Defaults to:
	                     * 
	                     * <pre>function () {
	                     * this.mapZoom(2);
	                     * }</pre>
	                     * 
	                     * @type {Function}
	                     * @product highmaps
	                     */
	                    onclick: function() {
	                        this.mapZoom(2);
	                    },
	
	                    /**
	                     * The text for the button. The tooltip (title) is a language option
	                     * given by [lang.zoomOut](#lang.zoomIn).
	                     * 
	                     * @type {String}
	                     * @default -
	                     * @product highmaps
	                     */
	                    text: '-',
	
	                    /**
	                     * The position of the zoomOut button relative to the vertical alignment.
	                     * 
	                     * @type {Number}
	                     * @default 28
	                     * @product highmaps
	                     */
	                    y: 28
	                }
	            },
	
	            /**
	             * Sensitivity of mouse wheel or trackpad scrolling. 1 is no sensitivity,
	             *  while with 2, one mousewheel delta will zoom in 50%.
	             * 
	             * @type {Number}
	             * @default 1.1
	             * @since 4.2.4
	             * @product highmaps
	             */
	            mouseWheelSensitivity: 1.1
	            // enabled: false,
	            // enableButtons: null, // inherit from enabled
	            // enableTouchZoom: null, // inherit from enabled
	            // enableDoubleClickZoom: null, // inherit from enabled
	            // enableDoubleClickZoomTo: false
	            // enableMouseWheelZoom: null, // inherit from enabled
	        };
	
	        /**
	         * Utility for reading SVG paths directly.
	         */
	        H.splitPath = function(path) {
	            var i;
	
	            // Move letters apart
	            path = path.replace(/([A-Za-z])/g, ' $1 ');
	            // Trim
	            path = path.replace(/^\s*/, '').replace(/\s*$/, '');
	
	            // Split on spaces and commas
	            path = path.split(/[ ,]+/); // Extra comma to escape gulp.scripts task
	
	            // Parse numbers
	            for (i = 0; i < path.length; i++) {
	                if (!/[a-zA-Z]/.test(path[i])) {
	                    path[i] = parseFloat(path[i]);
	                }
	            }
	            return path;
	        };
	
	        // A placeholder for map definitions
	        H.maps = {};
	
	
	
	
	
	        // Create symbols for the zoom buttons
	        function selectiveRoundedRect(x, y, w, h, rTopLeft, rTopRight, rBottomRight, rBottomLeft) {
	            return [
	                'M', x + rTopLeft, y,
	                // top side
	                'L', x + w - rTopRight, y,
	                // top right corner
	                'C', x + w - rTopRight / 2,
	                y, x + w,
	                y + rTopRight / 2, x + w, y + rTopRight,
	                // right side
	                'L', x + w, y + h - rBottomRight,
	                // bottom right corner
	                'C', x + w, y + h - rBottomRight / 2,
	                x + w - rBottomRight / 2, y + h,
	                x + w - rBottomRight, y + h,
	                // bottom side
	                'L', x + rBottomLeft, y + h,
	                // bottom left corner
	                'C', x + rBottomLeft / 2, y + h,
	                x, y + h - rBottomLeft / 2,
	                x, y + h - rBottomLeft,
	                // left side
	                'L', x, y + rTopLeft,
	                // top left corner
	                'C', x, y + rTopLeft / 2,
	                x + rTopLeft / 2, y,
	                x + rTopLeft, y,
	                'Z'
	            ];
	        }
	        SVGRenderer.prototype.symbols.topbutton = function(x, y, w, h, attr) {
	            return selectiveRoundedRect(x - 1, y - 1, w, h, attr.r, attr.r, 0, 0);
	        };
	        SVGRenderer.prototype.symbols.bottombutton = function(x, y, w, h, attr) {
	            return selectiveRoundedRect(x - 1, y - 1, w, h, 0, 0, attr.r, attr.r);
	        };
	        // The symbol callbacks are generated on the SVGRenderer object in all browsers. Even
	        // VML browsers need this in order to generate shapes in export. Now share
	        // them with the VMLRenderer.
	        if (Renderer === VMLRenderer) {
	            each(['topbutton', 'bottombutton'], function(shape) {
	                VMLRenderer.prototype.symbols[shape] = SVGRenderer.prototype.symbols[shape];
	            });
	        }
	
	
	        /**
	         * The factory function for creating new map charts. Creates a new {@link
	         * Chart|Chart} object with different default options than the basic Chart.
	         * 
	         * @function #mapChart
	         * @memberOf Highcharts
	         *
	         * @param  {String|HTMLDOMElement} renderTo
	         *         The DOM element to render to, or its id.
	         * @param  {Options} options
	         *         The chart options structure as described in the {@link
	         *         https://api.highcharts.com/highstock|options reference}.
	         * @param  {Function} callback
	         *         A function to execute when the chart object is finished loading and
	         *         rendering. In most cases the chart is built in one thread, but in
	         *         Internet Explorer version 8 or less the chart is sometimes initialized
	         *         before the document is ready, and in these cases the chart object
	         *         will not be finished synchronously. As a consequence, code that
	         *         relies on the newly built Chart object should always run in the
	         *         callback. Defining a {@link https://api.highcharts.com/highstock/chart.events.load|
	         *         chart.event.load} handler is equivalent.
	         *
	         * @return {Chart}
	         *         The chart object.
	         */
	        H.Map = H.mapChart = function(a, b, c) {
	
	            var hasRenderToArg = typeof a === 'string' || a.nodeName,
	                options = arguments[hasRenderToArg ? 1 : 0],
	                hiddenAxis = {
	                    endOnTick: false,
	                    visible: false,
	                    minPadding: 0,
	                    maxPadding: 0,
	                    startOnTick: false
	                },
	                seriesOptions,
	                defaultCreditsOptions = H.getOptions().credits;
	
	            /* For visual testing
	            hiddenAxis.gridLineWidth = 1;
	            hiddenAxis.gridZIndex = 10;
	            hiddenAxis.tickPositions = undefined;
	            // */
	
	            // Don't merge the data
	            seriesOptions = options.series;
	            options.series = null;
	
	            options = merge({
	                    chart: {
	                        panning: 'xy',
	                        type: 'map'
	                    },
	                    credits: {
	                        mapText: pick(defaultCreditsOptions.mapText, ' \u00a9 <a href="{geojson.copyrightUrl}">{geojson.copyrightShort}</a>'),
	                        mapTextFull: pick(defaultCreditsOptions.mapTextFull, '{geojson.copyright}')
	                    },
	                    tooltip: {
	                        followTouchMove: false
	                    },
	                    xAxis: hiddenAxis,
	                    yAxis: merge(hiddenAxis, {
	                        reversed: true
	                    })
	                },
	                options, // user's options
	
	                { // forced options
	                    chart: {
	                        inverted: false,
	                        alignTicks: false
	                    }
	                }
	            );
	
	            options.series = seriesOptions;
	
	
	            return hasRenderToArg ?
	                new Chart(a, options, c) :
	                new Chart(options, b);
	        };
	
	    }(Highcharts));
	    (function() {
	
	
	    }());
	    return Highcharts
	}));


/***/ }),
/* 541 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "748a59d941c96c7bdbbfad4f134cf1de.jpg";

/***/ }),
/* 542 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "cf1db774bf0d25febedec4c9c7020f5e.png";

/***/ }),
/* 543 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "b43d79b105fbbfcab5cb7f917b34fa11.png";

/***/ }),
/* 544 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "11642aa0f30faa56bb7587f2a7a4502a.png";

/***/ }),
/* 545 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "4806ee078ffa37ceb81672f287a2fed9.png";

/***/ }),
/* 546 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "bd9a9fd7c451acc809a7df7f67e0a871.png";

/***/ }),
/* 547 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "804148750331f306cb49f5f0ffe3ece8.png";

/***/ }),
/* 548 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "2de681b5ec8958c02471ea2c53d040a0.png";

/***/ }),
/* 549 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "158226c08db84eb59444dd1f90cc1583.png";

/***/ }),
/* 550 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "ae1b88816e6d60563a7548755b81eb3d.png";

/***/ }),
/* 551 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "3cb8c0cf9e8843c8bc357734f275444e.png";

/***/ }),
/* 552 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "416ae78da747e28372dfa2e7bc920712.jpg";

/***/ }),
/* 553 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "a31124c82f34a490ce3bbe5551b828cf.png";

/***/ }),
/* 554 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "8145a924a8b4ec2c42faf0e840bc1747.png";

/***/ }),
/* 555 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.resetIdCounter = exports.Tabs = exports.TabPanel = exports.TabList = exports.Tab = undefined;
	
	var _Tabs = __webpack_require__(556);
	
	var _Tabs2 = _interopRequireDefault(_Tabs);
	
	var _TabList = __webpack_require__(564);
	
	var _TabList2 = _interopRequireDefault(_TabList);
	
	var _Tab = __webpack_require__(565);
	
	var _Tab2 = _interopRequireDefault(_Tab);
	
	var _TabPanel = __webpack_require__(566);
	
	var _TabPanel2 = _interopRequireDefault(_TabPanel);
	
	var _uuid = __webpack_require__(562);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.Tab = _Tab2.default;
	exports.TabList = _TabList2.default;
	exports.TabPanel = _TabPanel2.default;
	exports.Tabs = _Tabs2.default;
	exports.resetIdCounter = _uuid.reset;

/***/ }),
/* 556 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _propTypes = __webpack_require__(420);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _propTypes3 = __webpack_require__(557);
	
	var _UncontrolledTabs = __webpack_require__(560);
	
	var _UncontrolledTabs2 = _interopRequireDefault(_UncontrolledTabs);
	
	var _count = __webpack_require__(563);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Tabs = function (_Component) {
	  _inherits(Tabs, _Component);
	
	  function Tabs(props) {
	    _classCallCheck(this, Tabs);
	
	    var _this = _possibleConstructorReturn(this, _Component.call(this, props));
	
	    _this.handleSelected = function (index, last, event) {
	      // Call change event handler
	      if (typeof _this.props.onSelect === 'function') {
	        // Check if the change event handler cancels the tab change
	        if (_this.props.onSelect(index, last, event) === false) return;
	      }
	
	      var state = {
	        // Set focus if the change was triggered from the keyboard
	        focus: event.type === 'keydown'
	      };
	
	      if (Tabs.inUncontrolledMode(_this.props)) {
	        // Update selected index
	        state.selectedIndex = index;
	      }
	
	      _this.setState(state);
	    };
	
	    _this.state = Tabs.copyPropsToState(_this.props, {}, _this.props.defaultFocus);
	    return _this;
	  }
	
	  Tabs.prototype.componentWillReceiveProps = function componentWillReceiveProps(newProps) {
	    if (("development") !== 'production' && Tabs.inUncontrolledMode(newProps) !== Tabs.inUncontrolledMode(this.props)) {
	      throw new Error('Switching between controlled mode (by using `selectedIndex`) and uncontrolled mode is not supported in `Tabs`.\nFor more information about controlled and uncontrolled mode of react-tabs see the README.');
	    }
	    // Use a transactional update to prevent race conditions
	    // when reading the state in copyPropsToState
	    // See https://github.com/reactjs/react-tabs/issues/51
	    this.setState(function (state) {
	      return Tabs.copyPropsToState(newProps, state);
	    });
	  };
	
	  Tabs.inUncontrolledMode = function inUncontrolledMode(props) {
	    return props.selectedIndex === null;
	  };
	
	  // preserve the existing selectedIndex from state.
	  // If the state has not selectedIndex, default to the defaultIndex or 0
	  Tabs.copyPropsToState = function copyPropsToState(props, state) {
	    var focus = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	
	    var newState = {
	      focus: focus
	    };
	
	    if (Tabs.inUncontrolledMode(props)) {
	      var maxTabIndex = (0, _count.getTabsCount)(props.children) - 1;
	      var selectedIndex = null;
	
	      if (state.selectedIndex != null) {
	        selectedIndex = Math.min(state.selectedIndex, maxTabIndex);
	      } else {
	        selectedIndex = props.defaultIndex || 0;
	      }
	      newState.selectedIndex = selectedIndex;
	    }
	
	    return newState;
	  };
	
	  Tabs.prototype.render = function render() {
	    var _props = this.props,
	        children = _props.children,
	        defaultIndex = _props.defaultIndex,
	        defaultFocus = _props.defaultFocus,
	        props = _objectWithoutProperties(_props, ['children', 'defaultIndex', 'defaultFocus']);
	
	    props.focus = this.state.focus;
	    props.onSelect = this.handleSelected;
	
	    if (this.state.selectedIndex != null) {
	      props.selectedIndex = this.state.selectedIndex;
	    }
	
	    return _react2.default.createElement(
	      _UncontrolledTabs2.default,
	      props,
	      children
	    );
	  };
	
	  return Tabs;
	}(_react.Component);
	
	Tabs.defaultProps = {
	  defaultFocus: false,
	  forceRenderTabPanel: false,
	  selectedIndex: null,
	  defaultIndex: null
	};
	exports.default = Tabs;
	Tabs.propTypes =  true ? {
	  children: _propTypes3.childrenPropType,
	  className: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.array, _propTypes2.default.object]),
	  defaultFocus: _propTypes2.default.bool,
	  defaultIndex: _propTypes2.default.number,
	  disabledTabClassName: _propTypes2.default.string,
	  forceRenderTabPanel: _propTypes2.default.bool,
	  onSelect: _propTypes3.onSelectPropType,
	  selectedIndex: _propTypes3.selectedIndexPropType,
	  selectedTabClassName: _propTypes2.default.string,
	  selectedTabPanelClassName: _propTypes2.default.string
	} : {};
	
	
	Tabs.tabsRole = 'Tabs';

/***/ }),
/* 557 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.childrenPropType = childrenPropType;
	exports.onSelectPropType = onSelectPropType;
	exports.selectedIndexPropType = selectedIndexPropType;
	
	var _childrenDeepMap = __webpack_require__(558);
	
	var _elementTypes = __webpack_require__(559);
	
	function childrenPropType(props, propName, componentName) {
	  var error = void 0;
	  var tabsCount = 0;
	  var panelsCount = 0;
	  var tabListFound = false;
	  var listTabs = [];
	  var children = props[propName];
	
	  (0, _childrenDeepMap.deepForEach)(children, function (child) {
	    if ((0, _elementTypes.isTabList)(child)) {
	      if (child.props && child.props.children && _typeof(child.props.children) === 'object') {
	        (0, _childrenDeepMap.deepForEach)(child.props.children, function (listChild) {
	          return listTabs.push(listChild);
	        });
	      }
	
	      if (tabListFound) {
	        error = new Error("Found multiple 'TabList' components inside 'Tabs'. Only one is allowed.");
	      }
	      tabListFound = true;
	    }
	    if ((0, _elementTypes.isTab)(child)) {
	      if (!tabListFound || listTabs.indexOf(child) === -1) {
	        error = new Error("Found a 'Tab' component outside of the 'TabList' component. 'Tab' components have to be inside the 'TabList' component.");
	      }
	      tabsCount++;
	    } else if ((0, _elementTypes.isTabPanel)(child)) {
	      panelsCount++;
	    }
	  });
	
	  if (!error && tabsCount !== panelsCount) {
	    error = new Error('There should be an equal number of \'Tab\' and \'TabPanel\' in `' + componentName + '`.' + ('Received ' + tabsCount + ' \'Tab\' and ' + panelsCount + ' \'TabPanel\'.'));
	  }
	
	  return error;
	}
	
	function onSelectPropType(props, propName, componentName, location, propFullName) {
	  var prop = props[propName];
	  var name = propFullName || propName;
	  var error = null;
	
	  if (prop && typeof prop !== 'function') {
	    error = new Error('Invalid ' + location + ' `' + name + '` of type `' + (typeof prop === 'undefined' ? 'undefined' : _typeof(prop)) + '` supplied to `' + componentName + '`, expected `function`.');
	  } else if (props.selectedIndex != null && prop == null) {
	    error = new Error('The ' + location + ' `' + name + '` is marked as required in `' + componentName + '`, but its value is `undefined` or `null`.\n`onSelect` is required when `selectedIndex` is also set. Not doing so will make the tabs not do anything, as `selectedIndex` indicates that you want to handle the selected tab yourself.\nIf you only want to set the inital tab replace `selectedIndex` with `defaultIndex`.');
	  }
	
	  return error;
	}
	
	function selectedIndexPropType(props, propName, componentName, location, propFullName) {
	  var prop = props[propName];
	  var name = propFullName || propName;
	  var error = null;
	
	  if (prop != null && typeof prop !== 'number') {
	    error = new Error('Invalid ' + location + ' `' + name + '` of type `' + (typeof prop === 'undefined' ? 'undefined' : _typeof(prop)) + '` supplied to `' + componentName + '`, expected `number`.');
	  } else if (props.defaultIndex != null && prop != null) {
	    return new Error('The ' + location + ' `' + name + '` cannot be used together with `defaultIndex` in `' + componentName + '`.\nEither remove `' + name + '` to let `' + componentName + '` handle the selected tab internally or remove `defaultIndex` to handle it yourself.');
	  }
	
	  return error;
	}

/***/ }),
/* 558 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.deepMap = deepMap;
	exports.deepForEach = deepForEach;
	
	var _react = __webpack_require__(2);
	
	var _elementTypes = __webpack_require__(559);
	
	function isTabChild(child) {
	  return (0, _elementTypes.isTab)(child) || (0, _elementTypes.isTabList)(child) || (0, _elementTypes.isTabPanel)(child);
	}
	
	function deepMap(children, callback) {
	  return _react.Children.map(children, function (child) {
	    // null happens when conditionally rendering TabPanel/Tab
	    // see https://github.com/reactjs/react-tabs/issues/37
	    if (child === null) return null;
	
	    if (isTabChild(child)) {
	      return callback(child);
	    }
	
	    if (child.props && child.props.children && _typeof(child.props.children) === 'object') {
	      // Clone the child that has children and map them too
	      return (0, _react.cloneElement)(child, _extends({}, child.props, {
	        children: deepMap(child.props.children, callback)
	      }));
	    }
	
	    return child;
	  });
	}
	
	function deepForEach(children, callback) {
	  return _react.Children.forEach(children, function (child) {
	    // null happens when conditionally rendering TabPanel/Tab
	    // see https://github.com/reactjs/react-tabs/issues/37
	    if (child === null) return;
	
	    if ((0, _elementTypes.isTab)(child) || (0, _elementTypes.isTabPanel)(child)) {
	      callback(child);
	    } else if (child.props && child.props.children && _typeof(child.props.children) === 'object') {
	      if ((0, _elementTypes.isTabList)(child)) callback(child);
	      deepForEach(child.props.children, callback);
	    }
	  });
	}

/***/ }),
/* 559 */
/***/ (function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports.isTab = isTab;
	exports.isTabPanel = isTabPanel;
	exports.isTabList = isTabList;
	function isTab(el) {
	  return el.type.tabsRole === 'Tab';
	}
	
	function isTabPanel(el) {
	  return el.type.tabsRole === 'TabPanel';
	}
	
	function isTabList(el) {
	  return el.type.tabsRole === 'TabList';
	}

/***/ }),
/* 560 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _propTypes = __webpack_require__(420);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(561);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	var _uuid = __webpack_require__(562);
	
	var _uuid2 = _interopRequireDefault(_uuid);
	
	var _propTypes3 = __webpack_require__(557);
	
	var _count = __webpack_require__(563);
	
	var _childrenDeepMap = __webpack_require__(558);
	
	var _elementTypes = __webpack_require__(559);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// Determine if a node from event.target is a Tab element
	function isTabNode(node) {
	  return node.nodeName === 'LI' && node.getAttribute('role') === 'tab';
	}
	
	// Determine if a tab node is disabled
	function isTabDisabled(node) {
	  return node.getAttribute('aria-disabled') === 'true';
	}
	
	var canUseActiveElement = void 0;
	try {
	  canUseActiveElement = !!(typeof window !== 'undefined' && window.document && window.document.activeElement);
	} catch (e) {
	  // Work around for IE bug when accessing document.activeElement in an iframe
	  // Refer to the following resources:
	  // http://stackoverflow.com/a/10982960/369687
	  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12733599
	  canUseActiveElement = false;
	}
	
	var UncontrolledTabs = function (_Component) {
	  _inherits(UncontrolledTabs, _Component);
	
	  function UncontrolledTabs() {
	    var _temp, _this, _ret;
	
	    _classCallCheck(this, UncontrolledTabs);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.tabNodes = [], _this.handleKeyDown = function (e) {
	      if (_this.isTabFromContainer(e.target)) {
	        var index = _this.props.selectedIndex;
	        var preventDefault = false;
	
	        if (e.keyCode === 37 || e.keyCode === 38) {
	          // Select next tab to the left
	          index = _this.getPrevTab(index);
	          preventDefault = true;
	        } else if (e.keyCode === 39 || e.keyCode === 40) {
	          // Select next tab to the right
	          index = _this.getNextTab(index);
	          preventDefault = true;
	        }
	
	        // This prevents scrollbars from moving around
	        if (preventDefault) {
	          e.preventDefault();
	        }
	
	        _this.setSelected(index, e);
	      }
	    }, _this.handleClick = function (e) {
	      var node = e.target;
	      // eslint-disable-next-line no-cond-assign
	      do {
	        if (_this.isTabFromContainer(node)) {
	          if (isTabDisabled(node)) {
	            return;
	          }
	
	          var index = [].slice.call(node.parentNode.children).filter(isTabNode).indexOf(node);
	          _this.setSelected(index, e);
	          return;
	        }
	      } while ((node = node.parentNode) !== null);
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }
	
	  UncontrolledTabs.prototype.setSelected = function setSelected(index, event) {
	    // Check index boundary
	    if (index < 0 || index >= this.getTabsCount()) return;
	
	    // Call change event handler
	    this.props.onSelect(index, this.props.selectedIndex, event);
	  };
	
	  UncontrolledTabs.prototype.getNextTab = function getNextTab(index) {
	    var count = this.getTabsCount();
	
	    // Look for non-disabled tab from index to the last tab on the right
	    for (var i = index + 1; i < count; i++) {
	      if (!isTabDisabled(this.getTab(i))) {
	        return i;
	      }
	    }
	
	    // If no tab found, continue searching from first on left to index
	    for (var _i = 0; _i < index; _i++) {
	      if (!isTabDisabled(this.getTab(_i))) {
	        return _i;
	      }
	    }
	
	    // No tabs are disabled, return index
	    return index;
	  };
	
	  UncontrolledTabs.prototype.getPrevTab = function getPrevTab(index) {
	    var i = index;
	
	    // Look for non-disabled tab from index to first tab on the left
	    while (i--) {
	      if (!isTabDisabled(this.getTab(i))) {
	        return i;
	      }
	    }
	
	    // If no tab found, continue searching from last tab on right to index
	    i = this.getTabsCount();
	    while (i-- > index) {
	      if (!isTabDisabled(this.getTab(i))) {
	        return i;
	      }
	    }
	
	    // No tabs are disabled, return index
	    return index;
	  };
	
	  UncontrolledTabs.prototype.getTabsCount = function getTabsCount() {
	    return (0, _count.getTabsCount)(this.props.children);
	  };
	
	  UncontrolledTabs.prototype.getPanelsCount = function getPanelsCount() {
	    return (0, _count.getPanelsCount)(this.props.children);
	  };
	
	  UncontrolledTabs.prototype.getTab = function getTab(index) {
	    return this.tabNodes['tabs-' + index];
	  };
	
	  UncontrolledTabs.prototype.getChildren = function getChildren() {
	    var _this2 = this;
	
	    var index = 0;
	    var _props = this.props,
	        children = _props.children,
	        disabledTabClassName = _props.disabledTabClassName,
	        focus = _props.focus,
	        forceRenderTabPanel = _props.forceRenderTabPanel,
	        selectedIndex = _props.selectedIndex,
	        selectedTabClassName = _props.selectedTabClassName,
	        selectedTabPanelClassName = _props.selectedTabPanelClassName;
	
	
	    this.tabIds = this.tabIds || [];
	    this.panelIds = this.panelIds || [];
	    var diff = this.tabIds.length - this.getTabsCount();
	
	    // Add ids if new tabs have been added
	    // Don't bother removing ids, just keep them in case they are added again
	    // This is more efficient, and keeps the uuid counter under control
	    while (diff++ < 0) {
	      this.tabIds.push((0, _uuid2.default)());
	      this.panelIds.push((0, _uuid2.default)());
	    }
	
	    // Map children to dynamically setup refs
	    return (0, _childrenDeepMap.deepMap)(children, function (child) {
	      var result = child;
	
	      // Clone TabList and Tab components to have refs
	      if ((0, _elementTypes.isTabList)(child)) {
	        var listIndex = 0;
	
	        // Figure out if the current focus in the DOM is set on a Tab
	        // If it is we should keep the focus on the next selected tab
	        var wasTabFocused = false;
	
	        if (canUseActiveElement) {
	          wasTabFocused = _react2.default.Children.toArray(child.props.children).filter(_elementTypes.isTab).some(function (tab, i) {
	            return document.activeElement === _this2.getTab(i);
	          });
	        }
	
	        result = (0, _react.cloneElement)(child, {
	          children: (0, _childrenDeepMap.deepMap)(child.props.children, function (tab) {
	            var key = 'tabs-' + listIndex;
	            var selected = selectedIndex === listIndex;
	
	            var props = {
	              tabRef: function tabRef(node) {
	                _this2.tabNodes[key] = node;
	              },
	              id: _this2.tabIds[listIndex],
	              panelId: _this2.panelIds[listIndex],
	              selected: selected,
	              focus: selected && (focus || wasTabFocused)
	            };
	
	            if (selectedTabClassName) props.selectedClassName = selectedTabClassName;
	            if (disabledTabClassName) props.disabledClassName = disabledTabClassName;
	
	            listIndex++;
	
	            return (0, _react.cloneElement)(tab, props);
	          })
	        });
	      } else if ((0, _elementTypes.isTabPanel)(child)) {
	        var props = {
	          id: _this2.panelIds[index],
	          tabId: _this2.tabIds[index],
	          selected: selectedIndex === index
	        };
	
	        if (forceRenderTabPanel) props.forceRender = forceRenderTabPanel;
	        if (selectedTabPanelClassName) props.selectedClassName = selectedTabPanelClassName;
	
	        index++;
	
	        result = (0, _react.cloneElement)(child, props);
	      }
	
	      return result;
	    });
	  };
	
	  /**
	   * Determine if a node from event.target is a Tab element for the current Tabs container.
	   * If the clicked element is not a Tab, it returns false.
	   * If it finds another Tabs container between the Tab and `this`, it returns false.
	   */
	  UncontrolledTabs.prototype.isTabFromContainer = function isTabFromContainer(node) {
	    // return immediately if the clicked element is not a Tab.
	    if (!isTabNode(node)) {
	      return false;
	    }
	
	    // Check if the first occurrence of a Tabs container is `this` one.
	    var nodeAncestor = node.parentElement;
	    do {
	      if (nodeAncestor === this.node) return true;else if (nodeAncestor.getAttribute('data-tabs')) break;
	
	      nodeAncestor = nodeAncestor.parentElement;
	    } while (nodeAncestor);
	
	    return false;
	  };
	
	  UncontrolledTabs.prototype.render = function render() {
	    var _this3 = this;
	
	    // Delete all known props, so they don't get added to DOM
	    var _props2 = this.props,
	        children = _props2.children,
	        className = _props2.className,
	        disabledTabClassName = _props2.disabledTabClassName,
	        focus = _props2.focus,
	        forceRenderTabPanel = _props2.forceRenderTabPanel,
	        onSelect = _props2.onSelect,
	        selectedIndex = _props2.selectedIndex,
	        selectedTabClassName = _props2.selectedTabClassName,
	        selectedTabPanelClassName = _props2.selectedTabPanelClassName,
	        attributes = _objectWithoutProperties(_props2, ['children', 'className', 'disabledTabClassName', 'focus', 'forceRenderTabPanel', 'onSelect', 'selectedIndex', 'selectedTabClassName', 'selectedTabPanelClassName']);
	
	    return _react2.default.createElement(
	      'div',
	      _extends({}, attributes, {
	        className: (0, _classnames2.default)(className),
	        onClick: this.handleClick,
	        onKeyDown: this.handleKeyDown,
	        ref: function ref(node) {
	          _this3.node = node;
	        },
	        'data-tabs': true
	      }),
	      this.getChildren()
	    );
	  };
	
	  return UncontrolledTabs;
	}(_react.Component);
	
	UncontrolledTabs.defaultProps = {
	  className: 'react-tabs',
	  focus: false
	};
	exports.default = UncontrolledTabs;
	UncontrolledTabs.propTypes =  true ? {
	  children: _propTypes3.childrenPropType,
	  className: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.array, _propTypes2.default.object]),
	  disabledTabClassName: _propTypes2.default.string,
	  focus: _propTypes2.default.bool,
	  forceRenderTabPanel: _propTypes2.default.bool,
	  onSelect: _propTypes2.default.func.isRequired,
	  selectedIndex: _propTypes2.default.number.isRequired,
	  selectedTabClassName: _propTypes2.default.string,
	  selectedTabPanelClassName: _propTypes2.default.string
	} : {};

/***/ }),
/* 561 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	  Copyright (c) 2016 Jed Watson.
	  Licensed under the MIT License (MIT), see
	  http://jedwatson.github.io/classnames
	*/
	/* global define */
	
	(function () {
		'use strict';
	
		var hasOwn = {}.hasOwnProperty;
	
		function classNames () {
			var classes = [];
	
			for (var i = 0; i < arguments.length; i++) {
				var arg = arguments[i];
				if (!arg) continue;
	
				var argType = typeof arg;
	
				if (argType === 'string' || argType === 'number') {
					classes.push(arg);
				} else if (Array.isArray(arg)) {
					classes.push(classNames.apply(null, arg));
				} else if (argType === 'object') {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				}
			}
	
			return classes.join(' ');
		}
	
		if (typeof module !== 'undefined' && module.exports) {
			module.exports = classNames;
		} else if (true) {
			// register as 'classnames', consistent with npm package name
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return classNames;
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
			window.classNames = classNames;
		}
	}());


/***/ }),
/* 562 */
/***/ (function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports.default = uuid;
	exports.reset = reset;
	// Get a universally unique identifier
	var count = 0;
	function uuid() {
	  return "react-tabs-" + count++;
	}
	
	function reset() {
	  count = 0;
	}

/***/ }),
/* 563 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.getTabsCount = getTabsCount;
	exports.getPanelsCount = getPanelsCount;
	
	var _childrenDeepMap = __webpack_require__(558);
	
	var _elementTypes = __webpack_require__(559);
	
	function getTabsCount(children) {
	  var tabCount = 0;
	  (0, _childrenDeepMap.deepForEach)(children, function (child) {
	    if ((0, _elementTypes.isTab)(child)) tabCount++;
	  });
	
	  return tabCount;
	}
	
	function getPanelsCount(children) {
	  var panelCount = 0;
	  (0, _childrenDeepMap.deepForEach)(children, function (child) {
	    if ((0, _elementTypes.isTabPanel)(child)) panelCount++;
	  });
	
	  return panelCount;
	}

/***/ }),
/* 564 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _propTypes = __webpack_require__(420);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(561);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var TabList = function (_Component) {
	  _inherits(TabList, _Component);
	
	  function TabList() {
	    _classCallCheck(this, TabList);
	
	    return _possibleConstructorReturn(this, _Component.apply(this, arguments));
	  }
	
	  TabList.prototype.render = function render() {
	    var _props = this.props,
	        children = _props.children,
	        className = _props.className,
	        attributes = _objectWithoutProperties(_props, ['children', 'className']);
	
	    return _react2.default.createElement(
	      'ul',
	      _extends({}, attributes, { className: (0, _classnames2.default)(className), role: 'tablist' }),
	      children
	    );
	  };
	
	  return TabList;
	}(_react.Component);
	
	TabList.defaultProps = {
	  className: 'react-tabs__tab-list'
	};
	exports.default = TabList;
	TabList.propTypes =  true ? {
	  children: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.array]),
	  className: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.array, _propTypes2.default.object])
	} : {};
	
	
	TabList.tabsRole = 'TabList';

/***/ }),
/* 565 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _propTypes = __webpack_require__(420);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(561);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var DEFAULT_CLASS = 'react-tabs__tab';
	
	var Tab = function (_Component) {
	  _inherits(Tab, _Component);
	
	  function Tab() {
	    _classCallCheck(this, Tab);
	
	    return _possibleConstructorReturn(this, _Component.apply(this, arguments));
	  }
	
	  Tab.prototype.componentDidMount = function componentDidMount() {
	    this.checkFocus();
	  };
	
	  Tab.prototype.componentDidUpdate = function componentDidUpdate() {
	    this.checkFocus();
	  };
	
	  Tab.prototype.checkFocus = function checkFocus() {
	    if (this.props.selected && this.props.focus) {
	      this.node.focus();
	    }
	  };
	
	  Tab.prototype.render = function render() {
	    var _cx,
	        _this2 = this;
	
	    var _props = this.props,
	        children = _props.children,
	        className = _props.className,
	        disabled = _props.disabled,
	        disabledClassName = _props.disabledClassName,
	        focus = _props.focus,
	        id = _props.id,
	        panelId = _props.panelId,
	        selected = _props.selected,
	        selectedClassName = _props.selectedClassName,
	        tabRef = _props.tabRef,
	        attributes = _objectWithoutProperties(_props, ['children', 'className', 'disabled', 'disabledClassName', 'focus', 'id', 'panelId', 'selected', 'selectedClassName', 'tabRef']);
	
	    return _react2.default.createElement(
	      'li',
	      _extends({}, attributes, {
	        className: (0, _classnames2.default)(className, (_cx = {}, _cx[selectedClassName] = selected, _cx[disabledClassName] = disabled, _cx)),
	        ref: function ref(node) {
	          _this2.node = node;
	          if (tabRef) tabRef(node);
	        },
	        role: 'tab',
	        id: id,
	        'aria-selected': selected ? 'true' : 'false',
	        'aria-disabled': disabled ? 'true' : 'false',
	        'aria-controls': panelId,
	        tabIndex: selected ? '0' : null
	      }),
	      children
	    );
	  };
	
	  return Tab;
	}(_react.Component);
	
	Tab.defaultProps = {
	  className: DEFAULT_CLASS,
	  disabledClassName: DEFAULT_CLASS + '--disabled',
	  focus: false,
	  id: null,
	  panelId: null,
	  selected: false,
	  selectedClassName: DEFAULT_CLASS + '--selected'
	};
	exports.default = Tab;
	Tab.propTypes =  true ? {
	  children: _propTypes2.default.oneOfType([_propTypes2.default.array, _propTypes2.default.object, _propTypes2.default.string]),
	  className: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.array, _propTypes2.default.object]),
	  disabled: _propTypes2.default.bool,
	  disabledClassName: _propTypes2.default.string,
	  focus: _propTypes2.default.bool, // private
	  id: _propTypes2.default.string, // private
	  panelId: _propTypes2.default.string, // private
	  selected: _propTypes2.default.bool, // private
	  selectedClassName: _propTypes2.default.string,
	  tabRef: _propTypes2.default.func // private
	} : {};
	
	
	Tab.tabsRole = 'Tab';

/***/ }),
/* 566 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _propTypes = __webpack_require__(420);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _classnames = __webpack_require__(561);
	
	var _classnames2 = _interopRequireDefault(_classnames);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var DEFAULT_CLASS = 'react-tabs__tab-panel';
	
	var TabPanel = function (_Component) {
	  _inherits(TabPanel, _Component);
	
	  function TabPanel() {
	    _classCallCheck(this, TabPanel);
	
	    return _possibleConstructorReturn(this, _Component.apply(this, arguments));
	  }
	
	  TabPanel.prototype.render = function render() {
	    var _cx;
	
	    var _props = this.props,
	        children = _props.children,
	        className = _props.className,
	        forceRender = _props.forceRender,
	        id = _props.id,
	        selected = _props.selected,
	        selectedClassName = _props.selectedClassName,
	        tabId = _props.tabId,
	        attributes = _objectWithoutProperties(_props, ['children', 'className', 'forceRender', 'id', 'selected', 'selectedClassName', 'tabId']);
	
	    return _react2.default.createElement(
	      'div',
	      _extends({}, attributes, {
	        className: (0, _classnames2.default)(className, (_cx = {}, _cx[selectedClassName] = selected, _cx)),
	        role: 'tabpanel',
	        id: id,
	        'aria-labelledby': tabId
	      }),
	      forceRender || selected ? children : null
	    );
	  };
	
	  return TabPanel;
	}(_react.Component);
	
	TabPanel.defaultProps = {
	  className: DEFAULT_CLASS,
	  forceRender: false,
	  selectedClassName: DEFAULT_CLASS + '--selected',
	  style: {}
	};
	exports.default = TabPanel;
	TabPanel.propTypes =  true ? {
	  children: _propTypes2.default.node,
	  className: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.array, _propTypes2.default.object]),
	  forceRender: _propTypes2.default.bool,
	  id: _propTypes2.default.string, // private
	  selected: _propTypes2.default.bool, // private
	  selectedClassName: _propTypes2.default.string,
	  tabId: _propTypes2.default.string // private
	} : {};
	
	
	TabPanel.tabsRole = 'TabPanel';

/***/ }),
/* 567 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(568);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(432)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(true) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept(568, function() {
				var newContent = __webpack_require__(568);
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 568 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(431)();
	// imports
	
	
	// module
	exports.push([module.id, ".react-tabs__tab-list{border-bottom:1px solid #aaa;margin:0 0 10px;padding:0}.react-tabs__tab{display:inline-block;border:1px solid transparent;border-bottom:none;bottom:-1px;position:relative;list-style:none;padding:6px 12px;cursor:pointer}.react-tabs__tab--selected{background:#fff;border-color:#aaa;color:#000;border-radius:5px 5px 0 0}.react-tabs__tab-panel{display:none}.react-tabs__tab-panel--selected{display:block}.react-tabs__tab--disabled{color:GrayText;cursor:default}.react-tabs__tab:focus{box-shadow:0 0 5px #0188fe;border-color:#0188fe;outline:none}.react-tabs__tab:focus:after{content:\"\";position:absolute;height:5px;left:-4px;right:-4px;bottom:-5px;background:#fff}", "", {"version":3,"sources":["/./node_modules/react-tabs/style/react-tabs.css"],"names":[],"mappings":"AAAA,sBACE,6BAA8B,gBACb,SACN,CACZ,iBAGC,qBAAsB,6BACQ,mBACV,YACP,kBACM,gBACF,iBACC,cACF,CACjB,2BAGC,gBAAiB,kBACE,WACN,yBACc,CAC5B,uBAGC,YAAc,CACf,iCAGC,aAAe,CAChB,2BAGC,eAAgB,cACA,CACjB,uBAGC,2BAAuC,qBACN,YACnB,CACf,6BAGC,WAAY,kBACO,WACP,UACD,WACC,YACC,eACI,CAClB","file":"react-tabs.css","sourcesContent":[".react-tabs__tab-list {\n  border-bottom: 1px solid #aaa;\n  margin: 0 0 10px;\n  padding: 0;\n}\n\n.react-tabs__tab {\n  display: inline-block;\n  border: 1px solid transparent;\n  border-bottom: none;\n  bottom: -1px;\n  position: relative;\n  list-style: none;\n  padding: 6px 12px;\n  cursor: pointer;\n}\n\n.react-tabs__tab--selected {\n  background: #fff;\n  border-color: #aaa;\n  color: black;\n  border-radius: 5px 5px 0 0;\n}\n\n.react-tabs__tab-panel {\n  display: none;\n}\n\n.react-tabs__tab-panel--selected {\n  display: block;\n}\n\n.react-tabs__tab--disabled {\n  color: GrayText;\n  cursor: default;\n}\n\n.react-tabs__tab:focus {\n  box-shadow: 0 0 5px hsl(208, 99%, 50%);\n  border-color: hsl(208, 99%, 50%);\n  outline: none;\n}\n\n.react-tabs__tab:focus:after {\n  content: \"\";\n  position: absolute;\n  height: 5px;\n  left: -4px;\n  right: -4px;\n  bottom: -5px;\n  background: #fff;\n}\n"],"sourceRoot":"webpack://"}]);
	
	// exports


/***/ }),
/* 569 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _PlayerDashboard = __webpack_require__(570);
	
	var _PlayerDashboard2 = _interopRequireDefault(_PlayerDashboard);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	  path: 'player',
	  component: _PlayerDashboard2.default
	};

/***/ }),
/* 570 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _PlayerPerformanceTrend = __webpack_require__(571);
	
	var _PlayerPerformanceTrend2 = _interopRequireDefault(_PlayerPerformanceTrend);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _PlayerPerformanceTrend2.default;

/***/ }),
/* 571 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(384);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(388);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(389);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(393);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(410);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _BarChart = __webpack_require__(572);
	
	var _BarChart2 = _interopRequireDefault(_BarChart);
	
	var _PlayerPerformanceTrend = __webpack_require__(573);
	
	var _PlayerPerformanceTrend2 = _interopRequireDefault(_PlayerPerformanceTrend);
	
	var _Dropdown = __webpack_require__(534);
	
	var _Dropdown2 = _interopRequireDefault(_Dropdown);
	
	var _lodash = __webpack_require__(275);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _Card = __webpack_require__(447);
	
	var _Card2 = _interopRequireDefault(_Card);
	
	var _reactTabs = __webpack_require__(555);
	
	var _reactRedux = __webpack_require__(418);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var PlayerPerformanceTrend = function (_React$Component) {
	  (0, _inherits3.default)(PlayerPerformanceTrend, _React$Component);
	
	  function PlayerPerformanceTrend(props) {
	    (0, _classCallCheck3.default)(this, PlayerPerformanceTrend);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (PlayerPerformanceTrend.__proto__ || (0, _getPrototypeOf2.default)(PlayerPerformanceTrend)).call(this, props));
	
	    _this.getSelectedYear = _this.getSelectedYear.bind(_this);
	    _this.getInitialState = _this.getInitialState.bind(_this);
	    _this.getSelectedPlayer = _this.getSelectedPlayer.bind(_this);
	    _this.calculateStats = _this.calculateStats.bind(_this);
	    _this.state = {
	      series: [],
	      teams: [{ 'label': 'All', value: 'All' }],
	      options: _lodash2.default.uniq(_lodash2.default.map(_this.props.matches, 'team1')),
	      seasons: _lodash2.default.uniq(_lodash2.default.map(_this.props.matches, 'season')),
	      seasonsOptions: [{ 'label': 'All', value: 'All' }],
	      uniqPlayers: [],
	      players: [{ 'label': 'None', value: 'None' }],
	      heatMapData: {
	        name: 'Average runs per season',
	        title: 'Average runs per season'
	      },
	      heatMapSeries: [],
	      allPlayers: [],
	      selectedPlayer: 'None',
	      runsBarSeries: [],
	      runsBarData: {
	        title: 'Runs Scored in every season against the team on y axis'
	      },
	      wicketBarSeries: [],
	      wicketsBarData: {
	        title: 'Wickets taken in every season against the team on y axis'
	      },
	      boundaryPercentage: 0,
	      dotsPercentage: 0,
	      dotsGivenPercentage: 0,
	      extrasGivenPercentage: 0,
	      selectedYear: 'All',
	      xAxis: [],
	      xAxisWickets: []
	    };
	    _this.mapping = {
	      2008: _this.props['2008'],
	      2009: _this.props['2009'],
	      2010: _this.props['2010'],
	      2011: _this.props['2011'],
	      2012: _this.props['2012'],
	      2013: _this.props['2013'],
	      2014: _this.props['2014'],
	      2015: _this.props['2015'],
	      2016: _this.props['2016']
	    };
	    return _this;
	  }
	
	  (0, _createClass3.default)(PlayerPerformanceTrend, [{
	    key: 'getInitialState',
	    value: function getInitialState() {
	      this.state = {
	        series: [],
	        teams: [{ 'label': 'All', value: 'All' }],
	        options: _lodash2.default.uniq(_lodash2.default.map(this.props.matches, 'team1')),
	        seasons: _lodash2.default.uniq(_lodash2.default.map(this.props.matches, 'season')),
	        seasonsOptions: [{ 'label': 'All', value: 'All' }],
	        uniqPlayers: [],
	        players: [{ 'label': 'None', value: 'None' }],
	        heatMapData: {
	          name: 'Average runs per season',
	          title: 'Average runs per season'
	        },
	        heatMapSeries: [],
	        allPlayers: [],
	        selectedPlayer: this.state.selectedPlayer ? this.state.selectedPlayer : 'None',
	        runsBarSeries: [],
	        runsBarData: {
	          title: 'Runs Scored in every season'
	        },
	        wicketBarSeries: [],
	        wicketsBarData: {
	          title: 'Wickets taken in every season'
	        },
	        boundaryPercentage: 0,
	        dotsPercentage: 0,
	        dotsGivenPercentage: 0,
	        extrasGivenPercentage: 0,
	        selectedYear: this.state.selectedYear ? this.state.selectedYear : 'All',
	        xAxis: [],
	        xAxisWickets: []
	      };
	    }
	  }, {
	    key: 'componentWillMount',
	    value: function componentWillMount() {
	      this.state.seasons.map(function (year) {
	        var uniqBatsmenInASeason = _lodash2.default.uniq(_lodash2.default.map(this.mapping[year], 'batsman'));
	        var uniqBowlersInASeason = _lodash2.default.uniq(_lodash2.default.map(this.mapping[year], 'bowler'));
	        this.state.allPlayers = uniqBatsmenInASeason.concat(uniqBowlersInASeason);
	      }, this);
	
	      this.state.uniqPlayers = _lodash2.default.uniq(this.state.allPlayers);
	
	      this.state.uniqPlayers.map(function (item) {
	        var newOption = {};
	        newOption.label = item;
	        newOption.value = item;
	        this.state.players.push(newOption);
	      }, this);
	
	      this.state.seasons.map(function (item) {
	        var newOption = {};
	        newOption.label = item;
	        newOption.value = item;
	        this.state.seasonsOptions.push(newOption);
	      }, this);
	    }
	  }, {
	    key: 'calculateStats',
	    value: function calculateStats(year, player) {
	      if (year === 'All') {
	        var selectedPlayer = player;
	        var runsBarSeries = {};
	        var boundarySeries = [];
	        var dotRuns = [];
	        var ballsFaced = [];
	        var dotsgivenArray = [];
	        var extrasGivenArray = [];
	        var totalRunsGivenArray = [];
	        var totalBowledArray = [];
	        runsBarSeries.name = 'Runs';
	        runsBarSeries.data = [];
	        this.state.seasons.map(function (year) {
	          var totalRunsMade = this.mapping[year].reduce(function (n, match) {
	            return n + (match.batsman === selectedPlayer ? parseInt(match['batsman_runs']) : 0);
	          }, 0);
	          var totalBoundries = this.mapping[year].reduce(function (n, match) {
	            return n + (match.batsman === selectedPlayer && (match['batsman_runs'] === '4' || match['batsman_runs'] === '6') ? parseInt(match['batsman_runs']) : 0);
	          }, 0);
	          var totalDots = this.mapping[year].reduce(function (n, match) {
	            return n + (match.batsman === selectedPlayer && match['batsman_runs'] === '0');
	          }, 0);
	          var totalBallsFaced = this.mapping[year].reduce(function (n, match) {
	            return n + (match.batsman === selectedPlayer);
	          }, 0);
	          var dotsGiven = this.mapping[year].reduce(function (n, match) {
	            return n + (match.bowler === selectedPlayer && match['total_runs'] === '0');
	          }, 0);
	          var totalBowled = this.mapping[year].reduce(function (n, match) {
	            return n + (match.bowler === selectedPlayer);
	          }, 0);
	          var extrasGiven = this.mapping[year].reduce(function (n, match) {
	            return n + (match.bowler === selectedPlayer && match['extra_runs'] !== '0' ? parseInt(match['extra_runs']) : 0);
	          }, 0);
	          var totalRunsGiven = this.mapping[year].reduce(function (n, match) {
	            return n + (match.bowler === selectedPlayer ? parseInt(match['total_runs']) : 0);
	          }, 0);
	          dotsgivenArray.push(dotsGiven);
	          extrasGivenArray.push(extrasGiven);
	          totalRunsGivenArray.push(totalRunsGiven);
	          totalBowledArray.push(totalBowled);
	          dotRuns.push(totalDots);
	          ballsFaced.push(totalBallsFaced);
	          boundarySeries.push(totalBoundries);
	          runsBarSeries.data.push(totalRunsMade);
	        }, this);
	
	        this.state.dotsPercentage = Math.round(_lodash2.default.sum(dotRuns) / _lodash2.default.sum(ballsFaced) * 100);
	        this.state.boundaryPercentage = Math.round(_lodash2.default.sum(boundarySeries) / _lodash2.default.sum(runsBarSeries.data) * 100);
	        this.state.extrasGivenPercentage = Math.round(_lodash2.default.sum(extrasGivenArray) / _lodash2.default.sum(totalRunsGivenArray) * 100);
	        this.state.dotsGivenPercentage = Math.round(_lodash2.default.sum(dotsgivenArray) / _lodash2.default.sum(totalBowledArray) * 100);
	        this.state.runsBarSeries.push(runsBarSeries);
	        this.state.xAxis = this.state.seasons;
	        this.state.xAxisWickets = this.state.seasons;
	
	        var wicketBarSeries = {};
	        wicketBarSeries.name = 'Wickets';
	        wicketBarSeries.data = [];
	        this.state.seasons.map(function (year) {
	          var totalWicketsTook = _lodash2.default.filter(this.mapping[year], function (match) {
	            if (match.bowler === selectedPlayer && match['player_dismissed'] && match['dismissal_kind'] !== 'run out') return match;
	          }).length;
	          wicketBarSeries.data.push(totalWicketsTook);
	        }, this);
	
	        this.state.wicketBarSeries.push(wicketBarSeries);
	      }
	      if (year !== 'All') {
	        var _selectedPlayer = player;
	        var _runsBarSeries = {};
	        var _wicketBarSeries = {};
	        _runsBarSeries.name = 'Runs';
	        _runsBarSeries.data = [];
	        _wicketBarSeries.name = 'Wickets';
	        _wicketBarSeries.data = [];
	        var matchOpponents = [];
	        var newRunsBarSeries = [];
	        var matchOpponentsBowling = [];
	        var newWicketBarSeries = [];
	        var deliveresPlayedByPlayer = _lodash2.default.filter(this.mapping[year], function (match) {
	          return match['batsman'] === _selectedPlayer;
	        });
	        var deliveresBowledByPlayer = _lodash2.default.filter(this.mapping[year], function (match) {
	          return match['bowler'] === _selectedPlayer;
	        });
	
	        _lodash2.default.map(_lodash2.default.groupBy(deliveresPlayedByPlayer, 'match_id'), function (item) {
	          matchOpponents.push(item[0]['bowling_team']);
	          var runsMadeByPlayerInMatch = item.reduce(function (n, match) {
	            return n + parseInt(match['total_runs']);
	          }, 0);
	          _runsBarSeries.data.push(runsMadeByPlayerInMatch);
	        });
	        newRunsBarSeries.push(_runsBarSeries);
	
	        _lodash2.default.map(_lodash2.default.groupBy(deliveresBowledByPlayer, 'match_id'), function (item) {
	          matchOpponentsBowling.push(item[0]['batting_team']);
	          var wicketsTakenByPlayerInMatch = _lodash2.default.filter(item, function (match) {
	            if (match['player_dismissed'] && match['dismissal_kind'] !== 'run out') {
	              return match;
	            }
	          }).length || 0;
	          _wicketBarSeries.data.push(wicketsTakenByPlayerInMatch);
	        });
	
	        newWicketBarSeries.push(_wicketBarSeries);
	
	        var totalRunsMade = this.mapping[year].reduce(function (n, match) {
	          return n + (match.batsman === _selectedPlayer ? parseInt(match['batsman_runs']) : 0);
	        }, 0);
	        var totalBoundries = this.mapping[year].reduce(function (n, match) {
	          return n + (match.batsman === _selectedPlayer && (match['batsman_runs'] === '4' || match['batsman_runs'] === '6') ? parseInt(match['batsman_runs']) : 0);
	        }, 0);
	        var totalDots = this.mapping[year].reduce(function (n, match) {
	          return n + (match.batsman === _selectedPlayer && match['batsman_runs'] === '0');
	        }, 0);
	        var totalBallsFaced = this.mapping[year].reduce(function (n, match) {
	          return n + (match.batsman === _selectedPlayer);
	        }, 0);
	        var dotsGiven = this.mapping[year].reduce(function (n, match) {
	          return n + (match.bowler === _selectedPlayer && match['total_runs'] === '0');
	        }, 0);
	        var totalBowled = this.mapping[year].reduce(function (n, match) {
	          return n + (match.bowler === _selectedPlayer);
	        }, 0);
	        var extrasGiven = this.mapping[year].reduce(function (n, match) {
	          return n + (match.bowler === _selectedPlayer && match['extra_runs'] !== '0' ? parseInt(match['extra_runs']) : 0);
	        }, 0);
	        var totalRunsGiven = this.mapping[year].reduce(function (n, match) {
	          return n + (match.bowler === _selectedPlayer ? parseInt(match['total_runs']) : 0);
	        }, 0);
	
	        this.setState({
	          dotsPercentage: Math.round(totalDots / totalBallsFaced * 100),
	          boundaryPercentage: Math.round(totalBoundries / totalRunsMade * 100),
	          extrasGivenPercentage: Math.round(extrasGiven / totalRunsGiven * 100),
	          dotsGivenPercentage: Math.round(dotsGiven / totalBowled * 100),
	          xAxis: matchOpponents,
	          xAxisWickets: matchOpponentsBowling,
	          runsBarSeries: newRunsBarSeries,
	          wicketBarSeries: newWicketBarSeries
	        });
	      }
	    }
	  }, {
	    key: 'getSelectedYear',
	    value: function getSelectedYear(item) {
	      this.setState({ selectedYear: item.target.value });
	      if (item.target.value !== 'All') {
	        this.getInitialState();
	        this.componentWillMount();
	        this.calculateStats(item.target.value, this.state.selectedPlayer);
	      } else {
	        this.getInitialState();
	        this.componentWillMount();
	        this.calculateStats('All', this.state.selectedPlayer);
	      }
	    }
	  }, {
	    key: 'getSelectedPlayer',
	    value: function getSelectedPlayer(item) {
	      this.setState({ selectedPlayer: item.target.value });
	      this.getInitialState();
	      this.componentWillMount();
	      this.calculateStats(this.state.selectedYear, item.target.value);
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      return _react2.default.createElement(
	        'div',
	        { className: _PlayerPerformanceTrend2.default.container + ' full-size' },
	        _react2.default.createElement(
	          _Card2.default,
	          { cardType: 'selector' },
	          _react2.default.createElement(
	            'div',
	            { className: _PlayerPerformanceTrend2.default.teamSelectorContainer },
	            _react2.default.createElement(
	              'div',
	              { className: _PlayerPerformanceTrend2.default.dropDownContainer },
	              _react2.default.createElement(
	                'div',
	                { className: _PlayerPerformanceTrend2.default.selectText },
	                'Select a player'
	              ),
	              _react2.default.createElement(_Dropdown2.default, { optionList: this.state.players, onChange: this.getSelectedPlayer })
	            ),
	            this.state.selectedPlayer !== 'None' && _react2.default.createElement(
	              'div',
	              { className: _PlayerPerformanceTrend2.default.dropDownContainer },
	              _react2.default.createElement(
	                'div',
	                { className: _PlayerPerformanceTrend2.default.selectText },
	                'Select an IPL season'
	              ),
	              _react2.default.createElement(_Dropdown2.default, { optionList: this.state.seasonsOptions, onChange: this.getSelectedYear })
	            )
	          )
	        ),
	        this.state.selectedPlayer !== 'None' && _react2.default.createElement(
	          'div',
	          { className: _PlayerPerformanceTrend2.default.flexAround + ' full-width' },
	          _react2.default.createElement(
	            'div',
	            { className: 'full-size' },
	            _react2.default.createElement(
	              _reactTabs.Tabs,
	              null,
	              _react2.default.createElement(
	                _reactTabs.TabList,
	                null,
	                _react2.default.createElement(
	                  _reactTabs.Tab,
	                  null,
	                  'Runs'
	                ),
	                _react2.default.createElement(
	                  _reactTabs.Tab,
	                  null,
	                  'Wickets'
	                )
	              ),
	              _react2.default.createElement(
	                _reactTabs.TabPanel,
	                null,
	                _react2.default.createElement(
	                  'div',
	                  { className: 'full-size' },
	                  _react2.default.createElement(_BarChart2.default, { container: 'runs', series: this.state.runsBarSeries,
	                    xAxis: this.state.xAxis, data: this.state.runsBarData })
	                )
	              ),
	              _react2.default.createElement(
	                _reactTabs.TabPanel,
	                null,
	                _react2.default.createElement(
	                  'div',
	                  { className: 'full-size' },
	                  _react2.default.createElement(_BarChart2.default, { container: 'wicktes', series: this.state.wicketBarSeries,
	                    xAxis: this.state.xAxisWickets, data: this.state.wicketsBarData })
	                )
	              )
	            )
	          ),
	          _react2.default.createElement(
	            'div',
	            { className: 'full-size' },
	            _react2.default.createElement(
	              'div',
	              { className: 'flex-center-xy full-width' },
	              _react2.default.createElement(
	                'div',
	                null,
	                _react2.default.createElement(
	                  'div',
	                  { className: _PlayerPerformanceTrend2.default.number },
	                  this.state.boundaryPercentage || 0,
	                  '%'
	                ),
	                _react2.default.createElement(
	                  'div',
	                  { className: _PlayerPerformanceTrend2.default.mediumText },
	                  ' Runs scores in boundaries '
	                )
	              ),
	              _react2.default.createElement(
	                'div',
	                null,
	                _react2.default.createElement(
	                  'div',
	                  { className: _PlayerPerformanceTrend2.default.number },
	                  this.state.dotsPercentage || 0,
	                  '%'
	                ),
	                _react2.default.createElement(
	                  'div',
	                  { className: _PlayerPerformanceTrend2.default.mediumText },
	                  ' Dot balls faced'
	                )
	              )
	            ),
	            _react2.default.createElement(
	              'div',
	              { className: 'flex-center-xy full-width' },
	              _react2.default.createElement(
	                'div',
	                null,
	                _react2.default.createElement(
	                  'div',
	                  { className: _PlayerPerformanceTrend2.default.number },
	                  this.state.extrasGivenPercentage || 0,
	                  '%'
	                ),
	                _react2.default.createElement(
	                  'div',
	                  { className: _PlayerPerformanceTrend2.default.mediumText },
	                  ' Extras conceded'
	                )
	              ),
	              _react2.default.createElement(
	                'div',
	                null,
	                _react2.default.createElement(
	                  'div',
	                  { className: _PlayerPerformanceTrend2.default.number },
	                  this.state.dotsGivenPercentage || 0,
	                  '%'
	                ),
	                _react2.default.createElement(
	                  'div',
	                  { className: _PlayerPerformanceTrend2.default.mediumText },
	                  'Dot balls bowled'
	                )
	              )
	            )
	          )
	        )
	      );
	    }
	  }]);
	  return PlayerPerformanceTrend;
	}(_react2.default.Component);
	
	PlayerPerformanceTrend.propTypes = {
	  params: _react2.default.PropTypes.object.isRequired
	};
	
	var mapStateToProps = function mapStateToProps(state) {
	  return {
	    matches: state.commonData.matches.data,
	    '2008': state.commonData['2008'].data,
	    '2009': state.commonData['2009'].data,
	    '2010': state.commonData['2010'].data,
	    '2011': state.commonData['2011'].data,
	    '2012': state.commonData['2012'].data,
	    '2013': state.commonData['2013'].data,
	    '2014': state.commonData['2014'].data,
	    '2015': state.commonData['2015'].data,
	    '2016': state.commonData['2016'].data
	  };
	};
	
	exports.default = (0, _reactRedux.connect)(mapStateToProps)(PlayerPerformanceTrend);

/***/ }),
/* 572 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(384);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(388);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(389);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(393);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(410);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _highcharts = __webpack_require__(530);
	
	var _highcharts2 = _interopRequireDefault(_highcharts);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var BarChart = function (_React$Component) {
	  (0, _inherits3.default)(BarChart, _React$Component);
	
	  function BarChart() {
	    var _ref;
	
	    var _temp, _this, _ret;
	
	    (0, _classCallCheck3.default)(this, BarChart);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = BarChart.__proto__ || (0, _getPrototypeOf2.default)(BarChart)).call.apply(_ref, [this].concat(args))), _this), _this.initializeChart = function (data, series, xAxis, container) {
	      _highcharts2.default.chart(container, {
	        colors: ['#616b7c'],
	        chart: {
	          type: 'bar',
	          backgroundColor: null
	        },
	        title: {
	          text: data.title
	        },
	        xAxis: {
	          categories: xAxis,
	          title: {
	            text: null
	          },
	          tickInterval: 1
	        },
	        yAxis: {
	          tickPixelInterval: 100
	        },
	        plotOptions: {
	          bar: {
	            dataLabels: {
	              enabled: true
	            }
	          }
	        },
	        credits: {
	          enabled: false
	        },
	        series: series
	      });
	    }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
	  }
	
	  (0, _createClass3.default)(BarChart, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      var _props = this.props,
	          data = _props.data,
	          series = _props.series,
	          xAxis = _props.xAxis,
	          container = _props.container;
	
	      this.initializeChart(data, series, xAxis, container);
	    }
	  }, {
	    key: 'componentDidUpdate',
	    value: function componentDidUpdate() {
	      var _props2 = this.props,
	          data = _props2.data,
	          series = _props2.series,
	          xAxis = _props2.xAxis,
	          container = _props2.container;
	
	      this.initializeChart(data, series, xAxis, container);
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      return _react2.default.createElement('div', { id: this.props.container, className: 'scroll' });
	    }
	  }]);
	  return BarChart;
	}(_react2.default.Component);
	
	BarChart.propTypes = {
	  data: _react2.default.PropTypes.object.isRequired,
	  series: _react2.default.PropTypes.array.isRequired,
	  xAxis: _react2.default.PropTypes.array,
	  container: _react2.default.PropTypes.string.isRequired
	};
	exports.default = BarChart;

/***/ }),
/* 573 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(574);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(432)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(true) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept(574, function() {
				var newContent = __webpack_require__(574);
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 574 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(431)();
	// imports
	
	
	// module
	exports.push([module.id, ".Player-Performance-Trend__container___19vpy{background-color:#def3e2}.Player-Performance-Trend__container___19vpy .performace-chart{-ms-flex-align:center;align-items:center;padding-top:10px}.Player-Performance-Trend__dropDownContainer___1Xfd6{text-align:end;padding:20px}.Player-Performance-Trend__dropDownContainer___1Xfd6,.Player-Performance-Trend__flexAround___CFxnS{display:-ms-flexbox;display:flex}.Player-Performance-Trend__flexAround___CFxnS{-ms-flex-pack:center;justify-content:center;-ms-flex-align:center;align-items:center}.Player-Performance-Trend__selectText___3IiaD{color:#fff;font-size:20px;text-align:start;padding:10px}.Player-Performance-Trend__number___2DW0z{font-size:60px;color:#172376;padding:20px;width:20vw}.Player-Performance-Trend__mediumText___2JzjG{color:#000;font-size:20px;padding:20px}@media screen and (max-width:768px){.Player-Performance-Trend__flexAround___CFxnS{display:block}.Player-Performance-Trend__number___2DW0z{font-size:50px;width:49vw}.Player-Performance-Trend__mediumText___2JzjG,.Player-Performance-Trend__selectText___3IiaD{font-size:14px}}", "", {"version":3,"sources":["/./src/components/Player-Performance-Trend/src/components/Player-Performance-Trend/Player-Performance-Trend.scss","/./src/components/Player-Performance-Trend/src/styles/variables.scss"],"names":[],"mappings":"AAEA,6CACE,wBCYyB,CDb3B,+DAIM,sBAAA,mBAAoB,gBACF,CACnB,qDAIH,eAAgB,YAEF,CACf,mGAFC,oBAAA,YAAc,CAGhB,8CAEE,qBAAA,uBAAwB,sBACxB,kBAAoB,CACrB,8CAEC,WAAa,eACG,iBACE,YACJ,CACf,0CAEC,eAAgB,cAEhB,aAAc,UACF,CACb,8CAEC,WACA,eAAgB,YACF,CACf,oCAED,8CACE,aAAe,CAChB,0CAEC,eAAgB,UACJ,CACb,4FAKC,cAAgB,CACjB,CAAA","file":"Player-Performance-Trend.scss","sourcesContent":["@import '../../styles/variables';\n\n.container {\n  background-color: $theme_light_green;\n  :global {\n    .performace-chart {\n      align-items: center;\n      padding-top: 10px;\n    }\n  }\n}\n.dropDownContainer {\n  text-align: end;\n  display: flex;\n  padding: 20px;\n}\n.flexAround{\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n.selectText {\n  color: white;\n  font-size: 20px;\n  text-align: start;\n  padding: 10px;\n}\n.number {\n  font-size: 60px;\n  color: $theme_blue;\n  padding: 20px;\n  width: 20vw;\n}\n.mediumText {\n  color: $theme_black;\n  font-size: 20px;\n  padding: 20px;\n}\n@media screen and (max-width: $mobile_breakpoint) {\n.flexAround{\n  display: block;\n}\n.number{\n  font-size: 50px;\n  width: 49vw;\n}\n.mediumText{\n  font-size: 14px;\n}\n.selectText{ \n  font-size: 14px;\n}\n}","// Color variables\n$theme_dark_red: #ca0716;\n$theme_grey_light: #e8e8e8;\n$theme_background_grey: #f8f8f8;\n$theme_white: #ffffff;\n$theme_text_grey: #606060;\n$theme_yellow:#fbff5b;\n$theme_green:#3ec654;\n$theme_black: #000000;\n$theme_red: #980411;\n$theme_orange:#F18625;\n$theme_purple:#7824EF;\n$theme_grey:#7F7F7F;\n$theme_blue:#172376;\n$theme_pink: #f9e2e3;\n$theme_light_green: #def3e2;\n\n\n//Font Size Variables\n$font-xs: 10px;\n$font-small: 12px;\n$font-medium: 15px;\n$font-large: 18px;\n\n//mobile breakpoint for css\n$mobile-breakpoint: 768px;"],"sourceRoot":"webpack://"}]);
	
	// exports
	exports.locals = {
		"container": "Player-Performance-Trend__container___19vpy",
		"dropDownContainer": "Player-Performance-Trend__dropDownContainer___1Xfd6",
		"flexAround": "Player-Performance-Trend__flexAround___CFxnS",
		"selectText": "Player-Performance-Trend__selectText___3IiaD",
		"number": "Player-Performance-Trend__number___2DW0z",
		"mediumText": "Player-Performance-Trend__mediumText___2JzjG"
	};

/***/ }),
/* 575 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _GroundDashboard = __webpack_require__(576);
	
	var _GroundDashboard2 = _interopRequireDefault(_GroundDashboard);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	  path: 'ground',
	  component: _GroundDashboard2.default
	};

/***/ }),
/* 576 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _GroundPerformanceTrend = __webpack_require__(577);
	
	var _GroundPerformanceTrend2 = _interopRequireDefault(_GroundPerformanceTrend);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _GroundPerformanceTrend2.default;

/***/ }),
/* 577 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(384);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(388);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(389);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(393);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(410);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _PieChart = __webpack_require__(578);
	
	var _PieChart2 = _interopRequireDefault(_PieChart);
	
	var _GroundPerformanceTrend = __webpack_require__(579);
	
	var _GroundPerformanceTrend2 = _interopRequireDefault(_GroundPerformanceTrend);
	
	var _Dropdown = __webpack_require__(534);
	
	var _Dropdown2 = _interopRequireDefault(_Dropdown);
	
	var _lodash = __webpack_require__(275);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _Card = __webpack_require__(447);
	
	var _Card2 = _interopRequireDefault(_Card);
	
	var _reactRedux = __webpack_require__(418);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var GroundPerformanceTrend = function (_React$Component) {
	  (0, _inherits3.default)(GroundPerformanceTrend, _React$Component);
	
	  function GroundPerformanceTrend(props) {
	    (0, _classCallCheck3.default)(this, GroundPerformanceTrend);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, (GroundPerformanceTrend.__proto__ || (0, _getPrototypeOf2.default)(GroundPerformanceTrend)).call(this, props));
	
	    _this.state = {
	      selectedGround: 'All',
	      series: [],
	      groundOptions: [{ 'label': 'All', value: 'All' }],
	      venues: _lodash2.default.uniq(_lodash2.default.map(_this.props.matches, 'venue')),
	      seasons: _lodash2.default.uniq(_lodash2.default.map(_this.props.matches, 'season')),
	      teamTrajectoryData: [],
	      pieChartData: {
	        title: '% of Matches won batting first on the ground',
	        name: 'Bat First'
	      },
	      pieChartSeriesBatFirst: [],
	      newpieChartSeriesBatFirst: []
	    };
	    _this.getSelectedGround = _this.getSelectedGround.bind(_this);
	    return _this;
	  }
	
	  (0, _createClass3.default)(GroundPerformanceTrend, [{
	    key: 'componentWillMount',
	    value: function componentWillMount() {
	      this.state.venues.map(function (item) {
	        var newOption = {};
	        newOption.label = item;
	        newOption.value = item;
	        this.state.groundOptions.push(newOption);
	      }, this);
	
	      var newOption = {};
	      newOption.name = 'Bat First Wins';
	
	      var newOptionBall = {};
	      newOptionBall.name = 'Ball First Wins';
	
	      var matchesWonBatFirst = this.props.matches.reduce(function (n, match) {
	        return n + (match.result === 'normal' && match['toss_winner'] === match['winner'] && match['toss_decision'] === 'bat' || match['toss_winner'] !== match['winner'] && match['toss_decision'] === 'field');
	      }, 0);
	
	      var totalMatches = this.props.matches.reduce(function (n, match) {
	        return n + (match.result === 'normal');
	      }, 0);
	
	      var percentage = parseInt(matchesWonBatFirst / totalMatches * 100);
	      newOption.y = percentage;
	      newOptionBall.y = 100 - percentage;
	      this.state.pieChartSeriesBatFirst.push(newOption);
	      this.state.pieChartSeriesBatFirst.push(newOptionBall);
	    }
	  }, {
	    key: 'getSelectedGround',
	    value: function getSelectedGround(item) {
	      this.setState({ selectedGround: item.target.value });
	      var newpieChartSeriesBatFirst = [];
	      if (item.target.value !== 'All') {
	        var newOption = {};
	        newOption.name = 'Bat First Wins';
	
	        var newOptionBall = {};
	        newOptionBall.name = 'Ball First Wins';
	
	        var matchesWonBatFirst = this.props.matches.reduce(function (n, match) {
	          return n + (match.venue === item.target.value && (match['toss_winner'] === match['winner'] && match['toss_decision'] === 'bat' || match['toss_winner'] !== match['winner'] && match['toss_decision'] === 'field'));
	        }, 0);
	        var totalMatches = this.props.matches.reduce(function (n, match) {
	          return n + (match.venue === item.target.value && match.result === 'normal');
	        }, 0);
	        var percentage = parseInt(matchesWonBatFirst / totalMatches * 100);
	        newOption.y = percentage;
	        newOptionBall.y = 100 - percentage;
	        newpieChartSeriesBatFirst.push(newOption);
	        newpieChartSeriesBatFirst.push(newOptionBall);
	        this.setState({ pieChartSeriesBatFirst: newpieChartSeriesBatFirst });
	      } else {
	        this.componentWillMount();
	      }
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      return _react2.default.createElement(
	        'div',
	        { className: _GroundPerformanceTrend2.default.container + ' full-size' },
	        _react2.default.createElement(
	          _Card2.default,
	          { cardType: 'selector' },
	          _react2.default.createElement(
	            'div',
	            { className: _GroundPerformanceTrend2.default.teamSelectorContainer },
	            _react2.default.createElement(
	              'div',
	              { className: _GroundPerformanceTrend2.default.dropDownContainer },
	              _react2.default.createElement(
	                'div',
	                { className: _GroundPerformanceTrend2.default.selectText },
	                'Select a cricket ground'
	              ),
	              _react2.default.createElement(_Dropdown2.default, { optionList: this.state.groundOptions, onChange: this.getSelectedGround })
	            )
	          )
	        ),
	        _react2.default.createElement(
	          'div',
	          { className: 'flex performace-chart pl1' },
	          _react2.default.createElement(_PieChart2.default, { data: this.state.pieChartData,
	            series: this.state.pieChartSeriesBatFirst, container: 'containerPie' })
	        )
	      );
	    }
	  }]);
	  return GroundPerformanceTrend;
	}(_react2.default.Component);
	
	GroundPerformanceTrend.propTypes = {
	  params: _react2.default.PropTypes.object.isRequired
	};
	
	GroundPerformanceTrend.propTypes = {
	  params: _react2.default.PropTypes.object.isRequired
	};
	
	var mapStateToProps = function mapStateToProps(state) {
	  return { matches: state.commonData.matches.data };
	};
	
	exports.default = (0, _reactRedux.connect)(mapStateToProps)(GroundPerformanceTrend);

/***/ }),
/* 578 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _getPrototypeOf = __webpack_require__(384);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _classCallCheck2 = __webpack_require__(388);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(389);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _possibleConstructorReturn2 = __webpack_require__(393);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(410);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _highcharts = __webpack_require__(530);
	
	var _highcharts2 = _interopRequireDefault(_highcharts);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var PieChart = function (_React$Component) {
	  (0, _inherits3.default)(PieChart, _React$Component);
	
	  function PieChart() {
	    var _ref;
	
	    var _temp, _this, _ret;
	
	    (0, _classCallCheck3.default)(this, PieChart);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = PieChart.__proto__ || (0, _getPrototypeOf2.default)(PieChart)).call.apply(_ref, [this].concat(args))), _this), _this.initializeChart = function (data, series, container) {
	      _highcharts2.default.chart(container, {
	        colors: ['#a82a28', '#478724'],
	        chart: {
	          plotBackgroundColor: null,
	          plotBorderWidth: null,
	          plotShadow: false,
	          type: 'pie',
	          backgroundColor: null
	        },
	        title: {
	          text: data.title
	        },
	        tooltip: {
	          pointFormat: '{series.name}: <b>{point.percentage:.1f}%</b>'
	        },
	        credits: {
	          enabled: false
	        },
	        plotOptions: {
	          pie: {
	            allowPointSelect: true,
	            cursor: 'pointer',
	            dataLabels: {
	              enabled: true,
	              format: '<b>{point.name}</b>: {point.percentage:.1f} %',
	              style: {
	                color: _highcharts2.default.theme && _highcharts2.default.theme.contrastTextColor || 'black'
	              }
	            }
	          }
	        },
	        series: [{
	          name: data.name,
	          colorByPoint: true,
	          data: series
	        }]
	      });
	    }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
	  }
	
	  (0, _createClass3.default)(PieChart, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      var _props = this.props,
	          data = _props.data,
	          series = _props.series,
	          container = _props.container;
	
	      this.initializeChart(data, series, container);
	    }
	  }, {
	    key: 'componentDidUpdate',
	    value: function componentDidUpdate() {
	      var _props2 = this.props,
	          data = _props2.data,
	          series = _props2.series,
	          container = _props2.container;
	
	      this.initializeChart(data, series, container);
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      return _react2.default.createElement('div', { id: this.props.container,
	        className: 'scroll' });
	    }
	  }]);
	  return PieChart;
	}(_react2.default.Component);
	
	PieChart.propTypes = {
	  data: _react2.default.PropTypes.object.isRequired,
	  series: _react2.default.PropTypes.array.isRequired,
	  container: _react2.default.PropTypes.string.isRequired
	};
	exports.default = PieChart;

/***/ }),
/* 579 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(580);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(432)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(true) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept(580, function() {
				var newContent = __webpack_require__(580);
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 580 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(431)();
	// imports
	
	
	// module
	exports.push([module.id, ".Ground-Performance-Trend__container___2i4Pw{background-color:#def3e2}.Ground-Performance-Trend__container___2i4Pw .performace-chart{-ms-flex-align:center;align-items:center;padding-top:10px}.Ground-Performance-Trend__selectText___2R9Z4{color:#fff;font-size:20px;text-align:start;padding:10px}.Ground-Performance-Trend__dropDownContainer___3uMAg{text-align:end;display:-ms-flexbox;display:flex;padding:40px;-ms-flex-direction:column;flex-direction:column}@media screen and (max-width:768px){.Ground-Performance-Trend__selectText___2R9Z4{font-size:14px}}", "", {"version":3,"sources":["/./src/components/Ground-Performance-Trend/src/components/Ground-Performance-Trend/Ground-Performance-Trend.scss","/./src/components/Ground-Performance-Trend/src/styles/variables.scss"],"names":[],"mappings":"AAEA,6CACE,wBCYyB,CDb3B,+DAIM,sBAAA,mBAAoB,gBACF,CACnB,8CAIH,WAAa,eACG,iBACE,YACJ,CACf,qDAEC,eAAgB,oBAChB,aAAc,aACA,0BACd,qBAAuB,CACxB,oCAED,8CACE,cAAgB,CACjB,CAAA","file":"Ground-Performance-Trend.scss","sourcesContent":["@import '../../styles/variables';\n\n.container {\n  background-color: $theme_light_green;\n  :global {\n    .performace-chart {\n      align-items: center;\n      padding-top: 10px;\n    }\n  }\n}\n.selectText {\n  color: white;\n  font-size: 20px;\n  text-align: start;\n  padding: 10px;\n}\n.dropDownContainer {\n  text-align: end;\n  display: flex;\n  padding: 40px;\n  flex-direction: column;\n}\n@media screen and (max-width: $mobile_breakpoint) {\n.selectText{ \n  font-size: 14px;\n}\n}\n","// Color variables\n$theme_dark_red: #ca0716;\n$theme_grey_light: #e8e8e8;\n$theme_background_grey: #f8f8f8;\n$theme_white: #ffffff;\n$theme_text_grey: #606060;\n$theme_yellow:#fbff5b;\n$theme_green:#3ec654;\n$theme_black: #000000;\n$theme_red: #980411;\n$theme_orange:#F18625;\n$theme_purple:#7824EF;\n$theme_grey:#7F7F7F;\n$theme_blue:#172376;\n$theme_pink: #f9e2e3;\n$theme_light_green: #def3e2;\n\n\n//Font Size Variables\n$font-xs: 10px;\n$font-small: 12px;\n$font-medium: 15px;\n$font-large: 18px;\n\n//mobile breakpoint for css\n$mobile-breakpoint: 768px;"],"sourceRoot":"webpack://"}]);
	
	// exports
	exports.locals = {
		"container": "Ground-Performance-Trend__container___2i4Pw",
		"selectText": "Ground-Performance-Trend__selectText___2R9Z4",
		"dropDownContainer": "Ground-Performance-Trend__dropDownContainer___3uMAg"
	};

/***/ }),
/* 581 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.__RewireAPI__ = exports.__ResetDependency__ = exports.__set__ = exports.__Rewire__ = exports.__GetDependency__ = exports.__get__ = exports.RedBoxError = undefined;
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _propTypes = __webpack_require__(420);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(38);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _style = __webpack_require__(582);
	
	var _style2 = _interopRequireDefault(_style);
	
	var _errorStackParser = __webpack_require__(583);
	
	var _errorStackParser2 = _interopRequireDefault(_errorStackParser);
	
	var _objectAssign = __webpack_require__(4);
	
	var _objectAssign2 = _interopRequireDefault(_objectAssign);
	
	var _lib = __webpack_require__(585);
	
	var _sourcemappedStacktrace = __webpack_require__(586);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var RedBoxError = exports.RedBoxError = function (_get__2) {
	  _inherits(RedBoxError, _get__2);
	
	  function RedBoxError(props) {
	    _classCallCheck(this, RedBoxError);
	
	    var _this = _possibleConstructorReturn(this, (RedBoxError.__proto__ || Object.getPrototypeOf(RedBoxError)).call(this, props));
	
	    _this.state = {
	      error: null,
	      mapped: false
	    };
	
	    _this.mapOnConstruction(props.error);
	    return _this;
	  }
	
	  // State is used to store the error mapped to the source map.
	
	
	  _createClass(RedBoxError, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      if (!this.state.mapped) this.mapError(this.props.error);
	    }
	
	    // Try to map the error when the component gets constructed, this is possible
	    // in some cases like evals.
	
	  }, {
	    key: 'mapOnConstruction',
	    value: function mapOnConstruction(error) {
	      var stackLines = error.stack.split('\n');
	
	      // There's no stack, only the error message.
	      if (stackLines.length < 2) {
	        this.state = { error: error, mapped: true };
	        return;
	      }
	
	      // Using the “eval” setting on webpack already gives the correct location.
	      var isWebpackEval = stackLines[1].search(/\(webpack:\/{3}/) !== -1;
	      if (isWebpackEval) {
	        // No changes are needed here.
	        this.state = { error: error, mapped: true };
	        return;
	      }
	
	      // Other eval follow a specific pattern and can be easily parsed.
	      var isEval = stackLines[1].search(/\(eval at/) !== -1;
	      if (!isEval) {
	        // mapping will be deferred until `componentDidMount`
	        this.state = { error: error, mapped: false };
	        return;
	      }
	
	      // The first line is the error message.
	      var fixedLines = [stackLines.shift()];
	      // The rest needs to be fixed.
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;
	
	      try {
	        for (var _iterator = stackLines[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var stackLine = _step.value;
	
	          var evalStackLine = stackLine.match(/(.+)\(eval at (.+) \(.+?\), .+(\:[0-9]+\:[0-9]+)\)/);
	          if (evalStackLine) {
	            var _evalStackLine = _slicedToArray(evalStackLine, 4),
	                atSomething = _evalStackLine[1],
	                file = _evalStackLine[2],
	                rowColumn = _evalStackLine[3];
	
	            fixedLines.push(atSomething + ' (' + file + rowColumn + ')');
	          } else {
	            // TODO: When stack frames of different types are detected, try to load the additional source maps
	            fixedLines.push(stackLine);
	          }
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	
	      error.stack = fixedLines.join('\n');
	      this.state = { error: error, mapped: true };
	    }
	  }, {
	    key: 'mapError',
	    value: function mapError(error) {
	      var _this2 = this;
	
	      _get__('mapStackTrace')(error.stack, function (mappedStack) {
	        error.stack = mappedStack.join('\n');
	        _this2.setState({ error: error, mapped: true });
	      });
	    }
	  }, {
	    key: 'renderFrames',
	    value: function renderFrames(frames) {
	      var _props = this.props,
	          filename = _props.filename,
	          editorScheme = _props.editorScheme,
	          useLines = _props.useLines,
	          useColumns = _props.useColumns;
	
	      var _get__3 = _get__('assign')({}, _get__('style'), this.props.style),
	          frame = _get__3.frame,
	          file = _get__3.file,
	          linkToFile = _get__3.linkToFile;
	
	      return frames.map(function (f, index) {
	        var text = void 0;
	        var url = void 0;
	
	        if (index === 0 && filename && !_get__('isFilenameAbsolute')(f.fileName)) {
	          url = _get__('makeUrl')(filename, editorScheme);
	          text = _get__('makeLinkText')(filename);
	        } else {
	          var lines = useLines ? f.lineNumber : null;
	          var columns = useColumns ? f.columnNumber : null;
	          url = _get__('makeUrl')(f.fileName, editorScheme, lines, columns);
	          text = _get__('makeLinkText')(f.fileName, lines, columns);
	        }
	
	        return _get__('React').createElement(
	          'div',
	          { style: frame, key: index },
	          _get__('React').createElement(
	            'div',
	            null,
	            f.functionName
	          ),
	          _get__('React').createElement(
	            'div',
	            { style: file },
	            _get__('React').createElement(
	              'a',
	              { href: url, style: linkToFile },
	              text
	            )
	          )
	        );
	      });
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      // The error is received as a property to initialize state.error, which may
	      // be updated when it is mapped to the source map.
	      var error = this.state.error;
	      var className = this.props.className;
	
	      var _get__4 = _get__('assign')({}, _get__('style'), this.props.style),
	          redbox = _get__4.redbox,
	          message = _get__4.message,
	          stack = _get__4.stack,
	          frame = _get__4.frame;
	
	      var frames = void 0;
	      var parseError = void 0;
	      try {
	        frames = _get__('ErrorStackParser').parse(error);
	      } catch (e) {
	        parseError = new Error('Failed to parse stack trace. Stack trace information unavailable.');
	      }
	
	      if (parseError) {
	        frames = _get__('React').createElement(
	          'div',
	          { style: frame, key: 0 },
	          _get__('React').createElement(
	            'div',
	            null,
	            parseError.message
	          )
	        );
	      } else {
	        frames = this.renderFrames(frames);
	      }
	
	      return _get__('React').createElement(
	        'div',
	        { style: redbox, className: className },
	        _get__('React').createElement(
	          'div',
	          { style: message },
	          error.name,
	          ': ',
	          error.message
	        ),
	        _get__('React').createElement(
	          'div',
	          { style: stack },
	          frames
	        )
	      );
	    }
	  }]);
	
	  return RedBoxError;
	}(_get__('Component'));
	
	// "Portal" component for actual RedBoxError component to
	// render to (directly under body). Prevents bugs as in #27.
	
	
	RedBoxError.propTypes = {
	  error: _get__('PropTypes').instanceOf(Error).isRequired,
	  filename: _get__('PropTypes').string,
	  editorScheme: _get__('PropTypes').string,
	  useLines: _get__('PropTypes').bool,
	  useColumns: _get__('PropTypes').bool,
	  style: _get__('PropTypes').object,
	  className: _get__('PropTypes').string
	};
	RedBoxError.displayName = 'RedBoxError';
	RedBoxError.defaultProps = {
	  useLines: true,
	  useColumns: true };
	
	var RedBox = function (_get__5) {
	  _inherits(RedBox, _get__5);
	
	  function RedBox() {
	    _classCallCheck(this, RedBox);
	
	    return _possibleConstructorReturn(this, (RedBox.__proto__ || Object.getPrototypeOf(RedBox)).apply(this, arguments));
	  }
	
	  _createClass(RedBox, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      this.el = document.createElement('div');
	      document.body.appendChild(this.el);
	      this.renderRedBoxError();
	    }
	  }, {
	    key: 'componentDidUpdate',
	    value: function componentDidUpdate() {
	      this.renderRedBoxError();
	    }
	  }, {
	    key: 'componentWillUnmount',
	    value: function componentWillUnmount() {
	      _get__('ReactDOM').unmountComponentAtNode(this.el);
	      document.body.removeChild(this.el);
	      this.el = null;
	    }
	  }, {
	    key: 'renderRedBoxError',
	    value: function renderRedBoxError() {
	      _get__('ReactDOM').render(_get__('React').createElement(_get__('RedBoxError'), this.props), this.el);
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      return null;
	    }
	  }]);
	
	  return RedBox;
	}(_get__('Component'));
	
	RedBox.propTypes = {
	  error: _get__('PropTypes').instanceOf(Error).isRequired
	};
	RedBox.displayName = 'RedBox';
	exports.default = RedBox;
	
	var _RewiredData__ = Object.create(null);
	
	var INTENTIONAL_UNDEFINED = '__INTENTIONAL_UNDEFINED__';
	var _RewireAPI__ = {};
	
	(function () {
	  function addPropertyToAPIObject(name, value) {
	    Object.defineProperty(_RewireAPI__, name, {
	      value: value,
	      enumerable: false,
	      configurable: true
	    });
	  }
	
	  addPropertyToAPIObject('__get__', _get__);
	  addPropertyToAPIObject('__GetDependency__', _get__);
	  addPropertyToAPIObject('__Rewire__', _set__);
	  addPropertyToAPIObject('__set__', _set__);
	  addPropertyToAPIObject('__reset__', _reset__);
	  addPropertyToAPIObject('__ResetDependency__', _reset__);
	  addPropertyToAPIObject('__with__', _with__);
	})();
	
	function _get__(variableName) {
	  if (_RewiredData__ === undefined || _RewiredData__[variableName] === undefined) {
	    return _get_original__(variableName);
	  } else {
	    var value = _RewiredData__[variableName];
	
	    if (value === INTENTIONAL_UNDEFINED) {
	      return undefined;
	    } else {
	      return value;
	    }
	  }
	}
	
	function _get_original__(variableName) {
	  switch (variableName) {
	    case 'PropTypes':
	      return _propTypes2.default;
	
	    case 'mapStackTrace':
	      return _sourcemappedStacktrace.mapStackTrace;
	
	    case 'assign':
	      return _objectAssign2.default;
	
	    case 'style':
	      return _style2.default;
	
	    case 'isFilenameAbsolute':
	      return _lib.isFilenameAbsolute;
	
	    case 'makeUrl':
	      return _lib.makeUrl;
	
	    case 'makeLinkText':
	      return _lib.makeLinkText;
	
	    case 'ErrorStackParser':
	      return _errorStackParser2.default;
	
	    case 'Component':
	      return _react.Component;
	
	    case 'ReactDOM':
	      return _reactDom2.default;
	
	    case 'React':
	      return _react2.default;
	
	    case 'RedBoxError':
	      return RedBoxError;
	  }
	
	  return undefined;
	}
	
	function _assign__(variableName, value) {
	  if (_RewiredData__ === undefined || _RewiredData__[variableName] === undefined) {
	    return _set_original__(variableName, value);
	  } else {
	    return _RewiredData__[variableName] = value;
	  }
	}
	
	function _set_original__(variableName, _value) {
	  switch (variableName) {}
	
	  return undefined;
	}
	
	function _update_operation__(operation, variableName, prefix) {
	  var oldValue = _get__(variableName);
	
	  var newValue = operation === '++' ? oldValue + 1 : oldValue - 1;
	
	  _assign__(variableName, newValue);
	
	  return prefix ? newValue : oldValue;
	}
	
	function _set__(variableName, value) {
	  if ((typeof variableName === 'undefined' ? 'undefined' : _typeof(variableName)) === 'object') {
	    Object.keys(variableName).forEach(function (name) {
	      _RewiredData__[name] = variableName[name];
	    });
	  } else {
	    if (value === undefined) {
	      _RewiredData__[variableName] = INTENTIONAL_UNDEFINED;
	    } else {
	      _RewiredData__[variableName] = value;
	    }
	
	    return function () {
	      _reset__(variableName);
	    };
	  }
	}
	
	function _reset__(variableName) {
	  delete _RewiredData__[variableName];
	}
	
	function _with__(object) {
	  var rewiredVariableNames = Object.keys(object);
	  var previousValues = {};
	
	  function reset() {
	    rewiredVariableNames.forEach(function (variableName) {
	      _RewiredData__[variableName] = previousValues[variableName];
	    });
	  }
	
	  return function (callback) {
	    rewiredVariableNames.forEach(function (variableName) {
	      previousValues[variableName] = _RewiredData__[variableName];
	      _RewiredData__[variableName] = object[variableName];
	    });
	    var result = callback();
	
	    if (!!result && typeof result.then == 'function') {
	      result.then(reset).catch(reset);
	    } else {
	      reset();
	    }
	
	    return result;
	  };
	}
	
	var _typeOfOriginalExport = typeof RedBox === 'undefined' ? 'undefined' : _typeof(RedBox);
	
	function addNonEnumerableProperty(name, value) {
	  Object.defineProperty(RedBox, name, {
	    value: value,
	    enumerable: false,
	    configurable: true
	  });
	}
	
	if ((_typeOfOriginalExport === 'object' || _typeOfOriginalExport === 'function') && Object.isExtensible(RedBox)) {
	  addNonEnumerableProperty('__get__', _get__);
	  addNonEnumerableProperty('__GetDependency__', _get__);
	  addNonEnumerableProperty('__Rewire__', _set__);
	  addNonEnumerableProperty('__set__', _set__);
	  addNonEnumerableProperty('__reset__', _reset__);
	  addNonEnumerableProperty('__ResetDependency__', _reset__);
	  addNonEnumerableProperty('__with__', _with__);
	  addNonEnumerableProperty('__RewireAPI__', _RewireAPI__);
	}
	
	exports.__get__ = _get__;
	exports.__GetDependency__ = _get__;
	exports.__Rewire__ = _set__;
	exports.__set__ = _set__;
	exports.__ResetDependency__ = _reset__;
	exports.__RewireAPI__ = _RewireAPI__;

/***/ }),
/* 582 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var _DefaultExportValue = {
	  redbox: {
	    boxSizing: 'border-box',
	    fontFamily: 'sans-serif',
	    position: 'fixed',
	    padding: 10,
	    top: '0px',
	    left: '0px',
	    bottom: '0px',
	    right: '0px',
	    width: '100%',
	    background: 'rgb(204, 0, 0)',
	    color: 'white',
	    zIndex: 2147483647,
	    textAlign: 'left',
	    fontSize: '16px',
	    lineHeight: 1.2,
	    overflow: 'auto'
	  },
	  message: {
	    fontWeight: 'bold'
	  },
	  stack: {
	    fontFamily: 'monospace',
	    marginTop: '2em'
	  },
	  frame: {
	    marginTop: '1em'
	  },
	  file: {
	    fontSize: '0.8em',
	    color: 'rgba(255, 255, 255, 0.7)'
	  },
	  linkToFile: {
	    textDecoration: 'none',
	    color: 'rgba(255, 255, 255, 0.7)'
	  }
	};
	exports.default = _DefaultExportValue;

/***/ }),
/* 583 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
	    'use strict';
	    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.
	
	    /* istanbul ignore next */
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(584)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('stackframe'));
	    } else {
	        root.ErrorStackParser = factory(root.StackFrame);
	    }
	}(this, function ErrorStackParser(StackFrame) {
	    'use strict';
	
	    var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+\:\d+/;
	    var CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+\:\d+|\(native\))/m;
	    var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code\])?$/;
	
	    function _map(array, fn, thisArg) {
	        if (typeof Array.prototype.map === 'function') {
	            return array.map(fn, thisArg);
	        } else {
	            var output = new Array(array.length);
	            for (var i = 0; i < array.length; i++) {
	                output[i] = fn.call(thisArg, array[i]);
	            }
	            return output;
	        }
	    }
	
	    function _filter(array, fn, thisArg) {
	        if (typeof Array.prototype.filter === 'function') {
	            return array.filter(fn, thisArg);
	        } else {
	            var output = [];
	            for (var i = 0; i < array.length; i++) {
	                if (fn.call(thisArg, array[i])) {
	                    output.push(array[i]);
	                }
	            }
	            return output;
	        }
	    }
	
	    function _indexOf(array, target) {
	        if (typeof Array.prototype.indexOf === 'function') {
	            return array.indexOf(target);
	        } else {
	            for (var i = 0; i < array.length; i++) {
	                if (array[i] === target) {
	                    return i;
	                }
	            }
	            return -1;
	        }
	    }
	
	    return {
	        /**
	         * Given an Error object, extract the most information from it.
	         *
	         * @param {Error} error object
	         * @return {Array} of StackFrames
	         */
	        parse: function ErrorStackParser$$parse(error) {
	            if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {
	                return this.parseOpera(error);
	            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {
	                return this.parseV8OrIE(error);
	            } else if (error.stack) {
	                return this.parseFFOrSafari(error);
	            } else {
	                throw new Error('Cannot parse given Error object');
	            }
	        },
	
	        // Separate line and column numbers from a string of the form: (URI:Line:Column)
	        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {
	            // Fail-fast but return locations like "(native)"
	            if (urlLike.indexOf(':') === -1) {
	                return [urlLike];
	            }
	
	            var regExp = /(.+?)(?:\:(\d+))?(?:\:(\d+))?$/;
	            var parts = regExp.exec(urlLike.replace(/[\(\)]/g, ''));
	            return [parts[1], parts[2] || undefined, parts[3] || undefined];
	        },
	
	        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {
	            var filtered = _filter(error.stack.split('\n'), function(line) {
	                return !!line.match(CHROME_IE_STACK_REGEXP);
	            }, this);
	
	            return _map(filtered, function(line) {
	                if (line.indexOf('(eval ') > -1) {
	                    // Throw away eval information until we implement stacktrace.js/stackframe#8
	                    line = line.replace(/eval code/g, 'eval').replace(/(\(eval at [^\()]*)|(\)\,.*$)/g, '');
	                }
	                var tokens = line.replace(/^\s+/, '').replace(/\(eval code/g, '(').split(/\s+/).slice(1);
	                var locationParts = this.extractLocation(tokens.pop());
	                var functionName = tokens.join(' ') || undefined;
	                var fileName = _indexOf(['eval', '<anonymous>'], locationParts[0]) > -1 ? undefined : locationParts[0];
	
	                return new StackFrame(functionName, undefined, fileName, locationParts[1], locationParts[2], line);
	            }, this);
	        },
	
	        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {
	            var filtered = _filter(error.stack.split('\n'), function(line) {
	                return !line.match(SAFARI_NATIVE_CODE_REGEXP);
	            }, this);
	
	            return _map(filtered, function(line) {
	                // Throw away eval information until we implement stacktrace.js/stackframe#8
	                if (line.indexOf(' > eval') > -1) {
	                    line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval\:\d+\:\d+/g, ':$1');
	                }
	
	                if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {
	                    // Safari eval frames only have function names and nothing else
	                    return new StackFrame(line);
	                } else {
	                    var tokens = line.split('@');
	                    var locationParts = this.extractLocation(tokens.pop());
	                    var functionName = tokens.join('@') || undefined;
	                    return new StackFrame(functionName,
	                        undefined,
	                        locationParts[0],
	                        locationParts[1],
	                        locationParts[2],
	                        line);
	                }
	            }, this);
	        },
	
	        parseOpera: function ErrorStackParser$$parseOpera(e) {
	            if (!e.stacktrace || (e.message.indexOf('\n') > -1 &&
	                e.message.split('\n').length > e.stacktrace.split('\n').length)) {
	                return this.parseOpera9(e);
	            } else if (!e.stack) {
	                return this.parseOpera10(e);
	            } else {
	                return this.parseOpera11(e);
	            }
	        },
	
	        parseOpera9: function ErrorStackParser$$parseOpera9(e) {
	            var lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
	            var lines = e.message.split('\n');
	            var result = [];
	
	            for (var i = 2, len = lines.length; i < len; i += 2) {
	                var match = lineRE.exec(lines[i]);
	                if (match) {
	                    result.push(new StackFrame(undefined, undefined, match[2], match[1], undefined, lines[i]));
	                }
	            }
	
	            return result;
	        },
	
	        parseOpera10: function ErrorStackParser$$parseOpera10(e) {
	            var lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
	            var lines = e.stacktrace.split('\n');
	            var result = [];
	
	            for (var i = 0, len = lines.length; i < len; i += 2) {
	                var match = lineRE.exec(lines[i]);
	                if (match) {
	                    result.push(
	                        new StackFrame(
	                            match[3] || undefined,
	                            undefined,
	                            match[2],
	                            match[1],
	                            undefined,
	                            lines[i]
	                        )
	                    );
	                }
	            }
	
	            return result;
	        },
	
	        // Opera 10.65+ Error.stack very similar to FF/Safari
	        parseOpera11: function ErrorStackParser$$parseOpera11(error) {
	            var filtered = _filter(error.stack.split('\n'), function(line) {
	                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
	            }, this);
	
	            return _map(filtered, function(line) {
	                var tokens = line.split('@');
	                var locationParts = this.extractLocation(tokens.pop());
	                var functionCall = (tokens.shift() || '');
	                var functionName = functionCall
	                        .replace(/<anonymous function(: (\w+))?>/, '$2')
	                        .replace(/\([^\)]*\)/g, '') || undefined;
	                var argsRaw;
	                if (functionCall.match(/\(([^\)]*)\)/)) {
	                    argsRaw = functionCall.replace(/^[^\(]+\(([^\)]*)\)$/, '$1');
	                }
	                var args = (argsRaw === undefined || argsRaw === '[arguments not available]') ?
	                    undefined : argsRaw.split(',');
	                return new StackFrame(
	                    functionName,
	                    args,
	                    locationParts[0],
	                    locationParts[1],
	                    locationParts[2],
	                    line);
	            }, this);
	        }
	    };
	}));
	


/***/ }),
/* 584 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
	    'use strict';
	    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.
	
	    /* istanbul ignore next */
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports === 'object') {
	        module.exports = factory();
	    } else {
	        root.StackFrame = factory();
	    }
	}(this, function () {
	    'use strict';
	    function _isNumber(n) {
	        return !isNaN(parseFloat(n)) && isFinite(n);
	    }
	
	    function StackFrame(functionName, args, fileName, lineNumber, columnNumber, source) {
	        if (functionName !== undefined) {
	            this.setFunctionName(functionName);
	        }
	        if (args !== undefined) {
	            this.setArgs(args);
	        }
	        if (fileName !== undefined) {
	            this.setFileName(fileName);
	        }
	        if (lineNumber !== undefined) {
	            this.setLineNumber(lineNumber);
	        }
	        if (columnNumber !== undefined) {
	            this.setColumnNumber(columnNumber);
	        }
	        if (source !== undefined) {
	            this.setSource(source);
	        }
	    }
	
	    StackFrame.prototype = {
	        getFunctionName: function () {
	            return this.functionName;
	        },
	        setFunctionName: function (v) {
	            this.functionName = String(v);
	        },
	
	        getArgs: function () {
	            return this.args;
	        },
	        setArgs: function (v) {
	            if (Object.prototype.toString.call(v) !== '[object Array]') {
	                throw new TypeError('Args must be an Array');
	            }
	            this.args = v;
	        },
	
	        // NOTE: Property name may be misleading as it includes the path,
	        // but it somewhat mirrors V8's JavaScriptStackTraceApi
	        // https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi and Gecko's
	        // http://mxr.mozilla.org/mozilla-central/source/xpcom/base/nsIException.idl#14
	        getFileName: function () {
	            return this.fileName;
	        },
	        setFileName: function (v) {
	            this.fileName = String(v);
	        },
	
	        getLineNumber: function () {
	            return this.lineNumber;
	        },
	        setLineNumber: function (v) {
	            if (!_isNumber(v)) {
	                throw new TypeError('Line Number must be a Number');
	            }
	            this.lineNumber = Number(v);
	        },
	
	        getColumnNumber: function () {
	            return this.columnNumber;
	        },
	        setColumnNumber: function (v) {
	            if (!_isNumber(v)) {
	                throw new TypeError('Column Number must be a Number');
	            }
	            this.columnNumber = Number(v);
	        },
	
	        getSource: function () {
	            return this.source;
	        },
	        setSource: function (v) {
	            this.source = String(v);
	        },
	
	        toString: function() {
	            var functionName = this.getFunctionName() || '{anonymous}';
	            var args = '(' + (this.getArgs() || []).join(',') + ')';
	            var fileName = this.getFileName() ? ('@' + this.getFileName()) : '';
	            var lineNumber = _isNumber(this.getLineNumber()) ? (':' + this.getLineNumber()) : '';
	            var columnNumber = _isNumber(this.getColumnNumber()) ? (':' + this.getColumnNumber()) : '';
	            return functionName + args + fileName + lineNumber + columnNumber;
	        }
	    };
	
	    return StackFrame;
	}));


/***/ }),
/* 585 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var filenameWithoutLoaders = exports.filenameWithoutLoaders = function filenameWithoutLoaders() {
	  var filename = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	
	  var index = filename.lastIndexOf('!');
	
	  return index < 0 ? filename : filename.substr(index + 1);
	};
	
	var filenameHasLoaders = exports.filenameHasLoaders = function filenameHasLoaders(filename) {
	  var actualFilename = _get__('filenameWithoutLoaders')(filename);
	
	  return actualFilename !== filename;
	};
	
	var filenameHasSchema = exports.filenameHasSchema = function filenameHasSchema(filename) {
	  return (/^[\w]+\:/.test(filename)
	  );
	};
	
	var isFilenameAbsolute = exports.isFilenameAbsolute = function isFilenameAbsolute(filename) {
	  var actualFilename = _get__('filenameWithoutLoaders')(filename);
	
	  if (actualFilename.indexOf('/') === 0) {
	    return true;
	  }
	
	  return false;
	};
	
	var makeUrl = exports.makeUrl = function makeUrl(filename, scheme, line, column) {
	  var actualFilename = _get__('filenameWithoutLoaders')(filename);
	
	  if (_get__('filenameHasSchema')(filename)) {
	    return actualFilename;
	  }
	
	  var url = 'file://' + actualFilename;
	
	  if (scheme) {
	    url = scheme + '://open?url=' + url;
	
	    if (line && actualFilename === filename) {
	      url = url + '&line=' + line;
	
	      if (column) {
	        url = url + '&column=' + column;
	      }
	    }
	  }
	
	  return url;
	};
	
	var makeLinkText = exports.makeLinkText = function makeLinkText(filename, line, column) {
	  var text = _get__('filenameWithoutLoaders')(filename);
	
	  if (line && text === filename) {
	    text = text + ':' + line;
	
	    if (column) {
	      text = text + ':' + column;
	    }
	  }
	
	  return text;
	};
	
	var _RewiredData__ = Object.create(null);
	
	var INTENTIONAL_UNDEFINED = '__INTENTIONAL_UNDEFINED__';
	var _RewireAPI__ = {};
	
	(function () {
	  function addPropertyToAPIObject(name, value) {
	    Object.defineProperty(_RewireAPI__, name, {
	      value: value,
	      enumerable: false,
	      configurable: true
	    });
	  }
	
	  addPropertyToAPIObject('__get__', _get__);
	  addPropertyToAPIObject('__GetDependency__', _get__);
	  addPropertyToAPIObject('__Rewire__', _set__);
	  addPropertyToAPIObject('__set__', _set__);
	  addPropertyToAPIObject('__reset__', _reset__);
	  addPropertyToAPIObject('__ResetDependency__', _reset__);
	  addPropertyToAPIObject('__with__', _with__);
	})();
	
	function _get__(variableName) {
	  if (_RewiredData__ === undefined || _RewiredData__[variableName] === undefined) {
	    return _get_original__(variableName);
	  } else {
	    var value = _RewiredData__[variableName];
	
	    if (value === INTENTIONAL_UNDEFINED) {
	      return undefined;
	    } else {
	      return value;
	    }
	  }
	}
	
	function _get_original__(variableName) {
	  switch (variableName) {
	    case 'filenameWithoutLoaders':
	      return filenameWithoutLoaders;
	
	    case 'filenameHasSchema':
	      return filenameHasSchema;
	  }
	
	  return undefined;
	}
	
	function _assign__(variableName, value) {
	  if (_RewiredData__ === undefined || _RewiredData__[variableName] === undefined) {
	    return _set_original__(variableName, value);
	  } else {
	    return _RewiredData__[variableName] = value;
	  }
	}
	
	function _set_original__(variableName, _value) {
	  switch (variableName) {}
	
	  return undefined;
	}
	
	function _update_operation__(operation, variableName, prefix) {
	  var oldValue = _get__(variableName);
	
	  var newValue = operation === '++' ? oldValue + 1 : oldValue - 1;
	
	  _assign__(variableName, newValue);
	
	  return prefix ? newValue : oldValue;
	}
	
	function _set__(variableName, value) {
	  if ((typeof variableName === 'undefined' ? 'undefined' : _typeof(variableName)) === 'object') {
	    Object.keys(variableName).forEach(function (name) {
	      _RewiredData__[name] = variableName[name];
	    });
	  } else {
	    if (value === undefined) {
	      _RewiredData__[variableName] = INTENTIONAL_UNDEFINED;
	    } else {
	      _RewiredData__[variableName] = value;
	    }
	
	    return function () {
	      _reset__(variableName);
	    };
	  }
	}
	
	function _reset__(variableName) {
	  delete _RewiredData__[variableName];
	}
	
	function _with__(object) {
	  var rewiredVariableNames = Object.keys(object);
	  var previousValues = {};
	
	  function reset() {
	    rewiredVariableNames.forEach(function (variableName) {
	      _RewiredData__[variableName] = previousValues[variableName];
	    });
	  }
	
	  return function (callback) {
	    rewiredVariableNames.forEach(function (variableName) {
	      previousValues[variableName] = _RewiredData__[variableName];
	      _RewiredData__[variableName] = object[variableName];
	    });
	    var result = callback();
	
	    if (!!result && typeof result.then == 'function') {
	      result.then(reset).catch(reset);
	    } else {
	      reset();
	    }
	
	    return result;
	  };
	}
	
	exports.__get__ = _get__;
	exports.__GetDependency__ = _get__;
	exports.__Rewire__ = _set__;
	exports.__set__ = _set__;
	exports.__ResetDependency__ = _reset__;
	exports.__RewireAPI__ = _RewireAPI__;
	exports.default = _RewireAPI__;

/***/ }),
/* 586 */
/***/ (function(module, exports, __webpack_require__) {

	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory();
		else if(typeof define === 'function' && define.amd)
			define([], factory);
		else if(typeof exports === 'object')
			exports["sourceMappedStackTrace"] = factory();
		else
			root["sourceMappedStackTrace"] = factory();
	})(this, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	
	
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {
	
		var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
		 * sourcemapped-stacktrace.js
		 * created by James Salter <iteration@gmail.com> (2014)
		 *
		 * https://github.com/novocaine/sourcemapped-stacktrace
		 *
		 * Licensed under the New BSD license. See LICENSE or:
		 * http://opensource.org/licenses/BSD-3-Clause
		 */
	
		/*global define */
	
		// note we only include source-map-consumer, not the whole source-map library,
		// which includes gear for generating source maps that we don't need
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function(source_map_consumer) {
	
		  var global_mapForUri = {};
	
		  /**
		   * Re-map entries in a stacktrace using sourcemaps if available.
		   *
		   * @param {Array} stack - Array of strings from the browser's stack
		   *                        representation. Currently only Chrome
		   *                        format is supported.
		   * @param {function} done - Callback invoked with the transformed stacktrace
		   *                          (an Array of Strings) passed as the first
		   *                          argument
		   * @param {Object} [opts] - Optional options object.
		   * @param {Function} [opts.filter] - Filter function applied to each stackTrace line.
		   *                                   Lines which do not pass the filter won't be processesd.
		   * @param {boolean} [opts.cacheGlobally] - Whether to cache sourcemaps globally across multiple calls.
		   */
		  var mapStackTrace = function(stack, done, opts) {
		    var lines;
		    var line;
		    var mapForUri = {};
		    var rows = {};
		    var fields;
		    var uri;
		    var expected_fields;
		    var regex;
	
		    var fetcher = new Fetcher(function() {
		      var result = processSourceMaps(lines, rows, fetcher.mapForUri);
		      done(result);
		    }, opts);
	
		    if (isChromeOrEdge() || isIE11Plus()) {
		      regex = /^ +at.+\((.*):([0-9]+):([0-9]+)/;
		      expected_fields = 4;
		      // (skip first line containing exception message)
		      skip_lines = 1;
		    } else if (isFirefox() || isSafari()) {
		      regex = /@(.*):([0-9]+):([0-9]+)/;
		      expected_fields = 4;
		      skip_lines = 0;
		    } else {
		      throw new Error("unknown browser :(");
		    }
	
		    lines = stack.split("\n").slice(skip_lines);
	
		    for (var i=0; i < lines.length; i++) {
		      line = lines[i];
		      if ( opts && opts.filter && !opts.filter(line) ) continue;
		      
		      fields = line.match(regex);
		      if (fields && fields.length === expected_fields) {
		        rows[i] = fields;
		        uri = fields[1];
		        if (!uri.match(/<anonymous>/)) {
		          fetcher.fetchScript(uri);
		        }
		      }
		    }
	
		    // if opts.cacheGlobally set, all maps could have been cached already,
		    // thus we need to call done callback right away
		    if ( fetcher.sem === 0 ) {
		      fetcher.done(fetcher.mapForUri);
		    }
		  };
	
		  var isChromeOrEdge = function() {
		    return navigator.userAgent.toLowerCase().indexOf('chrome') > -1;
		  };
	
		  var isFirefox = function() {
		    return navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
		  };  
	
		  var isSafari = function() {
		    return navigator.userAgent.toLowerCase().indexOf('safari') > -1;
		  };
				
		  var isIE11Plus = function() {
		   	return document.documentMode && document.documentMode >= 11;
		  };
	
		  var Fetcher = function(done, opts) {
		    this.sem = 0;
		    this.mapForUri = opts && opts.cacheGlobally ? global_mapForUri : {};
		    this.done = done;
		  };
	
		  Fetcher.prototype.fetchScript = function(uri) {
		    if (!(uri in this.mapForUri)) {
		      this.sem++;
		      this.mapForUri[uri] = null;
		    } else {
		      return;
		    }
	
		    var xhr = createXMLHTTPObject();
		    var that = this;
		    xhr.onreadystatechange = function(e) {
		      that.onScriptLoad.call(that, e, uri);
		    };
		    xhr.open("GET", uri, true);
		    xhr.send();
		  };
	
		  var absUrlRegex = new RegExp('^(?:[a-z]+:)?//', 'i');
	
		  Fetcher.prototype.onScriptLoad = function(e, uri) {
		    if (e.target.readyState !== 4) {
		      return;
		    }
	
		    if (e.target.status === 200 ||
		      (uri.slice(0, 7) === "file://" && e.target.status === 0))
		    {
		      // find .map in file.
		      //
		      // attempt to find it at the very end of the file, but tolerate trailing
		      // whitespace inserted by some packers.
		      var match = e.target.responseText.match("//# [s]ourceMappingURL=(.*)[\\s]*$", "m");
		      if (match && match.length === 2) {
		        // get the map
		        var mapUri = match[1];
	
		        var embeddedSourceMap = mapUri.match("data:application/json;(charset=[^;]+;)?base64,(.*)");
	
		        if (embeddedSourceMap && embeddedSourceMap[2]) {
		          this.mapForUri[uri] = new source_map_consumer.SourceMapConsumer(atob(embeddedSourceMap[2]));
		          this.done(this.mapForUri);
		        } else {
		          if (!absUrlRegex.test(mapUri)) {
		            // relative url; according to sourcemaps spec is 'source origin'
		            var origin;
		            var lastSlash = uri.lastIndexOf('/');
		            if (lastSlash !== -1) {
		              origin = uri.slice(0, lastSlash + 1);
		              mapUri = origin + mapUri;
		              // note if lastSlash === -1, actual script uri has no slash
		              // somehow, so no way to use it as a prefix... we give up and try
		              // as absolute
		            }
		          }
	
		          var xhrMap = createXMLHTTPObject();
		          var that = this;
		          xhrMap.onreadystatechange = function() {
		            if (xhrMap.readyState === 4) {
		              that.sem--;
		              if (xhrMap.status === 200 ||
		                (mapUri.slice(0, 7) === "file://" && xhrMap.status === 0)) {
		                that.mapForUri[uri] = new source_map_consumer.SourceMapConsumer(xhrMap.responseText);
		              }
		              if (that.sem === 0) {
		                that.done(that.mapForUri);
		              }
		            }
		          };
	
		          xhrMap.open("GET", mapUri, true);
		          xhrMap.send();
		        }
		      } else {
		        // no map
		        this.sem--;
		      }
		    } else {
		      // HTTP error fetching uri of the script
		      this.sem--;
		    }
	
		    if (this.sem === 0) {
		      this.done(this.mapForUri);
		    }
		  };
	
		  var processSourceMaps = function(lines, rows, mapForUri) {
		    var result = [];
		    var map;
		    for (var i=0; i < lines.length; i++) {
		      var row = rows[i];
		      if (row) {
		        var uri = row[1];
		        var line = parseInt(row[2], 10);
		        var column = parseInt(row[3], 10);
		        map = mapForUri[uri];
	
		        if (map) {
		          // we think we have a map for that uri. call source-map library
		          var origPos = map.originalPositionFor(
		            { line: line, column: column });
		          result.push(formatOriginalPosition(origPos.source,
		            origPos.line, origPos.column, origPos.name || origName(lines[i])));
		        } else {
		          // we can't find a map for that url, but we parsed the row.
		          // reformat unchanged line for consistency with the sourcemapped
		          // lines.
		          result.push(formatOriginalPosition(uri, line, column, origName(lines[i])));
		        }
		      } else {
		        // we weren't able to parse the row, push back what we were given
		        result.push(lines[i]);
		      }
		    }
	
		    return result;
		  };
	
		  function origName(origLine) {
		    var match = String(origLine).match((isChromeOrEdge() || isIE11Plus()) ?
		      / +at +([^ ]*).*/ :
		      /([^@]*)@.*/);
		    return match && match[1];
		  }
	
		  var formatOriginalPosition = function(source, line, column, name) {
		    // mimic chrome's format
		    return "    at " + (name ? name : "(unknown)") +
		      " (" + source + ":" + line + ":" + column + ")";
		  };
	
		  // xmlhttprequest boilerplate
		  var XMLHttpFactories = [
			function () {return new XMLHttpRequest();},
			function () {return new ActiveXObject("Msxml2.XMLHTTP");},
			function () {return new ActiveXObject("Msxml3.XMLHTTP");},
			function () {return new ActiveXObject("Microsoft.XMLHTTP");}
		  ];
	
		  function createXMLHTTPObject() {
		      var xmlhttp = false;
		      for (var i=0;i<XMLHttpFactories.length;i++) {
		          try {
		              xmlhttp = XMLHttpFactories[i]();
		          }
		          catch (e) {
		              continue;
		          }
		          break;
		      }
		      return xmlhttp;
		  }
	
		  return {
		    mapStackTrace: mapStackTrace
		  }
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	
	
	/***/ },
	/* 1 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* -*- Mode: js; js-indent-level: 2; -*- */
		/*
		 * Copyright 2011 Mozilla Foundation and contributors
		 * Licensed under the New BSD license. See LICENSE or:
		 * http://opensource.org/licenses/BSD-3-Clause
		 */
	
		var util = __webpack_require__(2);
		var binarySearch = __webpack_require__(3);
		var ArraySet = __webpack_require__(4).ArraySet;
		var base64VLQ = __webpack_require__(5);
		var quickSort = __webpack_require__(7).quickSort;
	
		function SourceMapConsumer(aSourceMap) {
		  var sourceMap = aSourceMap;
		  if (typeof aSourceMap === 'string') {
		    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
		  }
	
		  return sourceMap.sections != null
		    ? new IndexedSourceMapConsumer(sourceMap)
		    : new BasicSourceMapConsumer(sourceMap);
		}
	
		SourceMapConsumer.fromSourceMap = function(aSourceMap) {
		  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
		}
	
		/**
		 * The version of the source mapping spec that we are consuming.
		 */
		SourceMapConsumer.prototype._version = 3;
	
		// `__generatedMappings` and `__originalMappings` are arrays that hold the
		// parsed mapping coordinates from the source map's "mappings" attribute. They
		// are lazily instantiated, accessed via the `_generatedMappings` and
		// `_originalMappings` getters respectively, and we only parse the mappings
		// and create these arrays once queried for a source location. We jump through
		// these hoops because there can be many thousands of mappings, and parsing
		// them is expensive, so we only want to do it if we must.
		//
		// Each object in the arrays is of the form:
		//
		//     {
		//       generatedLine: The line number in the generated code,
		//       generatedColumn: The column number in the generated code,
		//       source: The path to the original source file that generated this
		//               chunk of code,
		//       originalLine: The line number in the original source that
		//                     corresponds to this chunk of generated code,
		//       originalColumn: The column number in the original source that
		//                       corresponds to this chunk of generated code,
		//       name: The name of the original symbol which generated this chunk of
		//             code.
		//     }
		//
		// All properties except for `generatedLine` and `generatedColumn` can be
		// `null`.
		//
		// `_generatedMappings` is ordered by the generated positions.
		//
		// `_originalMappings` is ordered by the original positions.
	
		SourceMapConsumer.prototype.__generatedMappings = null;
		Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
		  get: function () {
		    if (!this.__generatedMappings) {
		      this._parseMappings(this._mappings, this.sourceRoot);
		    }
	
		    return this.__generatedMappings;
		  }
		});
	
		SourceMapConsumer.prototype.__originalMappings = null;
		Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
		  get: function () {
		    if (!this.__originalMappings) {
		      this._parseMappings(this._mappings, this.sourceRoot);
		    }
	
		    return this.__originalMappings;
		  }
		});
	
		SourceMapConsumer.prototype._charIsMappingSeparator =
		  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
		    var c = aStr.charAt(index);
		    return c === ";" || c === ",";
		  };
	
		/**
		 * Parse the mappings in a string in to a data structure which we can easily
		 * query (the ordered arrays in the `this.__generatedMappings` and
		 * `this.__originalMappings` properties).
		 */
		SourceMapConsumer.prototype._parseMappings =
		  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
		    throw new Error("Subclasses must implement _parseMappings");
		  };
	
		SourceMapConsumer.GENERATED_ORDER = 1;
		SourceMapConsumer.ORIGINAL_ORDER = 2;
	
		SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
		SourceMapConsumer.LEAST_UPPER_BOUND = 2;
	
		/**
		 * Iterate over each mapping between an original source/line/column and a
		 * generated line/column in this source map.
		 *
		 * @param Function aCallback
		 *        The function that is called with each mapping.
		 * @param Object aContext
		 *        Optional. If specified, this object will be the value of `this` every
		 *        time that `aCallback` is called.
		 * @param aOrder
		 *        Either `SourceMapConsumer.GENERATED_ORDER` or
		 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
		 *        iterate over the mappings sorted by the generated file's line/column
		 *        order or the original's source/line/column order, respectively. Defaults to
		 *        `SourceMapConsumer.GENERATED_ORDER`.
		 */
		SourceMapConsumer.prototype.eachMapping =
		  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
		    var context = aContext || null;
		    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
	
		    var mappings;
		    switch (order) {
		    case SourceMapConsumer.GENERATED_ORDER:
		      mappings = this._generatedMappings;
		      break;
		    case SourceMapConsumer.ORIGINAL_ORDER:
		      mappings = this._originalMappings;
		      break;
		    default:
		      throw new Error("Unknown order of iteration.");
		    }
	
		    var sourceRoot = this.sourceRoot;
		    mappings.map(function (mapping) {
		      var source = mapping.source === null ? null : this._sources.at(mapping.source);
		      if (source != null && sourceRoot != null) {
		        source = util.join(sourceRoot, source);
		      }
		      return {
		        source: source,
		        generatedLine: mapping.generatedLine,
		        generatedColumn: mapping.generatedColumn,
		        originalLine: mapping.originalLine,
		        originalColumn: mapping.originalColumn,
		        name: mapping.name === null ? null : this._names.at(mapping.name)
		      };
		    }, this).forEach(aCallback, context);
		  };
	
		/**
		 * Returns all generated line and column information for the original source,
		 * line, and column provided. If no column is provided, returns all mappings
		 * corresponding to a either the line we are searching for or the next
		 * closest line that has any mappings. Otherwise, returns all mappings
		 * corresponding to the given line and either the column we are searching for
		 * or the next closest column that has any offsets.
		 *
		 * The only argument is an object with the following properties:
		 *
		 *   - source: The filename of the original source.
		 *   - line: The line number in the original source.
		 *   - column: Optional. the column number in the original source.
		 *
		 * and an array of objects is returned, each with the following properties:
		 *
		 *   - line: The line number in the generated source, or null.
		 *   - column: The column number in the generated source, or null.
		 */
		SourceMapConsumer.prototype.allGeneratedPositionsFor =
		  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
		    var line = util.getArg(aArgs, 'line');
	
		    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
		    // returns the index of the closest mapping less than the needle. By
		    // setting needle.originalColumn to 0, we thus find the last mapping for
		    // the given line, provided such a mapping exists.
		    var needle = {
		      source: util.getArg(aArgs, 'source'),
		      originalLine: line,
		      originalColumn: util.getArg(aArgs, 'column', 0)
		    };
	
		    if (this.sourceRoot != null) {
		      needle.source = util.relative(this.sourceRoot, needle.source);
		    }
		    if (!this._sources.has(needle.source)) {
		      return [];
		    }
		    needle.source = this._sources.indexOf(needle.source);
	
		    var mappings = [];
	
		    var index = this._findMapping(needle,
		                                  this._originalMappings,
		                                  "originalLine",
		                                  "originalColumn",
		                                  util.compareByOriginalPositions,
		                                  binarySearch.LEAST_UPPER_BOUND);
		    if (index >= 0) {
		      var mapping = this._originalMappings[index];
	
		      if (aArgs.column === undefined) {
		        var originalLine = mapping.originalLine;
	
		        // Iterate until either we run out of mappings, or we run into
		        // a mapping for a different line than the one we found. Since
		        // mappings are sorted, this is guaranteed to find all mappings for
		        // the line we found.
		        while (mapping && mapping.originalLine === originalLine) {
		          mappings.push({
		            line: util.getArg(mapping, 'generatedLine', null),
		            column: util.getArg(mapping, 'generatedColumn', null),
		            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
		          });
	
		          mapping = this._originalMappings[++index];
		        }
		      } else {
		        var originalColumn = mapping.originalColumn;
	
		        // Iterate until either we run out of mappings, or we run into
		        // a mapping for a different line than the one we were searching for.
		        // Since mappings are sorted, this is guaranteed to find all mappings for
		        // the line we are searching for.
		        while (mapping &&
		               mapping.originalLine === line &&
		               mapping.originalColumn == originalColumn) {
		          mappings.push({
		            line: util.getArg(mapping, 'generatedLine', null),
		            column: util.getArg(mapping, 'generatedColumn', null),
		            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
		          });
	
		          mapping = this._originalMappings[++index];
		        }
		      }
		    }
	
		    return mappings;
		  };
	
		exports.SourceMapConsumer = SourceMapConsumer;
	
		/**
		 * A BasicSourceMapConsumer instance represents a parsed source map which we can
		 * query for information about the original file positions by giving it a file
		 * position in the generated source.
		 *
		 * The only parameter is the raw source map (either as a JSON string, or
		 * already parsed to an object). According to the spec, source maps have the
		 * following attributes:
		 *
		 *   - version: Which version of the source map spec this map is following.
		 *   - sources: An array of URLs to the original source files.
		 *   - names: An array of identifiers which can be referrenced by individual mappings.
		 *   - sourceRoot: Optional. The URL root from which all sources are relative.
		 *   - sourcesContent: Optional. An array of contents of the original source files.
		 *   - mappings: A string of base64 VLQs which contain the actual mappings.
		 *   - file: Optional. The generated file this source map is associated with.
		 *
		 * Here is an example source map, taken from the source map spec[0]:
		 *
		 *     {
		 *       version : 3,
		 *       file: "out.js",
		 *       sourceRoot : "",
		 *       sources: ["foo.js", "bar.js"],
		 *       names: ["src", "maps", "are", "fun"],
		 *       mappings: "AA,AB;;ABCDE;"
		 *     }
		 *
		 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
		 */
		function BasicSourceMapConsumer(aSourceMap) {
		  var sourceMap = aSourceMap;
		  if (typeof aSourceMap === 'string') {
		    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
		  }
	
		  var version = util.getArg(sourceMap, 'version');
		  var sources = util.getArg(sourceMap, 'sources');
		  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
		  // requires the array) to play nice here.
		  var names = util.getArg(sourceMap, 'names', []);
		  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
		  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
		  var mappings = util.getArg(sourceMap, 'mappings');
		  var file = util.getArg(sourceMap, 'file', null);
	
		  // Once again, Sass deviates from the spec and supplies the version as a
		  // string rather than a number, so we use loose equality checking here.
		  if (version != this._version) {
		    throw new Error('Unsupported version: ' + version);
		  }
	
		  sources = sources
		    .map(String)
		    // Some source maps produce relative source paths like "./foo.js" instead of
		    // "foo.js".  Normalize these first so that future comparisons will succeed.
		    // See bugzil.la/1090768.
		    .map(util.normalize)
		    // Always ensure that absolute sources are internally stored relative to
		    // the source root, if the source root is absolute. Not doing this would
		    // be particularly problematic when the source root is a prefix of the
		    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
		    .map(function (source) {
		      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
		        ? util.relative(sourceRoot, source)
		        : source;
		    });
	
		  // Pass `true` below to allow duplicate names and sources. While source maps
		  // are intended to be compressed and deduplicated, the TypeScript compiler
		  // sometimes generates source maps with duplicates in them. See Github issue
		  // #72 and bugzil.la/889492.
		  this._names = ArraySet.fromArray(names.map(String), true);
		  this._sources = ArraySet.fromArray(sources, true);
	
		  this.sourceRoot = sourceRoot;
		  this.sourcesContent = sourcesContent;
		  this._mappings = mappings;
		  this.file = file;
		}
	
		BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
		BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
	
		/**
		 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
		 *
		 * @param SourceMapGenerator aSourceMap
		 *        The source map that will be consumed.
		 * @returns BasicSourceMapConsumer
		 */
		BasicSourceMapConsumer.fromSourceMap =
		  function SourceMapConsumer_fromSourceMap(aSourceMap) {
		    var smc = Object.create(BasicSourceMapConsumer.prototype);
	
		    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
		    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
		    smc.sourceRoot = aSourceMap._sourceRoot;
		    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
		                                                            smc.sourceRoot);
		    smc.file = aSourceMap._file;
	
		    // Because we are modifying the entries (by converting string sources and
		    // names to indices into the sources and names ArraySets), we have to make
		    // a copy of the entry or else bad things happen. Shared mutable state
		    // strikes again! See github issue #191.
	
		    var generatedMappings = aSourceMap._mappings.toArray().slice();
		    var destGeneratedMappings = smc.__generatedMappings = [];
		    var destOriginalMappings = smc.__originalMappings = [];
	
		    for (var i = 0, length = generatedMappings.length; i < length; i++) {
		      var srcMapping = generatedMappings[i];
		      var destMapping = new Mapping;
		      destMapping.generatedLine = srcMapping.generatedLine;
		      destMapping.generatedColumn = srcMapping.generatedColumn;
	
		      if (srcMapping.source) {
		        destMapping.source = sources.indexOf(srcMapping.source);
		        destMapping.originalLine = srcMapping.originalLine;
		        destMapping.originalColumn = srcMapping.originalColumn;
	
		        if (srcMapping.name) {
		          destMapping.name = names.indexOf(srcMapping.name);
		        }
	
		        destOriginalMappings.push(destMapping);
		      }
	
		      destGeneratedMappings.push(destMapping);
		    }
	
		    quickSort(smc.__originalMappings, util.compareByOriginalPositions);
	
		    return smc;
		  };
	
		/**
		 * The version of the source mapping spec that we are consuming.
		 */
		BasicSourceMapConsumer.prototype._version = 3;
	
		/**
		 * The list of original sources.
		 */
		Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
		  get: function () {
		    return this._sources.toArray().map(function (s) {
		      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
		    }, this);
		  }
		});
	
		/**
		 * Provide the JIT with a nice shape / hidden class.
		 */
		function Mapping() {
		  this.generatedLine = 0;
		  this.generatedColumn = 0;
		  this.source = null;
		  this.originalLine = null;
		  this.originalColumn = null;
		  this.name = null;
		}
	
		/**
		 * Parse the mappings in a string in to a data structure which we can easily
		 * query (the ordered arrays in the `this.__generatedMappings` and
		 * `this.__originalMappings` properties).
		 */
		BasicSourceMapConsumer.prototype._parseMappings =
		  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
		    var generatedLine = 1;
		    var previousGeneratedColumn = 0;
		    var previousOriginalLine = 0;
		    var previousOriginalColumn = 0;
		    var previousSource = 0;
		    var previousName = 0;
		    var length = aStr.length;
		    var index = 0;
		    var cachedSegments = {};
		    var temp = {};
		    var originalMappings = [];
		    var generatedMappings = [];
		    var mapping, str, segment, end, value;
	
		    while (index < length) {
		      if (aStr.charAt(index) === ';') {
		        generatedLine++;
		        index++;
		        previousGeneratedColumn = 0;
		      }
		      else if (aStr.charAt(index) === ',') {
		        index++;
		      }
		      else {
		        mapping = new Mapping();
		        mapping.generatedLine = generatedLine;
	
		        // Because each offset is encoded relative to the previous one,
		        // many segments often have the same encoding. We can exploit this
		        // fact by caching the parsed variable length fields of each segment,
		        // allowing us to avoid a second parse if we encounter the same
		        // segment again.
		        for (end = index; end < length; end++) {
		          if (this._charIsMappingSeparator(aStr, end)) {
		            break;
		          }
		        }
		        str = aStr.slice(index, end);
	
		        segment = cachedSegments[str];
		        if (segment) {
		          index += str.length;
		        } else {
		          segment = [];
		          while (index < end) {
		            base64VLQ.decode(aStr, index, temp);
		            value = temp.value;
		            index = temp.rest;
		            segment.push(value);
		          }
	
		          if (segment.length === 2) {
		            throw new Error('Found a source, but no line and column');
		          }
	
		          if (segment.length === 3) {
		            throw new Error('Found a source and line, but no column');
		          }
	
		          cachedSegments[str] = segment;
		        }
	
		        // Generated column.
		        mapping.generatedColumn = previousGeneratedColumn + segment[0];
		        previousGeneratedColumn = mapping.generatedColumn;
	
		        if (segment.length > 1) {
		          // Original source.
		          mapping.source = previousSource + segment[1];
		          previousSource += segment[1];
	
		          // Original line.
		          mapping.originalLine = previousOriginalLine + segment[2];
		          previousOriginalLine = mapping.originalLine;
		          // Lines are stored 0-based
		          mapping.originalLine += 1;
	
		          // Original column.
		          mapping.originalColumn = previousOriginalColumn + segment[3];
		          previousOriginalColumn = mapping.originalColumn;
	
		          if (segment.length > 4) {
		            // Original name.
		            mapping.name = previousName + segment[4];
		            previousName += segment[4];
		          }
		        }
	
		        generatedMappings.push(mapping);
		        if (typeof mapping.originalLine === 'number') {
		          originalMappings.push(mapping);
		        }
		      }
		    }
	
		    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
		    this.__generatedMappings = generatedMappings;
	
		    quickSort(originalMappings, util.compareByOriginalPositions);
		    this.__originalMappings = originalMappings;
		  };
	
		/**
		 * Find the mapping that best matches the hypothetical "needle" mapping that
		 * we are searching for in the given "haystack" of mappings.
		 */
		BasicSourceMapConsumer.prototype._findMapping =
		  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
		                                         aColumnName, aComparator, aBias) {
		    // To return the position we are searching for, we must first find the
		    // mapping for the given position and then return the opposite position it
		    // points to. Because the mappings are sorted, we can use binary search to
		    // find the best mapping.
	
		    if (aNeedle[aLineName] <= 0) {
		      throw new TypeError('Line must be greater than or equal to 1, got '
		                          + aNeedle[aLineName]);
		    }
		    if (aNeedle[aColumnName] < 0) {
		      throw new TypeError('Column must be greater than or equal to 0, got '
		                          + aNeedle[aColumnName]);
		    }
	
		    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
		  };
	
		/**
		 * Compute the last column for each generated mapping. The last column is
		 * inclusive.
		 */
		BasicSourceMapConsumer.prototype.computeColumnSpans =
		  function SourceMapConsumer_computeColumnSpans() {
		    for (var index = 0; index < this._generatedMappings.length; ++index) {
		      var mapping = this._generatedMappings[index];
	
		      // Mappings do not contain a field for the last generated columnt. We
		      // can come up with an optimistic estimate, however, by assuming that
		      // mappings are contiguous (i.e. given two consecutive mappings, the
		      // first mapping ends where the second one starts).
		      if (index + 1 < this._generatedMappings.length) {
		        var nextMapping = this._generatedMappings[index + 1];
	
		        if (mapping.generatedLine === nextMapping.generatedLine) {
		          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
		          continue;
		        }
		      }
	
		      // The last mapping for each line spans the entire line.
		      mapping.lastGeneratedColumn = Infinity;
		    }
		  };
	
		/**
		 * Returns the original source, line, and column information for the generated
		 * source's line and column positions provided. The only argument is an object
		 * with the following properties:
		 *
		 *   - line: The line number in the generated source.
		 *   - column: The column number in the generated source.
		 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
		 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
		 *     closest element that is smaller than or greater than the one we are
		 *     searching for, respectively, if the exact element cannot be found.
		 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
		 *
		 * and an object is returned with the following properties:
		 *
		 *   - source: The original source file, or null.
		 *   - line: The line number in the original source, or null.
		 *   - column: The column number in the original source, or null.
		 *   - name: The original identifier, or null.
		 */
		BasicSourceMapConsumer.prototype.originalPositionFor =
		  function SourceMapConsumer_originalPositionFor(aArgs) {
		    var needle = {
		      generatedLine: util.getArg(aArgs, 'line'),
		      generatedColumn: util.getArg(aArgs, 'column')
		    };
	
		    var index = this._findMapping(
		      needle,
		      this._generatedMappings,
		      "generatedLine",
		      "generatedColumn",
		      util.compareByGeneratedPositionsDeflated,
		      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
		    );
	
		    if (index >= 0) {
		      var mapping = this._generatedMappings[index];
	
		      if (mapping.generatedLine === needle.generatedLine) {
		        var source = util.getArg(mapping, 'source', null);
		        if (source !== null) {
		          source = this._sources.at(source);
		          if (this.sourceRoot != null) {
		            source = util.join(this.sourceRoot, source);
		          }
		        }
		        var name = util.getArg(mapping, 'name', null);
		        if (name !== null) {
		          name = this._names.at(name);
		        }
		        return {
		          source: source,
		          line: util.getArg(mapping, 'originalLine', null),
		          column: util.getArg(mapping, 'originalColumn', null),
		          name: name
		        };
		      }
		    }
	
		    return {
		      source: null,
		      line: null,
		      column: null,
		      name: null
		    };
		  };
	
		/**
		 * Return true if we have the source content for every source in the source
		 * map, false otherwise.
		 */
		BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
		  function BasicSourceMapConsumer_hasContentsOfAllSources() {
		    if (!this.sourcesContent) {
		      return false;
		    }
		    return this.sourcesContent.length >= this._sources.size() &&
		      !this.sourcesContent.some(function (sc) { return sc == null; });
		  };
	
		/**
		 * Returns the original source content. The only argument is the url of the
		 * original source file. Returns null if no original source content is
		 * available.
		 */
		BasicSourceMapConsumer.prototype.sourceContentFor =
		  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
		    if (!this.sourcesContent) {
		      return null;
		    }
	
		    if (this.sourceRoot != null) {
		      aSource = util.relative(this.sourceRoot, aSource);
		    }
	
		    if (this._sources.has(aSource)) {
		      return this.sourcesContent[this._sources.indexOf(aSource)];
		    }
	
		    var url;
		    if (this.sourceRoot != null
		        && (url = util.urlParse(this.sourceRoot))) {
		      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
		      // many users. We can help them out when they expect file:// URIs to
		      // behave like it would if they were running a local HTTP server. See
		      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
		      var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
		      if (url.scheme == "file"
		          && this._sources.has(fileUriAbsPath)) {
		        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
		      }
	
		      if ((!url.path || url.path == "/")
		          && this._sources.has("/" + aSource)) {
		        return this.sourcesContent[this._sources.indexOf("/" + aSource)];
		      }
		    }
	
		    // This function is used recursively from
		    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
		    // don't want to throw if we can't find the source - we just want to
		    // return null, so we provide a flag to exit gracefully.
		    if (nullOnMissing) {
		      return null;
		    }
		    else {
		      throw new Error('"' + aSource + '" is not in the SourceMap.');
		    }
		  };
	
		/**
		 * Returns the generated line and column information for the original source,
		 * line, and column positions provided. The only argument is an object with
		 * the following properties:
		 *
		 *   - source: The filename of the original source.
		 *   - line: The line number in the original source.
		 *   - column: The column number in the original source.
		 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
		 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
		 *     closest element that is smaller than or greater than the one we are
		 *     searching for, respectively, if the exact element cannot be found.
		 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
		 *
		 * and an object is returned with the following properties:
		 *
		 *   - line: The line number in the generated source, or null.
		 *   - column: The column number in the generated source, or null.
		 */
		BasicSourceMapConsumer.prototype.generatedPositionFor =
		  function SourceMapConsumer_generatedPositionFor(aArgs) {
		    var source = util.getArg(aArgs, 'source');
		    if (this.sourceRoot != null) {
		      source = util.relative(this.sourceRoot, source);
		    }
		    if (!this._sources.has(source)) {
		      return {
		        line: null,
		        column: null,
		        lastColumn: null
		      };
		    }
		    source = this._sources.indexOf(source);
	
		    var needle = {
		      source: source,
		      originalLine: util.getArg(aArgs, 'line'),
		      originalColumn: util.getArg(aArgs, 'column')
		    };
	
		    var index = this._findMapping(
		      needle,
		      this._originalMappings,
		      "originalLine",
		      "originalColumn",
		      util.compareByOriginalPositions,
		      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
		    );
	
		    if (index >= 0) {
		      var mapping = this._originalMappings[index];
	
		      if (mapping.source === needle.source) {
		        return {
		          line: util.getArg(mapping, 'generatedLine', null),
		          column: util.getArg(mapping, 'generatedColumn', null),
		          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
		        };
		      }
		    }
	
		    return {
		      line: null,
		      column: null,
		      lastColumn: null
		    };
		  };
	
		exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
	
		/**
		 * An IndexedSourceMapConsumer instance represents a parsed source map which
		 * we can query for information. It differs from BasicSourceMapConsumer in
		 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
		 * input.
		 *
		 * The only parameter is a raw source map (either as a JSON string, or already
		 * parsed to an object). According to the spec for indexed source maps, they
		 * have the following attributes:
		 *
		 *   - version: Which version of the source map spec this map is following.
		 *   - file: Optional. The generated file this source map is associated with.
		 *   - sections: A list of section definitions.
		 *
		 * Each value under the "sections" field has two fields:
		 *   - offset: The offset into the original specified at which this section
		 *       begins to apply, defined as an object with a "line" and "column"
		 *       field.
		 *   - map: A source map definition. This source map could also be indexed,
		 *       but doesn't have to be.
		 *
		 * Instead of the "map" field, it's also possible to have a "url" field
		 * specifying a URL to retrieve a source map from, but that's currently
		 * unsupported.
		 *
		 * Here's an example source map, taken from the source map spec[0], but
		 * modified to omit a section which uses the "url" field.
		 *
		 *  {
		 *    version : 3,
		 *    file: "app.js",
		 *    sections: [{
		 *      offset: {line:100, column:10},
		 *      map: {
		 *        version : 3,
		 *        file: "section.js",
		 *        sources: ["foo.js", "bar.js"],
		 *        names: ["src", "maps", "are", "fun"],
		 *        mappings: "AAAA,E;;ABCDE;"
		 *      }
		 *    }],
		 *  }
		 *
		 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
		 */
		function IndexedSourceMapConsumer(aSourceMap) {
		  var sourceMap = aSourceMap;
		  if (typeof aSourceMap === 'string') {
		    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
		  }
	
		  var version = util.getArg(sourceMap, 'version');
		  var sections = util.getArg(sourceMap, 'sections');
	
		  if (version != this._version) {
		    throw new Error('Unsupported version: ' + version);
		  }
	
		  this._sources = new ArraySet();
		  this._names = new ArraySet();
	
		  var lastOffset = {
		    line: -1,
		    column: 0
		  };
		  this._sections = sections.map(function (s) {
		    if (s.url) {
		      // The url field will require support for asynchronicity.
		      // See https://github.com/mozilla/source-map/issues/16
		      throw new Error('Support for url field in sections not implemented.');
		    }
		    var offset = util.getArg(s, 'offset');
		    var offsetLine = util.getArg(offset, 'line');
		    var offsetColumn = util.getArg(offset, 'column');
	
		    if (offsetLine < lastOffset.line ||
		        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
		      throw new Error('Section offsets must be ordered and non-overlapping.');
		    }
		    lastOffset = offset;
	
		    return {
		      generatedOffset: {
		        // The offset fields are 0-based, but we use 1-based indices when
		        // encoding/decoding from VLQ.
		        generatedLine: offsetLine + 1,
		        generatedColumn: offsetColumn + 1
		      },
		      consumer: new SourceMapConsumer(util.getArg(s, 'map'))
		    }
		  });
		}
	
		IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
		IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
	
		/**
		 * The version of the source mapping spec that we are consuming.
		 */
		IndexedSourceMapConsumer.prototype._version = 3;
	
		/**
		 * The list of original sources.
		 */
		Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
		  get: function () {
		    var sources = [];
		    for (var i = 0; i < this._sections.length; i++) {
		      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
		        sources.push(this._sections[i].consumer.sources[j]);
		      }
		    }
		    return sources;
		  }
		});
	
		/**
		 * Returns the original source, line, and column information for the generated
		 * source's line and column positions provided. The only argument is an object
		 * with the following properties:
		 *
		 *   - line: The line number in the generated source.
		 *   - column: The column number in the generated source.
		 *
		 * and an object is returned with the following properties:
		 *
		 *   - source: The original source file, or null.
		 *   - line: The line number in the original source, or null.
		 *   - column: The column number in the original source, or null.
		 *   - name: The original identifier, or null.
		 */
		IndexedSourceMapConsumer.prototype.originalPositionFor =
		  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
		    var needle = {
		      generatedLine: util.getArg(aArgs, 'line'),
		      generatedColumn: util.getArg(aArgs, 'column')
		    };
	
		    // Find the section containing the generated position we're trying to map
		    // to an original position.
		    var sectionIndex = binarySearch.search(needle, this._sections,
		      function(needle, section) {
		        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
		        if (cmp) {
		          return cmp;
		        }
	
		        return (needle.generatedColumn -
		                section.generatedOffset.generatedColumn);
		      });
		    var section = this._sections[sectionIndex];
	
		    if (!section) {
		      return {
		        source: null,
		        line: null,
		        column: null,
		        name: null
		      };
		    }
	
		    return section.consumer.originalPositionFor({
		      line: needle.generatedLine -
		        (section.generatedOffset.generatedLine - 1),
		      column: needle.generatedColumn -
		        (section.generatedOffset.generatedLine === needle.generatedLine
		         ? section.generatedOffset.generatedColumn - 1
		         : 0),
		      bias: aArgs.bias
		    });
		  };
	
		/**
		 * Return true if we have the source content for every source in the source
		 * map, false otherwise.
		 */
		IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
		  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
		    return this._sections.every(function (s) {
		      return s.consumer.hasContentsOfAllSources();
		    });
		  };
	
		/**
		 * Returns the original source content. The only argument is the url of the
		 * original source file. Returns null if no original source content is
		 * available.
		 */
		IndexedSourceMapConsumer.prototype.sourceContentFor =
		  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
		    for (var i = 0; i < this._sections.length; i++) {
		      var section = this._sections[i];
	
		      var content = section.consumer.sourceContentFor(aSource, true);
		      if (content) {
		        return content;
		      }
		    }
		    if (nullOnMissing) {
		      return null;
		    }
		    else {
		      throw new Error('"' + aSource + '" is not in the SourceMap.');
		    }
		  };
	
		/**
		 * Returns the generated line and column information for the original source,
		 * line, and column positions provided. The only argument is an object with
		 * the following properties:
		 *
		 *   - source: The filename of the original source.
		 *   - line: The line number in the original source.
		 *   - column: The column number in the original source.
		 *
		 * and an object is returned with the following properties:
		 *
		 *   - line: The line number in the generated source, or null.
		 *   - column: The column number in the generated source, or null.
		 */
		IndexedSourceMapConsumer.prototype.generatedPositionFor =
		  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
		    for (var i = 0; i < this._sections.length; i++) {
		      var section = this._sections[i];
	
		      // Only consider this section if the requested source is in the list of
		      // sources of the consumer.
		      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
		        continue;
		      }
		      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
		      if (generatedPosition) {
		        var ret = {
		          line: generatedPosition.line +
		            (section.generatedOffset.generatedLine - 1),
		          column: generatedPosition.column +
		            (section.generatedOffset.generatedLine === generatedPosition.line
		             ? section.generatedOffset.generatedColumn - 1
		             : 0)
		        };
		        return ret;
		      }
		    }
	
		    return {
		      line: null,
		      column: null
		    };
		  };
	
		/**
		 * Parse the mappings in a string in to a data structure which we can easily
		 * query (the ordered arrays in the `this.__generatedMappings` and
		 * `this.__originalMappings` properties).
		 */
		IndexedSourceMapConsumer.prototype._parseMappings =
		  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
		    this.__generatedMappings = [];
		    this.__originalMappings = [];
		    for (var i = 0; i < this._sections.length; i++) {
		      var section = this._sections[i];
		      var sectionMappings = section.consumer._generatedMappings;
		      for (var j = 0; j < sectionMappings.length; j++) {
		        var mapping = sectionMappings[j];
	
		        var source = section.consumer._sources.at(mapping.source);
		        if (section.consumer.sourceRoot !== null) {
		          source = util.join(section.consumer.sourceRoot, source);
		        }
		        this._sources.add(source);
		        source = this._sources.indexOf(source);
	
		        var name = section.consumer._names.at(mapping.name);
		        this._names.add(name);
		        name = this._names.indexOf(name);
	
		        // The mappings coming from the consumer for the section have
		        // generated positions relative to the start of the section, so we
		        // need to offset them to be relative to the start of the concatenated
		        // generated file.
		        var adjustedMapping = {
		          source: source,
		          generatedLine: mapping.generatedLine +
		            (section.generatedOffset.generatedLine - 1),
		          generatedColumn: mapping.generatedColumn +
		            (section.generatedOffset.generatedLine === mapping.generatedLine
		            ? section.generatedOffset.generatedColumn - 1
		            : 0),
		          originalLine: mapping.originalLine,
		          originalColumn: mapping.originalColumn,
		          name: name
		        };
	
		        this.__generatedMappings.push(adjustedMapping);
		        if (typeof adjustedMapping.originalLine === 'number') {
		          this.__originalMappings.push(adjustedMapping);
		        }
		      }
		    }
	
		    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
		    quickSort(this.__originalMappings, util.compareByOriginalPositions);
		  };
	
		exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
	
	
	/***/ },
	/* 2 */
	/***/ function(module, exports) {
	
		/* -*- Mode: js; js-indent-level: 2; -*- */
		/*
		 * Copyright 2011 Mozilla Foundation and contributors
		 * Licensed under the New BSD license. See LICENSE or:
		 * http://opensource.org/licenses/BSD-3-Clause
		 */
	
		/**
		 * This is a helper function for getting values from parameter/options
		 * objects.
		 *
		 * @param args The object we are extracting values from
		 * @param name The name of the property we are getting.
		 * @param defaultValue An optional value to return if the property is missing
		 * from the object. If this is not specified and the property is missing, an
		 * error will be thrown.
		 */
		function getArg(aArgs, aName, aDefaultValue) {
		  if (aName in aArgs) {
		    return aArgs[aName];
		  } else if (arguments.length === 3) {
		    return aDefaultValue;
		  } else {
		    throw new Error('"' + aName + '" is a required argument.');
		  }
		}
		exports.getArg = getArg;
	
		var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
		var dataUrlRegexp = /^data:.+\,.+$/;
	
		function urlParse(aUrl) {
		  var match = aUrl.match(urlRegexp);
		  if (!match) {
		    return null;
		  }
		  return {
		    scheme: match[1],
		    auth: match[2],
		    host: match[3],
		    port: match[4],
		    path: match[5]
		  };
		}
		exports.urlParse = urlParse;
	
		function urlGenerate(aParsedUrl) {
		  var url = '';
		  if (aParsedUrl.scheme) {
		    url += aParsedUrl.scheme + ':';
		  }
		  url += '//';
		  if (aParsedUrl.auth) {
		    url += aParsedUrl.auth + '@';
		  }
		  if (aParsedUrl.host) {
		    url += aParsedUrl.host;
		  }
		  if (aParsedUrl.port) {
		    url += ":" + aParsedUrl.port
		  }
		  if (aParsedUrl.path) {
		    url += aParsedUrl.path;
		  }
		  return url;
		}
		exports.urlGenerate = urlGenerate;
	
		/**
		 * Normalizes a path, or the path portion of a URL:
		 *
		 * - Replaces consecutive slashes with one slash.
		 * - Removes unnecessary '.' parts.
		 * - Removes unnecessary '<dir>/..' parts.
		 *
		 * Based on code in the Node.js 'path' core module.
		 *
		 * @param aPath The path or url to normalize.
		 */
		function normalize(aPath) {
		  var path = aPath;
		  var url = urlParse(aPath);
		  if (url) {
		    if (!url.path) {
		      return aPath;
		    }
		    path = url.path;
		  }
		  var isAbsolute = exports.isAbsolute(path);
	
		  var parts = path.split(/\/+/);
		  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
		    part = parts[i];
		    if (part === '.') {
		      parts.splice(i, 1);
		    } else if (part === '..') {
		      up++;
		    } else if (up > 0) {
		      if (part === '') {
		        // The first part is blank if the path is absolute. Trying to go
		        // above the root is a no-op. Therefore we can remove all '..' parts
		        // directly after the root.
		        parts.splice(i + 1, up);
		        up = 0;
		      } else {
		        parts.splice(i, 2);
		        up--;
		      }
		    }
		  }
		  path = parts.join('/');
	
		  if (path === '') {
		    path = isAbsolute ? '/' : '.';
		  }
	
		  if (url) {
		    url.path = path;
		    return urlGenerate(url);
		  }
		  return path;
		}
		exports.normalize = normalize;
	
		/**
		 * Joins two paths/URLs.
		 *
		 * @param aRoot The root path or URL.
		 * @param aPath The path or URL to be joined with the root.
		 *
		 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
		 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
		 *   first.
		 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
		 *   is updated with the result and aRoot is returned. Otherwise the result
		 *   is returned.
		 *   - If aPath is absolute, the result is aPath.
		 *   - Otherwise the two paths are joined with a slash.
		 * - Joining for example 'http://' and 'www.example.com' is also supported.
		 */
		function join(aRoot, aPath) {
		  if (aRoot === "") {
		    aRoot = ".";
		  }
		  if (aPath === "") {
		    aPath = ".";
		  }
		  var aPathUrl = urlParse(aPath);
		  var aRootUrl = urlParse(aRoot);
		  if (aRootUrl) {
		    aRoot = aRootUrl.path || '/';
		  }
	
		  // `join(foo, '//www.example.org')`
		  if (aPathUrl && !aPathUrl.scheme) {
		    if (aRootUrl) {
		      aPathUrl.scheme = aRootUrl.scheme;
		    }
		    return urlGenerate(aPathUrl);
		  }
	
		  if (aPathUrl || aPath.match(dataUrlRegexp)) {
		    return aPath;
		  }
	
		  // `join('http://', 'www.example.com')`
		  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
		    aRootUrl.host = aPath;
		    return urlGenerate(aRootUrl);
		  }
	
		  var joined = aPath.charAt(0) === '/'
		    ? aPath
		    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);
	
		  if (aRootUrl) {
		    aRootUrl.path = joined;
		    return urlGenerate(aRootUrl);
		  }
		  return joined;
		}
		exports.join = join;
	
		exports.isAbsolute = function (aPath) {
		  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
		};
	
		/**
		 * Make a path relative to a URL or another path.
		 *
		 * @param aRoot The root path or URL.
		 * @param aPath The path or URL to be made relative to aRoot.
		 */
		function relative(aRoot, aPath) {
		  if (aRoot === "") {
		    aRoot = ".";
		  }
	
		  aRoot = aRoot.replace(/\/$/, '');
	
		  // It is possible for the path to be above the root. In this case, simply
		  // checking whether the root is a prefix of the path won't work. Instead, we
		  // need to remove components from the root one by one, until either we find
		  // a prefix that fits, or we run out of components to remove.
		  var level = 0;
		  while (aPath.indexOf(aRoot + '/') !== 0) {
		    var index = aRoot.lastIndexOf("/");
		    if (index < 0) {
		      return aPath;
		    }
	
		    // If the only part of the root that is left is the scheme (i.e. http://,
		    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
		    // have exhausted all components, so the path is not relative to the root.
		    aRoot = aRoot.slice(0, index);
		    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
		      return aPath;
		    }
	
		    ++level;
		  }
	
		  // Make sure we add a "../" for each component we removed from the root.
		  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
		}
		exports.relative = relative;
	
		var supportsNullProto = (function () {
		  var obj = Object.create(null);
		  return !('__proto__' in obj);
		}());
	
		function identity (s) {
		  return s;
		}
	
		/**
		 * Because behavior goes wacky when you set `__proto__` on objects, we
		 * have to prefix all the strings in our set with an arbitrary character.
		 *
		 * See https://github.com/mozilla/source-map/pull/31 and
		 * https://github.com/mozilla/source-map/issues/30
		 *
		 * @param String aStr
		 */
		function toSetString(aStr) {
		  if (isProtoString(aStr)) {
		    return '$' + aStr;
		  }
	
		  return aStr;
		}
		exports.toSetString = supportsNullProto ? identity : toSetString;
	
		function fromSetString(aStr) {
		  if (isProtoString(aStr)) {
		    return aStr.slice(1);
		  }
	
		  return aStr;
		}
		exports.fromSetString = supportsNullProto ? identity : fromSetString;
	
		function isProtoString(s) {
		  if (!s) {
		    return false;
		  }
	
		  var length = s.length;
	
		  if (length < 9 /* "__proto__".length */) {
		    return false;
		  }
	
		  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
		      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
		      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
		      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
		      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
		      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
		      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
		      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
		      s.charCodeAt(length - 9) !== 95  /* '_' */) {
		    return false;
		  }
	
		  for (var i = length - 10; i >= 0; i--) {
		    if (s.charCodeAt(i) !== 36 /* '$' */) {
		      return false;
		    }
		  }
	
		  return true;
		}
	
		/**
		 * Comparator between two mappings where the original positions are compared.
		 *
		 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
		 * mappings with the same original source/line/column, but different generated
		 * line and column the same. Useful when searching for a mapping with a
		 * stubbed out mapping.
		 */
		function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
		  var cmp = mappingA.source - mappingB.source;
		  if (cmp !== 0) {
		    return cmp;
		  }
	
		  cmp = mappingA.originalLine - mappingB.originalLine;
		  if (cmp !== 0) {
		    return cmp;
		  }
	
		  cmp = mappingA.originalColumn - mappingB.originalColumn;
		  if (cmp !== 0 || onlyCompareOriginal) {
		    return cmp;
		  }
	
		  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }
	
		  cmp = mappingA.generatedLine - mappingB.generatedLine;
		  if (cmp !== 0) {
		    return cmp;
		  }
	
		  return mappingA.name - mappingB.name;
		}
		exports.compareByOriginalPositions = compareByOriginalPositions;
	
		/**
		 * Comparator between two mappings with deflated source and name indices where
		 * the generated positions are compared.
		 *
		 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
		 * mappings with the same generated line and column, but different
		 * source/name/original line and column the same. Useful when searching for a
		 * mapping with a stubbed out mapping.
		 */
		function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
		  var cmp = mappingA.generatedLine - mappingB.generatedLine;
		  if (cmp !== 0) {
		    return cmp;
		  }
	
		  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		  if (cmp !== 0 || onlyCompareGenerated) {
		    return cmp;
		  }
	
		  cmp = mappingA.source - mappingB.source;
		  if (cmp !== 0) {
		    return cmp;
		  }
	
		  cmp = mappingA.originalLine - mappingB.originalLine;
		  if (cmp !== 0) {
		    return cmp;
		  }
	
		  cmp = mappingA.originalColumn - mappingB.originalColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }
	
		  return mappingA.name - mappingB.name;
		}
		exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
	
		function strcmp(aStr1, aStr2) {
		  if (aStr1 === aStr2) {
		    return 0;
		  }
	
		  if (aStr1 > aStr2) {
		    return 1;
		  }
	
		  return -1;
		}
	
		/**
		 * Comparator between two mappings with inflated source and name strings where
		 * the generated positions are compared.
		 */
		function compareByGeneratedPositionsInflated(mappingA, mappingB) {
		  var cmp = mappingA.generatedLine - mappingB.generatedLine;
		  if (cmp !== 0) {
		    return cmp;
		  }
	
		  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }
	
		  cmp = strcmp(mappingA.source, mappingB.source);
		  if (cmp !== 0) {
		    return cmp;
		  }
	
		  cmp = mappingA.originalLine - mappingB.originalLine;
		  if (cmp !== 0) {
		    return cmp;
		  }
	
		  cmp = mappingA.originalColumn - mappingB.originalColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }
	
		  return strcmp(mappingA.name, mappingB.name);
		}
		exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
	
	
	/***/ },
	/* 3 */
	/***/ function(module, exports) {
	
		/* -*- Mode: js; js-indent-level: 2; -*- */
		/*
		 * Copyright 2011 Mozilla Foundation and contributors
		 * Licensed under the New BSD license. See LICENSE or:
		 * http://opensource.org/licenses/BSD-3-Clause
		 */
	
		exports.GREATEST_LOWER_BOUND = 1;
		exports.LEAST_UPPER_BOUND = 2;
	
		/**
		 * Recursive implementation of binary search.
		 *
		 * @param aLow Indices here and lower do not contain the needle.
		 * @param aHigh Indices here and higher do not contain the needle.
		 * @param aNeedle The element being searched for.
		 * @param aHaystack The non-empty array being searched.
		 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
		 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
		 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
		 *     closest element that is smaller than or greater than the one we are
		 *     searching for, respectively, if the exact element cannot be found.
		 */
		function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
		  // This function terminates when one of the following is true:
		  //
		  //   1. We find the exact element we are looking for.
		  //
		  //   2. We did not find the exact element, but we can return the index of
		  //      the next-closest element.
		  //
		  //   3. We did not find the exact element, and there is no next-closest
		  //      element than the one we are searching for, so we return -1.
		  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
		  var cmp = aCompare(aNeedle, aHaystack[mid], true);
		  if (cmp === 0) {
		    // Found the element we are looking for.
		    return mid;
		  }
		  else if (cmp > 0) {
		    // Our needle is greater than aHaystack[mid].
		    if (aHigh - mid > 1) {
		      // The element is in the upper half.
		      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
		    }
	
		    // The exact needle element was not found in this haystack. Determine if
		    // we are in termination case (3) or (2) and return the appropriate thing.
		    if (aBias == exports.LEAST_UPPER_BOUND) {
		      return aHigh < aHaystack.length ? aHigh : -1;
		    } else {
		      return mid;
		    }
		  }
		  else {
		    // Our needle is less than aHaystack[mid].
		    if (mid - aLow > 1) {
		      // The element is in the lower half.
		      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
		    }
	
		    // we are in termination case (3) or (2) and return the appropriate thing.
		    if (aBias == exports.LEAST_UPPER_BOUND) {
		      return mid;
		    } else {
		      return aLow < 0 ? -1 : aLow;
		    }
		  }
		}
	
		/**
		 * This is an implementation of binary search which will always try and return
		 * the index of the closest element if there is no exact hit. This is because
		 * mappings between original and generated line/col pairs are single points,
		 * and there is an implicit region between each of them, so a miss just means
		 * that you aren't on the very start of a region.
		 *
		 * @param aNeedle The element you are looking for.
		 * @param aHaystack The array that is being searched.
		 * @param aCompare A function which takes the needle and an element in the
		 *     array and returns -1, 0, or 1 depending on whether the needle is less
		 *     than, equal to, or greater than the element, respectively.
		 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
		 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
		 *     closest element that is smaller than or greater than the one we are
		 *     searching for, respectively, if the exact element cannot be found.
		 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
		 */
		exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
		  if (aHaystack.length === 0) {
		    return -1;
		  }
	
		  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
		                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
		  if (index < 0) {
		    return -1;
		  }
	
		  // We have found either the exact element, or the next-closest element than
		  // the one we are searching for. However, there may be more than one such
		  // element. Make sure we always return the smallest of these.
		  while (index - 1 >= 0) {
		    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
		      break;
		    }
		    --index;
		  }
	
		  return index;
		};
	
	
	/***/ },
	/* 4 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* -*- Mode: js; js-indent-level: 2; -*- */
		/*
		 * Copyright 2011 Mozilla Foundation and contributors
		 * Licensed under the New BSD license. See LICENSE or:
		 * http://opensource.org/licenses/BSD-3-Clause
		 */
	
		var util = __webpack_require__(2);
		var has = Object.prototype.hasOwnProperty;
	
		/**
		 * A data structure which is a combination of an array and a set. Adding a new
		 * member is O(1), testing for membership is O(1), and finding the index of an
		 * element is O(1). Removing elements from the set is not supported. Only
		 * strings are supported for membership.
		 */
		function ArraySet() {
		  this._array = [];
		  this._set = Object.create(null);
		}
	
		/**
		 * Static method for creating ArraySet instances from an existing array.
		 */
		ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
		  var set = new ArraySet();
		  for (var i = 0, len = aArray.length; i < len; i++) {
		    set.add(aArray[i], aAllowDuplicates);
		  }
		  return set;
		};
	
		/**
		 * Return how many unique items are in this ArraySet. If duplicates have been
		 * added, than those do not count towards the size.
		 *
		 * @returns Number
		 */
		ArraySet.prototype.size = function ArraySet_size() {
		  return Object.getOwnPropertyNames(this._set).length;
		};
	
		/**
		 * Add the given string to this set.
		 *
		 * @param String aStr
		 */
		ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
		  var sStr = util.toSetString(aStr);
		  var isDuplicate = has.call(this._set, sStr);
		  var idx = this._array.length;
		  if (!isDuplicate || aAllowDuplicates) {
		    this._array.push(aStr);
		  }
		  if (!isDuplicate) {
		    this._set[sStr] = idx;
		  }
		};
	
		/**
		 * Is the given string a member of this set?
		 *
		 * @param String aStr
		 */
		ArraySet.prototype.has = function ArraySet_has(aStr) {
		  var sStr = util.toSetString(aStr);
		  return has.call(this._set, sStr);
		};
	
		/**
		 * What is the index of the given string in the array?
		 *
		 * @param String aStr
		 */
		ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
		  var sStr = util.toSetString(aStr);
		  if (has.call(this._set, sStr)) {
		    return this._set[sStr];
		  }
		  throw new Error('"' + aStr + '" is not in the set.');
		};
	
		/**
		 * What is the element at the given index?
		 *
		 * @param Number aIdx
		 */
		ArraySet.prototype.at = function ArraySet_at(aIdx) {
		  if (aIdx >= 0 && aIdx < this._array.length) {
		    return this._array[aIdx];
		  }
		  throw new Error('No element indexed by ' + aIdx);
		};
	
		/**
		 * Returns the array representation of this set (which has the proper indices
		 * indicated by indexOf). Note that this is a copy of the internal array used
		 * for storing the members so that no one can mess with internal state.
		 */
		ArraySet.prototype.toArray = function ArraySet_toArray() {
		  return this._array.slice();
		};
	
		exports.ArraySet = ArraySet;
	
	
	/***/ },
	/* 5 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* -*- Mode: js; js-indent-level: 2; -*- */
		/*
		 * Copyright 2011 Mozilla Foundation and contributors
		 * Licensed under the New BSD license. See LICENSE or:
		 * http://opensource.org/licenses/BSD-3-Clause
		 *
		 * Based on the Base 64 VLQ implementation in Closure Compiler:
		 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
		 *
		 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 *  * Redistributions of source code must retain the above copyright
		 *    notice, this list of conditions and the following disclaimer.
		 *  * Redistributions in binary form must reproduce the above
		 *    copyright notice, this list of conditions and the following
		 *    disclaimer in the documentation and/or other materials provided
		 *    with the distribution.
		 *  * Neither the name of Google Inc. nor the names of its
		 *    contributors may be used to endorse or promote products derived
		 *    from this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
		 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
		 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
		 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
		 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
		 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */
	
		var base64 = __webpack_require__(6);
	
		// A single base 64 digit can contain 6 bits of data. For the base 64 variable
		// length quantities we use in the source map spec, the first bit is the sign,
		// the next four bits are the actual value, and the 6th bit is the
		// continuation bit. The continuation bit tells us whether there are more
		// digits in this value following this digit.
		//
		//   Continuation
		//   |    Sign
		//   |    |
		//   V    V
		//   101011
	
		var VLQ_BASE_SHIFT = 5;
	
		// binary: 100000
		var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
	
		// binary: 011111
		var VLQ_BASE_MASK = VLQ_BASE - 1;
	
		// binary: 100000
		var VLQ_CONTINUATION_BIT = VLQ_BASE;
	
		/**
		 * Converts from a two-complement value to a value where the sign bit is
		 * placed in the least significant bit.  For example, as decimals:
		 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
		 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
		 */
		function toVLQSigned(aValue) {
		  return aValue < 0
		    ? ((-aValue) << 1) + 1
		    : (aValue << 1) + 0;
		}
	
		/**
		 * Converts to a two-complement value from a value where the sign bit is
		 * placed in the least significant bit.  For example, as decimals:
		 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
		 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
		 */
		function fromVLQSigned(aValue) {
		  var isNegative = (aValue & 1) === 1;
		  var shifted = aValue >> 1;
		  return isNegative
		    ? -shifted
		    : shifted;
		}
	
		/**
		 * Returns the base 64 VLQ encoded value.
		 */
		exports.encode = function base64VLQ_encode(aValue) {
		  var encoded = "";
		  var digit;
	
		  var vlq = toVLQSigned(aValue);
	
		  do {
		    digit = vlq & VLQ_BASE_MASK;
		    vlq >>>= VLQ_BASE_SHIFT;
		    if (vlq > 0) {
		      // There are still more digits in this value, so we must make sure the
		      // continuation bit is marked.
		      digit |= VLQ_CONTINUATION_BIT;
		    }
		    encoded += base64.encode(digit);
		  } while (vlq > 0);
	
		  return encoded;
		};
	
		/**
		 * Decodes the next base 64 VLQ value from the given string and returns the
		 * value and the rest of the string via the out parameter.
		 */
		exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
		  var strLen = aStr.length;
		  var result = 0;
		  var shift = 0;
		  var continuation, digit;
	
		  do {
		    if (aIndex >= strLen) {
		      throw new Error("Expected more digits in base 64 VLQ value.");
		    }
	
		    digit = base64.decode(aStr.charCodeAt(aIndex++));
		    if (digit === -1) {
		      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
		    }
	
		    continuation = !!(digit & VLQ_CONTINUATION_BIT);
		    digit &= VLQ_BASE_MASK;
		    result = result + (digit << shift);
		    shift += VLQ_BASE_SHIFT;
		  } while (continuation);
	
		  aOutParam.value = fromVLQSigned(result);
		  aOutParam.rest = aIndex;
		};
	
	
	/***/ },
	/* 6 */
	/***/ function(module, exports) {
	
		/* -*- Mode: js; js-indent-level: 2; -*- */
		/*
		 * Copyright 2011 Mozilla Foundation and contributors
		 * Licensed under the New BSD license. See LICENSE or:
		 * http://opensource.org/licenses/BSD-3-Clause
		 */
	
		var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
	
		/**
		 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
		 */
		exports.encode = function (number) {
		  if (0 <= number && number < intToCharMap.length) {
		    return intToCharMap[number];
		  }
		  throw new TypeError("Must be between 0 and 63: " + number);
		};
	
		/**
		 * Decode a single base 64 character code digit to an integer. Returns -1 on
		 * failure.
		 */
		exports.decode = function (charCode) {
		  var bigA = 65;     // 'A'
		  var bigZ = 90;     // 'Z'
	
		  var littleA = 97;  // 'a'
		  var littleZ = 122; // 'z'
	
		  var zero = 48;     // '0'
		  var nine = 57;     // '9'
	
		  var plus = 43;     // '+'
		  var slash = 47;    // '/'
	
		  var littleOffset = 26;
		  var numberOffset = 52;
	
		  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
		  if (bigA <= charCode && charCode <= bigZ) {
		    return (charCode - bigA);
		  }
	
		  // 26 - 51: abcdefghijklmnopqrstuvwxyz
		  if (littleA <= charCode && charCode <= littleZ) {
		    return (charCode - littleA + littleOffset);
		  }
	
		  // 52 - 61: 0123456789
		  if (zero <= charCode && charCode <= nine) {
		    return (charCode - zero + numberOffset);
		  }
	
		  // 62: +
		  if (charCode == plus) {
		    return 62;
		  }
	
		  // 63: /
		  if (charCode == slash) {
		    return 63;
		  }
	
		  // Invalid base64 digit.
		  return -1;
		};
	
	
	/***/ },
	/* 7 */
	/***/ function(module, exports) {
	
		/* -*- Mode: js; js-indent-level: 2; -*- */
		/*
		 * Copyright 2011 Mozilla Foundation and contributors
		 * Licensed under the New BSD license. See LICENSE or:
		 * http://opensource.org/licenses/BSD-3-Clause
		 */
	
		// It turns out that some (most?) JavaScript engines don't self-host
		// `Array.prototype.sort`. This makes sense because C++ will likely remain
		// faster than JS when doing raw CPU-intensive sorting. However, when using a
		// custom comparator function, calling back and forth between the VM's C++ and
		// JIT'd JS is rather slow *and* loses JIT type information, resulting in
		// worse generated code for the comparator function than would be optimal. In
		// fact, when sorting with a comparator, these costs outweigh the benefits of
		// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
		// a ~3500ms mean speed-up in `bench/bench.html`.
	
		/**
		 * Swap the elements indexed by `x` and `y` in the array `ary`.
		 *
		 * @param {Array} ary
		 *        The array.
		 * @param {Number} x
		 *        The index of the first item.
		 * @param {Number} y
		 *        The index of the second item.
		 */
		function swap(ary, x, y) {
		  var temp = ary[x];
		  ary[x] = ary[y];
		  ary[y] = temp;
		}
	
		/**
		 * Returns a random integer within the range `low .. high` inclusive.
		 *
		 * @param {Number} low
		 *        The lower bound on the range.
		 * @param {Number} high
		 *        The upper bound on the range.
		 */
		function randomIntInRange(low, high) {
		  return Math.round(low + (Math.random() * (high - low)));
		}
	
		/**
		 * The Quick Sort algorithm.
		 *
		 * @param {Array} ary
		 *        An array to sort.
		 * @param {function} comparator
		 *        Function to use to compare two items.
		 * @param {Number} p
		 *        Start index of the array
		 * @param {Number} r
		 *        End index of the array
		 */
		function doQuickSort(ary, comparator, p, r) {
		  // If our lower bound is less than our upper bound, we (1) partition the
		  // array into two pieces and (2) recurse on each half. If it is not, this is
		  // the empty array and our base case.
	
		  if (p < r) {
		    // (1) Partitioning.
		    //
		    // The partitioning chooses a pivot between `p` and `r` and moves all
		    // elements that are less than or equal to the pivot to the before it, and
		    // all the elements that are greater than it after it. The effect is that
		    // once partition is done, the pivot is in the exact place it will be when
		    // the array is put in sorted order, and it will not need to be moved
		    // again. This runs in O(n) time.
	
		    // Always choose a random pivot so that an input array which is reverse
		    // sorted does not cause O(n^2) running time.
		    var pivotIndex = randomIntInRange(p, r);
		    var i = p - 1;
	
		    swap(ary, pivotIndex, r);
		    var pivot = ary[r];
	
		    // Immediately after `j` is incremented in this loop, the following hold
		    // true:
		    //
		    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
		    //
		    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
		    for (var j = p; j < r; j++) {
		      if (comparator(ary[j], pivot) <= 0) {
		        i += 1;
		        swap(ary, i, j);
		      }
		    }
	
		    swap(ary, i + 1, j);
		    var q = i + 1;
	
		    // (2) Recurse on each half.
	
		    doQuickSort(ary, comparator, p, q - 1);
		    doQuickSort(ary, comparator, q + 1, r);
		  }
		}
	
		/**
		 * Sort the given array in-place with the given comparator function.
		 *
		 * @param {Array} ary
		 *        An array to sort.
		 * @param {function} comparator
		 *        Function to use to compare two items.
		 */
		exports.quickSort = function (ary, comparator) {
		  doQuickSort(ary, comparator, 0, ary.length - 1);
		};
	
	
	/***/ }
	/******/ ])
	});
	;

/***/ }),
/* 587 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__resourceQuery, module) {/*eslint-env browser*/
	/*global __resourceQuery __webpack_public_path__*/
	
	var options = {
	  path: "/__webpack_hmr",
	  timeout: 20 * 1000,
	  overlay: true,
	  reload: false,
	  log: true,
	  warn: true,
	  name: '',
	  autoConnect: true
	};
	if (true) {
	  var querystring = __webpack_require__(588);
	  var overrides = querystring.parse(__resourceQuery.slice(1));
	  setOverrides(overrides);
	}
	
	if (typeof window === 'undefined') {
	  // do nothing
	} else if (typeof window.EventSource === 'undefined') {
	  console.warn(
	    "webpack-hot-middleware's client requires EventSource to work. " +
	    "You should include a polyfill if you want to support this browser: " +
	    "https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events#Tools"
	  );
	} else {
	  if (options.autoConnect) {
	    connect();
	  }
	}
	
	/* istanbul ignore next */
	function setOptionsAndConnect(overrides) {
	  setOverrides(overrides);
	  connect();
	}
	
	function setOverrides(overrides) {
	  if (overrides.autoConnect) options.autoConnect = overrides.autoConnect == 'true';
	  if (overrides.path) options.path = overrides.path;
	  if (overrides.timeout) options.timeout = overrides.timeout;
	  if (overrides.overlay) options.overlay = overrides.overlay !== 'false';
	  if (overrides.reload) options.reload = overrides.reload !== 'false';
	  if (overrides.noInfo && overrides.noInfo !== 'false') {
	    options.log = false;
	  }
	  if (overrides.name) {
	    options.name = overrides.name;
	  }
	  if (overrides.quiet && overrides.quiet !== 'false') {
	    options.log = false;
	    options.warn = false;
	  }
	
	  if (overrides.dynamicPublicPath) {
	    options.path = __webpack_require__.p + options.path;
	  }
	}
	
	function EventSourceWrapper() {
	  var source;
	  var lastActivity = new Date();
	  var listeners = [];
	
	  init();
	  var timer = setInterval(function() {
	    if ((new Date() - lastActivity) > options.timeout) {
	      handleDisconnect();
	    }
	  }, options.timeout / 2);
	
	  function init() {
	    source = new window.EventSource(options.path);
	    source.onopen = handleOnline;
	    source.onerror = handleDisconnect;
	    source.onmessage = handleMessage;
	  }
	
	  function handleOnline() {
	    if (options.log) console.log("[HMR] connected");
	    lastActivity = new Date();
	  }
	
	  function handleMessage(event) {
	    lastActivity = new Date();
	    for (var i = 0; i < listeners.length; i++) {
	      listeners[i](event);
	    }
	  }
	
	  function handleDisconnect() {
	    clearInterval(timer);
	    source.close();
	    setTimeout(init, options.timeout);
	  }
	
	  return {
	    addMessageListener: function(fn) {
	      listeners.push(fn);
	    }
	  };
	}
	
	function getEventSourceWrapper() {
	  if (!window.__whmEventSourceWrapper) {
	    window.__whmEventSourceWrapper = {};
	  }
	  if (!window.__whmEventSourceWrapper[options.path]) {
	    // cache the wrapper for other entries loaded on
	    // the same page with the same options.path
	    window.__whmEventSourceWrapper[options.path] = EventSourceWrapper();
	  }
	  return window.__whmEventSourceWrapper[options.path];
	}
	
	function connect() {
	  getEventSourceWrapper().addMessageListener(handleMessage);
	
	  function handleMessage(event) {
	    if (event.data == "\uD83D\uDC93") {
	      return;
	    }
	    try {
	      processMessage(JSON.parse(event.data));
	    } catch (ex) {
	      if (options.warn) {
	        console.warn("Invalid HMR message: " + event.data + "\n" + ex);
	      }
	    }
	  }
	}
	
	// the reporter needs to be a singleton on the page
	// in case the client is being used by multiple bundles
	// we only want to report once.
	// all the errors will go to all clients
	var singletonKey = '__webpack_hot_middleware_reporter__';
	var reporter;
	if (typeof window !== 'undefined') {
	  if (!window[singletonKey]) {
	    window[singletonKey] = createReporter();
	  }
	  reporter = window[singletonKey];
	}
	
	function createReporter() {
	  var strip = __webpack_require__(591);
	
	  var overlay;
	  if (typeof document !== 'undefined' && options.overlay) {
	    overlay = __webpack_require__(593);
	  }
	
	  var styles = {
	    errors: "color: #ff0000;",
	    warnings: "color: #999933;"
	  };
	  var previousProblems = null;
	  function log(type, obj) {
	    var newProblems = obj[type].map(function(msg) { return strip(msg); }).join('\n');
	    if (previousProblems == newProblems) {
	      return;
	    } else {
	      previousProblems = newProblems;
	    }
	
	    var style = styles[type];
	    var name = obj.name ? "'" + obj.name + "' " : "";
	    var title = "[HMR] bundle " + name + "has " + obj[type].length + " " + type;
	    // NOTE: console.warn or console.error will print the stack trace
	    // which isn't helpful here, so using console.log to escape it.
	    if (console.group && console.groupEnd) {
	      console.group("%c" + title, style);
	      console.log("%c" + newProblems, style);
	      console.groupEnd();
	    } else {
	      console.log(
	        "%c" + title + "\n\t%c" + newProblems.replace(/\n/g, "\n\t"),
	        style + "font-weight: bold;",
	        style + "font-weight: normal;"
	      );
	    }
	  }
	
	  return {
	    cleanProblemsCache: function () {
	      previousProblems = null;
	    },
	    problems: function(type, obj) {
	      if (options.warn) {
	        log(type, obj);
	      }
	      if (overlay && type !== 'warnings') overlay.showProblems(type, obj[type]);
	    },
	    success: function() {
	      if (overlay) overlay.clear();
	    },
	    useCustomOverlay: function(customOverlay) {
	      overlay = customOverlay;
	    }
	  };
	}
	
	var processUpdate = __webpack_require__(599);
	
	var customHandler;
	var subscribeAllHandler;
	function processMessage(obj) {
	  switch(obj.action) {
	    case "building":
	      if (options.log) {
	        console.log(
	          "[HMR] bundle " + (obj.name ? "'" + obj.name + "' " : "") +
	          "rebuilding"
	        );
	      }
	      break;
	    case "built":
	      if (options.log) {
	        console.log(
	          "[HMR] bundle " + (obj.name ? "'" + obj.name + "' " : "") +
	          "rebuilt in " + obj.time + "ms"
	        );
	      }
	      // fall through
	    case "sync":
	      if (obj.name && options.name && obj.name !== options.name) {
	        return;
	      }
	      if (obj.errors.length > 0) {
	        if (reporter) reporter.problems('errors', obj);
	      } else {
	        if (reporter) {
	          if (obj.warnings.length > 0) {
	            reporter.problems('warnings', obj);
	          } else {
	            reporter.cleanProblemsCache();
	          }
	          reporter.success();
	        }
	        processUpdate(obj.hash, obj.modules, options);
	      }
	      break;
	    default:
	      if (customHandler) {
	        customHandler(obj);
	      }
	  }
	
	  if (subscribeAllHandler) {
	    subscribeAllHandler(obj);
	  }
	}
	
	if (module) {
	  module.exports = {
	    subscribeAll: function subscribeAll(handler) {
	      subscribeAllHandler = handler;
	    },
	    subscribe: function subscribe(handler) {
	      customHandler = handler;
	    },
	    useCustomOverlay: function useCustomOverlay(customOverlay) {
	      if (reporter) reporter.useCustomOverlay(customOverlay);
	    },
	    setOptionsAndConnect: setOptionsAndConnect
	  };
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, "?path=http://192.168.0.3:3000/__webpack_hmr", __webpack_require__(268)(module)))

/***/ }),
/* 588 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.decode = exports.parse = __webpack_require__(589);
	exports.encode = exports.stringify = __webpack_require__(590);


/***/ }),
/* 589 */
/***/ (function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	module.exports = function(qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};
	
	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }
	
	  var regexp = /\+/g;
	  qs = qs.split(sep);
	
	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }
	
	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }
	
	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr, vstr, k, v;
	
	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }
	
	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);
	
	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (Array.isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }
	
	  return obj;
	};


/***/ }),
/* 590 */
/***/ (function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	var stringifyPrimitive = function(v) {
	  switch (typeof v) {
	    case 'string':
	      return v;
	
	    case 'boolean':
	      return v ? 'true' : 'false';
	
	    case 'number':
	      return isFinite(v) ? v : '';
	
	    default:
	      return '';
	  }
	};
	
	module.exports = function(obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }
	
	  if (typeof obj === 'object') {
	    return Object.keys(obj).map(function(k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (Array.isArray(obj[k])) {
	        return obj[k].map(function(v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);
	
	  }
	
	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq +
	         encodeURIComponent(stringifyPrimitive(obj));
	};


/***/ }),
/* 591 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var ansiRegex = __webpack_require__(592)();
	
	module.exports = function (str) {
		return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
	};


/***/ }),
/* 592 */
/***/ (function(module, exports) {

	'use strict';
	module.exports = function () {
		return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
	};


/***/ }),
/* 593 */
/***/ (function(module, exports, __webpack_require__) {

	/*eslint-env browser*/
	
	var clientOverlay = document.createElement('div');
	clientOverlay.id = 'webpack-hot-middleware-clientOverlay';
	var styles = {
	  background: 'rgba(0,0,0,0.85)',
	  color: '#E8E8E8',
	  lineHeight: '1.2',
	  whiteSpace: 'pre',
	  fontFamily: 'Menlo, Consolas, monospace',
	  fontSize: '13px',
	  position: 'fixed',
	  zIndex: 9999,
	  padding: '10px',
	  left: 0,
	  right: 0,
	  top: 0,
	  bottom: 0,
	  overflow: 'auto',
	  dir: 'ltr',
	  textAlign: 'left'
	};
	for (var key in styles) {
	  clientOverlay.style[key] = styles[key];
	}
	
	var ansiHTML = __webpack_require__(594);
	var colors = {
	  reset: ['transparent', 'transparent'],
	  black: '181818',
	  red: 'E36049',
	  green: 'B3CB74',
	  yellow: 'FFD080',
	  blue: '7CAFC2',
	  magenta: '7FACCA',
	  cyan: 'C3C2EF',
	  lightgrey: 'EBE7E3',
	  darkgrey: '6D7891'
	};
	ansiHTML.setColors(colors);
	
	var Entities = __webpack_require__(595).AllHtmlEntities;
	var entities = new Entities();
	
	exports.showProblems =
	function showProblems(type, lines) {
	  clientOverlay.innerHTML = '';
	  lines.forEach(function(msg) {
	    msg = ansiHTML(entities.encode(msg));
	    var div = document.createElement('div');
	    div.style.marginBottom = '26px';
	    div.innerHTML = problemType(type) + ' in ' + msg;
	    clientOverlay.appendChild(div);
	  });
	  if (document.body) {
	    document.body.appendChild(clientOverlay);
	  }
	};
	
	exports.clear =
	function clear() {
	  if (document.body && clientOverlay.parentNode) {
	    document.body.removeChild(clientOverlay);
	  }
	};
	
	var problemColors = {
	  errors: colors.red,
	  warnings: colors.yellow
	};
	
	function problemType (type) {
	  var color = problemColors[type] || colors.red;
	  return (
	    '<span style="background-color:#' + color + '; color:#fff; padding:2px 4px; border-radius: 2px">' +
	      type.slice(0, -1).toUpperCase() +
	    '</span>'
	  );
	}


/***/ }),
/* 594 */
/***/ (function(module, exports) {

	'use strict'
	
	module.exports = ansiHTML
	
	// Reference to https://github.com/sindresorhus/ansi-regex
	var _regANSI = /(?:(?:\u001b\[)|\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\u001b[A-M]/
	
	var _defColors = {
	  reset: ['fff', '000'], // [FOREGROUD_COLOR, BACKGROUND_COLOR]
	  black: '000',
	  red: 'ff0000',
	  green: '209805',
	  yellow: 'e8bf03',
	  blue: '0000ff',
	  magenta: 'ff00ff',
	  cyan: '00ffee',
	  lightgrey: 'f0f0f0',
	  darkgrey: '888'
	}
	var _styles = {
	  30: 'black',
	  31: 'red',
	  32: 'green',
	  33: 'yellow',
	  34: 'blue',
	  35: 'magenta',
	  36: 'cyan',
	  37: 'lightgrey'
	}
	var _openTags = {
	  '1': 'font-weight:bold', // bold
	  '2': 'opacity:0.5', // dim
	  '3': '<i>', // italic
	  '4': '<u>', // underscore
	  '8': 'display:none', // hidden
	  '9': '<del>' // delete
	}
	var _closeTags = {
	  '23': '</i>', // reset italic
	  '24': '</u>', // reset underscore
	  '29': '</del>' // reset delete
	}
	
	;[0, 21, 22, 27, 28, 39, 49].forEach(function (n) {
	  _closeTags[n] = '</span>'
	})
	
	/**
	 * Converts text with ANSI color codes to HTML markup.
	 * @param {String} text
	 * @returns {*}
	 */
	function ansiHTML (text) {
	  // Returns the text if the string has no ANSI escape code.
	  if (!_regANSI.test(text)) {
	    return text
	  }
	
	  // Cache opened sequence.
	  var ansiCodes = []
	  // Replace with markup.
	  var ret = text.replace(/\033\[(\d+)*m/g, function (match, seq) {
	    var ot = _openTags[seq]
	    if (ot) {
	      // If current sequence has been opened, close it.
	      if (!!~ansiCodes.indexOf(seq)) { // eslint-disable-line no-extra-boolean-cast
	        ansiCodes.pop()
	        return '</span>'
	      }
	      // Open tag.
	      ansiCodes.push(seq)
	      return ot[0] === '<' ? ot : '<span style="' + ot + ';">'
	    }
	
	    var ct = _closeTags[seq]
	    if (ct) {
	      // Pop sequence
	      ansiCodes.pop()
	      return ct
	    }
	    return ''
	  })
	
	  // Make sure tags are closed.
	  var l = ansiCodes.length
	  ;(l > 0) && (ret += Array(l + 1).join('</span>'))
	
	  return ret
	}
	
	/**
	 * Customize colors.
	 * @param {Object} colors reference to _defColors
	 */
	ansiHTML.setColors = function (colors) {
	  if (typeof colors !== 'object') {
	    throw new Error('`colors` parameter must be an Object.')
	  }
	
	  var _finalColors = {}
	  for (var key in _defColors) {
	    var hex = colors.hasOwnProperty(key) ? colors[key] : null
	    if (!hex) {
	      _finalColors[key] = _defColors[key]
	      continue
	    }
	    if ('reset' === key) {
	      if (typeof hex === 'string') {
	        hex = [hex]
	      }
	      if (!Array.isArray(hex) || hex.length === 0 || hex.some(function (h) {
	        return typeof h !== 'string'
	      })) {
	        throw new Error('The value of `' + key + '` property must be an Array and each item could only be a hex string, e.g.: FF0000')
	      }
	      var defHexColor = _defColors[key]
	      if (!hex[0]) {
	        hex[0] = defHexColor[0]
	      }
	      if (hex.length === 1 || !hex[1]) {
	        hex = [hex[0]]
	        hex.push(defHexColor[1])
	      }
	
	      hex = hex.slice(0, 2)
	    } else if (typeof hex !== 'string') {
	      throw new Error('The value of `' + key + '` property must be a hex string, e.g.: FF0000')
	    }
	    _finalColors[key] = hex
	  }
	  _setTags(_finalColors)
	}
	
	/**
	 * Reset colors.
	 */
	ansiHTML.reset = function () {
	  _setTags(_defColors)
	}
	
	/**
	 * Expose tags, including open and close.
	 * @type {Object}
	 */
	ansiHTML.tags = {}
	
	if (Object.defineProperty) {
	  Object.defineProperty(ansiHTML.tags, 'open', {
	    get: function () { return _openTags }
	  })
	  Object.defineProperty(ansiHTML.tags, 'close', {
	    get: function () { return _closeTags }
	  })
	} else {
	  ansiHTML.tags.open = _openTags
	  ansiHTML.tags.close = _closeTags
	}
	
	function _setTags (colors) {
	  // reset all
	  _openTags['0'] = 'font-weight:normal;opacity:1;color:#' + colors.reset[0] + ';background:#' + colors.reset[1]
	  // inverse
	  _openTags['7'] = 'color:#' + colors.reset[1] + ';background:#' + colors.reset[0]
	  // dark grey
	  _openTags['90'] = 'color:#' + colors.darkgrey
	
	  for (var code in _styles) {
	    var color = _styles[code]
	    var oriColor = colors[color] || '000'
	    _openTags[code] = 'color:#' + oriColor
	    code = parseInt(code)
	    _openTags[(code + 10).toString()] = 'background:#' + oriColor
	  }
	}
	
	ansiHTML.reset()


/***/ }),
/* 595 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = {
	  XmlEntities: __webpack_require__(596),
	  Html4Entities: __webpack_require__(597),
	  Html5Entities: __webpack_require__(598),
	  AllHtmlEntities: __webpack_require__(598)
	};


/***/ }),
/* 596 */
/***/ (function(module, exports) {

	var ALPHA_INDEX = {
	    '&lt': '<',
	    '&gt': '>',
	    '&quot': '"',
	    '&apos': '\'',
	    '&amp': '&',
	    '&lt;': '<',
	    '&gt;': '>',
	    '&quot;': '"',
	    '&apos;': '\'',
	    '&amp;': '&'
	};
	
	var CHAR_INDEX = {
	    60: 'lt',
	    62: 'gt',
	    34: 'quot',
	    39: 'apos',
	    38: 'amp'
	};
	
	var CHAR_S_INDEX = {
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    '\'': '&apos;',
	    '&': '&amp;'
	};
	
	/**
	 * @constructor
	 */
	function XmlEntities() {}
	
	/**
	 * @param {String} str
	 * @returns {String}
	 */
	XmlEntities.prototype.encode = function(str) {
	    if (!str || !str.length) {
	        return '';
	    }
	    return str.replace(/<|>|"|'|&/g, function(s) {
	        return CHAR_S_INDEX[s];
	    });
	};
	
	/**
	 * @param {String} str
	 * @returns {String}
	 */
	 XmlEntities.encode = function(str) {
	    return new XmlEntities().encode(str);
	 };
	
	/**
	 * @param {String} str
	 * @returns {String}
	 */
	XmlEntities.prototype.decode = function(str) {
	    if (!str || !str.length) {
	        return '';
	    }
	    return str.replace(/&#?[0-9a-zA-Z]+;?/g, function(s) {
	        if (s.charAt(1) === '#') {
	            var code = s.charAt(2).toLowerCase() === 'x' ?
	                parseInt(s.substr(3), 16) :
	                parseInt(s.substr(2));
	
	            if (isNaN(code) || code < -32768 || code > 65535) {
	                return '';
	            }
	            return String.fromCharCode(code);
	        }
	        return ALPHA_INDEX[s] || s;
	    });
	};
	
	/**
	 * @param {String} str
	 * @returns {String}
	 */
	 XmlEntities.decode = function(str) {
	    return new XmlEntities().decode(str);
	 };
	
	/**
	 * @param {String} str
	 * @returns {String}
	 */
	XmlEntities.prototype.encodeNonUTF = function(str) {
	    if (!str || !str.length) {
	        return '';
	    }
	    var strLength = str.length;
	    var result = '';
	    var i = 0;
	    while (i < strLength) {
	        var c = str.charCodeAt(i);
	        var alpha = CHAR_INDEX[c];
	        if (alpha) {
	            result += "&" + alpha + ";";
	            i++;
	            continue;
	        }
	        if (c < 32 || c > 126) {
	            result += '&#' + c + ';';
	        } else {
	            result += str.charAt(i);
	        }
	        i++;
	    }
	    return result;
	};
	
	/**
	 * @param {String} str
	 * @returns {String}
	 */
	 XmlEntities.encodeNonUTF = function(str) {
	    return new XmlEntities().encodeNonUTF(str);
	 };
	
	/**
	 * @param {String} str
	 * @returns {String}
	 */
	XmlEntities.prototype.encodeNonASCII = function(str) {
	    if (!str || !str.length) {
	        return '';
	    }
	    var strLenght = str.length;
	    var result = '';
	    var i = 0;
	    while (i < strLenght) {
	        var c = str.charCodeAt(i);
	        if (c <= 255) {
	            result += str[i++];
	            continue;
	        }
	        result += '&#' + c + ';';
	        i++;
	    }
	    return result;
	};
	
	/**
	 * @param {String} str
	 * @returns {String}
	 */
	 XmlEntities.encodeNonASCII = function(str) {
	    return new XmlEntities().encodeNonASCII(str);
	 };
	
	module.exports = XmlEntities;


/***/ }),
/* 597 */
/***/ (function(module, exports) {

	var HTML_ALPHA = ['apos', 'nbsp', 'iexcl', 'cent', 'pound', 'curren', 'yen', 'brvbar', 'sect', 'uml', 'copy', 'ordf', 'laquo', 'not', 'shy', 'reg', 'macr', 'deg', 'plusmn', 'sup2', 'sup3', 'acute', 'micro', 'para', 'middot', 'cedil', 'sup1', 'ordm', 'raquo', 'frac14', 'frac12', 'frac34', 'iquest', 'Agrave', 'Aacute', 'Acirc', 'Atilde', 'Auml', 'Aring', 'Aelig', 'Ccedil', 'Egrave', 'Eacute', 'Ecirc', 'Euml', 'Igrave', 'Iacute', 'Icirc', 'Iuml', 'ETH', 'Ntilde', 'Ograve', 'Oacute', 'Ocirc', 'Otilde', 'Ouml', 'times', 'Oslash', 'Ugrave', 'Uacute', 'Ucirc', 'Uuml', 'Yacute', 'THORN', 'szlig', 'agrave', 'aacute', 'acirc', 'atilde', 'auml', 'aring', 'aelig', 'ccedil', 'egrave', 'eacute', 'ecirc', 'euml', 'igrave', 'iacute', 'icirc', 'iuml', 'eth', 'ntilde', 'ograve', 'oacute', 'ocirc', 'otilde', 'ouml', 'divide', 'oslash', 'ugrave', 'uacute', 'ucirc', 'uuml', 'yacute', 'thorn', 'yuml', 'quot', 'amp', 'lt', 'gt', 'OElig', 'oelig', 'Scaron', 'scaron', 'Yuml', 'circ', 'tilde', 'ensp', 'emsp', 'thinsp', 'zwnj', 'zwj', 'lrm', 'rlm', 'ndash', 'mdash', 'lsquo', 'rsquo', 'sbquo', 'ldquo', 'rdquo', 'bdquo', 'dagger', 'Dagger', 'permil', 'lsaquo', 'rsaquo', 'euro', 'fnof', 'Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma', 'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigmaf', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'thetasym', 'upsih', 'piv', 'bull', 'hellip', 'prime', 'Prime', 'oline', 'frasl', 'weierp', 'image', 'real', 'trade', 'alefsym', 'larr', 'uarr', 'rarr', 'darr', 'harr', 'crarr', 'lArr', 'uArr', 'rArr', 'dArr', 'hArr', 'forall', 'part', 'exist', 'empty', 'nabla', 'isin', 'notin', 'ni', 'prod', 'sum', 'minus', 'lowast', 'radic', 'prop', 'infin', 'ang', 'and', 'or', 'cap', 'cup', 'int', 'there4', 'sim', 'cong', 'asymp', 'ne', 'equiv', 'le', 'ge', 'sub', 'sup', 'nsub', 'sube', 'supe', 'oplus', 'otimes', 'perp', 'sdot', 'lceil', 'rceil', 'lfloor', 'rfloor', 'lang', 'rang', 'loz', 'spades', 'clubs', 'hearts', 'diams'];
	var HTML_CODES = [39, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 34, 38, 60, 62, 338, 339, 352, 353, 376, 710, 732, 8194, 8195, 8201, 8204, 8205, 8206, 8207, 8211, 8212, 8216, 8217, 8218, 8220, 8221, 8222, 8224, 8225, 8240, 8249, 8250, 8364, 402, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 977, 978, 982, 8226, 8230, 8242, 8243, 8254, 8260, 8472, 8465, 8476, 8482, 8501, 8592, 8593, 8594, 8595, 8596, 8629, 8656, 8657, 8658, 8659, 8660, 8704, 8706, 8707, 8709, 8711, 8712, 8713, 8715, 8719, 8721, 8722, 8727, 8730, 8733, 8734, 8736, 8743, 8744, 8745, 8746, 8747, 8756, 8764, 8773, 8776, 8800, 8801, 8804, 8805, 8834, 8835, 8836, 8838, 8839, 8853, 8855, 8869, 8901, 8968, 8969, 8970, 8971, 9001, 9002, 9674, 9824, 9827, 9829, 9830];
	
	var alphaIndex = {};
	var numIndex = {};
	
	var i = 0;
	var length = HTML_ALPHA.length;
	while (i < length) {
	    var a = HTML_ALPHA[i];
	    var c = HTML_CODES[i];
	    alphaIndex[a] = String.fromCharCode(c);
	    numIndex[c] = a;
	    i++;
	}
	
	/**
	 * @constructor
	 */
	function Html4Entities() {}
	
	/**
	 * @param {String} str
	 * @returns {String}
	 */
	Html4Entities.prototype.decode = function(str) {
	    if (!str || !str.length) {
	        return '';
	    }
	    return str.replace(/&(#?[\w\d]+);?/g, function(s, entity) {
	        var chr;
	        if (entity.charAt(0) === "#") {
	            var code = entity.charAt(1).toLowerCase() === 'x' ?
	                parseInt(entity.substr(2), 16) :
	                parseInt(entity.substr(1));
	
	            if (!(isNaN(code) || code < -32768 || code > 65535)) {
	                chr = String.fromCharCode(code);
	            }
	        } else {
	            chr = alphaIndex[entity];
	        }
	        return chr || s;
	    });
	};
	
	/**
	 * @param {String} str
	 * @returns {String}
	 */
	Html4Entities.decode = function(str) {
	    return new Html4Entities().decode(str);
	};
	
	/**
	 * @param {String} str
	 * @returns {String}
	 */
	Html4Entities.prototype.encode = function(str) {
	    if (!str || !str.length) {
	        return '';
	    }
	    var strLength = str.length;
	    var result = '';
	    var i = 0;
	    while (i < strLength) {
	        var alpha = numIndex[str.charCodeAt(i)];
	        result += alpha ? "&" + alpha + ";" : str.charAt(i);
	        i++;
	    }
	    return result;
	};
	
	/**
	 * @param {String} str
	 * @returns {String}
	 */
	Html4Entities.encode = function(str) {
	    return new Html4Entities().encode(str);
	};
	
	/**
	 * @param {String} str
	 * @returns {String}
	 */
	Html4Entities.prototype.encodeNonUTF = function(str) {
	    if (!str || !str.length) {
	        return '';
	    }
	    var strLength = str.length;
	    var result = '';
	    var i = 0;
	    while (i < strLength) {
	        var cc = str.charCodeAt(i);
	        var alpha = numIndex[cc];
	        if (alpha) {
	            result += "&" + alpha + ";";
	        } else if (cc < 32 || cc > 126) {
	            result += "&#" + cc + ";";
	        } else {
	            result += str.charAt(i);
	        }
	        i++;
	    }
	    return result;
	};
	
	/**
	 * @param {String} str
	 * @returns {String}
	 */
	Html4Entities.encodeNonUTF = function(str) {
	    return new Html4Entities().encodeNonUTF(str);
	};
	
	/**
	 * @param {String} str
	 * @returns {String}
	 */
	Html4Entities.prototype.encodeNonASCII = function(str) {
	    if (!str || !str.length) {
	        return '';
	    }
	    var strLength = str.length;
	    var result = '';
	    var i = 0;
	    while (i < strLength) {
	        var c = str.charCodeAt(i);
	        if (c <= 255) {
	            result += str[i++];
	            continue;
	        }
	        result += '&#' + c + ';';
	        i++;
	    }
	    return result;
	};
	
	/**
	 * @param {String} str
	 * @returns {String}
	 */
	Html4Entities.encodeNonASCII = function(str) {
	    return new Html4Entities().encodeNonASCII(str);
	};
	
	module.exports = Html4Entities;


/***/ }),
/* 598 */
/***/ (function(module, exports) {

	var ENTITIES = [['Aacute', [193]], ['aacute', [225]], ['Abreve', [258]], ['abreve', [259]], ['ac', [8766]], ['acd', [8767]], ['acE', [8766, 819]], ['Acirc', [194]], ['acirc', [226]], ['acute', [180]], ['Acy', [1040]], ['acy', [1072]], ['AElig', [198]], ['aelig', [230]], ['af', [8289]], ['Afr', [120068]], ['afr', [120094]], ['Agrave', [192]], ['agrave', [224]], ['alefsym', [8501]], ['aleph', [8501]], ['Alpha', [913]], ['alpha', [945]], ['Amacr', [256]], ['amacr', [257]], ['amalg', [10815]], ['amp', [38]], ['AMP', [38]], ['andand', [10837]], ['And', [10835]], ['and', [8743]], ['andd', [10844]], ['andslope', [10840]], ['andv', [10842]], ['ang', [8736]], ['ange', [10660]], ['angle', [8736]], ['angmsdaa', [10664]], ['angmsdab', [10665]], ['angmsdac', [10666]], ['angmsdad', [10667]], ['angmsdae', [10668]], ['angmsdaf', [10669]], ['angmsdag', [10670]], ['angmsdah', [10671]], ['angmsd', [8737]], ['angrt', [8735]], ['angrtvb', [8894]], ['angrtvbd', [10653]], ['angsph', [8738]], ['angst', [197]], ['angzarr', [9084]], ['Aogon', [260]], ['aogon', [261]], ['Aopf', [120120]], ['aopf', [120146]], ['apacir', [10863]], ['ap', [8776]], ['apE', [10864]], ['ape', [8778]], ['apid', [8779]], ['apos', [39]], ['ApplyFunction', [8289]], ['approx', [8776]], ['approxeq', [8778]], ['Aring', [197]], ['aring', [229]], ['Ascr', [119964]], ['ascr', [119990]], ['Assign', [8788]], ['ast', [42]], ['asymp', [8776]], ['asympeq', [8781]], ['Atilde', [195]], ['atilde', [227]], ['Auml', [196]], ['auml', [228]], ['awconint', [8755]], ['awint', [10769]], ['backcong', [8780]], ['backepsilon', [1014]], ['backprime', [8245]], ['backsim', [8765]], ['backsimeq', [8909]], ['Backslash', [8726]], ['Barv', [10983]], ['barvee', [8893]], ['barwed', [8965]], ['Barwed', [8966]], ['barwedge', [8965]], ['bbrk', [9141]], ['bbrktbrk', [9142]], ['bcong', [8780]], ['Bcy', [1041]], ['bcy', [1073]], ['bdquo', [8222]], ['becaus', [8757]], ['because', [8757]], ['Because', [8757]], ['bemptyv', [10672]], ['bepsi', [1014]], ['bernou', [8492]], ['Bernoullis', [8492]], ['Beta', [914]], ['beta', [946]], ['beth', [8502]], ['between', [8812]], ['Bfr', [120069]], ['bfr', [120095]], ['bigcap', [8898]], ['bigcirc', [9711]], ['bigcup', [8899]], ['bigodot', [10752]], ['bigoplus', [10753]], ['bigotimes', [10754]], ['bigsqcup', [10758]], ['bigstar', [9733]], ['bigtriangledown', [9661]], ['bigtriangleup', [9651]], ['biguplus', [10756]], ['bigvee', [8897]], ['bigwedge', [8896]], ['bkarow', [10509]], ['blacklozenge', [10731]], ['blacksquare', [9642]], ['blacktriangle', [9652]], ['blacktriangledown', [9662]], ['blacktriangleleft', [9666]], ['blacktriangleright', [9656]], ['blank', [9251]], ['blk12', [9618]], ['blk14', [9617]], ['blk34', [9619]], ['block', [9608]], ['bne', [61, 8421]], ['bnequiv', [8801, 8421]], ['bNot', [10989]], ['bnot', [8976]], ['Bopf', [120121]], ['bopf', [120147]], ['bot', [8869]], ['bottom', [8869]], ['bowtie', [8904]], ['boxbox', [10697]], ['boxdl', [9488]], ['boxdL', [9557]], ['boxDl', [9558]], ['boxDL', [9559]], ['boxdr', [9484]], ['boxdR', [9554]], ['boxDr', [9555]], ['boxDR', [9556]], ['boxh', [9472]], ['boxH', [9552]], ['boxhd', [9516]], ['boxHd', [9572]], ['boxhD', [9573]], ['boxHD', [9574]], ['boxhu', [9524]], ['boxHu', [9575]], ['boxhU', [9576]], ['boxHU', [9577]], ['boxminus', [8863]], ['boxplus', [8862]], ['boxtimes', [8864]], ['boxul', [9496]], ['boxuL', [9563]], ['boxUl', [9564]], ['boxUL', [9565]], ['boxur', [9492]], ['boxuR', [9560]], ['boxUr', [9561]], ['boxUR', [9562]], ['boxv', [9474]], ['boxV', [9553]], ['boxvh', [9532]], ['boxvH', [9578]], ['boxVh', [9579]], ['boxVH', [9580]], ['boxvl', [9508]], ['boxvL', [9569]], ['boxVl', [9570]], ['boxVL', [9571]], ['boxvr', [9500]], ['boxvR', [9566]], ['boxVr', [9567]], ['boxVR', [9568]], ['bprime', [8245]], ['breve', [728]], ['Breve', [728]], ['brvbar', [166]], ['bscr', [119991]], ['Bscr', [8492]], ['bsemi', [8271]], ['bsim', [8765]], ['bsime', [8909]], ['bsolb', [10693]], ['bsol', [92]], ['bsolhsub', [10184]], ['bull', [8226]], ['bullet', [8226]], ['bump', [8782]], ['bumpE', [10926]], ['bumpe', [8783]], ['Bumpeq', [8782]], ['bumpeq', [8783]], ['Cacute', [262]], ['cacute', [263]], ['capand', [10820]], ['capbrcup', [10825]], ['capcap', [10827]], ['cap', [8745]], ['Cap', [8914]], ['capcup', [10823]], ['capdot', [10816]], ['CapitalDifferentialD', [8517]], ['caps', [8745, 65024]], ['caret', [8257]], ['caron', [711]], ['Cayleys', [8493]], ['ccaps', [10829]], ['Ccaron', [268]], ['ccaron', [269]], ['Ccedil', [199]], ['ccedil', [231]], ['Ccirc', [264]], ['ccirc', [265]], ['Cconint', [8752]], ['ccups', [10828]], ['ccupssm', [10832]], ['Cdot', [266]], ['cdot', [267]], ['cedil', [184]], ['Cedilla', [184]], ['cemptyv', [10674]], ['cent', [162]], ['centerdot', [183]], ['CenterDot', [183]], ['cfr', [120096]], ['Cfr', [8493]], ['CHcy', [1063]], ['chcy', [1095]], ['check', [10003]], ['checkmark', [10003]], ['Chi', [935]], ['chi', [967]], ['circ', [710]], ['circeq', [8791]], ['circlearrowleft', [8634]], ['circlearrowright', [8635]], ['circledast', [8859]], ['circledcirc', [8858]], ['circleddash', [8861]], ['CircleDot', [8857]], ['circledR', [174]], ['circledS', [9416]], ['CircleMinus', [8854]], ['CirclePlus', [8853]], ['CircleTimes', [8855]], ['cir', [9675]], ['cirE', [10691]], ['cire', [8791]], ['cirfnint', [10768]], ['cirmid', [10991]], ['cirscir', [10690]], ['ClockwiseContourIntegral', [8754]], ['clubs', [9827]], ['clubsuit', [9827]], ['colon', [58]], ['Colon', [8759]], ['Colone', [10868]], ['colone', [8788]], ['coloneq', [8788]], ['comma', [44]], ['commat', [64]], ['comp', [8705]], ['compfn', [8728]], ['complement', [8705]], ['complexes', [8450]], ['cong', [8773]], ['congdot', [10861]], ['Congruent', [8801]], ['conint', [8750]], ['Conint', [8751]], ['ContourIntegral', [8750]], ['copf', [120148]], ['Copf', [8450]], ['coprod', [8720]], ['Coproduct', [8720]], ['copy', [169]], ['COPY', [169]], ['copysr', [8471]], ['CounterClockwiseContourIntegral', [8755]], ['crarr', [8629]], ['cross', [10007]], ['Cross', [10799]], ['Cscr', [119966]], ['cscr', [119992]], ['csub', [10959]], ['csube', [10961]], ['csup', [10960]], ['csupe', [10962]], ['ctdot', [8943]], ['cudarrl', [10552]], ['cudarrr', [10549]], ['cuepr', [8926]], ['cuesc', [8927]], ['cularr', [8630]], ['cularrp', [10557]], ['cupbrcap', [10824]], ['cupcap', [10822]], ['CupCap', [8781]], ['cup', [8746]], ['Cup', [8915]], ['cupcup', [10826]], ['cupdot', [8845]], ['cupor', [10821]], ['cups', [8746, 65024]], ['curarr', [8631]], ['curarrm', [10556]], ['curlyeqprec', [8926]], ['curlyeqsucc', [8927]], ['curlyvee', [8910]], ['curlywedge', [8911]], ['curren', [164]], ['curvearrowleft', [8630]], ['curvearrowright', [8631]], ['cuvee', [8910]], ['cuwed', [8911]], ['cwconint', [8754]], ['cwint', [8753]], ['cylcty', [9005]], ['dagger', [8224]], ['Dagger', [8225]], ['daleth', [8504]], ['darr', [8595]], ['Darr', [8609]], ['dArr', [8659]], ['dash', [8208]], ['Dashv', [10980]], ['dashv', [8867]], ['dbkarow', [10511]], ['dblac', [733]], ['Dcaron', [270]], ['dcaron', [271]], ['Dcy', [1044]], ['dcy', [1076]], ['ddagger', [8225]], ['ddarr', [8650]], ['DD', [8517]], ['dd', [8518]], ['DDotrahd', [10513]], ['ddotseq', [10871]], ['deg', [176]], ['Del', [8711]], ['Delta', [916]], ['delta', [948]], ['demptyv', [10673]], ['dfisht', [10623]], ['Dfr', [120071]], ['dfr', [120097]], ['dHar', [10597]], ['dharl', [8643]], ['dharr', [8642]], ['DiacriticalAcute', [180]], ['DiacriticalDot', [729]], ['DiacriticalDoubleAcute', [733]], ['DiacriticalGrave', [96]], ['DiacriticalTilde', [732]], ['diam', [8900]], ['diamond', [8900]], ['Diamond', [8900]], ['diamondsuit', [9830]], ['diams', [9830]], ['die', [168]], ['DifferentialD', [8518]], ['digamma', [989]], ['disin', [8946]], ['div', [247]], ['divide', [247]], ['divideontimes', [8903]], ['divonx', [8903]], ['DJcy', [1026]], ['djcy', [1106]], ['dlcorn', [8990]], ['dlcrop', [8973]], ['dollar', [36]], ['Dopf', [120123]], ['dopf', [120149]], ['Dot', [168]], ['dot', [729]], ['DotDot', [8412]], ['doteq', [8784]], ['doteqdot', [8785]], ['DotEqual', [8784]], ['dotminus', [8760]], ['dotplus', [8724]], ['dotsquare', [8865]], ['doublebarwedge', [8966]], ['DoubleContourIntegral', [8751]], ['DoubleDot', [168]], ['DoubleDownArrow', [8659]], ['DoubleLeftArrow', [8656]], ['DoubleLeftRightArrow', [8660]], ['DoubleLeftTee', [10980]], ['DoubleLongLeftArrow', [10232]], ['DoubleLongLeftRightArrow', [10234]], ['DoubleLongRightArrow', [10233]], ['DoubleRightArrow', [8658]], ['DoubleRightTee', [8872]], ['DoubleUpArrow', [8657]], ['DoubleUpDownArrow', [8661]], ['DoubleVerticalBar', [8741]], ['DownArrowBar', [10515]], ['downarrow', [8595]], ['DownArrow', [8595]], ['Downarrow', [8659]], ['DownArrowUpArrow', [8693]], ['DownBreve', [785]], ['downdownarrows', [8650]], ['downharpoonleft', [8643]], ['downharpoonright', [8642]], ['DownLeftRightVector', [10576]], ['DownLeftTeeVector', [10590]], ['DownLeftVectorBar', [10582]], ['DownLeftVector', [8637]], ['DownRightTeeVector', [10591]], ['DownRightVectorBar', [10583]], ['DownRightVector', [8641]], ['DownTeeArrow', [8615]], ['DownTee', [8868]], ['drbkarow', [10512]], ['drcorn', [8991]], ['drcrop', [8972]], ['Dscr', [119967]], ['dscr', [119993]], ['DScy', [1029]], ['dscy', [1109]], ['dsol', [10742]], ['Dstrok', [272]], ['dstrok', [273]], ['dtdot', [8945]], ['dtri', [9663]], ['dtrif', [9662]], ['duarr', [8693]], ['duhar', [10607]], ['dwangle', [10662]], ['DZcy', [1039]], ['dzcy', [1119]], ['dzigrarr', [10239]], ['Eacute', [201]], ['eacute', [233]], ['easter', [10862]], ['Ecaron', [282]], ['ecaron', [283]], ['Ecirc', [202]], ['ecirc', [234]], ['ecir', [8790]], ['ecolon', [8789]], ['Ecy', [1069]], ['ecy', [1101]], ['eDDot', [10871]], ['Edot', [278]], ['edot', [279]], ['eDot', [8785]], ['ee', [8519]], ['efDot', [8786]], ['Efr', [120072]], ['efr', [120098]], ['eg', [10906]], ['Egrave', [200]], ['egrave', [232]], ['egs', [10902]], ['egsdot', [10904]], ['el', [10905]], ['Element', [8712]], ['elinters', [9191]], ['ell', [8467]], ['els', [10901]], ['elsdot', [10903]], ['Emacr', [274]], ['emacr', [275]], ['empty', [8709]], ['emptyset', [8709]], ['EmptySmallSquare', [9723]], ['emptyv', [8709]], ['EmptyVerySmallSquare', [9643]], ['emsp13', [8196]], ['emsp14', [8197]], ['emsp', [8195]], ['ENG', [330]], ['eng', [331]], ['ensp', [8194]], ['Eogon', [280]], ['eogon', [281]], ['Eopf', [120124]], ['eopf', [120150]], ['epar', [8917]], ['eparsl', [10723]], ['eplus', [10865]], ['epsi', [949]], ['Epsilon', [917]], ['epsilon', [949]], ['epsiv', [1013]], ['eqcirc', [8790]], ['eqcolon', [8789]], ['eqsim', [8770]], ['eqslantgtr', [10902]], ['eqslantless', [10901]], ['Equal', [10869]], ['equals', [61]], ['EqualTilde', [8770]], ['equest', [8799]], ['Equilibrium', [8652]], ['equiv', [8801]], ['equivDD', [10872]], ['eqvparsl', [10725]], ['erarr', [10609]], ['erDot', [8787]], ['escr', [8495]], ['Escr', [8496]], ['esdot', [8784]], ['Esim', [10867]], ['esim', [8770]], ['Eta', [919]], ['eta', [951]], ['ETH', [208]], ['eth', [240]], ['Euml', [203]], ['euml', [235]], ['euro', [8364]], ['excl', [33]], ['exist', [8707]], ['Exists', [8707]], ['expectation', [8496]], ['exponentiale', [8519]], ['ExponentialE', [8519]], ['fallingdotseq', [8786]], ['Fcy', [1060]], ['fcy', [1092]], ['female', [9792]], ['ffilig', [64259]], ['fflig', [64256]], ['ffllig', [64260]], ['Ffr', [120073]], ['ffr', [120099]], ['filig', [64257]], ['FilledSmallSquare', [9724]], ['FilledVerySmallSquare', [9642]], ['fjlig', [102, 106]], ['flat', [9837]], ['fllig', [64258]], ['fltns', [9649]], ['fnof', [402]], ['Fopf', [120125]], ['fopf', [120151]], ['forall', [8704]], ['ForAll', [8704]], ['fork', [8916]], ['forkv', [10969]], ['Fouriertrf', [8497]], ['fpartint', [10765]], ['frac12', [189]], ['frac13', [8531]], ['frac14', [188]], ['frac15', [8533]], ['frac16', [8537]], ['frac18', [8539]], ['frac23', [8532]], ['frac25', [8534]], ['frac34', [190]], ['frac35', [8535]], ['frac38', [8540]], ['frac45', [8536]], ['frac56', [8538]], ['frac58', [8541]], ['frac78', [8542]], ['frasl', [8260]], ['frown', [8994]], ['fscr', [119995]], ['Fscr', [8497]], ['gacute', [501]], ['Gamma', [915]], ['gamma', [947]], ['Gammad', [988]], ['gammad', [989]], ['gap', [10886]], ['Gbreve', [286]], ['gbreve', [287]], ['Gcedil', [290]], ['Gcirc', [284]], ['gcirc', [285]], ['Gcy', [1043]], ['gcy', [1075]], ['Gdot', [288]], ['gdot', [289]], ['ge', [8805]], ['gE', [8807]], ['gEl', [10892]], ['gel', [8923]], ['geq', [8805]], ['geqq', [8807]], ['geqslant', [10878]], ['gescc', [10921]], ['ges', [10878]], ['gesdot', [10880]], ['gesdoto', [10882]], ['gesdotol', [10884]], ['gesl', [8923, 65024]], ['gesles', [10900]], ['Gfr', [120074]], ['gfr', [120100]], ['gg', [8811]], ['Gg', [8921]], ['ggg', [8921]], ['gimel', [8503]], ['GJcy', [1027]], ['gjcy', [1107]], ['gla', [10917]], ['gl', [8823]], ['glE', [10898]], ['glj', [10916]], ['gnap', [10890]], ['gnapprox', [10890]], ['gne', [10888]], ['gnE', [8809]], ['gneq', [10888]], ['gneqq', [8809]], ['gnsim', [8935]], ['Gopf', [120126]], ['gopf', [120152]], ['grave', [96]], ['GreaterEqual', [8805]], ['GreaterEqualLess', [8923]], ['GreaterFullEqual', [8807]], ['GreaterGreater', [10914]], ['GreaterLess', [8823]], ['GreaterSlantEqual', [10878]], ['GreaterTilde', [8819]], ['Gscr', [119970]], ['gscr', [8458]], ['gsim', [8819]], ['gsime', [10894]], ['gsiml', [10896]], ['gtcc', [10919]], ['gtcir', [10874]], ['gt', [62]], ['GT', [62]], ['Gt', [8811]], ['gtdot', [8919]], ['gtlPar', [10645]], ['gtquest', [10876]], ['gtrapprox', [10886]], ['gtrarr', [10616]], ['gtrdot', [8919]], ['gtreqless', [8923]], ['gtreqqless', [10892]], ['gtrless', [8823]], ['gtrsim', [8819]], ['gvertneqq', [8809, 65024]], ['gvnE', [8809, 65024]], ['Hacek', [711]], ['hairsp', [8202]], ['half', [189]], ['hamilt', [8459]], ['HARDcy', [1066]], ['hardcy', [1098]], ['harrcir', [10568]], ['harr', [8596]], ['hArr', [8660]], ['harrw', [8621]], ['Hat', [94]], ['hbar', [8463]], ['Hcirc', [292]], ['hcirc', [293]], ['hearts', [9829]], ['heartsuit', [9829]], ['hellip', [8230]], ['hercon', [8889]], ['hfr', [120101]], ['Hfr', [8460]], ['HilbertSpace', [8459]], ['hksearow', [10533]], ['hkswarow', [10534]], ['hoarr', [8703]], ['homtht', [8763]], ['hookleftarrow', [8617]], ['hookrightarrow', [8618]], ['hopf', [120153]], ['Hopf', [8461]], ['horbar', [8213]], ['HorizontalLine', [9472]], ['hscr', [119997]], ['Hscr', [8459]], ['hslash', [8463]], ['Hstrok', [294]], ['hstrok', [295]], ['HumpDownHump', [8782]], ['HumpEqual', [8783]], ['hybull', [8259]], ['hyphen', [8208]], ['Iacute', [205]], ['iacute', [237]], ['ic', [8291]], ['Icirc', [206]], ['icirc', [238]], ['Icy', [1048]], ['icy', [1080]], ['Idot', [304]], ['IEcy', [1045]], ['iecy', [1077]], ['iexcl', [161]], ['iff', [8660]], ['ifr', [120102]], ['Ifr', [8465]], ['Igrave', [204]], ['igrave', [236]], ['ii', [8520]], ['iiiint', [10764]], ['iiint', [8749]], ['iinfin', [10716]], ['iiota', [8489]], ['IJlig', [306]], ['ijlig', [307]], ['Imacr', [298]], ['imacr', [299]], ['image', [8465]], ['ImaginaryI', [8520]], ['imagline', [8464]], ['imagpart', [8465]], ['imath', [305]], ['Im', [8465]], ['imof', [8887]], ['imped', [437]], ['Implies', [8658]], ['incare', [8453]], ['in', [8712]], ['infin', [8734]], ['infintie', [10717]], ['inodot', [305]], ['intcal', [8890]], ['int', [8747]], ['Int', [8748]], ['integers', [8484]], ['Integral', [8747]], ['intercal', [8890]], ['Intersection', [8898]], ['intlarhk', [10775]], ['intprod', [10812]], ['InvisibleComma', [8291]], ['InvisibleTimes', [8290]], ['IOcy', [1025]], ['iocy', [1105]], ['Iogon', [302]], ['iogon', [303]], ['Iopf', [120128]], ['iopf', [120154]], ['Iota', [921]], ['iota', [953]], ['iprod', [10812]], ['iquest', [191]], ['iscr', [119998]], ['Iscr', [8464]], ['isin', [8712]], ['isindot', [8949]], ['isinE', [8953]], ['isins', [8948]], ['isinsv', [8947]], ['isinv', [8712]], ['it', [8290]], ['Itilde', [296]], ['itilde', [297]], ['Iukcy', [1030]], ['iukcy', [1110]], ['Iuml', [207]], ['iuml', [239]], ['Jcirc', [308]], ['jcirc', [309]], ['Jcy', [1049]], ['jcy', [1081]], ['Jfr', [120077]], ['jfr', [120103]], ['jmath', [567]], ['Jopf', [120129]], ['jopf', [120155]], ['Jscr', [119973]], ['jscr', [119999]], ['Jsercy', [1032]], ['jsercy', [1112]], ['Jukcy', [1028]], ['jukcy', [1108]], ['Kappa', [922]], ['kappa', [954]], ['kappav', [1008]], ['Kcedil', [310]], ['kcedil', [311]], ['Kcy', [1050]], ['kcy', [1082]], ['Kfr', [120078]], ['kfr', [120104]], ['kgreen', [312]], ['KHcy', [1061]], ['khcy', [1093]], ['KJcy', [1036]], ['kjcy', [1116]], ['Kopf', [120130]], ['kopf', [120156]], ['Kscr', [119974]], ['kscr', [120000]], ['lAarr', [8666]], ['Lacute', [313]], ['lacute', [314]], ['laemptyv', [10676]], ['lagran', [8466]], ['Lambda', [923]], ['lambda', [955]], ['lang', [10216]], ['Lang', [10218]], ['langd', [10641]], ['langle', [10216]], ['lap', [10885]], ['Laplacetrf', [8466]], ['laquo', [171]], ['larrb', [8676]], ['larrbfs', [10527]], ['larr', [8592]], ['Larr', [8606]], ['lArr', [8656]], ['larrfs', [10525]], ['larrhk', [8617]], ['larrlp', [8619]], ['larrpl', [10553]], ['larrsim', [10611]], ['larrtl', [8610]], ['latail', [10521]], ['lAtail', [10523]], ['lat', [10923]], ['late', [10925]], ['lates', [10925, 65024]], ['lbarr', [10508]], ['lBarr', [10510]], ['lbbrk', [10098]], ['lbrace', [123]], ['lbrack', [91]], ['lbrke', [10635]], ['lbrksld', [10639]], ['lbrkslu', [10637]], ['Lcaron', [317]], ['lcaron', [318]], ['Lcedil', [315]], ['lcedil', [316]], ['lceil', [8968]], ['lcub', [123]], ['Lcy', [1051]], ['lcy', [1083]], ['ldca', [10550]], ['ldquo', [8220]], ['ldquor', [8222]], ['ldrdhar', [10599]], ['ldrushar', [10571]], ['ldsh', [8626]], ['le', [8804]], ['lE', [8806]], ['LeftAngleBracket', [10216]], ['LeftArrowBar', [8676]], ['leftarrow', [8592]], ['LeftArrow', [8592]], ['Leftarrow', [8656]], ['LeftArrowRightArrow', [8646]], ['leftarrowtail', [8610]], ['LeftCeiling', [8968]], ['LeftDoubleBracket', [10214]], ['LeftDownTeeVector', [10593]], ['LeftDownVectorBar', [10585]], ['LeftDownVector', [8643]], ['LeftFloor', [8970]], ['leftharpoondown', [8637]], ['leftharpoonup', [8636]], ['leftleftarrows', [8647]], ['leftrightarrow', [8596]], ['LeftRightArrow', [8596]], ['Leftrightarrow', [8660]], ['leftrightarrows', [8646]], ['leftrightharpoons', [8651]], ['leftrightsquigarrow', [8621]], ['LeftRightVector', [10574]], ['LeftTeeArrow', [8612]], ['LeftTee', [8867]], ['LeftTeeVector', [10586]], ['leftthreetimes', [8907]], ['LeftTriangleBar', [10703]], ['LeftTriangle', [8882]], ['LeftTriangleEqual', [8884]], ['LeftUpDownVector', [10577]], ['LeftUpTeeVector', [10592]], ['LeftUpVectorBar', [10584]], ['LeftUpVector', [8639]], ['LeftVectorBar', [10578]], ['LeftVector', [8636]], ['lEg', [10891]], ['leg', [8922]], ['leq', [8804]], ['leqq', [8806]], ['leqslant', [10877]], ['lescc', [10920]], ['les', [10877]], ['lesdot', [10879]], ['lesdoto', [10881]], ['lesdotor', [10883]], ['lesg', [8922, 65024]], ['lesges', [10899]], ['lessapprox', [10885]], ['lessdot', [8918]], ['lesseqgtr', [8922]], ['lesseqqgtr', [10891]], ['LessEqualGreater', [8922]], ['LessFullEqual', [8806]], ['LessGreater', [8822]], ['lessgtr', [8822]], ['LessLess', [10913]], ['lesssim', [8818]], ['LessSlantEqual', [10877]], ['LessTilde', [8818]], ['lfisht', [10620]], ['lfloor', [8970]], ['Lfr', [120079]], ['lfr', [120105]], ['lg', [8822]], ['lgE', [10897]], ['lHar', [10594]], ['lhard', [8637]], ['lharu', [8636]], ['lharul', [10602]], ['lhblk', [9604]], ['LJcy', [1033]], ['ljcy', [1113]], ['llarr', [8647]], ['ll', [8810]], ['Ll', [8920]], ['llcorner', [8990]], ['Lleftarrow', [8666]], ['llhard', [10603]], ['lltri', [9722]], ['Lmidot', [319]], ['lmidot', [320]], ['lmoustache', [9136]], ['lmoust', [9136]], ['lnap', [10889]], ['lnapprox', [10889]], ['lne', [10887]], ['lnE', [8808]], ['lneq', [10887]], ['lneqq', [8808]], ['lnsim', [8934]], ['loang', [10220]], ['loarr', [8701]], ['lobrk', [10214]], ['longleftarrow', [10229]], ['LongLeftArrow', [10229]], ['Longleftarrow', [10232]], ['longleftrightarrow', [10231]], ['LongLeftRightArrow', [10231]], ['Longleftrightarrow', [10234]], ['longmapsto', [10236]], ['longrightarrow', [10230]], ['LongRightArrow', [10230]], ['Longrightarrow', [10233]], ['looparrowleft', [8619]], ['looparrowright', [8620]], ['lopar', [10629]], ['Lopf', [120131]], ['lopf', [120157]], ['loplus', [10797]], ['lotimes', [10804]], ['lowast', [8727]], ['lowbar', [95]], ['LowerLeftArrow', [8601]], ['LowerRightArrow', [8600]], ['loz', [9674]], ['lozenge', [9674]], ['lozf', [10731]], ['lpar', [40]], ['lparlt', [10643]], ['lrarr', [8646]], ['lrcorner', [8991]], ['lrhar', [8651]], ['lrhard', [10605]], ['lrm', [8206]], ['lrtri', [8895]], ['lsaquo', [8249]], ['lscr', [120001]], ['Lscr', [8466]], ['lsh', [8624]], ['Lsh', [8624]], ['lsim', [8818]], ['lsime', [10893]], ['lsimg', [10895]], ['lsqb', [91]], ['lsquo', [8216]], ['lsquor', [8218]], ['Lstrok', [321]], ['lstrok', [322]], ['ltcc', [10918]], ['ltcir', [10873]], ['lt', [60]], ['LT', [60]], ['Lt', [8810]], ['ltdot', [8918]], ['lthree', [8907]], ['ltimes', [8905]], ['ltlarr', [10614]], ['ltquest', [10875]], ['ltri', [9667]], ['ltrie', [8884]], ['ltrif', [9666]], ['ltrPar', [10646]], ['lurdshar', [10570]], ['luruhar', [10598]], ['lvertneqq', [8808, 65024]], ['lvnE', [8808, 65024]], ['macr', [175]], ['male', [9794]], ['malt', [10016]], ['maltese', [10016]], ['Map', [10501]], ['map', [8614]], ['mapsto', [8614]], ['mapstodown', [8615]], ['mapstoleft', [8612]], ['mapstoup', [8613]], ['marker', [9646]], ['mcomma', [10793]], ['Mcy', [1052]], ['mcy', [1084]], ['mdash', [8212]], ['mDDot', [8762]], ['measuredangle', [8737]], ['MediumSpace', [8287]], ['Mellintrf', [8499]], ['Mfr', [120080]], ['mfr', [120106]], ['mho', [8487]], ['micro', [181]], ['midast', [42]], ['midcir', [10992]], ['mid', [8739]], ['middot', [183]], ['minusb', [8863]], ['minus', [8722]], ['minusd', [8760]], ['minusdu', [10794]], ['MinusPlus', [8723]], ['mlcp', [10971]], ['mldr', [8230]], ['mnplus', [8723]], ['models', [8871]], ['Mopf', [120132]], ['mopf', [120158]], ['mp', [8723]], ['mscr', [120002]], ['Mscr', [8499]], ['mstpos', [8766]], ['Mu', [924]], ['mu', [956]], ['multimap', [8888]], ['mumap', [8888]], ['nabla', [8711]], ['Nacute', [323]], ['nacute', [324]], ['nang', [8736, 8402]], ['nap', [8777]], ['napE', [10864, 824]], ['napid', [8779, 824]], ['napos', [329]], ['napprox', [8777]], ['natural', [9838]], ['naturals', [8469]], ['natur', [9838]], ['nbsp', [160]], ['nbump', [8782, 824]], ['nbumpe', [8783, 824]], ['ncap', [10819]], ['Ncaron', [327]], ['ncaron', [328]], ['Ncedil', [325]], ['ncedil', [326]], ['ncong', [8775]], ['ncongdot', [10861, 824]], ['ncup', [10818]], ['Ncy', [1053]], ['ncy', [1085]], ['ndash', [8211]], ['nearhk', [10532]], ['nearr', [8599]], ['neArr', [8663]], ['nearrow', [8599]], ['ne', [8800]], ['nedot', [8784, 824]], ['NegativeMediumSpace', [8203]], ['NegativeThickSpace', [8203]], ['NegativeThinSpace', [8203]], ['NegativeVeryThinSpace', [8203]], ['nequiv', [8802]], ['nesear', [10536]], ['nesim', [8770, 824]], ['NestedGreaterGreater', [8811]], ['NestedLessLess', [8810]], ['nexist', [8708]], ['nexists', [8708]], ['Nfr', [120081]], ['nfr', [120107]], ['ngE', [8807, 824]], ['nge', [8817]], ['ngeq', [8817]], ['ngeqq', [8807, 824]], ['ngeqslant', [10878, 824]], ['nges', [10878, 824]], ['nGg', [8921, 824]], ['ngsim', [8821]], ['nGt', [8811, 8402]], ['ngt', [8815]], ['ngtr', [8815]], ['nGtv', [8811, 824]], ['nharr', [8622]], ['nhArr', [8654]], ['nhpar', [10994]], ['ni', [8715]], ['nis', [8956]], ['nisd', [8954]], ['niv', [8715]], ['NJcy', [1034]], ['njcy', [1114]], ['nlarr', [8602]], ['nlArr', [8653]], ['nldr', [8229]], ['nlE', [8806, 824]], ['nle', [8816]], ['nleftarrow', [8602]], ['nLeftarrow', [8653]], ['nleftrightarrow', [8622]], ['nLeftrightarrow', [8654]], ['nleq', [8816]], ['nleqq', [8806, 824]], ['nleqslant', [10877, 824]], ['nles', [10877, 824]], ['nless', [8814]], ['nLl', [8920, 824]], ['nlsim', [8820]], ['nLt', [8810, 8402]], ['nlt', [8814]], ['nltri', [8938]], ['nltrie', [8940]], ['nLtv', [8810, 824]], ['nmid', [8740]], ['NoBreak', [8288]], ['NonBreakingSpace', [160]], ['nopf', [120159]], ['Nopf', [8469]], ['Not', [10988]], ['not', [172]], ['NotCongruent', [8802]], ['NotCupCap', [8813]], ['NotDoubleVerticalBar', [8742]], ['NotElement', [8713]], ['NotEqual', [8800]], ['NotEqualTilde', [8770, 824]], ['NotExists', [8708]], ['NotGreater', [8815]], ['NotGreaterEqual', [8817]], ['NotGreaterFullEqual', [8807, 824]], ['NotGreaterGreater', [8811, 824]], ['NotGreaterLess', [8825]], ['NotGreaterSlantEqual', [10878, 824]], ['NotGreaterTilde', [8821]], ['NotHumpDownHump', [8782, 824]], ['NotHumpEqual', [8783, 824]], ['notin', [8713]], ['notindot', [8949, 824]], ['notinE', [8953, 824]], ['notinva', [8713]], ['notinvb', [8951]], ['notinvc', [8950]], ['NotLeftTriangleBar', [10703, 824]], ['NotLeftTriangle', [8938]], ['NotLeftTriangleEqual', [8940]], ['NotLess', [8814]], ['NotLessEqual', [8816]], ['NotLessGreater', [8824]], ['NotLessLess', [8810, 824]], ['NotLessSlantEqual', [10877, 824]], ['NotLessTilde', [8820]], ['NotNestedGreaterGreater', [10914, 824]], ['NotNestedLessLess', [10913, 824]], ['notni', [8716]], ['notniva', [8716]], ['notnivb', [8958]], ['notnivc', [8957]], ['NotPrecedes', [8832]], ['NotPrecedesEqual', [10927, 824]], ['NotPrecedesSlantEqual', [8928]], ['NotReverseElement', [8716]], ['NotRightTriangleBar', [10704, 824]], ['NotRightTriangle', [8939]], ['NotRightTriangleEqual', [8941]], ['NotSquareSubset', [8847, 824]], ['NotSquareSubsetEqual', [8930]], ['NotSquareSuperset', [8848, 824]], ['NotSquareSupersetEqual', [8931]], ['NotSubset', [8834, 8402]], ['NotSubsetEqual', [8840]], ['NotSucceeds', [8833]], ['NotSucceedsEqual', [10928, 824]], ['NotSucceedsSlantEqual', [8929]], ['NotSucceedsTilde', [8831, 824]], ['NotSuperset', [8835, 8402]], ['NotSupersetEqual', [8841]], ['NotTilde', [8769]], ['NotTildeEqual', [8772]], ['NotTildeFullEqual', [8775]], ['NotTildeTilde', [8777]], ['NotVerticalBar', [8740]], ['nparallel', [8742]], ['npar', [8742]], ['nparsl', [11005, 8421]], ['npart', [8706, 824]], ['npolint', [10772]], ['npr', [8832]], ['nprcue', [8928]], ['nprec', [8832]], ['npreceq', [10927, 824]], ['npre', [10927, 824]], ['nrarrc', [10547, 824]], ['nrarr', [8603]], ['nrArr', [8655]], ['nrarrw', [8605, 824]], ['nrightarrow', [8603]], ['nRightarrow', [8655]], ['nrtri', [8939]], ['nrtrie', [8941]], ['nsc', [8833]], ['nsccue', [8929]], ['nsce', [10928, 824]], ['Nscr', [119977]], ['nscr', [120003]], ['nshortmid', [8740]], ['nshortparallel', [8742]], ['nsim', [8769]], ['nsime', [8772]], ['nsimeq', [8772]], ['nsmid', [8740]], ['nspar', [8742]], ['nsqsube', [8930]], ['nsqsupe', [8931]], ['nsub', [8836]], ['nsubE', [10949, 824]], ['nsube', [8840]], ['nsubset', [8834, 8402]], ['nsubseteq', [8840]], ['nsubseteqq', [10949, 824]], ['nsucc', [8833]], ['nsucceq', [10928, 824]], ['nsup', [8837]], ['nsupE', [10950, 824]], ['nsupe', [8841]], ['nsupset', [8835, 8402]], ['nsupseteq', [8841]], ['nsupseteqq', [10950, 824]], ['ntgl', [8825]], ['Ntilde', [209]], ['ntilde', [241]], ['ntlg', [8824]], ['ntriangleleft', [8938]], ['ntrianglelefteq', [8940]], ['ntriangleright', [8939]], ['ntrianglerighteq', [8941]], ['Nu', [925]], ['nu', [957]], ['num', [35]], ['numero', [8470]], ['numsp', [8199]], ['nvap', [8781, 8402]], ['nvdash', [8876]], ['nvDash', [8877]], ['nVdash', [8878]], ['nVDash', [8879]], ['nvge', [8805, 8402]], ['nvgt', [62, 8402]], ['nvHarr', [10500]], ['nvinfin', [10718]], ['nvlArr', [10498]], ['nvle', [8804, 8402]], ['nvlt', [60, 8402]], ['nvltrie', [8884, 8402]], ['nvrArr', [10499]], ['nvrtrie', [8885, 8402]], ['nvsim', [8764, 8402]], ['nwarhk', [10531]], ['nwarr', [8598]], ['nwArr', [8662]], ['nwarrow', [8598]], ['nwnear', [10535]], ['Oacute', [211]], ['oacute', [243]], ['oast', [8859]], ['Ocirc', [212]], ['ocirc', [244]], ['ocir', [8858]], ['Ocy', [1054]], ['ocy', [1086]], ['odash', [8861]], ['Odblac', [336]], ['odblac', [337]], ['odiv', [10808]], ['odot', [8857]], ['odsold', [10684]], ['OElig', [338]], ['oelig', [339]], ['ofcir', [10687]], ['Ofr', [120082]], ['ofr', [120108]], ['ogon', [731]], ['Ograve', [210]], ['ograve', [242]], ['ogt', [10689]], ['ohbar', [10677]], ['ohm', [937]], ['oint', [8750]], ['olarr', [8634]], ['olcir', [10686]], ['olcross', [10683]], ['oline', [8254]], ['olt', [10688]], ['Omacr', [332]], ['omacr', [333]], ['Omega', [937]], ['omega', [969]], ['Omicron', [927]], ['omicron', [959]], ['omid', [10678]], ['ominus', [8854]], ['Oopf', [120134]], ['oopf', [120160]], ['opar', [10679]], ['OpenCurlyDoubleQuote', [8220]], ['OpenCurlyQuote', [8216]], ['operp', [10681]], ['oplus', [8853]], ['orarr', [8635]], ['Or', [10836]], ['or', [8744]], ['ord', [10845]], ['order', [8500]], ['orderof', [8500]], ['ordf', [170]], ['ordm', [186]], ['origof', [8886]], ['oror', [10838]], ['orslope', [10839]], ['orv', [10843]], ['oS', [9416]], ['Oscr', [119978]], ['oscr', [8500]], ['Oslash', [216]], ['oslash', [248]], ['osol', [8856]], ['Otilde', [213]], ['otilde', [245]], ['otimesas', [10806]], ['Otimes', [10807]], ['otimes', [8855]], ['Ouml', [214]], ['ouml', [246]], ['ovbar', [9021]], ['OverBar', [8254]], ['OverBrace', [9182]], ['OverBracket', [9140]], ['OverParenthesis', [9180]], ['para', [182]], ['parallel', [8741]], ['par', [8741]], ['parsim', [10995]], ['parsl', [11005]], ['part', [8706]], ['PartialD', [8706]], ['Pcy', [1055]], ['pcy', [1087]], ['percnt', [37]], ['period', [46]], ['permil', [8240]], ['perp', [8869]], ['pertenk', [8241]], ['Pfr', [120083]], ['pfr', [120109]], ['Phi', [934]], ['phi', [966]], ['phiv', [981]], ['phmmat', [8499]], ['phone', [9742]], ['Pi', [928]], ['pi', [960]], ['pitchfork', [8916]], ['piv', [982]], ['planck', [8463]], ['planckh', [8462]], ['plankv', [8463]], ['plusacir', [10787]], ['plusb', [8862]], ['pluscir', [10786]], ['plus', [43]], ['plusdo', [8724]], ['plusdu', [10789]], ['pluse', [10866]], ['PlusMinus', [177]], ['plusmn', [177]], ['plussim', [10790]], ['plustwo', [10791]], ['pm', [177]], ['Poincareplane', [8460]], ['pointint', [10773]], ['popf', [120161]], ['Popf', [8473]], ['pound', [163]], ['prap', [10935]], ['Pr', [10939]], ['pr', [8826]], ['prcue', [8828]], ['precapprox', [10935]], ['prec', [8826]], ['preccurlyeq', [8828]], ['Precedes', [8826]], ['PrecedesEqual', [10927]], ['PrecedesSlantEqual', [8828]], ['PrecedesTilde', [8830]], ['preceq', [10927]], ['precnapprox', [10937]], ['precneqq', [10933]], ['precnsim', [8936]], ['pre', [10927]], ['prE', [10931]], ['precsim', [8830]], ['prime', [8242]], ['Prime', [8243]], ['primes', [8473]], ['prnap', [10937]], ['prnE', [10933]], ['prnsim', [8936]], ['prod', [8719]], ['Product', [8719]], ['profalar', [9006]], ['profline', [8978]], ['profsurf', [8979]], ['prop', [8733]], ['Proportional', [8733]], ['Proportion', [8759]], ['propto', [8733]], ['prsim', [8830]], ['prurel', [8880]], ['Pscr', [119979]], ['pscr', [120005]], ['Psi', [936]], ['psi', [968]], ['puncsp', [8200]], ['Qfr', [120084]], ['qfr', [120110]], ['qint', [10764]], ['qopf', [120162]], ['Qopf', [8474]], ['qprime', [8279]], ['Qscr', [119980]], ['qscr', [120006]], ['quaternions', [8461]], ['quatint', [10774]], ['quest', [63]], ['questeq', [8799]], ['quot', [34]], ['QUOT', [34]], ['rAarr', [8667]], ['race', [8765, 817]], ['Racute', [340]], ['racute', [341]], ['radic', [8730]], ['raemptyv', [10675]], ['rang', [10217]], ['Rang', [10219]], ['rangd', [10642]], ['range', [10661]], ['rangle', [10217]], ['raquo', [187]], ['rarrap', [10613]], ['rarrb', [8677]], ['rarrbfs', [10528]], ['rarrc', [10547]], ['rarr', [8594]], ['Rarr', [8608]], ['rArr', [8658]], ['rarrfs', [10526]], ['rarrhk', [8618]], ['rarrlp', [8620]], ['rarrpl', [10565]], ['rarrsim', [10612]], ['Rarrtl', [10518]], ['rarrtl', [8611]], ['rarrw', [8605]], ['ratail', [10522]], ['rAtail', [10524]], ['ratio', [8758]], ['rationals', [8474]], ['rbarr', [10509]], ['rBarr', [10511]], ['RBarr', [10512]], ['rbbrk', [10099]], ['rbrace', [125]], ['rbrack', [93]], ['rbrke', [10636]], ['rbrksld', [10638]], ['rbrkslu', [10640]], ['Rcaron', [344]], ['rcaron', [345]], ['Rcedil', [342]], ['rcedil', [343]], ['rceil', [8969]], ['rcub', [125]], ['Rcy', [1056]], ['rcy', [1088]], ['rdca', [10551]], ['rdldhar', [10601]], ['rdquo', [8221]], ['rdquor', [8221]], ['CloseCurlyDoubleQuote', [8221]], ['rdsh', [8627]], ['real', [8476]], ['realine', [8475]], ['realpart', [8476]], ['reals', [8477]], ['Re', [8476]], ['rect', [9645]], ['reg', [174]], ['REG', [174]], ['ReverseElement', [8715]], ['ReverseEquilibrium', [8651]], ['ReverseUpEquilibrium', [10607]], ['rfisht', [10621]], ['rfloor', [8971]], ['rfr', [120111]], ['Rfr', [8476]], ['rHar', [10596]], ['rhard', [8641]], ['rharu', [8640]], ['rharul', [10604]], ['Rho', [929]], ['rho', [961]], ['rhov', [1009]], ['RightAngleBracket', [10217]], ['RightArrowBar', [8677]], ['rightarrow', [8594]], ['RightArrow', [8594]], ['Rightarrow', [8658]], ['RightArrowLeftArrow', [8644]], ['rightarrowtail', [8611]], ['RightCeiling', [8969]], ['RightDoubleBracket', [10215]], ['RightDownTeeVector', [10589]], ['RightDownVectorBar', [10581]], ['RightDownVector', [8642]], ['RightFloor', [8971]], ['rightharpoondown', [8641]], ['rightharpoonup', [8640]], ['rightleftarrows', [8644]], ['rightleftharpoons', [8652]], ['rightrightarrows', [8649]], ['rightsquigarrow', [8605]], ['RightTeeArrow', [8614]], ['RightTee', [8866]], ['RightTeeVector', [10587]], ['rightthreetimes', [8908]], ['RightTriangleBar', [10704]], ['RightTriangle', [8883]], ['RightTriangleEqual', [8885]], ['RightUpDownVector', [10575]], ['RightUpTeeVector', [10588]], ['RightUpVectorBar', [10580]], ['RightUpVector', [8638]], ['RightVectorBar', [10579]], ['RightVector', [8640]], ['ring', [730]], ['risingdotseq', [8787]], ['rlarr', [8644]], ['rlhar', [8652]], ['rlm', [8207]], ['rmoustache', [9137]], ['rmoust', [9137]], ['rnmid', [10990]], ['roang', [10221]], ['roarr', [8702]], ['robrk', [10215]], ['ropar', [10630]], ['ropf', [120163]], ['Ropf', [8477]], ['roplus', [10798]], ['rotimes', [10805]], ['RoundImplies', [10608]], ['rpar', [41]], ['rpargt', [10644]], ['rppolint', [10770]], ['rrarr', [8649]], ['Rrightarrow', [8667]], ['rsaquo', [8250]], ['rscr', [120007]], ['Rscr', [8475]], ['rsh', [8625]], ['Rsh', [8625]], ['rsqb', [93]], ['rsquo', [8217]], ['rsquor', [8217]], ['CloseCurlyQuote', [8217]], ['rthree', [8908]], ['rtimes', [8906]], ['rtri', [9657]], ['rtrie', [8885]], ['rtrif', [9656]], ['rtriltri', [10702]], ['RuleDelayed', [10740]], ['ruluhar', [10600]], ['rx', [8478]], ['Sacute', [346]], ['sacute', [347]], ['sbquo', [8218]], ['scap', [10936]], ['Scaron', [352]], ['scaron', [353]], ['Sc', [10940]], ['sc', [8827]], ['sccue', [8829]], ['sce', [10928]], ['scE', [10932]], ['Scedil', [350]], ['scedil', [351]], ['Scirc', [348]], ['scirc', [349]], ['scnap', [10938]], ['scnE', [10934]], ['scnsim', [8937]], ['scpolint', [10771]], ['scsim', [8831]], ['Scy', [1057]], ['scy', [1089]], ['sdotb', [8865]], ['sdot', [8901]], ['sdote', [10854]], ['searhk', [10533]], ['searr', [8600]], ['seArr', [8664]], ['searrow', [8600]], ['sect', [167]], ['semi', [59]], ['seswar', [10537]], ['setminus', [8726]], ['setmn', [8726]], ['sext', [10038]], ['Sfr', [120086]], ['sfr', [120112]], ['sfrown', [8994]], ['sharp', [9839]], ['SHCHcy', [1065]], ['shchcy', [1097]], ['SHcy', [1064]], ['shcy', [1096]], ['ShortDownArrow', [8595]], ['ShortLeftArrow', [8592]], ['shortmid', [8739]], ['shortparallel', [8741]], ['ShortRightArrow', [8594]], ['ShortUpArrow', [8593]], ['shy', [173]], ['Sigma', [931]], ['sigma', [963]], ['sigmaf', [962]], ['sigmav', [962]], ['sim', [8764]], ['simdot', [10858]], ['sime', [8771]], ['simeq', [8771]], ['simg', [10910]], ['simgE', [10912]], ['siml', [10909]], ['simlE', [10911]], ['simne', [8774]], ['simplus', [10788]], ['simrarr', [10610]], ['slarr', [8592]], ['SmallCircle', [8728]], ['smallsetminus', [8726]], ['smashp', [10803]], ['smeparsl', [10724]], ['smid', [8739]], ['smile', [8995]], ['smt', [10922]], ['smte', [10924]], ['smtes', [10924, 65024]], ['SOFTcy', [1068]], ['softcy', [1100]], ['solbar', [9023]], ['solb', [10692]], ['sol', [47]], ['Sopf', [120138]], ['sopf', [120164]], ['spades', [9824]], ['spadesuit', [9824]], ['spar', [8741]], ['sqcap', [8851]], ['sqcaps', [8851, 65024]], ['sqcup', [8852]], ['sqcups', [8852, 65024]], ['Sqrt', [8730]], ['sqsub', [8847]], ['sqsube', [8849]], ['sqsubset', [8847]], ['sqsubseteq', [8849]], ['sqsup', [8848]], ['sqsupe', [8850]], ['sqsupset', [8848]], ['sqsupseteq', [8850]], ['square', [9633]], ['Square', [9633]], ['SquareIntersection', [8851]], ['SquareSubset', [8847]], ['SquareSubsetEqual', [8849]], ['SquareSuperset', [8848]], ['SquareSupersetEqual', [8850]], ['SquareUnion', [8852]], ['squarf', [9642]], ['squ', [9633]], ['squf', [9642]], ['srarr', [8594]], ['Sscr', [119982]], ['sscr', [120008]], ['ssetmn', [8726]], ['ssmile', [8995]], ['sstarf', [8902]], ['Star', [8902]], ['star', [9734]], ['starf', [9733]], ['straightepsilon', [1013]], ['straightphi', [981]], ['strns', [175]], ['sub', [8834]], ['Sub', [8912]], ['subdot', [10941]], ['subE', [10949]], ['sube', [8838]], ['subedot', [10947]], ['submult', [10945]], ['subnE', [10955]], ['subne', [8842]], ['subplus', [10943]], ['subrarr', [10617]], ['subset', [8834]], ['Subset', [8912]], ['subseteq', [8838]], ['subseteqq', [10949]], ['SubsetEqual', [8838]], ['subsetneq', [8842]], ['subsetneqq', [10955]], ['subsim', [10951]], ['subsub', [10965]], ['subsup', [10963]], ['succapprox', [10936]], ['succ', [8827]], ['succcurlyeq', [8829]], ['Succeeds', [8827]], ['SucceedsEqual', [10928]], ['SucceedsSlantEqual', [8829]], ['SucceedsTilde', [8831]], ['succeq', [10928]], ['succnapprox', [10938]], ['succneqq', [10934]], ['succnsim', [8937]], ['succsim', [8831]], ['SuchThat', [8715]], ['sum', [8721]], ['Sum', [8721]], ['sung', [9834]], ['sup1', [185]], ['sup2', [178]], ['sup3', [179]], ['sup', [8835]], ['Sup', [8913]], ['supdot', [10942]], ['supdsub', [10968]], ['supE', [10950]], ['supe', [8839]], ['supedot', [10948]], ['Superset', [8835]], ['SupersetEqual', [8839]], ['suphsol', [10185]], ['suphsub', [10967]], ['suplarr', [10619]], ['supmult', [10946]], ['supnE', [10956]], ['supne', [8843]], ['supplus', [10944]], ['supset', [8835]], ['Supset', [8913]], ['supseteq', [8839]], ['supseteqq', [10950]], ['supsetneq', [8843]], ['supsetneqq', [10956]], ['supsim', [10952]], ['supsub', [10964]], ['supsup', [10966]], ['swarhk', [10534]], ['swarr', [8601]], ['swArr', [8665]], ['swarrow', [8601]], ['swnwar', [10538]], ['szlig', [223]], ['Tab', [9]], ['target', [8982]], ['Tau', [932]], ['tau', [964]], ['tbrk', [9140]], ['Tcaron', [356]], ['tcaron', [357]], ['Tcedil', [354]], ['tcedil', [355]], ['Tcy', [1058]], ['tcy', [1090]], ['tdot', [8411]], ['telrec', [8981]], ['Tfr', [120087]], ['tfr', [120113]], ['there4', [8756]], ['therefore', [8756]], ['Therefore', [8756]], ['Theta', [920]], ['theta', [952]], ['thetasym', [977]], ['thetav', [977]], ['thickapprox', [8776]], ['thicksim', [8764]], ['ThickSpace', [8287, 8202]], ['ThinSpace', [8201]], ['thinsp', [8201]], ['thkap', [8776]], ['thksim', [8764]], ['THORN', [222]], ['thorn', [254]], ['tilde', [732]], ['Tilde', [8764]], ['TildeEqual', [8771]], ['TildeFullEqual', [8773]], ['TildeTilde', [8776]], ['timesbar', [10801]], ['timesb', [8864]], ['times', [215]], ['timesd', [10800]], ['tint', [8749]], ['toea', [10536]], ['topbot', [9014]], ['topcir', [10993]], ['top', [8868]], ['Topf', [120139]], ['topf', [120165]], ['topfork', [10970]], ['tosa', [10537]], ['tprime', [8244]], ['trade', [8482]], ['TRADE', [8482]], ['triangle', [9653]], ['triangledown', [9663]], ['triangleleft', [9667]], ['trianglelefteq', [8884]], ['triangleq', [8796]], ['triangleright', [9657]], ['trianglerighteq', [8885]], ['tridot', [9708]], ['trie', [8796]], ['triminus', [10810]], ['TripleDot', [8411]], ['triplus', [10809]], ['trisb', [10701]], ['tritime', [10811]], ['trpezium', [9186]], ['Tscr', [119983]], ['tscr', [120009]], ['TScy', [1062]], ['tscy', [1094]], ['TSHcy', [1035]], ['tshcy', [1115]], ['Tstrok', [358]], ['tstrok', [359]], ['twixt', [8812]], ['twoheadleftarrow', [8606]], ['twoheadrightarrow', [8608]], ['Uacute', [218]], ['uacute', [250]], ['uarr', [8593]], ['Uarr', [8607]], ['uArr', [8657]], ['Uarrocir', [10569]], ['Ubrcy', [1038]], ['ubrcy', [1118]], ['Ubreve', [364]], ['ubreve', [365]], ['Ucirc', [219]], ['ucirc', [251]], ['Ucy', [1059]], ['ucy', [1091]], ['udarr', [8645]], ['Udblac', [368]], ['udblac', [369]], ['udhar', [10606]], ['ufisht', [10622]], ['Ufr', [120088]], ['ufr', [120114]], ['Ugrave', [217]], ['ugrave', [249]], ['uHar', [10595]], ['uharl', [8639]], ['uharr', [8638]], ['uhblk', [9600]], ['ulcorn', [8988]], ['ulcorner', [8988]], ['ulcrop', [8975]], ['ultri', [9720]], ['Umacr', [362]], ['umacr', [363]], ['uml', [168]], ['UnderBar', [95]], ['UnderBrace', [9183]], ['UnderBracket', [9141]], ['UnderParenthesis', [9181]], ['Union', [8899]], ['UnionPlus', [8846]], ['Uogon', [370]], ['uogon', [371]], ['Uopf', [120140]], ['uopf', [120166]], ['UpArrowBar', [10514]], ['uparrow', [8593]], ['UpArrow', [8593]], ['Uparrow', [8657]], ['UpArrowDownArrow', [8645]], ['updownarrow', [8597]], ['UpDownArrow', [8597]], ['Updownarrow', [8661]], ['UpEquilibrium', [10606]], ['upharpoonleft', [8639]], ['upharpoonright', [8638]], ['uplus', [8846]], ['UpperLeftArrow', [8598]], ['UpperRightArrow', [8599]], ['upsi', [965]], ['Upsi', [978]], ['upsih', [978]], ['Upsilon', [933]], ['upsilon', [965]], ['UpTeeArrow', [8613]], ['UpTee', [8869]], ['upuparrows', [8648]], ['urcorn', [8989]], ['urcorner', [8989]], ['urcrop', [8974]], ['Uring', [366]], ['uring', [367]], ['urtri', [9721]], ['Uscr', [119984]], ['uscr', [120010]], ['utdot', [8944]], ['Utilde', [360]], ['utilde', [361]], ['utri', [9653]], ['utrif', [9652]], ['uuarr', [8648]], ['Uuml', [220]], ['uuml', [252]], ['uwangle', [10663]], ['vangrt', [10652]], ['varepsilon', [1013]], ['varkappa', [1008]], ['varnothing', [8709]], ['varphi', [981]], ['varpi', [982]], ['varpropto', [8733]], ['varr', [8597]], ['vArr', [8661]], ['varrho', [1009]], ['varsigma', [962]], ['varsubsetneq', [8842, 65024]], ['varsubsetneqq', [10955, 65024]], ['varsupsetneq', [8843, 65024]], ['varsupsetneqq', [10956, 65024]], ['vartheta', [977]], ['vartriangleleft', [8882]], ['vartriangleright', [8883]], ['vBar', [10984]], ['Vbar', [10987]], ['vBarv', [10985]], ['Vcy', [1042]], ['vcy', [1074]], ['vdash', [8866]], ['vDash', [8872]], ['Vdash', [8873]], ['VDash', [8875]], ['Vdashl', [10982]], ['veebar', [8891]], ['vee', [8744]], ['Vee', [8897]], ['veeeq', [8794]], ['vellip', [8942]], ['verbar', [124]], ['Verbar', [8214]], ['vert', [124]], ['Vert', [8214]], ['VerticalBar', [8739]], ['VerticalLine', [124]], ['VerticalSeparator', [10072]], ['VerticalTilde', [8768]], ['VeryThinSpace', [8202]], ['Vfr', [120089]], ['vfr', [120115]], ['vltri', [8882]], ['vnsub', [8834, 8402]], ['vnsup', [8835, 8402]], ['Vopf', [120141]], ['vopf', [120167]], ['vprop', [8733]], ['vrtri', [8883]], ['Vscr', [119985]], ['vscr', [120011]], ['vsubnE', [10955, 65024]], ['vsubne', [8842, 65024]], ['vsupnE', [10956, 65024]], ['vsupne', [8843, 65024]], ['Vvdash', [8874]], ['vzigzag', [10650]], ['Wcirc', [372]], ['wcirc', [373]], ['wedbar', [10847]], ['wedge', [8743]], ['Wedge', [8896]], ['wedgeq', [8793]], ['weierp', [8472]], ['Wfr', [120090]], ['wfr', [120116]], ['Wopf', [120142]], ['wopf', [120168]], ['wp', [8472]], ['wr', [8768]], ['wreath', [8768]], ['Wscr', [119986]], ['wscr', [120012]], ['xcap', [8898]], ['xcirc', [9711]], ['xcup', [8899]], ['xdtri', [9661]], ['Xfr', [120091]], ['xfr', [120117]], ['xharr', [10231]], ['xhArr', [10234]], ['Xi', [926]], ['xi', [958]], ['xlarr', [10229]], ['xlArr', [10232]], ['xmap', [10236]], ['xnis', [8955]], ['xodot', [10752]], ['Xopf', [120143]], ['xopf', [120169]], ['xoplus', [10753]], ['xotime', [10754]], ['xrarr', [10230]], ['xrArr', [10233]], ['Xscr', [119987]], ['xscr', [120013]], ['xsqcup', [10758]], ['xuplus', [10756]], ['xutri', [9651]], ['xvee', [8897]], ['xwedge', [8896]], ['Yacute', [221]], ['yacute', [253]], ['YAcy', [1071]], ['yacy', [1103]], ['Ycirc', [374]], ['ycirc', [375]], ['Ycy', [1067]], ['ycy', [1099]], ['yen', [165]], ['Yfr', [120092]], ['yfr', [120118]], ['YIcy', [1031]], ['yicy', [1111]], ['Yopf', [120144]], ['yopf', [120170]], ['Yscr', [119988]], ['yscr', [120014]], ['YUcy', [1070]], ['yucy', [1102]], ['yuml', [255]], ['Yuml', [376]], ['Zacute', [377]], ['zacute', [378]], ['Zcaron', [381]], ['zcaron', [382]], ['Zcy', [1047]], ['zcy', [1079]], ['Zdot', [379]], ['zdot', [380]], ['zeetrf', [8488]], ['ZeroWidthSpace', [8203]], ['Zeta', [918]], ['zeta', [950]], ['zfr', [120119]], ['Zfr', [8488]], ['ZHcy', [1046]], ['zhcy', [1078]], ['zigrarr', [8669]], ['zopf', [120171]], ['Zopf', [8484]], ['Zscr', [119989]], ['zscr', [120015]], ['zwj', [8205]], ['zwnj', [8204]]];
	
	var alphaIndex = {};
	var charIndex = {};
	
	createIndexes(alphaIndex, charIndex);
	
	/**
	 * @constructor
	 */
	function Html5Entities() {}
	
	/**
	 * @param {String} str
	 * @returns {String}
	 */
	Html5Entities.prototype.decode = function(str) {
	    if (!str || !str.length) {
	        return '';
	    }
	    return str.replace(/&(#?[\w\d]+);?/g, function(s, entity) {
	        var chr;
	        if (entity.charAt(0) === "#") {
	            var code = entity.charAt(1) === 'x' ?
	                parseInt(entity.substr(2).toLowerCase(), 16) :
	                parseInt(entity.substr(1));
	
	            if (!(isNaN(code) || code < -32768 || code > 65535)) {
	                chr = String.fromCharCode(code);
	            }
	        } else {
	            chr = alphaIndex[entity];
	        }
	        return chr || s;
	    });
	};
	
	/**
	 * @param {String} str
	 * @returns {String}
	 */
	 Html5Entities.decode = function(str) {
	    return new Html5Entities().decode(str);
	 };
	
	/**
	 * @param {String} str
	 * @returns {String}
	 */
	Html5Entities.prototype.encode = function(str) {
	    if (!str || !str.length) {
	        return '';
	    }
	    var strLength = str.length;
	    var result = '';
	    var i = 0;
	    while (i < strLength) {
	        var charInfo = charIndex[str.charCodeAt(i)];
	        if (charInfo) {
	            var alpha = charInfo[str.charCodeAt(i + 1)];
	            if (alpha) {
	                i++;
	            } else {
	                alpha = charInfo[''];
	            }
	            if (alpha) {
	                result += "&" + alpha + ";";
	                i++;
	                continue;
	            }
	        }
	        result += str.charAt(i);
	        i++;
	    }
	    return result;
	};
	
	/**
	 * @param {String} str
	 * @returns {String}
	 */
	 Html5Entities.encode = function(str) {
	    return new Html5Entities().encode(str);
	 };
	
	/**
	 * @param {String} str
	 * @returns {String}
	 */
	Html5Entities.prototype.encodeNonUTF = function(str) {
	    if (!str || !str.length) {
	        return '';
	    }
	    var strLength = str.length;
	    var result = '';
	    var i = 0;
	    while (i < strLength) {
	        var c = str.charCodeAt(i);
	        var charInfo = charIndex[c];
	        if (charInfo) {
	            var alpha = charInfo[str.charCodeAt(i + 1)];
	            if (alpha) {
	                i++;
	            } else {
	                alpha = charInfo[''];
	            }
	            if (alpha) {
	                result += "&" + alpha + ";";
	                i++;
	                continue;
	            }
	        }
	        if (c < 32 || c > 126) {
	            result += '&#' + c + ';';
	        } else {
	            result += str.charAt(i);
	        }
	        i++;
	    }
	    return result;
	};
	
	/**
	 * @param {String} str
	 * @returns {String}
	 */
	 Html5Entities.encodeNonUTF = function(str) {
	    return new Html5Entities().encodeNonUTF(str);
	 };
	
	/**
	 * @param {String} str
	 * @returns {String}
	 */
	Html5Entities.prototype.encodeNonASCII = function(str) {
	    if (!str || !str.length) {
	        return '';
	    }
	    var strLength = str.length;
	    var result = '';
	    var i = 0;
	    while (i < strLength) {
	        var c = str.charCodeAt(i);
	        if (c <= 255) {
	            result += str[i++];
	            continue;
	        }
	        result += '&#' + c + ';';
	        i++
	    }
	    return result;
	};
	
	/**
	 * @param {String} str
	 * @returns {String}
	 */
	 Html5Entities.encodeNonASCII = function(str) {
	    return new Html5Entities().encodeNonASCII(str);
	 };
	
	/**
	 * @param {Object} alphaIndex Passed by reference.
	 * @param {Object} charIndex Passed by reference.
	 */
	function createIndexes(alphaIndex, charIndex) {
	    var i = ENTITIES.length;
	    var _results = [];
	    while (i--) {
	        var e = ENTITIES[i];
	        var alpha = e[0];
	        var chars = e[1];
	        var chr = chars[0];
	        var addChar = (chr < 32 || chr > 126) || chr === 62 || chr === 60 || chr === 38 || chr === 34 || chr === 39;
	        var charInfo;
	        if (addChar) {
	            charInfo = charIndex[chr] = charIndex[chr] || {};
	        }
	        if (chars[1]) {
	            var chr2 = chars[1];
	            alphaIndex[alpha] = String.fromCharCode(chr) + String.fromCharCode(chr2);
	            _results.push(addChar && (charInfo[chr2] = alpha));
	        } else {
	            alphaIndex[alpha] = String.fromCharCode(chr);
	            _results.push(addChar && (charInfo[''] = alpha));
	        }
	    }
	}
	
	module.exports = Html5Entities;


/***/ }),
/* 599 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Based heavily on https://github.com/webpack/webpack/blob/
	 *  c0afdf9c6abc1dd70707c594e473802a566f7b6e/hot/only-dev-server.js
	 * Original copyright Tobias Koppers @sokra (MIT license)
	 */
	
	/* global window __webpack_hash__ */
	
	if (false) {
	  throw new Error("[HMR] Hot Module Replacement is disabled.");
	}
	
	var hmrDocsUrl = "https://webpack.js.org/concepts/hot-module-replacement/"; // eslint-disable-line max-len
	
	var lastHash;
	var failureStatuses = { abort: 1, fail: 1 };
	var applyOptions = { ignoreUnaccepted: true };
	
	function upToDate(hash) {
	  if (hash) lastHash = hash;
	  return lastHash == __webpack_require__.h();
	}
	
	module.exports = function(hash, moduleMap, options) {
	  var reload = options.reload;
	  if (!upToDate(hash) && module.hot.status() == "idle") {
	    if (options.log) console.log("[HMR] Checking for updates on the server...");
	    check();
	  }
	
	  function check() {
	    var cb = function(err, updatedModules) {
	      if (err) return handleError(err);
	
	      if(!updatedModules) {
	        if (options.warn) {
	          console.warn("[HMR] Cannot find update (Full reload needed)");
	          console.warn("[HMR] (Probably because of restarting the server)");
	        }
	        performReload();
	        return null;
	      }
	
	      var applyCallback = function(applyErr, renewedModules) {
	        if (applyErr) return handleError(applyErr);
	
	        if (!upToDate()) check();
	
	        logUpdates(updatedModules, renewedModules);
	      };
	
	      var applyResult = module.hot.apply(applyOptions, applyCallback);
	      // webpack 2 promise
	      if (applyResult && applyResult.then) {
	        // HotModuleReplacement.runtime.js refers to the result as `outdatedModules`
	        applyResult.then(function(outdatedModules) {
	          applyCallback(null, outdatedModules);
	        });
	        applyResult.catch(applyCallback);
	      }
	
	    };
	
	    var result = module.hot.check(false, cb);
	    // webpack 2 promise
	    if (result && result.then) {
	        result.then(function(updatedModules) {
	            cb(null, updatedModules);
	        });
	        result.catch(cb);
	    }
	  }
	
	  function logUpdates(updatedModules, renewedModules) {
	    var unacceptedModules = updatedModules.filter(function(moduleId) {
	      return renewedModules && renewedModules.indexOf(moduleId) < 0;
	    });
	
	    if(unacceptedModules.length > 0) {
	      if (options.warn) {
	        console.warn(
	          "[HMR] The following modules couldn't be hot updated: " +
	          "(Full reload needed)\n" +
	          "This is usually because the modules which have changed " +
	          "(and their parents) do not know how to hot reload themselves. " +
	          "See " + hmrDocsUrl + " for more details."
	        );
	        unacceptedModules.forEach(function(moduleId) {
	          console.warn("[HMR]  - " + moduleMap[moduleId]);
	        });
	      }
	      performReload();
	      return;
	    }
	
	    if (options.log) {
	      if(!renewedModules || renewedModules.length === 0) {
	        console.log("[HMR] Nothing hot updated.");
	      } else {
	        console.log("[HMR] Updated modules:");
	        renewedModules.forEach(function(moduleId) {
	          console.log("[HMR]  - " + moduleMap[moduleId]);
	        });
	      }
	
	      if (upToDate()) {
	        console.log("[HMR] App is up to date.");
	      }
	    }
	  }
	
	  function handleError(err) {
	    if (module.hot.status() in failureStatuses) {
	      if (options.warn) {
	        console.warn("[HMR] Cannot check for update (Full reload needed)");
	        console.warn("[HMR] " + err.stack || err.message);
	      }
	      performReload();
	      return;
	    }
	    if (options.warn) {
	      console.warn("[HMR] Update check failed: " + err.stack || err.message);
	    }
	  }
	
	  function performReload() {
	    if (reload) {
	      if (options.warn) console.warn("[HMR] Reloading page");
	      window.location.reload();
	    }
	  }
	};


/***/ })
]);
//# sourceMappingURL=app.826962f9d02eb286ea90.js.map